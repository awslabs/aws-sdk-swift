//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyXML.Reader
@_spi(SmithyReadWrite) import class SmithyXML.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestXMLError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct AssociateAliasOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCachePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCloudFrontOriginAccessIdentityOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteContinuousDeploymentPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDistributionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFieldLevelEncryptionConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFieldLevelEncryptionProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFunctionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteKeyGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteKeyValueStoreOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOriginAccessControlOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOriginRequestPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePublicKeyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRealtimeLogConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResponseHeadersPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStreamingDistributionOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CloudFrontClientTypes {

    public enum ResponseHeadersPolicyAccessControlAllowMethodsValues: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyAccessControlAllowMethodsValues] {
            return [
                .all,
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Access denied.
public struct AccessDenied: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// A list of CloudFront key pair identifiers.
    public struct KeyPairIds: Swift.Sendable {
        /// A list of CloudFront key pair identifiers.
        public var items: [Swift.String]?
        /// The number of key pair identifiers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of identifiers for the public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct KGKeyPairIds: Swift.Sendable {
        /// The identifier of the key group that contains the public keys.
        public var keyGroupId: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init(
            keyGroupId: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.keyGroupId = keyGroupId
            self.keyPairIds = keyPairIds
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of key groups, and the public keys in each key group, that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedKeyGroups: Swift.Sendable {
        /// This field is true if any of the key groups have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups, including the identifiers of the public keys in each key group that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.KGKeyPairIds]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.KGKeyPairIds]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct Signer: Swift.Sendable {
        /// An Amazon Web Services account number that contains active CloudFront key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies. If the Amazon Web Services account that owns the key pairs is the same account that owns the CloudFront distribution, the value of this field is self.
        public var awsAccountNumber: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init(
            awsAccountNumber: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.keyPairIds = keyPairIds
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedSigners: Swift.Sendable {
        /// This field is true if any of the Amazon Web Services accounts in the list are configured as trusted signers. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services accounts and the identifiers of active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.Signer]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.Signer]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
    public struct Aliases: Swift.Sendable, Swift.Equatable {
        /// A complex type that contains the CNAME aliases, if any, that you want to associate with this distribution.
        public var items: [Swift.String]?
        /// The number of CNAME aliases, if any, that you want to associate with this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    public enum ICPRecordalStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [ICPRecordalStatus] {
            return [
                .approved,
                .pending,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure it yourself. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
    public struct AliasICPRecordal: Swift.Sendable, Swift.Equatable {
        /// A domain name associated with a distribution.
        public var cname: Swift.String?
        /// The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to APPROVED for all CNAMEs (aliases) in regions outside of China. The status values returned are the following:
        ///
        /// * APPROVED indicates that the associated CNAME has a valid ICP recordal number. Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.
        ///
        /// * SUSPENDED indicates that the associated CNAME does not have a valid ICP recordal number.
        ///
        /// * PENDING indicates that CloudFront can't determine the ICP recordal status of the CNAME associated with the distribution because there was an error in trying to determine the status. You can try again to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.
        public var icpRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus?

        public init(
            cname: Swift.String? = nil,
            icpRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus? = nil
        )
        {
            self.cname = cname
            self.icpRecordalStatus = icpRecordalStatus
        }
    }
}

extension CloudFrontClientTypes {

    public enum Method: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [Method] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
    ///
    /// * CloudFront caches responses to GET and HEAD requests.
    ///
    /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
    ///
    ///
    /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
    public struct CachedMethods: Swift.Sendable, Swift.Equatable {
        /// A complex type that contains the HTTP methods that you want CloudFront to cache responses to. Valid values for CachedMethods include GET, HEAD, and OPTIONS, depending on which caching option you choose. For more information, see the preceding section.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods for which you want CloudFront to cache responses. Valid values are 2 (for caching responses to GET and HEAD requests) and 3 (for caching responses to GET, HEAD, and OPTIONS requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
    ///
    /// * CloudFront forwards only GET and HEAD requests.
    ///
    /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
    ///
    /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
    ///
    ///
    /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
    public struct AllowedMethods: Swift.Sendable, Swift.Equatable {
        /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
        ///
        /// * CloudFront caches responses to GET and HEAD requests.
        ///
        /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
        ///
        ///
        /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        public var cachedMethods: CloudFrontClientTypes.CachedMethods?
        /// A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD, and OPTIONS requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            cachedMethods: CloudFrontClientTypes.CachedMethods? = nil,
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.cachedMethods = cachedMethods
            self.items = items
            self.quantity = quantity
        }
    }
}

/// The update contains modifications that are not allowed.
public struct IllegalUpdate: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalUpdate" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An argument is invalid.
public struct InvalidArgument: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgument" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified distribution does not exist.
public struct NoSuchDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchDistribution" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyDistributionCNAMEs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionCNAMEs" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateAliasInput: Swift.Sendable {
    /// The alias (also known as a CNAME) to add to the target distribution.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the distribution that you're associating the alias with.
    /// This member is required.
    public var targetDistributionId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        targetDistributionId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.targetDistributionId = targetDistributionId
    }
}

/// Invalidation batch specified is too large.
public struct BatchTooLarge: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchTooLarge" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum ItemSelection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemSelection] {
            return [
                .all,
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains a list of cookie names.
    public struct CookieNames: Swift.Sendable, Swift.Equatable {
        /// A list of cookie names.
        public var items: [Swift.String]?
        /// The number of cookie names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use CookiesConfig in a cache policy. See CachePolicy. If you want to send cookies to the origin but not include them in the cache key, use CookiesConfig in an origin request policy. See OriginRequestPolicy. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [Caching Content Based on Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
    public struct CookiePreference: Swift.Sendable, Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Specifies which cookies to forward to the origin for this cache behavior: all, none, or the list of cookies specified in the WhitelistedNames complex type. Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an Amazon S3 origin, specify none for the Forward element.
        /// This member is required.
        public var forward: CloudFrontClientTypes.ItemSelection?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Required if you specify whitelist for the value of Forward. A complex type that specifies how many different cookies you want CloudFront to forward to the origin for this cache behavior and, if you want to forward selected cookies, the names of those cookies. If you specify all or none for the value of Forward, omit WhitelistedNames. If you change the value of Forward from whitelist to all or none and you don't delete the WhitelistedNames element and its child elements, CloudFront deletes them automatically. For the current limit on the number of cookie names that you can whitelist for each cache behavior, see [ CloudFront Limits](https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront) in the Amazon Web Services General Reference.
        public var whitelistedNames: CloudFrontClientTypes.CookieNames?

        public init(
            forward: CloudFrontClientTypes.ItemSelection? = nil,
            whitelistedNames: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.forward = forward
            self.whitelistedNames = whitelistedNames
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains a list of HTTP header names.
    public struct Headers: Swift.Sendable, Swift.Equatable {
        /// A list of HTTP header names.
        public var items: [Swift.String]?
        /// The number of header names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use QueryStringsConfig in a cache policy. See CachePolicy. If you want to send query strings to the origin but not include them in the cache key, use QueryStringsConfig in an origin request policy. See OriginRequestPolicy. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for a cache behavior.
    public struct QueryStringCacheKeys: Swift.Sendable, Swift.Equatable {
        /// A list that contains the query string parameters that you want CloudFront to use as a basis for caching for a cache behavior. If Quantity is 0, you can omit Items.
        public var items: [Swift.String]?
        /// The number of whitelisted query string parameters for a cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
    public struct ForwardedValues: Swift.Sendable, Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var cookies: CloudFrontClientTypes.CookiePreference?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include headers in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send headers to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies the Headers, if any, that you want CloudFront to forward to the origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches separate versions of a specified object that is based on the header values in viewer requests. For more information, see [ Caching Content Based on Request Headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html) in the Amazon CloudFront Developer Guide.
        public var headers: CloudFrontClientTypes.Headers?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior and cache based on the query string parameters. CloudFront behavior depends on the value of QueryString and on the values that you specify for QueryStringCacheKeys, if any: If you specify true for QueryString and you don't specify any values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin and caches based on all query string parameters. Depending on how many query string parameters and values you have, this can adversely affect performance because CloudFront must forward more requests to the origin. If you specify true for QueryString and you specify one or more values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin, but it only caches based on the query string parameters that you specify. If you specify false for QueryString, CloudFront doesn't forward any query string parameters to the origin, and doesn't cache based on query string parameters. For more information, see [Configuring CloudFront to Cache Based on Query String Parameters](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var queryString: Swift.Bool?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for this cache behavior.
        public var queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys?

        public init(
            cookies: CloudFrontClientTypes.CookiePreference? = nil,
            headers: CloudFrontClientTypes.Headers? = nil,
            queryString: Swift.Bool? = nil,
            queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys? = nil
        )
        {
            self.cookies = cookies
            self.headers = headers
            self.queryString = queryString
            self.queryStringCacheKeys = queryStringCacheKeys
        }
    }
}

extension CloudFrontClientTypes {

    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case originRequest
        case originResponse
        case viewerRequest
        case viewerResponse
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .originRequest,
                .originResponse,
                .viewerRequest,
                .viewerResponse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .originRequest: return "origin-request"
            case .originResponse: return "origin-response"
            case .viewerRequest: return "viewer-request"
            case .viewerResponse: return "viewer-response"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A CloudFront function that is associated with a cache behavior in a CloudFront distribution.
    public struct FunctionAssociation: Swift.Sendable, Swift.Equatable {
        /// The event type of the function, either viewer-request or viewer-response. You cannot use origin-facing event types (origin-request and origin-response) with a CloudFront function.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// The Amazon Resource Name (ARN) of the function.
        /// This member is required.
        public var functionARN: Swift.String?

        public init(
            eventType: CloudFrontClientTypes.EventType? = nil,
            functionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.functionARN = functionARN
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution. Your functions must be published to the LIVE stage to associate them with a cache behavior.
    public struct FunctionAssociations: Swift.Sendable, Swift.Equatable {
        /// The CloudFront functions that are associated with a cache behavior in a CloudFront distribution. Your functions must be published to the LIVE stage to associate them with a cache behavior.
        public var items: [CloudFrontClientTypes.FunctionAssociation]?
        /// The number of CloudFront functions in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains a Lambda@Edge function association.
    public struct LambdaFunctionAssociation: Swift.Sendable, Swift.Equatable {
        /// Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:
        ///
        /// * viewer-request: The function executes when CloudFront receives a request from a viewer and before it checks to see whether the requested object is in the edge cache.
        ///
        /// * origin-request: The function executes only when CloudFront sends a request to your origin. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * origin-response: The function executes after CloudFront receives a response from the origin and before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * viewer-response: The function executes before CloudFront returns the requested object to the viewer. The function executes regardless of whether the object was already in the edge cache. If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// A flag that allows a Lambda@Edge function to have read access to the body content. For more information, see [Accessing the Request Body by Choosing the Include Body Option](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html) in the Amazon CloudFront Developer Guide.
        public var includeBody: Swift.Bool?
        /// The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias or $LATEST.
        /// This member is required.
        public var lambdaFunctionARN: Swift.String?

        public init(
            eventType: CloudFrontClientTypes.EventType? = nil,
            includeBody: Swift.Bool? = nil,
            lambdaFunctionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.includeBody = includeBody
            self.lambdaFunctionARN = lambdaFunctionARN
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that specifies a list of Lambda@Edge functions associations for a cache behavior. If you want to invoke one or more Lambda@Edge functions triggered by requests that match the PathPattern of the cache behavior, specify the applicable values for Quantity and Items. Note that there can be up to 4 LambdaFunctionAssociation items in this list (one for each possible value of EventType) and each EventType can be associated with only one function. If you don't want to invoke any Lambda@Edge functions for the requests that match PathPattern, specify 0 for Quantity and omit Items.
    public struct LambdaFunctionAssociations: Swift.Sendable, Swift.Equatable {
        /// Optional: A complex type that contains LambdaFunctionAssociation items for this cache behavior. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.LambdaFunctionAssociation]?
        /// The number of Lambda@Edge function associations for this cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.LambdaFunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of key groups whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedKeyGroups: Swift.Sendable, Swift.Equatable {
        /// This field is true if any of the key groups in the list have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups identifiers.
        public var items: [Swift.String]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of Amazon Web Services accounts whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedSigners: Swift.Sendable, Swift.Equatable {
        /// This field is true if any of the Amazon Web Services accounts in the list are configured as trusted signers. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services account identifiers.
        public var items: [Swift.String]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    public enum ViewerProtocolPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowAll
        case httpsOnly
        case redirectToHttps
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewerProtocolPolicy] {
            return [
                .allowAll,
                .httpsOnly,
                .redirectToHttps
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "allow-all"
            case .httpsOnly: return "https-only"
            case .redirectToHttps: return "redirect-to-https"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that describes how CloudFront processes requests. You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to serve objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin is never used. For the current quota (formerly known as limit) on the number of cache behaviors that you can add to a distribution, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) in the Amazon CloudFront Developer Guide. If you don't want to specify any cache behaviors, include only an empty CacheBehaviors element. Don't specify an empty individual CacheBehavior element, because this is invalid. For more information, see [CacheBehaviors](https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CacheBehaviors.html). To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty CacheBehaviors element. To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution. For more information about cache behaviors, see [Cache Behavior Settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior) in the Amazon CloudFront Developer Guide.
    public struct CacheBehavior: Swift.Sendable, Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to this cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for this cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [ Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to this cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The pattern (for example, images/*.jpg) that specifies which requests to apply the behavior to. When CloudFront receives a viewer request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. You can optionally include a slash (/) at the beginning of the path pattern. For example, /images/*.jpg. CloudFront behavior is the same with or without the leading /. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior. For more information, see [Path Pattern](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var pathPattern: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they match this cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in the trusted signer's Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init(
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            pathPattern: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.pathPattern = pathPattern
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains zero or more CacheBehavior elements.
    public struct CacheBehaviors: Swift.Sendable, Swift.Equatable {
        /// Optional: A complex type that contains cache behaviors for this distribution. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.CacheBehavior]?
        /// The number of cache behaviors for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CacheBehavior]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    public enum CachePolicyCookieBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyCookiesConfig: Swift.Sendable {
        /// Determines whether any cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No cookies in viewer requests are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – Only the cookies in viewer requests that are listed in the CookieNames type are included in the cache key and in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin, except for those that are listed in the CookieNames type, which are not included.
        ///
        /// * all – All cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init(
            cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }
}

extension CloudFrontClientTypes {

    public enum CachePolicyHeaderBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyHeaderBehavior] {
            return [
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyHeadersConfig: Swift.Sendable {
        /// Determines whether any HTTP headers are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No HTTP headers are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – Only the HTTP headers that are listed in the Headers type are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init(
            headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }
}

extension CloudFrontClientTypes {

    public enum CachePolicyQueryStringBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains a list of query string names.
    public struct QueryStringNames: Swift.Sendable {
        /// A list of query string names.
        public var items: [Swift.String]?
        /// The number of query string names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyQueryStringsConfig: Swift.Sendable {
        /// Determines whether any URL query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No query strings in viewer requests are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – Only the query strings in viewer requests that are listed in the QueryStringNames type are included in the cache key and in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin, except those that are listed in the QueryStringNames type, which are not included.
        ///
        /// * all – All query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in the cache key and in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the CachePolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init(
            queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }
}

extension CloudFrontClientTypes {

    /// This object determines the values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer. The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find an object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct ParametersInCacheKeyAndForwardedToOrigin: Swift.Sendable {
        /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingGzip field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer's Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it's not included in the cache key and it's not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        public var enableAcceptEncodingBrotli: Swift.Bool?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingBrotli field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer's Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it's not included in the cache key and it's not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        /// This member is required.
        public var enableAcceptEncodingGzip: Swift.Bool?
        /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig?
        /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig?

        public init(
            cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig? = nil,
            enableAcceptEncodingBrotli: Swift.Bool? = nil,
            enableAcceptEncodingGzip: Swift.Bool? = nil,
            headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig? = nil,
            queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig? = nil
        )
        {
            self.cookiesConfig = cookiesConfig
            self.enableAcceptEncodingBrotli = enableAcceptEncodingBrotli
            self.enableAcceptEncodingGzip = enableAcceptEncodingGzip
            self.headersConfig = headersConfig
            self.queryStringsConfig = queryStringsConfig
        }
    }
}

extension CloudFrontClientTypes {

    /// A cache policy configuration. This configuration determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find a valid object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicyConfig: Swift.Sendable {
        /// A comment to describe the cache policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value as the object's time to live (TTL) only when the origin does not send Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 86400 seconds (one day). If the value of MinTTL is more than 86400 seconds, then the default value for this field is the same as the value of MinTTL.
        public var defaultTTL: Swift.Int?
        /// The maximum amount of time, in seconds, that objects stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value only when the origin sends Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 31536000 seconds (one year). If the value of MinTTL or DefaultTTL is more than 31536000 seconds, then the default value for this field is the same as the value of DefaultTTL.
        public var maxTTL: Swift.Int?
        /// The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var minTTL: Swift.Int?
        /// A unique name to identify the cache policy.
        /// This member is required.
        public var name: Swift.String?
        /// The HTTP headers, cookies, and URL query strings to include in the cache key. The values included in the cache key are also included in requests that CloudFront sends to the origin.
        public var parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?

        public init(
            comment: Swift.String? = nil,
            defaultTTL: Swift.Int? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            name: Swift.String? = nil,
            parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin? = nil
        )
        {
            self.comment = comment
            self.defaultTTL = defaultTTL
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.name = name
            self.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin
        }
    }
}

extension CloudFrontClientTypes {

    /// A cache policy. When it's attached to a cache behavior, the cache policy determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find a valid object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicy: Swift.Sendable {
        /// The cache policy configuration.
        /// This member is required.
        public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
        /// The unique identifier for the cache policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the cache policy was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?

        public init(
            cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil
        )
        {
            self.cachePolicyConfig = cachePolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

/// A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use UpdateCachePolicy.
public struct CachePolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CachePolicyAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Cannot delete the cache policy because it is attached to one or more cache behaviors.
public struct CachePolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CachePolicyInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum CachePolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyType] {
            return [
                .custom,
                .managed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains a cache policy.
    public struct CachePolicySummary: Swift.Sendable {
        /// The cache policy.
        /// This member is required.
        public var cachePolicy: CloudFrontClientTypes.CachePolicy?
        /// The type of cache policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.CachePolicyType?

        public init(
            cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
            type: CloudFrontClientTypes.CachePolicyType? = nil
        )
        {
            self.cachePolicy = cachePolicy
            self.type = type
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of cache policies.
    public struct CachePolicyList: Swift.Sendable {
        /// Contains the cache policies in the list.
        public var items: [CloudFrontClientTypes.CachePolicySummary]?
        /// The maximum number of cache policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing cache policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of cache policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CachePolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

/// You can't change the value of a public key.
public struct CannotChangeImmutablePublicKeyFields: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotChangeImmutablePublicKeyFields" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The key value store entity cannot be deleted while it is in use.
public struct CannotDeleteEntityWhileInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotDeleteEntityWhileInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum CertificateSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acm
        case cloudfront
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateSource] {
            return [
                .acm,
                .cloudfront,
                .iam
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acm: return "acm"
            case .cloudfront: return "cloudfront"
            case .iam: return "iam"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The CNAME specified is already defined for CloudFront.
public struct CNAMEAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CNAMEAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The caller reference you attempted to create the distribution with is associated with another distribution.
public struct DistributionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DistributionAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified configuration for field-level encryption can't be associated with the specified cache behavior.
public struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The value of Quantity and the size of Items don't match.
public struct InconsistentQuantities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InconsistentQuantities" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The default root object file name is too big or contains an invalid character.
public struct InvalidDefaultRootObject: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDefaultRootObject" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An invalid error code was specified.
public struct InvalidErrorCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidErrorCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.
public struct InvalidForwardCookies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidForwardCookies" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A CloudFront function association is invalid.
public struct InvalidFunctionAssociation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFunctionAssociation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified geo restriction parameter is not valid.
public struct InvalidGeoRestrictionParameter: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidGeoRestrictionParameter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The headers specified are not valid for an Amazon S3 origin.
public struct InvalidHeadersForS3Origin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidHeadersForS3Origin" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The If-Match version is missing or not valid.
public struct InvalidIfMatchVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidIfMatchVersion" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified Lambda@Edge function association is invalid.
public struct InvalidLambdaFunctionAssociation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLambdaFunctionAssociation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The location code specified is not valid.
public struct InvalidLocationCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLocationCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The minimum protocol version specified is not valid.
public struct InvalidMinimumProtocolVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMinimumProtocolVersion" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.
public struct InvalidOrigin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOrigin" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The origin access control is not valid.
public struct InvalidOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginAccessControl" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The origin access identity is not valid or doesn't exist.
public struct InvalidOriginAccessIdentity: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginAccessIdentity" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The keep alive timeout specified for the origin is not valid.
public struct InvalidOriginKeepaliveTimeout: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginKeepaliveTimeout" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The read timeout specified for the origin is not valid.
public struct InvalidOriginReadTimeout: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginReadTimeout" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).
public struct InvalidProtocolSettings: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidProtocolSettings" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The query string parameters specified are not valid.
public struct InvalidQueryStringParameters: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryStringParameters" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The relative path is too big, is not URL-encoded, or does not begin with a slash (/).
public struct InvalidRelativePath: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRelativePath" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration.
public struct InvalidRequiredProtocol: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequiredProtocol" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A response code is not valid.
public struct InvalidResponseCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResponseCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The TTL order specified is not valid.
public struct InvalidTTLOrder: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTTLOrder" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A viewer certificate specified is not valid.
public struct InvalidViewerCertificate: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidViewerCertificate" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a.
public struct InvalidWebACLId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidWebACLId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This operation requires a body. Ensure that the body is present and the Content-Type header is set.
public struct MissingBody: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingBody" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The cache policy does not exist.
public struct NoSuchCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchCachePolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified configuration for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFieldLevelEncryptionConfig" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// No origin exists with the specified Origin Id.
public struct NoSuchOrigin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOrigin" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The origin request policy does not exist.
public struct NoSuchOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOriginRequestPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The real-time log configuration does not exist.
public struct NoSuchRealtimeLogConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchRealtimeLogConfig" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The response headers policy does not exist.
public struct NoSuchResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResponseHeadersPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The precondition in one or more of the request fields evaluated to false.
public struct PreconditionFailed: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailed" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified real-time log configuration belongs to a different Amazon Web Services account.
public struct RealtimeLogConfigOwnerMismatch: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigOwnerMismatch" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You cannot create more cache behaviors for the distribution.
public struct TooManyCacheBehaviors: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCacheBehaviors" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You cannot create anymore custom SSL/TLS certificates.
public struct TooManyCertificates: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCertificates" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains more cookie names in the whitelist than are allowed per cache behavior.
public struct TooManyCookieNamesInWhiteList: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookieNamesInWhiteList" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of distributions allowed.
public struct TooManyDistributions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributions" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of distributions have been associated with the specified cache policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToCachePolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of distributions have been associated with the specified configuration for field-level encryption.
public struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of distributions that reference this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToKeyGroup: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToKeyGroup" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of distributions have been associated with the specified origin access control. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToOriginAccessControl" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of distributions have been associated with the specified origin request policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToOriginRequestPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of distributions have been associated with the specified response headers policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToResponseHeadersPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsWithFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithFunctionAssociations" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.
public struct TooManyDistributionsWithLambdaAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithLambdaAssociations" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of distributions have been associated with the specified Lambda@Edge function.
public struct TooManyDistributionsWithSingleFunctionARN: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithSingleFunctionARN" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of CloudFront function associations for this distribution. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFunctionAssociations" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains too many headers in forwarded values.
public struct TooManyHeadersInForwardedValues: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInForwardedValues" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroupsAssociatedToDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyKeyGroupsAssociatedToDistribution" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains more Lambda@Edge function associations than are allowed per distribution.
public struct TooManyLambdaFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyLambdaFunctionAssociations" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains too many origin custom headers.
public struct TooManyOriginCustomHeaders: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginCustomHeaders" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin groups allowed.
public struct TooManyOriginGroupsPerDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginGroupsPerDistribution" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You cannot create more origins for the distribution.
public struct TooManyOrigins: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOrigins" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains too many query string parameters.
public struct TooManyQueryStringParameters: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringParameters" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains more trusted signers than are allowed per distribution.
public struct TooManyTrustedSigners: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTrustedSigners" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified key group does not exist.
public struct TrustedKeyGroupDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrustedKeyGroupDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of your trusted signers don't exist.
public struct TrustedSignerDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrustedSignerDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CopyDistributionInput: Swift.Sendable {
    /// A value that uniquely identifies a request to create a resource. This helps to prevent CloudFront from creating a duplicate resource if you accidentally resubmit an identical request.
    /// This member is required.
    public var callerReference: Swift.String?
    /// A Boolean flag to specify the state of the staging distribution when it's created. When you set this value to True, the staging distribution is enabled. When you set this value to False, the staging distribution is disabled. If you omit this field, the default value is True.
    public var enabled: Swift.Bool?
    /// The version identifier of the primary distribution whose configuration you are copying. This is the ETag value returned in the response to GetDistribution and GetDistributionConfig.
    public var ifMatch: Swift.String?
    /// The identifier of the primary distribution whose configuration you are copying. To get a distribution ID, use ListDistributions.
    /// This member is required.
    public var primaryDistributionId: Swift.String?
    /// The type of distribution that your primary distribution will be copied to. The only valid value is True, indicating that you are copying to a staging distribution.
    public var staging: Swift.Bool?

    public init(
        callerReference: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ifMatch: Swift.String? = nil,
        primaryDistributionId: Swift.String? = nil,
        staging: Swift.Bool? = nil
    )
    {
        self.callerReference = callerReference
        self.enabled = enabled
        self.ifMatch = ifMatch
        self.primaryDistributionId = primaryDistributionId
        self.staging = staging
    }
}

extension CloudFrontClientTypes {

    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponse: Swift.Sendable, Swift.Equatable {
        /// The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status code specified in ErrorCode. When this time period has elapsed, CloudFront queries your origin to see whether the problem that caused the error has been resolved and the requested object is now available. For more information, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var errorCachingMinTTL: Swift.Int?
        /// The HTTP status code for which you want to specify a custom error page and/or a caching duration.
        /// This member is required.
        public var errorCode: Swift.Int?
        /// The HTTP status code that you want CloudFront to return to the viewer along with the custom error page. There are a variety of reasons that you might want CloudFront to return a status code different from the status code that your origin returned to CloudFront, for example:
        ///
        /// * Some Internet devices (some firewalls and corporate proxies, for example) intercept HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you substitute 200, the response typically won't be intercepted.
        ///
        /// * If you don't care about distinguishing among different client errors or server errors, you can specify 400 or 500 as the ResponseCode for all 4xx or 5xx errors.
        ///
        /// * You might want to return a 200 status code (OK) and static website so your customers don't know that your website is down.
        ///
        ///
        /// If you specify a value for ResponseCode, you must also specify a value for ResponsePagePath.
        public var responseCode: Swift.String?
        /// The path to the custom error page that you want CloudFront to return to a viewer when your origin returns the HTTP status code specified by ErrorCode, for example, /4xx-errors/403-forbidden.html. If you want to store your objects and your custom error pages in different locations, your distribution must include a cache behavior for which the following is true:
        ///
        /// * The value of PathPattern matches the path to your custom error messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3 bucket in a directory named /4xx-errors. Your distribution must include a cache behavior for which the path pattern routes requests for your custom error pages to that location, for example, /4xx-errors/*.
        ///
        /// * The value of TargetOriginId specifies the value of the ID element for the origin that contains your custom error pages.
        ///
        ///
        /// If you specify a value for ResponsePagePath, you must also specify a value for ResponseCode. We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the files that you want to return to viewers because the origin server is unavailable.
        public var responsePagePath: Swift.String?

        public init(
            errorCachingMinTTL: Swift.Int? = nil,
            errorCode: Swift.Int? = nil,
            responseCode: Swift.String? = nil,
            responsePagePath: Swift.String? = nil
        )
        {
            self.errorCachingMinTTL = errorCachingMinTTL
            self.errorCode = errorCode
            self.responseCode = responseCode
            self.responsePagePath = responsePagePath
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponses: Swift.Sendable, Swift.Equatable {
        /// A complex type that contains a CustomErrorResponse element for each HTTP status code for which you want to specify a custom error page and/or a caching duration.
        public var items: [CloudFrontClientTypes.CustomErrorResponse]?
        /// The number of HTTP status codes for which you want to specify a custom error page and/or a caching duration. If Quantity is 0, you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CustomErrorResponse]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if request URLs don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
    public struct DefaultCacheBehavior: Swift.Sendable, Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to the default cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for the default cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. Your functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to the default cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they use the default cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in a trusted signer's Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init(
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }
}

extension CloudFrontClientTypes {

    public enum HttpVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http11
        case http2
        case http2and3
        case http3
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpVersion] {
            return [
                .http11,
                .http2,
                .http2and3,
                .http3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http11: return "http1.1"
            case .http2: return "http2"
            case .http2and3: return "http2and3"
            case .http3: return "http3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that controls whether access logs are written for the distribution.
    public struct LoggingConfig: Swift.Sendable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a distribution or if you want to disable logging for an existing distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket, prefix, and IncludeCookies, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs, specify true for IncludeCookies. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you don't want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify false for IncludeCookies.
        /// This member is required.
        public var includeCookies: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            includeCookies: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.`prefix` = `prefix`
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex data type for the status codes that you specify that, when returned by a primary origin, trigger CloudFront to failover to a second origin.
    public struct StatusCodes: Swift.Sendable, Swift.Equatable {
        /// The items (status codes) for an origin group.
        /// This member is required.
        public var items: [Swift.Int]?
        /// The number of status codes.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.Int]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex data type that includes information about the failover criteria for an origin group, including the status codes for which CloudFront will failover from the primary origin to the second origin.
    public struct OriginGroupFailoverCriteria: Swift.Sendable, Swift.Equatable {
        /// The status codes that, when returned from the primary origin, will trigger CloudFront to failover to the second origin.
        /// This member is required.
        public var statusCodes: CloudFrontClientTypes.StatusCodes?

        public init(
            statusCodes: CloudFrontClientTypes.StatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }
}

extension CloudFrontClientTypes {

    /// An origin in an origin group.
    public struct OriginGroupMember: Swift.Sendable, Swift.Equatable {
        /// The ID for an origin in an origin group.
        /// This member is required.
        public var originId: Swift.String?

        public init(
            originId: Swift.String? = nil
        )
        {
            self.originId = originId
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex data type for the origins included in an origin group.
    public struct OriginGroupMembers: Swift.Sendable, Swift.Equatable {
        /// Items (origins) in an origin group.
        /// This member is required.
        public var items: [CloudFrontClientTypes.OriginGroupMember]?
        /// The number of origins in an origin group.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginGroupMember]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify. You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specify the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin under the failover conditions that you've chosen.
    public struct OriginGroup: Swift.Sendable, Swift.Equatable {
        /// A complex type that contains information about the failover criteria for an origin group.
        /// This member is required.
        public var failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria?
        /// The origin group's ID.
        /// This member is required.
        public var id: Swift.String?
        /// A complex type that contains information about the origins in an origin group.
        /// This member is required.
        public var members: CloudFrontClientTypes.OriginGroupMembers?

        public init(
            failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria? = nil,
            id: Swift.String? = nil,
            members: CloudFrontClientTypes.OriginGroupMembers? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
            self.id = id
            self.members = members
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex data type for the origin groups specified for a distribution.
    public struct OriginGroups: Swift.Sendable, Swift.Equatable {
        /// The items (origin groups) in a distribution.
        public var items: [CloudFrontClientTypes.OriginGroup]?
        /// The number of origin groups.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginGroup]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains HeaderName and HeaderValue elements, if any, for this distribution.
    public struct OriginCustomHeader: Swift.Sendable, Swift.Equatable {
        /// The name of a header that you want CloudFront to send to your origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var headerName: Swift.String?
        /// The value for the header that you specified in the HeaderName field.
        /// This member is required.
        public var headerValue: Swift.String?

        public init(
            headerName: Swift.String? = nil,
            headerValue: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.headerValue = headerValue
        }
    }
}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginCustomHeader(headerName: \(Swift.String(describing: headerName)), headerValue: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes {

    /// A complex type that contains the list of Custom Headers for each origin.
    public struct CustomHeaders: Swift.Sendable, Swift.Equatable {
        /// Optional: A list that contains one OriginCustomHeader element for each custom header that you want CloudFront to forward to the origin. If Quantity is 0, omit Items.
        public var items: [CloudFrontClientTypes.OriginCustomHeader]?
        /// The number of custom headers, if any, for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    public enum OriginProtocolPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case httpOnly
        case httpsOnly
        case matchViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginProtocolPolicy] {
            return [
                .httpOnly,
                .httpsOnly,
                .matchViewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .httpOnly: return "http-only"
            case .httpsOnly: return "https-only"
            case .matchViewer: return "match-viewer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    public enum SslProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv11
        case tlsv12
        case sdkUnknown(Swift.String)

        public static var allCases: [SslProtocol] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv11,
                .tlsv12
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv11: return "TLSv1.1"
            case .tlsv12: return "TLSv1.2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin.
    public struct OriginSslProtocols: Swift.Sendable, Swift.Equatable {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        /// This member is required.
        public var items: [CloudFrontClientTypes.SslProtocol]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.SslProtocol]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) is a custom origin.
    public struct CustomOriginConfig: Swift.Sendable, Swift.Equatable {
        /// The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin listens on.
        /// This member is required.
        public var httpPort: Swift.Int?
        /// The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the origin listens on.
        /// This member is required.
        public var httpsPort: Swift.Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 5 seconds. For more information, see [Origin Keep-alive Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout) in the Amazon CloudFront Developer Guide.
        public var originKeepaliveTimeout: Swift.Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values are:
        ///
        /// * http-only – CloudFront always uses HTTP to connect to the origin.
        ///
        /// * match-viewer – CloudFront connects to the origin using the same protocol that the viewer used to connect to CloudFront.
        ///
        /// * https-only – CloudFront always uses HTTPS to connect to the origin.
        /// This member is required.
        public var originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the origin response timeout. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 30 seconds. For more information, see [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout) in the Amazon CloudFront Developer Guide.
        public var originReadTimeout: Swift.Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. Valid values include SSLv3, TLSv1, TLSv1.1, and TLSv1.2. For more information, see [Minimum Origin SSL Protocol](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols) in the Amazon CloudFront Developer Guide.
        public var originSslProtocols: CloudFrontClientTypes.OriginSslProtocols?

        public init(
            httpPort: Swift.Int? = nil,
            httpsPort: Swift.Int? = nil,
            originKeepaliveTimeout: Swift.Int? = nil,
            originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy? = nil,
            originReadTimeout: Swift.Int? = nil,
            originSslProtocols: CloudFrontClientTypes.OriginSslProtocols? = nil
        )
        {
            self.httpPort = httpPort
            self.httpsPort = httpsPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }
}

extension CloudFrontClientTypes {

    /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
    public struct OriginShield: Swift.Sendable, Swift.Equatable {
        /// A flag that specifies whether Origin Shield is enabled. When it's enabled, CloudFront routes all requests through Origin Shield, which can help protect your origin. When it's disabled, CloudFront might send requests directly to your origin from multiple edge locations or regional edge caches.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The Amazon Web Services Region for Origin Shield. Specify the Amazon Web Services Region that has the lowest latency to your origin. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2. When you enable CloudFront Origin Shield, you must specify the Amazon Web Services Region for Origin Shield. For the list of Amazon Web Services Regions that you can specify, and for help choosing the best Region for your origin, see [Choosing the Amazon Web Services Region for Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region) in the Amazon CloudFront Developer Guide.
        public var originShieldRegion: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            originShieldRegion: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.originShieldRegion = originShieldRegion
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin or an S3 bucket that is configured as a website endpoint, use the CustomOriginConfig element instead.
    public struct S3OriginConfig: Swift.Sendable, Swift.Equatable {
        /// If you're using origin access control (OAC) instead of origin access identity, specify an empty OriginAccessIdentity element. For more information, see [Restricting access to an Amazon Web Services](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-origin.html) in the Amazon CloudFront Developer Guide. The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that viewers can only access objects in an Amazon S3 bucket through CloudFront. The format of the value is: origin-access-identity/cloudfront/ID-of-origin-access-identity The  ID-of-origin-access-identity  is the value that CloudFront returned in the ID element when you created the origin access identity. If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information about the origin access identity, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init(
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }
}

extension CloudFrontClientTypes {

    /// An origin. An origin is the location where content is stored, and from which CloudFront gets content to serve to viewers. To specify an origin:
    ///
    /// * Use S3OriginConfig to specify an Amazon S3 bucket that is not configured with static website hosting.
    ///
    /// * Use CustomOriginConfig to specify all other kinds of origins, including:
    ///
    /// * An Amazon S3 bucket that is configured with static website hosting
    ///
    /// * An Elastic Load Balancing load balancer
    ///
    /// * An Elemental MediaPackage endpoint
    ///
    /// * An Elemental MediaStore container
    ///
    /// * Any other HTTP server, running on an Amazon EC2 instance or any other kind of host
    ///
    ///
    ///
    ///
    ///
    /// For the current maximum number of origins that you can specify per distribution, see [General Quotas on Web Distributions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions) in the Amazon CloudFront Developer Guide (quotas were formerly referred to as limits).
    public struct Origin: Swift.Sendable, Swift.Equatable {
        /// The number of times that CloudFront attempts to connect to the origin. The minimum number is 1, the maximum is 3, and the default (if you don't specify otherwise) is 3. For a custom origin (including an Amazon S3 bucket that's configured with static website hosting), this value also specifies the number of times that CloudFront attempts to get a response from the origin, in the case of an [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout). For more information, see [Origin Connection Attempts](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts) in the Amazon CloudFront Developer Guide.
        public var connectionAttempts: Swift.Int?
        /// The number of seconds that CloudFront waits when trying to establish a connection to the origin. The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you don't specify otherwise) is 10 seconds. For more information, see [Origin Connection Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout) in the Amazon CloudFront Developer Guide.
        public var connectionTimeout: Swift.Int?
        /// A list of HTTP header names and values that CloudFront adds to the requests that it sends to the origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html) in the Amazon CloudFront Developer Guide.
        public var customHeaders: CloudFrontClientTypes.CustomHeaders?
        /// Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public var customOriginConfig: CloudFrontClientTypes.CustomOriginConfig?
        /// The domain name for the origin. For more information, see [Origin Domain Name](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the origin. This value must be unique within the distribution. Use this value to specify the TargetOriginId in a CacheBehavior or DefaultCacheBehavior.
        /// This member is required.
        public var id: Swift.String?
        /// The unique identifier of an origin access control for this origin. For more information, see [Restricting access to an Amazon S3 origin](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        public var originAccessControlId: Swift.String?
        /// An optional path that CloudFront appends to the origin domain name when CloudFront requests content from the origin. For more information, see [Origin Path](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath) in the Amazon CloudFront Developer Guide.
        public var originPath: Swift.String?
        /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
        public var originShield: CloudFrontClientTypes.OriginShield?
        /// Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static website hosting. To specify any other type of origin, including an Amazon S3 bucket that is configured with static website hosting, use the CustomOriginConfig type instead.
        public var s3OriginConfig: CloudFrontClientTypes.S3OriginConfig?

        public init(
            connectionAttempts: Swift.Int? = nil,
            connectionTimeout: Swift.Int? = nil,
            customHeaders: CloudFrontClientTypes.CustomHeaders? = nil,
            customOriginConfig: CloudFrontClientTypes.CustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originAccessControlId: Swift.String? = nil,
            originPath: Swift.String? = nil,
            originShield: CloudFrontClientTypes.OriginShield? = nil,
            s3OriginConfig: CloudFrontClientTypes.S3OriginConfig? = nil
        )
        {
            self.connectionAttempts = connectionAttempts
            self.connectionTimeout = connectionTimeout
            self.customHeaders = customHeaders
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originAccessControlId = originAccessControlId
            self.originPath = originPath
            self.originShield = originShield
            self.s3OriginConfig = s3OriginConfig
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains information about the origins for this distribution.
    public struct Origins: Swift.Sendable, Swift.Equatable {
        /// A list of origins.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Origin]?
        /// The number of origins for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.Origin]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    public enum PriceClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case priceclass100
        case priceclass200
        case priceclassAll
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceClass] {
            return [
                .priceclass100,
                .priceclass200,
                .priceclassAll
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .priceclass100: return "PriceClass_100"
            case .priceclass200: return "PriceClass_200"
            case .priceclassAll: return "PriceClass_All"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    public enum GeoRestrictionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blacklist
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoRestrictionType] {
            return [
                .blacklist,
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blacklist: return "blacklist"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
    public struct GeoRestriction: Swift.Sendable, Swift.Equatable {
        /// A complex type that contains a Location element for each country in which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). The Location element is a two-letter, uppercase country code for a country that you want to include in your blacklist or whitelist. Include one Location element for each country. CloudFront and MaxMind both use ISO 3166 country codes. For the current list of countries and the corresponding codes, see ISO 3166-1-alpha-2 code on the International Organization for Standardization website. You can also refer to the country list on the CloudFront console, which includes both country names and codes.
        public var items: [Swift.String]?
        /// When geo restriction is enabled, this is the number of countries in your whitelist or blacklist. Otherwise, when it is not enabled, Quantity is 0, and you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?
        /// The method that you want to use to restrict distribution of your content by country:
        ///
        /// * none: No geo restriction is enabled, meaning access to content is not restricted by client geo location.
        ///
        /// * blacklist: The Location elements specify the countries in which you don't want CloudFront to distribute your content.
        ///
        /// * whitelist: The Location elements specify the countries in which you want CloudFront to distribute your content.
        /// This member is required.
        public var restrictionType: CloudFrontClientTypes.GeoRestrictionType?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil,
            restrictionType: CloudFrontClientTypes.GeoRestrictionType? = nil
        )
        {
            self.items = items
            self.quantity = quantity
            self.restrictionType = restrictionType
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that identifies ways in which you want to restrict distribution of your content.
    public struct Restrictions: Swift.Sendable, Swift.Equatable {
        /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
        /// This member is required.
        public var geoRestriction: CloudFrontClientTypes.GeoRestriction?

        public init(
            geoRestriction: CloudFrontClientTypes.GeoRestriction? = nil
        )
        {
            self.geoRestriction = geoRestriction
        }
    }
}

extension CloudFrontClientTypes {

    public enum MinimumProtocolVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv112016
        case tlsv12016
        case tlsv122018
        case tlsv122019
        case tlsv122021
        case sdkUnknown(Swift.String)

        public static var allCases: [MinimumProtocolVersion] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv112016,
                .tlsv12016,
                .tlsv122018,
                .tlsv122019,
                .tlsv122021
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv112016: return "TLSv1.1_2016"
            case .tlsv12016: return "TLSv1_2016"
            case .tlsv122018: return "TLSv1.2_2018"
            case .tlsv122019: return "TLSv1.2_2019"
            case .tlsv122021: return "TLSv1.2_2021"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    public enum SSLSupportMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sniOnly
        case staticIp
        case vip
        case sdkUnknown(Swift.String)

        public static var allCases: [SSLSupportMethod] {
            return [
                .sniOnly,
                .staticIp,
                .vip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sniOnly: return "sni-only"
            case .staticIp: return "static-ip"
            case .vip: return "vip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers. If the distribution doesn't use Aliases (also known as alternate domain names or CNAMEs)—that is, if the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net—set CloudFrontDefaultCertificate to true and leave all other fields empty. If the distribution uses Aliases (alternate domain names or CNAMEs), use the fields in this type to specify the following settings:
    ///
    /// * Which viewers the distribution accepts HTTPS connections from: only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication) (recommended), or all viewers including those that don't support SNI.
    ///
    /// * To accept HTTPS connections from only viewers that support SNI, set SSLSupportMethod to sni-only. This is recommended. Most browsers and clients support SNI.
    ///
    /// * To accept HTTPS connections from all viewers, including those that don't support SNI, set SSLSupportMethod to vip. This is not recommended, and results in additional monthly charges from CloudFront.
    ///
    ///
    ///
    ///
    /// * The minimum SSL/TLS protocol version that the distribution can use to communicate with viewers. To specify a minimum version, choose a value for MinimumProtocolVersion. For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) in the Amazon CloudFront Developer Guide.
    ///
    /// * The location of the SSL/TLS certificate, [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended) or [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html). You specify the location by setting a value in one of the following fields (not both):
    ///
    /// * ACMCertificateArn
    ///
    /// * IAMCertificateId
    ///
    ///
    ///
    ///
    ///
    /// All distributions support HTTPS connections from viewers. To require viewers to use HTTPS only, or to redirect them from HTTP to HTTPS, use ViewerProtocolPolicy in the CacheBehavior or DefaultCacheBehavior. To specify how CloudFront should use SSL/TLS to communicate with your custom origin, use CustomOriginConfig. For more information, see [Using HTTPS with CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html) and [ Using Alternate Domain Names and HTTPS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html) in the Amazon CloudFront Developer Guide.
    public struct ViewerCertificate: Swift.Sendable, Swift.Equatable {
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html), provide the Amazon Resource Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US East (N. Virginia) Region (us-east-1). If you specify an ACM certificate ARN, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var acmCertificateArn: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificate: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificateSource: CloudFrontClientTypes.CertificateSource?
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, set this field to true. If the distribution uses Aliases (alternate domain names or CNAMEs), set this field to false and specify values for the following fields:
        ///
        /// * ACMCertificateArn or IAMCertificateId (specify a value for one, not both)
        ///
        /// * MinimumProtocolVersion
        ///
        /// * SSLSupportMethod
        public var cloudFrontDefaultCertificate: Swift.Bool?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html), provide the ID of the IAM certificate. If you specify an IAM certificate ID, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var iamCertificateId: Swift.String?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify the security policy that you want CloudFront to use for HTTPS connections with viewers. The security policy determines two settings:
        ///
        /// * The minimum SSL/TLS protocol that CloudFront can use to communicate with viewers.
        ///
        /// * The ciphers that CloudFront can use to encrypt the content that it returns to viewers.
        ///
        ///
        /// For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) and [Supported Protocols and Ciphers Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers) in the Amazon CloudFront Developer Guide. On the CloudFront console, this setting is called Security Policy. When you're using SNI only (you set SSLSupportMethod to sni-only), you must specify TLSv1 or higher. If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net (you set CloudFrontDefaultCertificate to true), CloudFront automatically sets the security policy to TLSv1 regardless of the value that you set here.
        public var minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify which viewers the distribution accepts HTTPS connections from.
        ///
        /// * sni-only – The distribution accepts HTTPS connections from only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication). This is recommended. Most browsers and clients support SNI.
        ///
        /// * vip – The distribution accepts HTTPS connections from all viewers including those that don't support SNI. This is not recommended, and results in additional monthly charges from CloudFront.
        ///
        /// * static-ip - Do not specify this value unless your distribution has been enabled for this feature by the CloudFront team. If you have a use case that requires static IP addresses for a distribution, contact CloudFront through the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home).
        ///
        ///
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, don't set a value for this field.
        public var sslSupportMethod: CloudFrontClientTypes.SSLSupportMethod?

        public init(
            acmCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: CloudFrontClientTypes.CertificateSource? = nil,
            cloudFrontDefaultCertificate: Swift.Bool? = nil,
            iamCertificateId: Swift.String? = nil,
            minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion? = nil,
            sslSupportMethod: CloudFrontClientTypes.SSLSupportMethod? = nil
        )
        {
            self.acmCertificateArn = acmCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iamCertificateId = iamCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sslSupportMethod = sslSupportMethod
        }
    }
}

extension CloudFrontClientTypes {

    /// A distribution configuration.
    public struct DistributionConfig: Swift.Sendable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A complex type that contains zero or more CacheBehavior elements.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the DistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the distribution. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?
        /// The identifier of a continuous deployment policy. For more information, see CreateContinuousDeploymentPolicy.
        public var continuousDeploymentPolicyId: Swift.String?
        /// A complex type that controls the following:
        ///
        /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
        ///
        /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
        ///
        ///
        /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution (https://www.example.com) instead of an object in your distribution (https://www.example.com/product-description.html). Specifying a default root object avoids exposing the contents of your distribution. Specify only the object name, for example, index.html. Don't add a / before the object name. If you don't want to specify a default root object when you create a distribution, include an empty DefaultRootObject element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty DefaultRootObject element. To replace the default root object, update the distribution configuration and specify the new object. For more information about the default root object, see [Creating a Default Root Object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html) in the Amazon CloudFront Developer Guide.
        public var defaultRootObject: Swift.String?
        /// From this field, you can enable or disable the selected distribution.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// (Optional) Specify the HTTP version(s) that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 automatically use an earlier HTTP version. For viewers and CloudFront to use HTTP/2, viewers must support TLSv1.2 or later, and must support Server Name Indication (SNI). For viewers and CloudFront to use HTTP/3, viewers must support TLSv1.3 and Server Name Indication (SNI). CloudFront supports HTTP/3 connection migration to allow the viewer to switch networks without losing connection. For more information about connection migration, see [Connection Migration](https://www.rfc-editor.org/rfc/rfc9000.html#name-connection-migration) at RFC 9000. For more information about supported TLSv1.3 ciphers, see [Supported protocols and ciphers between viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html).
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your distribution, specify true. If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. In general, you should enable IPv6 if you have users on IPv6 networks who want to access your content. However, if you're using signed URLs or signed cookies to restrict access to your content, and if you're using a custom policy that includes the IpAddress parameter to restrict the IP addresses that can access your content, don't enable IPv6. If you want to restrict access to some content by IP address and not restrict access to other content (or restrict access but not by IP address), you can create two distributions. For more information, see [Creating a Signed URL Using a Custom Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html) in the Amazon CloudFront Developer Guide. If you're using an Route 53 Amazon Web Services Integration alias resource record set to route traffic to your CloudFront distribution, you need to create a second alias resource record set when both of the following are true:
        ///
        /// * You enable IPv6 for the distribution
        ///
        /// * You're using alternate domain names in the URLs for your objects
        ///
        ///
        /// For more information, see [Routing Traffic to an Amazon CloudFront Web Distribution by Using Your Domain Name](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html) in the Route 53 Amazon Web Services Integration Developer Guide. If you created a CNAME resource record set, either with Route 53 Amazon Web Services Integration or with another DNS service, you don't need to make any changes. A CNAME record will route traffic to your distribution regardless of the IP address format of the viewer request.
        public var isIPV6Enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the distribution. For more information about logging, see [Access Logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html) in the Amazon CloudFront Developer Guide.
        public var logging: CloudFrontClientTypes.LoggingConfig?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Viewers who are in or near regions that are excluded from your specified price class may encounter slower performance. For more information about price classes, see [Choosing the Price Class for a CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html) in the Amazon CloudFront Developer Guide. For information about CloudFront pricing, including how price classes (such as Price Class 100) map to CloudFront regions, see [Amazon CloudFront Pricing](http://aws.amazon.com/cloudfront/pricing/).
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// A Boolean that indicates whether this is a staging distribution. When this value is true, this is a staging distribution. When this value is false, this is not a staging distribution.
        public var staging: Swift.Bool?
        /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/a1b2c3d4-5678-90ab-cdef-EXAMPLE11111. To specify a web ACL created using WAF Classic, use the ACL ID, for example a1b2c3d4-5678-90ab-cdef-EXAMPLE11111. WAF is a web application firewall that lets you monitor the HTTP and HTTPS requests that are forwarded to CloudFront, and lets you control access to your content. Based on conditions that you specify, such as the IP addresses that requests originate from or the values of query strings, CloudFront responds to requests either with the requested content or with an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page when a request is blocked. For more information about WAF, see the [WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html).
        public var webACLId: Swift.String?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            continuousDeploymentPolicyId: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.LoggingConfig? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            staging: Swift.Bool? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.callerReference = callerReference
            self.comment = comment
            self.continuousDeploymentPolicyId = continuousDeploymentPolicyId
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.isIPV6Enabled = isIPV6Enabled
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.staging = staging
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfig(aliases: \(Swift.String(describing: aliases)), cacheBehaviors: \(Swift.String(describing: cacheBehaviors)), callerReference: \(Swift.String(describing: callerReference)), continuousDeploymentPolicyId: \(Swift.String(describing: continuousDeploymentPolicyId)), customErrorResponses: \(Swift.String(describing: customErrorResponses)), defaultCacheBehavior: \(Swift.String(describing: defaultCacheBehavior)), defaultRootObject: \(Swift.String(describing: defaultRootObject)), enabled: \(Swift.String(describing: enabled)), httpVersion: \(Swift.String(describing: httpVersion)), isIPV6Enabled: \(Swift.String(describing: isIPV6Enabled)), logging: \(Swift.String(describing: logging)), originGroups: \(Swift.String(describing: originGroups)), origins: \(Swift.String(describing: origins)), priceClass: \(Swift.String(describing: priceClass)), restrictions: \(Swift.String(describing: restrictions)), staging: \(Swift.String(describing: staging)), viewerCertificate: \(Swift.String(describing: viewerCertificate)), webACLId: \(Swift.String(describing: webACLId)), comment: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes {

    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public struct Distribution: Swift.Sendable {
        /// This field contains a list of key groups and the public keys in each key group that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. This field contains a list of Amazon Web Services account IDs and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// The distribution's Amazon Resource Name (ARN).
        /// This member is required.
        public var arn: Swift.String?
        /// The distribution's configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// The distribution's CloudFront domain name. For example: d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The distribution's identifier. For example: E1U5RQF7T870K0.
        /// This member is required.
        public var id: Swift.String?
        /// The number of invalidation batches currently in progress.
        /// This member is required.
        public var inProgressInvalidationBatches: Swift.Int?
        /// The date and time when the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The distribution's status. When the status is Deployed, the distribution's information is fully propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?

        public init(
            activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            arn: Swift.String? = nil,
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            inProgressInvalidationBatches: Swift.Int? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.activeTrustedKeyGroups = activeTrustedKeyGroups
            self.activeTrustedSigners = activeTrustedSigners
            self.aliasICPRecordals = aliasICPRecordals
            self.arn = arn
            self.distributionConfig = distributionConfig
            self.domainName = domainName
            self.id = id
            self.inProgressInvalidationBatches = inProgressInvalidationBatches
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }
}

public struct CopyDistributionOutput: Swift.Sendable {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The version identifier for the current version of the staging distribution.
    public var eTag: Swift.String?
    /// The URL of the staging distribution.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

/// You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCachePolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCachePolicies" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of cookies in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookiesInCachePolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of headers in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInCachePolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of query strings in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringsInCachePolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateCachePolicyInput: Swift.Sendable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
    }
}

public struct CreateCachePolicyOutput: Swift.Sendable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the cache policy just created.
    public var location: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
        self.location = location
    }
}

/// If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
public struct CloudFrontOriginAccessIdentityAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudFrontOriginAccessIdentityAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin access identities allowed.
public struct TooManyCloudFrontOriginAccessIdentities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCloudFrontOriginAccessIdentities" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// Origin access identity configuration. Send a GET request to the /CloudFront API version/CloudFront/identity ID/config resource.
    public struct CloudFrontOriginAccessIdentityConfig: Swift.Sendable {
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the CloudFrontOriginAccessIdentityConfig object), a new origin access identity is created. If the CallerReference is a value already sent in a previous identity request, and the content of the CloudFrontOriginAccessIdentityConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create an identity, but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the origin access identity. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
        }
    }
}

/// The request to create a new origin access identity (OAI). An origin access identity is a special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or just some of your Amazon S3 content. For more information, see [ Restricting Access to Amazon S3 Content by Using an Origin Access Identity](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
public struct CreateCloudFrontOriginAccessIdentityInput: Swift.Sendable {
    /// The current configuration information for the identity.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
    }
}

extension CloudFrontClientTypes {

    /// CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentity: Swift.Sendable {
        /// The current configuration information for the identity.
        public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
        /// The ID for the origin access identity, for example, E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, used when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init(
            cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateCloudFrontOriginAccessIdentityOutput: Swift.Sendable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new origin access identity just created.
    public var location: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
        self.location = location
    }
}

/// A continuous deployment policy with this configuration already exists.
public struct ContinuousDeploymentPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContinuousDeploymentPolicyAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A continuous deployment policy for this staging distribution already exists.
public struct StagingDistributionInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StagingDistributionInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of continuous deployment policies for this Amazon Web Services account.
public struct TooManyContinuousDeploymentPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyContinuousDeploymentPolicies" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// The CloudFront domain name of the staging distribution.
    public struct StagingDistributionDnsNames: Swift.Sendable {
        /// The CloudFront domain name of the staging distribution.
        public var items: [Swift.String]?
        /// The number of CloudFront domain names in your staging distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// This configuration determines which HTTP requests are sent to the staging distribution. If the HTTP request contains a header and value that matches what you specify here, the request is sent to the staging distribution. Otherwise the request is sent to the primary distribution.
    public struct ContinuousDeploymentSingleHeaderConfig: Swift.Sendable {
        /// The request header name that you want CloudFront to send to your staging distribution. The header must contain the prefix aws-cf-cd-.
        /// This member is required.
        public var header: Swift.String?
        /// The request header value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            header: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.header = header
            self.value = value
        }
    }
}

extension CloudFrontClientTypes {

    /// Session stickiness provides the ability to define multiple requests from a single viewer as a single session. This prevents the potentially inconsistent experience of sending some of a given user's requests to your staging distribution, while others are sent to your primary distribution. Define the session duration using TTL values.
    public struct SessionStickinessConfig: Swift.Sendable {
        /// The amount of time after which you want sessions to cease if no requests are received. Allowed values are 300–3600 seconds (5–60 minutes). The value must be less than or equal to MaximumTTL.
        /// This member is required.
        public var idleTTL: Swift.Int?
        /// The maximum amount of time to consider requests from the viewer as being part of the same session. Allowed values are 300–3600 seconds (5–60 minutes). The value must be greater than or equal to IdleTTL.
        /// This member is required.
        public var maximumTTL: Swift.Int?

        public init(
            idleTTL: Swift.Int? = nil,
            maximumTTL: Swift.Int? = nil
        )
        {
            self.idleTTL = idleTTL
            self.maximumTTL = maximumTTL
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains the percentage of traffic to send to a staging distribution.
    public struct ContinuousDeploymentSingleWeightConfig: Swift.Sendable {
        /// Session stickiness provides the ability to define multiple requests from a single viewer as a single session. This prevents the potentially inconsistent experience of sending some of a given user's requests to your staging distribution, while others are sent to your primary distribution. Define the session duration using TTL values.
        public var sessionStickinessConfig: CloudFrontClientTypes.SessionStickinessConfig?
        /// The percentage of traffic to send to a staging distribution, expressed as a decimal number between 0 and 0.15. For example, a value of 0.10 means 10% of traffic is sent to the staging distribution.
        /// This member is required.
        public var weight: Swift.Float?

        public init(
            sessionStickinessConfig: CloudFrontClientTypes.SessionStickinessConfig? = nil,
            weight: Swift.Float? = nil
        )
        {
            self.sessionStickinessConfig = sessionStickinessConfig
            self.weight = weight
        }
    }
}

extension CloudFrontClientTypes {

    public enum ContinuousDeploymentPolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case singleheader
        case singleweight
        case sdkUnknown(Swift.String)

        public static var allCases: [ContinuousDeploymentPolicyType] {
            return [
                .singleheader,
                .singleweight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleheader: return "SingleHeader"
            case .singleweight: return "SingleWeight"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// The traffic configuration of your continuous deployment.
    public struct TrafficConfig: Swift.Sendable {
        /// Determines which HTTP requests are sent to the staging distribution.
        public var singleHeaderConfig: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig?
        /// Contains the percentage of traffic to send to the staging distribution.
        public var singleWeightConfig: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig?
        /// The type of traffic configuration.
        /// This member is required.
        public var type: CloudFrontClientTypes.ContinuousDeploymentPolicyType?

        public init(
            singleHeaderConfig: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig? = nil,
            singleWeightConfig: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig? = nil,
            type: CloudFrontClientTypes.ContinuousDeploymentPolicyType? = nil
        )
        {
            self.singleHeaderConfig = singleHeaderConfig
            self.singleWeightConfig = singleWeightConfig
            self.type = type
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains the configuration for a continuous deployment policy.
    public struct ContinuousDeploymentPolicyConfig: Swift.Sendable {
        /// A Boolean that indicates whether this continuous deployment policy is enabled (in effect). When this value is true, this policy is enabled and in effect. When this value is false, this policy is not enabled and has no effect.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The CloudFront domain name of the staging distribution. For example: d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var stagingDistributionDnsNames: CloudFrontClientTypes.StagingDistributionDnsNames?
        /// Contains the parameters for routing production traffic from your primary to staging distributions.
        public var trafficConfig: CloudFrontClientTypes.TrafficConfig?

        public init(
            enabled: Swift.Bool? = nil,
            stagingDistributionDnsNames: CloudFrontClientTypes.StagingDistributionDnsNames? = nil,
            trafficConfig: CloudFrontClientTypes.TrafficConfig? = nil
        )
        {
            self.enabled = enabled
            self.stagingDistributionDnsNames = stagingDistributionDnsNames
            self.trafficConfig = trafficConfig
        }
    }
}

public struct CreateContinuousDeploymentPolicyInput: Swift.Sendable {
    /// Contains the configuration for a continuous deployment policy.
    /// This member is required.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
    }
}

extension CloudFrontClientTypes {

    /// A continuous deployment policy.
    public struct ContinuousDeploymentPolicy: Swift.Sendable {
        /// Contains the configuration for a continuous deployment policy.
        /// This member is required.
        public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
        /// The identifier of the continuous deployment policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the continuous deployment policy was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?

        public init(
            continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil
        )
        {
            self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct CreateContinuousDeploymentPolicyOutput: Swift.Sendable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?
    /// The location of the continuous deployment policy.
    public var location: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
        self.location = location
    }
}

/// You cannot delete a continuous deployment policy that is associated with a primary distribution.
public struct ContinuousDeploymentPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContinuousDeploymentPolicyInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).
public struct IllegalOriginAccessConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalOriginAccessConfiguration" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An origin access control is associated with an origin whose domain name is not supported.
public struct InvalidDomainNameForOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDomainNameForOriginAccessControl" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The continuous deployment policy doesn't exist.
public struct NoSuchContinuousDeploymentPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchContinuousDeploymentPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request to create a new distribution.
public struct CreateDistributionInput: Swift.Sendable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil
    )
    {
        self.distributionConfig = distributionConfig
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionOutput: Swift.Sendable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

/// The tagging specified is not valid.
public struct InvalidTagging: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagging" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains Tag key and Tag value.
    public struct Tag: Swift.Sendable {
        /// A string that contains Tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional Tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains zero or more Tag elements.
    public struct Tags: Swift.Sendable {
        /// A complex type that contains Tag elements.
        public var items: [CloudFrontClientTypes.Tag]?

        public init(
            items: [CloudFrontClientTypes.Tag]? = nil
        )
        {
            self.items = items
        }
    }
}

extension CloudFrontClientTypes {

    /// A distribution Configuration and a list of tags to be associated with the distribution.
    public struct DistributionConfigWithTags: Swift.Sendable {
        /// A distribution configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init(
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.distributionConfig = distributionConfig
            self.tags = tags
        }
    }
}

/// The request to create a new distribution with tags.
public struct CreateDistributionWithTagsInput: Swift.Sendable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?

    public init(
        distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags? = nil
    )
    {
        self.distributionConfigWithTags = distributionConfigWithTags
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionWithTagsOutput: Swift.Sendable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

/// The specified configuration for field-level encryption already exists.
public struct FieldLevelEncryptionConfigAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionConfigAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified profile for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionProfile: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFieldLevelEncryptionProfile" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// No profile specified for the field-level encryption query argument.
public struct QueryArgProfileEmpty: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryArgProfileEmpty" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of configurations for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionConfigs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionConfigs" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of content type profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionContentTypeProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionContentTypeProfiles" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of query arg profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionQueryArgProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionQueryArgProfiles" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum Format: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case urlencoded
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .urlencoded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .urlencoded: return "URLEncoded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A field-level encryption content type profile.
    public struct ContentTypeProfile: Swift.Sendable {
        /// The content type for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var contentType: Swift.String?
        /// The format for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var format: CloudFrontClientTypes.Format?
        /// The profile ID for a field-level encryption content type-profile mapping.
        public var profileId: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            format: CloudFrontClientTypes.Format? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.format = format
            self.profileId = profileId
        }
    }
}

extension CloudFrontClientTypes {

    /// Field-level encryption content type-profile.
    public struct ContentTypeProfiles: Swift.Sendable {
        /// Items in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.ContentTypeProfile]?
        /// The number of field-level encryption content type-profile mappings.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ContentTypeProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// The configuration for a field-level encryption content type-profile mapping.
    public struct ContentTypeProfileConfig: Swift.Sendable {
        /// The configuration for a field-level encryption content type-profile.
        public var contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles?
        /// The setting in a field-level encryption content type-profile mapping that specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
        /// This member is required.
        public var forwardWhenContentTypeIsUnknown: Swift.Bool?

        public init(
            contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles? = nil,
            forwardWhenContentTypeIsUnknown: Swift.Bool? = nil
        )
        {
            self.contentTypeProfiles = contentTypeProfiles
            self.forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown
        }
    }
}

extension CloudFrontClientTypes {

    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfile: Swift.Sendable {
        /// ID of profile to use for field-level encryption query argument-profile mapping
        /// This member is required.
        public var profileId: Swift.String?
        /// Query argument for field-level encryption query argument-profile mapping.
        /// This member is required.
        public var queryArg: Swift.String?

        public init(
            profileId: Swift.String? = nil,
            queryArg: Swift.String? = nil
        )
        {
            self.profileId = profileId
            self.queryArg = queryArg
        }
    }
}

extension CloudFrontClientTypes {

    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfiles: Swift.Sendable {
        /// Number of items for query argument-profile mapping for field-level encryption.
        public var items: [CloudFrontClientTypes.QueryArgProfile]?
        /// Number of profiles for query argument-profile mapping for field-level encryption.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.QueryArgProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// Configuration for query argument-profile mapping for field-level encryption.
    public struct QueryArgProfileConfig: Swift.Sendable {
        /// Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
        /// This member is required.
        public var forwardWhenQueryArgProfileIsUnknown: Swift.Bool?
        /// Profiles specified for query argument-profile mapping for field-level encryption.
        public var queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles?

        public init(
            forwardWhenQueryArgProfileIsUnknown: Swift.Bool? = nil,
            queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles? = nil
        )
        {
            self.forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown
            self.queryArgProfiles = queryArgProfiles
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex data type that includes the profile configurations specified for field-level encryption.
    public struct FieldLevelEncryptionConfig: Swift.Sendable {
        /// A unique number that ensures the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment about the configuration. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default in a request if a query argument doesn't specify a profile to use.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a query argument in a request.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }
}

public struct CreateFieldLevelEncryptionConfigInput: Swift.Sendable {
    /// The request to create a new field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init(
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

extension CloudFrontClientTypes {

    /// A complex data type that includes the profile configurations and other options specified for field-level encryption.
    public struct FieldLevelEncryption: Swift.Sendable {
        /// A complex data type that includes the profile configurations specified for field-level encryption.
        /// This member is required.
        public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
        /// The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption configuration was changed.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?

        public init(
            fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil
        )
        {
            self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct CreateFieldLevelEncryptionConfigOutput: Swift.Sendable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
    /// The fully qualified URI of the new configuration resource just created.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
        self.location = location
    }
}

/// The specified profile for field-level encryption already exists.
public struct FieldLevelEncryptionProfileAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum size of a profile for field-level encryption was exceeded.
public struct FieldLevelEncryptionProfileSizeExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileSizeExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified public key doesn't exist.
public struct NoSuchPublicKey: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchPublicKey" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of encryption entities for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionEncryptionEntities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionEncryptionEntities" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of field patterns for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionFieldPatterns: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionFieldPatterns" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionProfiles" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// A complex data type that includes the field patterns to match for field-level encryption.
    public struct FieldPatterns: Swift.Sendable {
        /// An array of the field-level encryption field patterns.
        public var items: [Swift.String]?
        /// The number of field-level encryption field patterns.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications.
    public struct EncryptionEntity: Swift.Sendable {
        /// Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have both ABC* and AB*. Note that field patterns are case-sensitive.
        /// This member is required.
        public var fieldPatterns: CloudFrontClientTypes.FieldPatterns?
        /// The provider associated with the public key being used for encryption. This value must also be provided with the private key for applications to be able to decrypt data.
        /// This member is required.
        public var providerId: Swift.String?
        /// The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match the patterns.
        /// This member is required.
        public var publicKeyId: Swift.String?

        public init(
            fieldPatterns: CloudFrontClientTypes.FieldPatterns? = nil,
            providerId: Swift.String? = nil,
            publicKeyId: Swift.String? = nil
        )
        {
            self.fieldPatterns = fieldPatterns
            self.providerId = providerId
            self.publicKeyId = publicKeyId
        }
    }
}

extension CloudFrontClientTypes {

    /// Complex data type for field-level encryption profiles that includes all of the encryption entities.
    public struct EncryptionEntities: Swift.Sendable {
        /// An array of field patterns in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.EncryptionEntity]?
        /// Number of field pattern items in a field-level encryption content type-profile mapping.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.EncryptionEntity]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex data type of profiles for the field-level encryption.
    public struct FieldLevelEncryptionProfileConfig: Swift.Sendable {
        /// A unique number that ensures that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment for the field-level encryption profile. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// Profile name for the field-level encryption profile.
        /// This member is required.
        public var name: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.name = name
        }
    }
}

public struct CreateFieldLevelEncryptionProfileInput: Swift.Sendable {
    /// The request to create a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init(
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

extension CloudFrontClientTypes {

    /// A complex data type for field-level encryption profiles.
    public struct FieldLevelEncryptionProfile: Swift.Sendable {
        /// A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.
        /// This member is required.
        public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
        /// The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption profile was updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?

        public init(
            fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil
        )
        {
            self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct CreateFieldLevelEncryptionProfileOutput: Swift.Sendable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
    /// The fully qualified URI of the new profile resource just created.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
        self.location = location
    }
}

/// A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use UpdateFunction.
public struct FunctionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The function is too large. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct FunctionSizeLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionSizeLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFunctions" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This operation is not supported in this region.
public struct UnsupportedOperation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// The key value store association.
    public struct KeyValueStoreAssociation: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the key value store association.
        /// This member is required.
        public var keyValueStoreARN: Swift.String?

        public init(
            keyValueStoreARN: Swift.String? = nil
        )
        {
            self.keyValueStoreARN = keyValueStoreARN
        }
    }
}

extension CloudFrontClientTypes {

    /// The key value store associations.
    public struct KeyValueStoreAssociations: Swift.Sendable {
        /// The items of the key value store association.
        public var items: [CloudFrontClientTypes.KeyValueStoreAssociation]?
        /// The quantity of key value store associations.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.KeyValueStoreAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    public enum FunctionRuntime: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudfrontJs10
        case cloudfrontJs20
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionRuntime] {
            return [
                .cloudfrontJs10,
                .cloudfrontJs20
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontJs10: return "cloudfront-js-1.0"
            case .cloudfrontJs20: return "cloudfront-js-2.0"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains configuration information about a CloudFront function.
    public struct FunctionConfig: Swift.Sendable {
        /// A comment to describe the function.
        /// This member is required.
        public var comment: Swift.String?
        /// The configuration for the key value store associations.
        public var keyValueStoreAssociations: CloudFrontClientTypes.KeyValueStoreAssociations?
        /// The function's runtime environment version.
        /// This member is required.
        public var runtime: CloudFrontClientTypes.FunctionRuntime?

        public init(
            comment: Swift.String? = nil,
            keyValueStoreAssociations: CloudFrontClientTypes.KeyValueStoreAssociations? = nil,
            runtime: CloudFrontClientTypes.FunctionRuntime? = nil
        )
        {
            self.comment = comment
            self.keyValueStoreAssociations = keyValueStoreAssociations
            self.runtime = runtime
        }
    }
}

public struct CreateFunctionInput: Swift.Sendable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: Foundation.Data?
    /// Configuration information about the function, including an optional comment and the function's runtime.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// A name to identify the function.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionCode: Foundation.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.name = name
    }
}

extension CreateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionInput(functionConfig: \(Swift.String(describing: functionConfig)), name: \(Swift.String(describing: name)), functionCode: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes {

    public enum FunctionStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionStage] {
            return [
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains metadata about a CloudFront function.
    public struct FunctionMetadata: Swift.Sendable {
        /// The date and time when the function was created.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the function.
        /// This member is required.
        public var functionARN: Swift.String?
        /// The date and time when the function was most recently updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The stage that the function is in, either DEVELOPMENT or LIVE. When a function is in the DEVELOPMENT stage, you can test the function with TestFunction, and update it with UpdateFunction. When a function is in the LIVE stage, you can attach the function to a distribution's cache behavior, using the function's ARN.
        public var stage: CloudFrontClientTypes.FunctionStage?

        public init(
            createdTime: Foundation.Date? = nil,
            functionARN: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            stage: CloudFrontClientTypes.FunctionStage? = nil
        )
        {
            self.createdTime = createdTime
            self.functionARN = functionARN
            self.lastModifiedTime = lastModifiedTime
            self.stage = stage
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains configuration information and metadata about a CloudFront function.
    public struct FunctionSummary: Swift.Sendable {
        /// Contains configuration information about a CloudFront function.
        /// This member is required.
        public var functionConfig: CloudFrontClientTypes.FunctionConfig?
        /// Contains metadata about a CloudFront function.
        /// This member is required.
        public var functionMetadata: CloudFrontClientTypes.FunctionMetadata?
        /// The name of the CloudFront function.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the CloudFront function.
        public var status: Swift.String?

        public init(
            functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
            functionMetadata: CloudFrontClientTypes.FunctionMetadata? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.functionConfig = functionConfig
            self.functionMetadata = functionMetadata
            self.name = name
            self.status = status
        }
    }
}

public struct CreateFunctionOutput: Swift.Sendable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?
    /// The URL of the CloudFront function. Use the URL to manage the function with the CloudFront API.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
        self.location = location
    }
}

/// You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.
public struct TooManyInvalidationsInProgress: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyInvalidationsInProgress" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
    public struct Paths: Swift.Sendable {
        /// A complex type that contains a list of the paths that you want to invalidate.
        public var items: [Swift.String]?
        /// The number of invalidation paths specified for the objects that you want to invalidate.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// An invalidation batch.
    public struct InvalidationBatch: Swift.Sendable {
        /// A value that you specify to uniquely identify an invalidation request. CloudFront uses the value to prevent you from accidentally resubmitting an identical request. Whenever you create a new invalidation request, you must specify a new value for CallerReference and change other values in the request as applicable. One way to ensure that the value of CallerReference is unique is to use a timestamp, for example, 20120301090000. If you make a second invalidation request with the same value for CallerReference, and if the rest of the request is the same, CloudFront doesn't create a new invalidation request. Instead, CloudFront returns information about the invalidation request that you previously created with the same CallerReference. If CallerReference is a value you already sent in a previous invalidation batch request but the content of any Path is different from the original request, CloudFront returns an InvalidationBatchAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var paths: CloudFrontClientTypes.Paths?

        public init(
            callerReference: Swift.String? = nil,
            paths: CloudFrontClientTypes.Paths? = nil
        )
        {
            self.callerReference = callerReference
            self.paths = paths
        }
    }
}

/// The request to create an invalidation.
public struct CreateInvalidationInput: Swift.Sendable {
    /// The distribution's id.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The batch information for the invalidation.
    /// This member is required.
    public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?

    public init(
        distributionId: Swift.String? = nil,
        invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil
    )
    {
        self.distributionId = distributionId
        self.invalidationBatch = invalidationBatch
    }
}

extension CloudFrontClientTypes {

    /// An invalidation.
    public struct Invalidation: Swift.Sendable {
        /// The date and time the invalidation request was first made.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The identifier for the invalidation request. For example: IDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The current invalidation information for the batch request.
        /// This member is required.
        public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
        /// The status of the invalidation request. When the invalidation batch is finished, the status is Completed.
        /// This member is required.
        public var status: Swift.String?

        public init(
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.invalidationBatch = invalidationBatch
            self.status = status
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateInvalidationOutput: Swift.Sendable {
    /// The invalidation's information.
    public var invalidation: CloudFrontClientTypes.Invalidation?
    /// The fully qualified URI of the distribution and invalidation batch request, including the Invalidation ID.
    public var location: Swift.String?

    public init(
        invalidation: CloudFrontClientTypes.Invalidation? = nil,
        location: Swift.String? = nil
    )
    {
        self.invalidation = invalidation
        self.location = location
    }
}

/// A key group with this name already exists. You must provide a unique name. To modify an existing key group, use UpdateKeyGroup.
public struct KeyGroupAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KeyGroupAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroups: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyKeyGroups" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of public keys in this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyPublicKeysInKeyGroup: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPublicKeysInKeyGroup" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// A key group configuration. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroupConfig: Swift.Sendable {
        /// A comment to describe the key group. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A list of the identifiers of the public keys in the key group.
        /// This member is required.
        public var items: [Swift.String]?
        /// A name to identify the key group.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            items: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.items = items
            self.name = name
        }
    }
}

public struct CreateKeyGroupInput: Swift.Sendable {
    /// A key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.keyGroupConfig = keyGroupConfig
    }
}

extension CloudFrontClientTypes {

    /// A key group. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroup: Swift.Sendable {
        /// The identifier for the key group.
        /// This member is required.
        public var id: Swift.String?
        /// The key group configuration.
        /// This member is required.
        public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
        /// The date and time when the key group was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?

        public init(
            id: Swift.String? = nil,
            keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil,
            lastModifiedTime: Foundation.Date? = nil
        )
        {
            self.id = id
            self.keyGroupConfig = keyGroupConfig
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

public struct CreateKeyGroupOutput: Swift.Sendable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just created.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?
    /// The URL of the key group.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
        self.location = location
    }
}

/// The key value store entity already exists. You must provide a unique key value store entity.
public struct EntityAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The key value store entity limit has been exceeded.
public struct EntityLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The key value store entity size limit was exceeded.
public struct EntitySizeLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitySizeLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum ImportSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportSourceType] {
            return [
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// The import source for the key value store.
    public struct ImportSource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the import source for the key value store.
        /// This member is required.
        public var sourceARN: Swift.String?
        /// The source type of the import source for the key value store.
        /// This member is required.
        public var sourceType: CloudFrontClientTypes.ImportSourceType?

        public init(
            sourceARN: Swift.String? = nil,
            sourceType: CloudFrontClientTypes.ImportSourceType? = nil
        )
        {
            self.sourceARN = sourceARN
            self.sourceType = sourceType
        }
    }
}

public struct CreateKeyValueStoreInput: Swift.Sendable {
    /// The comment of the key value store.
    public var comment: Swift.String?
    /// The S3 bucket that provides the source for the import. The source must be in a valid JSON format.
    public var importSource: CloudFrontClientTypes.ImportSource?
    /// The name of the key value store. The minimum length is 1 character and the maximum length is 64 characters.
    /// This member is required.
    public var name: Swift.String?

    public init(
        comment: Swift.String? = nil,
        importSource: CloudFrontClientTypes.ImportSource? = nil,
        name: Swift.String? = nil
    )
    {
        self.comment = comment
        self.importSource = importSource
        self.name = name
    }
}

extension CloudFrontClientTypes {

    /// The key value store. Use this to separate data from function code, allowing you to update data without having to publish a new version of a function. The key value store holds keys and their corresponding values.
    public struct KeyValueStore: Swift.Sendable, Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the key value store.
        /// This member is required.
        public var arn: Swift.String?
        /// A comment for the key value store.
        /// This member is required.
        public var comment: Swift.String?
        /// The unique Id for the key value store.
        /// This member is required.
        public var id: Swift.String?
        /// The last-modified time of the key value store.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the key value store.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the key value store.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.comment = comment
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }
}

public struct CreateKeyValueStoreOutput: Swift.Sendable {
    /// The ETag in the resulting key value store.
    public var eTag: Swift.String?
    /// The resulting key value store.
    public var keyValueStore: CloudFrontClientTypes.KeyValueStore?
    /// The location of the resulting key value store.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        keyValueStore: CloudFrontClientTypes.KeyValueStore? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyValueStore = keyValueStore
        self.location = location
    }
}

/// A monitoring subscription already exists for the specified distribution.
public struct MonitoringSubscriptionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MonitoringSubscriptionAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum RealtimeMetricsSubscriptionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RealtimeMetricsSubscriptionStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A subscription configuration for additional CloudWatch metrics.
    public struct RealtimeMetricsSubscriptionConfig: Swift.Sendable {
        /// A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
        /// This member is required.
        public var realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus?

        public init(
            realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus? = nil
        )
        {
            self.realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus
        }
    }
}

extension CloudFrontClientTypes {

    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public struct MonitoringSubscription: Swift.Sendable {
        /// A subscription configuration for additional CloudWatch metrics.
        public var realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?

        public init(
            realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig? = nil
        )
        {
            self.realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig
        }
    }
}

public struct CreateMonitoringSubscriptionInput: Swift.Sendable {
    /// The ID of the distribution that you are enabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    /// This member is required.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        distributionId: Swift.String? = nil,
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.distributionId = distributionId
        self.monitoringSubscription = monitoringSubscription
    }
}

public struct CreateMonitoringSubscriptionOutput: Swift.Sendable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

/// An origin access control with the specified parameters already exists.
public struct OriginAccessControlAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginAccessControlAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of origin access controls in your Amazon Web Services account exceeds the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginAccessControls: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginAccessControls" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum OriginAccessControlOriginTypes: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lambda
        case mediapackagev2
        case mediastore
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlOriginTypes] {
            return [
                .lambda,
                .mediapackagev2,
                .mediastore,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "lambda"
            case .mediapackagev2: return "mediapackagev2"
            case .mediastore: return "mediastore"
            case .s3: return "s3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    public enum OriginAccessControlSigningBehaviors: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case always
        case never
        case noOverride
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlSigningBehaviors] {
            return [
                .always,
                .never,
                .noOverride
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .always: return "always"
            case .never: return "never"
            case .noOverride: return "no-override"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    public enum OriginAccessControlSigningProtocols: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sigv4
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlSigningProtocols] {
            return [
                .sigv4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sigv4: return "sigv4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// A CloudFront origin access control configuration.
    public struct OriginAccessControlConfig: Swift.Sendable {
        /// A description of the origin access control.
        public var description: Swift.String?
        /// A name to identify the origin access control. You can specify up to 64 characters.
        /// This member is required.
        public var name: Swift.String?
        /// The type of origin that this origin access control is for.
        /// This member is required.
        public var originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes?
        /// Specifies which requests CloudFront signs (adds authentication information to). Specify always for the most common use case. For more information, see [origin access control advanced settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html#oac-advanced-settings) in the Amazon CloudFront Developer Guide. This field can have one of the following values:
        ///
        /// * always – CloudFront signs all origin requests, overwriting the Authorization header from the viewer request if one exists.
        ///
        /// * never – CloudFront doesn't sign any origin requests. This value turns off origin access control for all origins in all distributions that use this origin access control.
        ///
        /// * no-override – If the viewer request doesn't contain the Authorization header, then CloudFront signs the origin request. If the viewer request contains the Authorization header, then CloudFront doesn't sign the origin request and instead passes along the Authorization header from the viewer request. WARNING: To pass along the Authorization header from the viewer request, you must add the Authorization header to a [cache policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html) for all cache behaviors that use origins associated with this origin access control.
        /// This member is required.
        public var signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors?
        /// The signing protocol of the origin access control, which determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
        /// This member is required.
        public var signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes? = nil,
            signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors? = nil,
            signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols? = nil
        )
        {
            self.description = description
            self.name = name
            self.originAccessControlOriginType = originAccessControlOriginType
            self.signingBehavior = signingBehavior
            self.signingProtocol = signingProtocol
        }
    }
}

public struct CreateOriginAccessControlInput: Swift.Sendable {
    /// Contains the origin access control.
    /// This member is required.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.originAccessControlConfig = originAccessControlConfig
    }
}

extension CloudFrontClientTypes {

    /// A CloudFront origin access control, including its unique identifier.
    public struct OriginAccessControl: Swift.Sendable {
        /// The unique identifier of the origin access control.
        /// This member is required.
        public var id: Swift.String?
        /// The origin access control.
        public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

        public init(
            id: Swift.String? = nil,
            originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
        )
        {
            self.id = id
            self.originAccessControlConfig = originAccessControlConfig
        }
    }
}

public struct CreateOriginAccessControlOutput: Swift.Sendable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// The URL of the origin access control.
    public var location: Swift.String?
    /// Contains an origin access control.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originAccessControl = originAccessControl
    }
}

/// An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use UpdateOriginRequestPolicy.
public struct OriginRequestPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginRequestPolicyAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of cookies in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookiesInOriginRequestPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of headers in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInOriginRequestPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginRequestPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginRequestPolicies" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of query strings in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringsInOriginRequestPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    public enum OriginRequestPolicyCookieBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyCookiesConfig: Swift.Sendable {
        /// Determines whether cookies in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No cookies in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – Only the cookies in viewer requests that are listed in the CookieNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All cookies in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All cookies in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the CookieNames type, which are not included.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init(
            cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }
}

extension CloudFrontClientTypes {

    public enum OriginRequestPolicyHeaderBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allexcept
        case allviewer
        case allviewerandwhitelistcloudfront
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyHeaderBehavior] {
            return [
                .allexcept,
                .allviewer,
                .allviewerandwhitelistcloudfront,
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allexcept: return "allExcept"
            case .allviewer: return "allViewer"
            case .allviewerandwhitelistcloudfront: return "allViewerAndWhitelistCloudFront"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// An object that determines whether any HTTP headers (and if so, which headers) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyHeadersConfig: Swift.Sendable {
        /// Determines whether any HTTP headers are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No HTTP headers in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – Only the HTTP headers that are listed in the Headers type are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewer – All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewerAndWhitelistCloudFront – All HTTP headers in viewer requests and the additional CloudFront headers that are listed in the Headers type are included in requests that CloudFront sends to the origin. The additional headers are added by CloudFront.
        ///
        /// * allExcept – All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the Headers type, which are not included.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init(
            headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }
}

extension CloudFrontClientTypes {

    public enum OriginRequestPolicyQueryStringBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyQueryStringsConfig: Swift.Sendable {
        /// Determines whether any URL query strings in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No query strings in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – Only the query strings in viewer requests that are listed in the QueryStringNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All query strings in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All query strings in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the QueryStringNames type, which are not included.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the OriginRequestPolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init(
            queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }
}

extension CloudFrontClientTypes {

    /// An origin request policy configuration. This configuration determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can't find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicyConfig: Swift.Sendable {
        /// A comment to describe the origin request policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The cookies from viewer requests to include in origin requests.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?
        /// The HTTP headers to include in origin requests. These can include headers from viewer requests and additional headers added by CloudFront.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?
        /// A unique name to identify the origin request policy.
        /// This member is required.
        public var name: Swift.String?
        /// The URL query strings from viewer requests to include in origin requests.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?

        public init(
            comment: Swift.String? = nil,
            cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig? = nil,
            headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig? = nil,
            name: Swift.String? = nil,
            queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig? = nil
        )
        {
            self.comment = comment
            self.cookiesConfig = cookiesConfig
            self.headersConfig = headersConfig
            self.name = name
            self.queryStringsConfig = queryStringsConfig
        }
    }
}

public struct CreateOriginRequestPolicyInput: Swift.Sendable {
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

extension CloudFrontClientTypes {

    /// An origin request policy. When it's attached to a cache behavior, the origin request policy determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can't find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicy: Swift.Sendable {
        /// The unique identifier for the origin request policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the origin request policy was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The origin request policy configuration.
        /// This member is required.
        public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

        public init(
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.originRequestPolicyConfig = originRequestPolicyConfig
        }
    }
}

public struct CreateOriginRequestPolicyOutput: Swift.Sendable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the origin request policy just created.
    public var location: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originRequestPolicy = originRequestPolicy
    }
}

/// The specified public key already exists.
public struct PublicKeyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PublicKeyAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.
public struct TooManyPublicKeys: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPublicKeys" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyConfig: Swift.Sendable {
        /// A string included in the request to help make sure that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var encodedKey: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encodedKey: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encodedKey = encodedKey
            self.name = name
        }
    }
}

public struct CreatePublicKeyInput: Swift.Sendable {
    /// A CloudFront public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.publicKeyConfig = publicKeyConfig
    }
}

extension CloudFrontClientTypes {

    /// A public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKey: Swift.Sendable {
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

        public init(
            createdTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
        )
        {
            self.createdTime = createdTime
            self.id = id
            self.publicKeyConfig = publicKeyConfig
        }
    }
}

public struct CreatePublicKeyOutput: Swift.Sendable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The URL of the public key.
    public var location: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.publicKey = publicKey
    }
}

/// A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use UpdateRealtimeLogConfig.
public struct RealtimeLogConfigAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRealtimeLogConfigs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRealtimeLogConfigs" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public struct KinesisStreamConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that CloudFront can use to send real-time log data to your Kinesis data stream. For more information the IAM role, see [Real-time log configuration IAM role](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var roleARN: Swift.String?
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time log data.
        /// This member is required.
        public var streamARN: Swift.String?

        public init(
            roleARN: Swift.String? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.roleARN = roleARN
            self.streamARN = streamARN
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data in a real-time log configuration.
    public struct EndPoint: Swift.Sendable {
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
        public var kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig?
        /// The type of data stream where you are sending real-time log data. The only valid value is Kinesis.
        /// This member is required.
        public var streamType: Swift.String?

        public init(
            kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig? = nil,
            streamType: Swift.String? = nil
        )
        {
            self.kinesisStreamConfig = kinesisStreamConfig
            self.streamType = streamType
        }
    }
}

public struct CreateRealtimeLogConfigInput: Swift.Sendable {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    /// This member is required.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var fields: [Swift.String]?
    /// A unique name to identify this real-time log configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. You can specify a whole number between 1 and 100 (inclusive) to determine the percentage of viewer requests that are represented in the real-time log data.
    /// This member is required.
    public var samplingRate: Swift.Int?

    public init(
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

extension CloudFrontClientTypes {

    /// A real-time log configuration.
    public struct RealtimeLogConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this real-time log configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data for this real-time log configuration.
        /// This member is required.
        public var endPoints: [CloudFrontClientTypes.EndPoint]?
        /// A list of fields that are included in each real-time log record. In an API response, the fields are provided in the same order in which they are sent to the Amazon Kinesis data stream. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var fields: [Swift.String]?
        /// The unique name of this real-time log configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. The sampling rate is an integer between 1 and 100, inclusive.
        /// This member is required.
        public var samplingRate: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
            fields: [Swift.String]? = nil,
            name: Swift.String? = nil,
            samplingRate: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.endPoints = endPoints
            self.fields = fields
            self.name = name
            self.samplingRate = samplingRate
        }
    }
}

public struct CreateRealtimeLogConfigOutput: Swift.Sendable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

/// A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use UpdateResponseHeadersPolicy.
public struct ResponseHeadersPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResponseHeadersPolicyAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The length of the Content-Security-Policy header value in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooLongCSPInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooLongCSPInResponseHeadersPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of custom headers in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCustomHeadersInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCustomHeadersInResponseHeadersPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of headers in RemoveHeadersConfig in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRemoveHeadersInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRemoveHeadersInResponseHeadersPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum number of response headers policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyResponseHeadersPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyResponseHeadersPolicies" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowHeaders: Swift.Sendable {
        /// The list of HTTP header names. You can specify * to allow all headers.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of HTTP header names in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowMethods: Swift.Sendable {
        /// The list of HTTP methods. Valid values are:
        ///
        /// * GET
        ///
        /// * DELETE
        ///
        /// * HEAD
        ///
        /// * OPTIONS
        ///
        /// * PATCH
        ///
        /// * POST
        ///
        /// * PUT
        ///
        /// * ALL
        ///
        ///
        /// ALL is a special value that includes all of the listed HTTP methods.
        /// This member is required.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]?
        /// The number of HTTP methods in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowOrigins: Swift.Sendable {
        /// The list of origins (domain names). You can specify * to allow all origins.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of origins in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlExposeHeaders: Swift.Sendable {
        /// The list of HTTP headers. You can specify * to expose all headers.
        public var items: [Swift.String]?
        /// The number of HTTP headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS). CloudFront adds these headers to HTTP responses that it sends for CORS requests that match a cache behavior associated with this response headers policy. For more information about CORS, see [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) in the MDN Web Docs.
    public struct ResponseHeadersPolicyCorsConfig: Swift.Sendable {
        /// A Boolean that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header. For more information about the Access-Control-Allow-Credentials HTTP response header, see [Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowCredentials: Swift.Bool?
        /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders?
        /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods?
        /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins?
        /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
        public var accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders?
        /// A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header. For more information about the Access-Control-Max-Age HTTP response header, see [Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age) in the MDN Web Docs.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront overrides HTTP response headers received from the origin with the ones specified in this response headers policy.
        /// This member is required.
        public var originOverride: Swift.Bool?

        public init(
            accessControlAllowCredentials: Swift.Bool? = nil,
            accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders? = nil,
            accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods? = nil,
            accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins? = nil,
            accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders? = nil,
            accessControlMaxAgeSec: Swift.Int? = nil,
            originOverride: Swift.Bool? = nil
        )
        {
            self.accessControlAllowCredentials = accessControlAllowCredentials
            self.accessControlAllowHeaders = accessControlAllowHeaders
            self.accessControlAllowMethods = accessControlAllowMethods
            self.accessControlAllowOrigins = accessControlAllowOrigins
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.originOverride = originOverride
        }
    }
}

extension CloudFrontClientTypes {

    /// An HTTP response header name and its value. CloudFront includes this header in HTTP responses that it sends for requests that match a cache behavior that's associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeader: Swift.Sendable {
        /// The HTTP response header name.
        /// This member is required.
        public var header: Swift.String?
        /// A Boolean that determines whether CloudFront overrides a response header with the same name received from the origin with the header specified here.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value for the HTTP response header.
        /// This member is required.
        public var value: Swift.String?

        public init(
            header: Swift.String? = nil,
            `override`: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.header = header
            self.`override` = `override`
            self.value = value
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of HTTP response header names and their values. CloudFront includes these headers in HTTP responses that it sends for requests that match a cache behavior that's associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeadersConfig: Swift.Sendable {
        /// The list of HTTP response headers and their values.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]?
        /// The number of HTTP response headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// The name of an HTTP header that CloudFront removes from HTTP responses to requests that match the cache behavior that this response headers policy is attached to.
    public struct ResponseHeadersPolicyRemoveHeader: Swift.Sendable {
        /// The HTTP header name.
        /// This member is required.
        public var header: Swift.String?

        public init(
            header: Swift.String? = nil
        )
        {
            self.header = header
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of HTTP header names that CloudFront removes from HTTP responses to requests that match the cache behavior that this response headers policy is attached to.
    public struct ResponseHeadersPolicyRemoveHeadersConfig: Swift.Sendable {
        /// The list of HTTP header names.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]?
        /// The number of HTTP header names in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }
}

extension CloudFrontClientTypes {

    /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentSecurityPolicy: Swift.Sendable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
        /// This member is required.
        public var contentSecurityPolicy: Swift.String?
        /// A Boolean that determines whether CloudFront overrides the Content-Security-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            contentSecurityPolicy: Swift.String? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.`override` = `override`
        }
    }
}

extension CloudFrontClientTypes {

    /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentTypeOptions: Swift.Sendable {
        /// A Boolean that determines whether CloudFront overrides the X-Content-Type-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            `override`: Swift.Bool? = nil
        )
        {
            self.`override` = `override`
        }
    }
}

extension CloudFrontClientTypes {

    public enum FrameOptionsList: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sameorigin
        case sdkUnknown(Swift.String)

        public static var allCases: [FrameOptionsList] {
            return [
                .deny,
                .sameorigin
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case .sameorigin: return "SAMEORIGIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header's value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyFrameOptions: Swift.Sendable {
        /// The value of the X-Frame-Options HTTP response header. Valid values are DENY and SAMEORIGIN. For more information about these values, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        /// This member is required.
        public var frameOption: CloudFrontClientTypes.FrameOptionsList?
        /// A Boolean that determines whether CloudFront overrides the X-Frame-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            frameOption: CloudFrontClientTypes.FrameOptionsList? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.frameOption = frameOption
            self.`override` = `override`
        }
    }
}

extension CloudFrontClientTypes {

    public enum ReferrerPolicyList: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noReferrer
        case noReferrerWhenDowngrade
        case origin
        case originWhenCrossOrigin
        case sameOrigin
        case strictOrigin
        case strictOriginWhenCrossOrigin
        case unsafeUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferrerPolicyList] {
            return [
                .noReferrer,
                .noReferrerWhenDowngrade,
                .origin,
                .originWhenCrossOrigin,
                .sameOrigin,
                .strictOrigin,
                .strictOriginWhenCrossOrigin,
                .unsafeUrl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noReferrer: return "no-referrer"
            case .noReferrerWhenDowngrade: return "no-referrer-when-downgrade"
            case .origin: return "origin"
            case .originWhenCrossOrigin: return "origin-when-cross-origin"
            case .sameOrigin: return "same-origin"
            case .strictOrigin: return "strict-origin"
            case .strictOriginWhenCrossOrigin: return "strict-origin-when-cross-origin"
            case .unsafeUrl: return "unsafe-url"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudFrontClientTypes {

    /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header's value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyReferrerPolicy: Swift.Sendable {
        /// A Boolean that determines whether CloudFront overrides the Referrer-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value of the Referrer-Policy HTTP response header. Valid values are:
        ///
        /// * no-referrer
        ///
        /// * no-referrer-when-downgrade
        ///
        /// * origin
        ///
        /// * origin-when-cross-origin
        ///
        /// * same-origin
        ///
        /// * strict-origin
        ///
        /// * strict-origin-when-cross-origin
        ///
        /// * unsafe-url
        ///
        ///
        /// For more information about these values, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        /// This member is required.
        public var referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList?

        public init(
            `override`: Swift.Bool? = nil,
            referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList? = nil
        )
        {
            self.`override` = `override`
            self.referrerPolicy = referrerPolicy
        }
    }
}

extension CloudFrontClientTypes {

    /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header's value. For more information about the Strict-Transport-Security HTTP response header, see [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
    public struct ResponseHeadersPolicyStrictTransportSecurity: Swift.Sendable {
        /// A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
        /// This member is required.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
        public var includeSubdomains: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the Strict-Transport-Security HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
        public var preload: Swift.Bool?

        public init(
            accessControlMaxAgeSec: Swift.Int? = nil,
            includeSubdomains: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            preload: Swift.Bool? = nil
        )
        {
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.includeSubdomains = includeSubdomains
            self.`override` = `override`
            self.preload = preload
        }
    }
}

extension CloudFrontClientTypes {

    /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header's value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
    public struct ResponseHeadersPolicyXSSProtection: Swift.Sendable {
        /// A Boolean that determines whether CloudFront includes the mode=block directive in the X-XSS-Protection header. For more information about this directive, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var modeBlock: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0. For more information about these settings, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        /// This member is required.
        public var protection: Swift.Bool?
        /// A reporting URI, which CloudFront uses as the value of the report directive in the X-XSS-Protection header. You cannot specify a ReportUri when ModeBlock is true. For more information about using a reporting URL, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var reportUri: Swift.String?

        public init(
            modeBlock: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            protection: Swift.Bool? = nil,
            reportUri: Swift.String? = nil
        )
        {
            self.modeBlock = modeBlock
            self.`override` = `override`
            self.protection = protection
            self.reportUri = reportUri
        }
    }
}

extension CloudFrontClientTypes {

    /// A configuration for a set of security-related HTTP response headers. CloudFront adds these headers to HTTP responses that it sends for requests that match a cache behavior associated with this response headers policy.
    public struct ResponseHeadersPolicySecurityHeadersConfig: Swift.Sendable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
        public var contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy?
        /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
        public var contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions?
        /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header's value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        public var frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions?
        /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header's value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        public var referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy?
        /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header's value. For more information about the Strict-Transport-Security HTTP response header, see [Security headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/understanding-response-headers-policies.html#understanding-response-headers-policies-security) in the Amazon CloudFront Developer Guide and [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
        public var strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity?
        /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header's value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var xssProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection?

        public init(
            contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy? = nil,
            contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions? = nil,
            frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions? = nil,
            referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy? = nil,
            strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity? = nil,
            xssProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.contentTypeOptions = contentTypeOptions
            self.frameOptions = frameOptions
            self.referrerPolicy = referrerPolicy
            self.strictTransportSecurity = strictTransportSecurity
            self.xssProtection = xssProtection
        }
    }
}

extension CloudFrontClientTypes {

    /// A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront. CloudFront adds this header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy. You can use the Server-Timing header to view metrics that can help you gain insights about the behavior and performance of CloudFront. For example, you can see which cache layer served a cache hit, or the first byte latency from the origin when there was a cache miss. You can use the metrics in the Server-Timing header to troubleshoot issues or test the efficiency of your CloudFront configuration. For more information, see [Server-Timing header](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/understanding-response-headers-policies.html#server-timing-header) in the Amazon CloudFront Developer Guide.
    public struct ResponseHeadersPolicyServerTimingHeadersConfig: Swift.Sendable {
        /// A Boolean that determines whether CloudFront adds the Server-Timing header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to. When you set the sampling rate to 100, CloudFront adds the Server-Timing header to the HTTP response for every request that matches the cache behavior that this response headers policy is attached to. When you set it to 50, CloudFront adds the header to 50% of the responses for requests that match the cache behavior. You can set the sampling rate to any number 0–100 with up to four decimal places.
        public var samplingRate: Swift.Double?

        public init(
            enabled: Swift.Bool? = nil,
            samplingRate: Swift.Double? = nil
        )
        {
            self.enabled = enabled
            self.samplingRate = samplingRate
        }
    }
}

extension CloudFrontClientTypes {

    /// A response headers policy configuration. A response headers policy configuration contains metadata about the response headers policy, and configurations for sets of HTTP response headers.
    public struct ResponseHeadersPolicyConfig: Swift.Sendable {
        /// A comment to describe the response headers policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS).
        public var corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig?
        /// A configuration for a set of custom HTTP response headers.
        public var customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig?
        /// A name to identify the response headers policy. The name must be unique for response headers policies in this Amazon Web Services account.
        /// This member is required.
        public var name: Swift.String?
        /// A configuration for a set of HTTP headers to remove from the HTTP response.
        public var removeHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig?
        /// A configuration for a set of security-related HTTP response headers.
        public var securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig?
        /// A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront.
        public var serverTimingHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig?

        public init(
            comment: Swift.String? = nil,
            corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig? = nil,
            customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig? = nil,
            name: Swift.String? = nil,
            removeHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig? = nil,
            securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig? = nil,
            serverTimingHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig? = nil
        )
        {
            self.comment = comment
            self.corsConfig = corsConfig
            self.customHeadersConfig = customHeadersConfig
            self.name = name
            self.removeHeadersConfig = removeHeadersConfig
            self.securityHeadersConfig = securityHeadersConfig
            self.serverTimingHeadersConfig = serverTimingHeadersConfig
        }
    }
}

public struct CreateResponseHeadersPolicyInput: Swift.Sendable {
    /// Contains metadata about the response headers policy, and a set of configurations that specify the HTTP headers.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

extension CloudFrontClientTypes {

    /// A response headers policy. A response headers policy contains information about a set of HTTP response headers. After you create a response headers policy, you can use its ID to attach it to one or more cache behaviors in a CloudFront distribution. When it's attached to a cache behavior, the response headers policy affects the HTTP headers that CloudFront includes in HTTP responses to requests that match the cache behavior. CloudFront adds or removes response headers according to the configuration of the response headers policy. For more information, see [Adding or removing HTTP headers in CloudFront responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/modifying-response-headers.html) in the Amazon CloudFront Developer Guide.
    public struct ResponseHeadersPolicy: Swift.Sendable {
        /// The identifier for the response headers policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the response headers policy was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// A response headers policy configuration.
        /// This member is required.
        public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

        public init(
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
        }
    }
}

public struct CreateResponseHeadersPolicyOutput: Swift.Sendable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// The URL of the response headers policy.
    public var location: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

/// The caller reference you attempted to create the streaming distribution with is associated with another distribution
public struct StreamingDistributionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamingDistributionAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyStreamingDistributionCNAMEs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyStreamingDistributionCNAMEs" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of streaming distributions allowed.
public struct TooManyStreamingDistributions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyStreamingDistributions" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {

    /// A complex type that controls whether access logs are written for this streaming distribution.
    public struct StreamingLoggingConfig: Swift.Sendable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a streaming distribution or if you want to disable logging for an existing streaming distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket and Prefix, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
    public struct S3Origin: Swift.Sendable, Swift.Equatable {
        /// The DNS name of the Amazon S3 origin.
        /// This member is required.
        public var domainName: Swift.String?
        /// The CloudFront origin access identity to associate with the distribution. Use an origin access identity to configure the distribution so that end users can only access objects in an Amazon S3 bucket through CloudFront. If you want end users to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information, see [Using an Origin Access Identity to Restrict Access to Your Amazon S3 Content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.originAccessIdentity = originAccessIdentity
        }
    }
}

extension CloudFrontClientTypes {

    /// The RTMP distribution's configuration information.
    public struct StreamingDistributionConfig: Swift.Sendable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the StreamingDistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// Any comments you want to include about the streaming distribution.
        /// This member is required.
        public var comment: Swift.String?
        /// Whether the streaming distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the streaming distribution.
        public var logging: CloudFrontClientTypes.StreamingLoggingConfig?
        /// A complex type that contains information about price class for this streaming distribution.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// A complex type that specifies any Amazon Web Services accounts that you want to permit to create signed URLs for private content. If you want the distribution to use signed URLs, include this element; if you want the distribution to use public URLs, remove this element. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.StreamingLoggingConfig? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.callerReference = callerReference
            self.comment = comment
            self.enabled = enabled
            self.logging = logging
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.trustedSigners = trustedSigners
        }
    }
}

/// The request to create a new streaming distribution.
public struct CreateStreamingDistributionInput: Swift.Sendable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

extension CloudFrontClientTypes {

    /// A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to track and manage content delivery.
    public struct StreamingDistribution: Swift.Sendable {
        /// A complex type that lists the Amazon Web Services accounts, if any, that you included in the TrustedSigners complex type for this distribution. These are the accounts that you want to allow to create signed URLs for private content. The Signer complex type lists the Amazon Web Services account number of the trusted signer or self if the signer is the Amazon Web Services account that created the distribution. The Signer element also includes the IDs of any active CloudFront key pairs that are associated with the trusted signer's Amazon Web Services account. If no KeyPairId element appears for a Signer, that signer can't create signed URLs. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// The domain name that corresponds to the streaming distribution, for example, s5c39gqb8ow64r.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The identifier for the RTMP distribution. For example: EGTXBD79EXAMPLE.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the distribution was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The current status of the RTMP distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// The current configuration information for the RTMP distribution.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

        public init(
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            arn: Swift.String? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: Swift.String? = nil,
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
        )
        {
            self.activeTrustedSigners = activeTrustedSigners
            self.arn = arn
            self.domainName = domainName
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.streamingDistributionConfig = streamingDistributionConfig
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionOutput: Swift.Sendable {
    /// The current version of the streaming distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

extension CloudFrontClientTypes {

    /// A streaming distribution Configuration and a list of tags to be associated with the streaming distribution.
    public struct StreamingDistributionConfigWithTags: Swift.Sendable {
        /// A streaming distribution Configuration.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init(
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.streamingDistributionConfig = streamingDistributionConfig
            self.tags = tags
        }
    }
}

/// The request to create a new streaming distribution with tags.
public struct CreateStreamingDistributionWithTagsInput: Swift.Sendable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?

    public init(
        streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags? = nil
    )
    {
        self.streamingDistributionConfigWithTags = streamingDistributionConfigWithTags
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionWithTagsOutput: Swift.Sendable {
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

/// You cannot delete a managed policy.
public struct IllegalDelete: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalDelete" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteCachePolicyInput: Swift.Sendable {
    /// The unique identifier for the cache policy that you are deleting. To get the identifier, you can use ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are deleting. The version is the cache policy's ETag value, which you can get using ListCachePolicies, GetCachePolicy, or GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The Origin Access Identity specified is already in use.
public struct CloudFrontOriginAccessIdentityInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudFrontOriginAccessIdentityInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified origin access identity does not exist.
public struct NoSuchCloudFrontOriginAccessIdentity: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchCloudFrontOriginAccessIdentity" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Deletes a origin access identity.
public struct DeleteCloudFrontOriginAccessIdentityInput: Swift.Sendable {
    /// The origin access identity's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header you received from a previous GET or PUT request. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

public struct DeleteContinuousDeploymentPolicyInput: Swift.Sendable {
    /// The identifier of the continuous deployment policy that you are deleting.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the continuous deployment policy that you are deleting.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct DistributionNotDisabled: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DistributionNotDisabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This action deletes a web distribution. To delete a web distribution using the CloudFront API, perform the following steps. To delete a web distribution using the CloudFront API:
///
/// * Disable the web distribution
///
/// * Submit a GET Distribution Config request to get the current configuration and the Etag header for the distribution.
///
/// * Update the XML document that was returned in the response to your GET Distribution Config request to change the value of Enabled to false.
///
/// * Submit a PUT Distribution Config request to update the configuration for your distribution. In the request body, include the XML document that you updated in Step 3. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 2.
///
/// * Review the response to the PUT Distribution Config request to confirm that the distribution was successfully disabled.
///
/// * Submit a GET Distribution request to confirm that your changes have propagated. When propagation is complete, the value of Status is Deployed.
///
/// * Submit a DELETE Distribution request. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 6.
///
/// * Review the response to your DELETE Distribution request to confirm that the distribution was successfully deleted.
///
///
/// For information about deleting a distribution using the CloudFront console, see [Deleting a Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html) in the Amazon CloudFront Developer Guide.
public struct DeleteDistributionInput: Swift.Sendable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The specified configuration for field-level encryption is in use.
public struct FieldLevelEncryptionConfigInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionConfigInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFieldLevelEncryptionConfigInput: Swift.Sendable {
    /// The ID of the configuration you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The specified profile for field-level encryption is in use.
public struct FieldLevelEncryptionProfileInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFieldLevelEncryptionProfileInput: Swift.Sendable {
    /// Request the ID of the profile you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// Cannot delete the function because it's attached to one or more cache behaviors.
public struct FunctionInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The function does not exist.
public struct NoSuchFunctionExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFunctionExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFunctionInput: Swift.Sendable {
    /// The current version (ETag value) of the function that you are deleting, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are deleting.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

/// A resource that was specified is not valid.
public struct NoSuchResource: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResource" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Cannot delete this resource because it is in use.
public struct ResourceInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteKeyGroupInput: Swift.Sendable {
    /// The identifier of the key group that you are deleting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are deleting. The version is the key group's ETag value. To get the ETag, use GetKeyGroup or GetKeyGroupConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The key value store entity was not found.
public struct EntityNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteKeyValueStoreInput: Swift.Sendable {
    /// The key value store to delete, if a match occurs.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the key value store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

/// A monitoring subscription does not exist for the specified distribution.
public struct NoSuchMonitoringSubscription: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchMonitoringSubscription" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteMonitoringSubscriptionInput: Swift.Sendable {
    /// The ID of the distribution that you are disabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init(
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

public struct DeleteMonitoringSubscriptionOutput: Swift.Sendable {

    public init() { }
}

/// The origin access control does not exist.
public struct NoSuchOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOriginAccessControl" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Cannot delete the origin access control because it's in use by one or more distributions.
public struct OriginAccessControlInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginAccessControlInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteOriginAccessControlInput: Swift.Sendable {
    /// The unique identifier of the origin access control that you are deleting.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the origin access control that you are deleting.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// Cannot delete the origin request policy because it is attached to one or more cache behaviors.
public struct OriginRequestPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginRequestPolicyInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteOriginRequestPolicyInput: Swift.Sendable {
    /// The unique identifier for the origin request policy that you are deleting. To get the identifier, you can use ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are deleting. The version is the origin request policy's ETag value, which you can get using ListOriginRequestPolicies, GetOriginRequestPolicy, or GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The specified public key is in use.
public struct PublicKeyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PublicKeyInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeletePublicKeyInput: Swift.Sendable {
    /// The ID of the public key you want to remove from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.
public struct RealtimeLogConfigInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteRealtimeLogConfigInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to delete.
    public var arn: Swift.String?
    /// The name of the real-time log configuration to delete.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

/// Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.
public struct ResponseHeadersPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResponseHeadersPolicyInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteResponseHeadersPolicyInput: Swift.Sendable {
    /// The identifier for the response headers policy that you are deleting. To get the identifier, you can use ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are deleting. The version is the response headers policy's ETag value, which you can get using ListResponseHeadersPolicies, GetResponseHeadersPolicy, or GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The specified streaming distribution does not exist.
public struct NoSuchStreamingDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchStreamingDistribution" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct StreamingDistributionNotDisabled: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamingDistributionNotDisabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request to delete a streaming distribution.
public struct DeleteStreamingDistributionInput: Swift.Sendable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the streaming distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

public struct DescribeFunctionInput: Swift.Sendable {
    /// The name of the function that you are getting information about.
    /// This member is required.
    public var name: Swift.String?
    /// The function's stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

public struct DescribeFunctionOutput: Swift.Sendable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

public struct DescribeKeyValueStoreInput: Swift.Sendable {
    /// The name of the key value store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DescribeKeyValueStoreOutput: Swift.Sendable {
    /// The ETag of the resulting key value store.
    public var eTag: Swift.String?
    /// The resulting key value store.
    public var keyValueStore: CloudFrontClientTypes.KeyValueStore?

    public init(
        eTag: Swift.String? = nil,
        keyValueStore: CloudFrontClientTypes.KeyValueStore? = nil
    )
    {
        self.eTag = eTag
        self.keyValueStore = keyValueStore
    }
}

public struct GetCachePolicyInput: Swift.Sendable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetCachePolicyOutput: Swift.Sendable {
    /// The cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

public struct GetCachePolicyConfigInput: Swift.Sendable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetCachePolicyConfigOutput: Swift.Sendable {
    /// The cache policy configuration.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.eTag = eTag
    }
}

/// The request to get an origin access identity's information.
public struct GetCloudFrontOriginAccessIdentityInput: Swift.Sendable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityOutput: Swift.Sendable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

/// The origin access identity's configuration information. For more information, see [CloudFrontOriginAccessIdentityConfig](https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html).
public struct GetCloudFrontOriginAccessIdentityConfigInput: Swift.Sendable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityConfigOutput: Swift.Sendable {
    /// The origin access identity's configuration information.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.eTag = eTag
    }
}

public struct GetContinuousDeploymentPolicyInput: Swift.Sendable {
    /// The identifier of the continuous deployment policy that you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetContinuousDeploymentPolicyOutput: Swift.Sendable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
    }
}

public struct GetContinuousDeploymentPolicyConfigInput: Swift.Sendable {
    /// The identifier of the continuous deployment policy whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetContinuousDeploymentPolicyConfigOutput: Swift.Sendable {
    /// Contains the configuration for a continuous deployment policy.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
        self.eTag = eTag
    }
}

/// The request to get a distribution's information.
public struct GetDistributionInput: Swift.Sendable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionOutput: Swift.Sendable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

/// The request to get a distribution configuration.
public struct GetDistributionConfigInput: Swift.Sendable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionConfigOutput: Swift.Sendable {
    /// The distribution's configuration information.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.eTag = eTag
    }
}

public struct GetFieldLevelEncryptionInput: Swift.Sendable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetFieldLevelEncryptionOutput: Swift.Sendable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

public struct GetFieldLevelEncryptionConfigInput: Swift.Sendable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetFieldLevelEncryptionConfigOutput: Swift.Sendable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

public struct GetFieldLevelEncryptionProfileInput: Swift.Sendable {
    /// Get the ID for the field-level encryption profile information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetFieldLevelEncryptionProfileOutput: Swift.Sendable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile information.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

public struct GetFieldLevelEncryptionProfileConfigInput: Swift.Sendable {
    /// Get the ID for the field-level encryption profile configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetFieldLevelEncryptionProfileConfigOutput: Swift.Sendable {
    /// The current version of the field-level encryption profile configuration result. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile configuration information.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

public struct GetFunctionInput: Swift.Sendable {
    /// The name of the function whose code you are getting.
    /// This member is required.
    public var name: Swift.String?
    /// The function's stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

public struct GetFunctionOutput: Swift.Sendable {
    /// The content type (media type) of the response.
    public var contentType: Swift.String?
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// The function code of a CloudFront function.
    public var functionCode: Foundation.Data?

    public init(
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        functionCode: Foundation.Data? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.functionCode = functionCode
    }
}

extension GetFunctionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionOutput(contentType: \(Swift.String(describing: contentType)), eTag: \(Swift.String(describing: eTag)), functionCode: \"CONTENT_REDACTED\")"}
}

/// The specified invalidation does not exist.
public struct NoSuchInvalidation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchInvalidation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request to get an invalidation's information.
public struct GetInvalidationInput: Swift.Sendable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The identifier for the invalidation request, for example, IDFDVBD632BHDS5.
    /// This member is required.
    public var id: Swift.String?

    public init(
        distributionId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
        self.id = id
    }
}

/// The returned result of the corresponding request.
public struct GetInvalidationOutput: Swift.Sendable {
    /// The invalidation's information. For more information, see [Invalidation Complex Type](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html).
    public var invalidation: CloudFrontClientTypes.Invalidation?

    public init(
        invalidation: CloudFrontClientTypes.Invalidation? = nil
    )
    {
        self.invalidation = invalidation
    }
}

public struct GetKeyGroupInput: Swift.Sendable {
    /// The identifier of the key group that you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetKeyGroupOutput: Swift.Sendable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

public struct GetKeyGroupConfigInput: Swift.Sendable {
    /// The identifier of the key group whose configuration you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetKeyGroupConfigOutput: Swift.Sendable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group configuration.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        eTag: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.eTag = eTag
        self.keyGroupConfig = keyGroupConfig
    }
}

public struct GetMonitoringSubscriptionInput: Swift.Sendable {
    /// The ID of the distribution that you are getting metrics information for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init(
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

public struct GetMonitoringSubscriptionOutput: Swift.Sendable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

public struct GetOriginAccessControlInput: Swift.Sendable {
    /// The unique identifier of the origin access control.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetOriginAccessControlOutput: Swift.Sendable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// Contains an origin access control, including its unique identifier.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControl = originAccessControl
    }
}

public struct GetOriginAccessControlConfigInput: Swift.Sendable {
    /// The unique identifier of the origin access control.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetOriginAccessControlConfigOutput: Swift.Sendable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// Contains an origin access control configuration.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        eTag: Swift.String? = nil,
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControlConfig = originAccessControlConfig
    }
}

public struct GetOriginRequestPolicyInput: Swift.Sendable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetOriginRequestPolicyOutput: Swift.Sendable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

public struct GetOriginRequestPolicyConfigInput: Swift.Sendable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetOriginRequestPolicyConfigOutput: Swift.Sendable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy configuration.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

public struct GetPublicKeyInput: Swift.Sendable {
    /// The identifier of the public key you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetPublicKeyOutput: Swift.Sendable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

public struct GetPublicKeyConfigInput: Swift.Sendable {
    /// The identifier of the public key whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetPublicKeyConfigOutput: Swift.Sendable {
    /// The identifier for this version of the public key configuration.
    public var eTag: Swift.String?
    /// A public key configuration.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        eTag: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.eTag = eTag
        self.publicKeyConfig = publicKeyConfig
    }
}

public struct GetRealtimeLogConfigInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to get.
    public var arn: Swift.String?
    /// The name of the real-time log configuration to get.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct GetRealtimeLogConfigOutput: Swift.Sendable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

public struct GetResponseHeadersPolicyInput: Swift.Sendable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetResponseHeadersPolicyOutput: Swift.Sendable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

public struct GetResponseHeadersPolicyConfigInput: Swift.Sendable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetResponseHeadersPolicyConfigOutput: Swift.Sendable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

/// The request to get a streaming distribution's information.
public struct GetStreamingDistributionInput: Swift.Sendable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionOutput: Swift.Sendable {
    /// The current version of the streaming distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

/// To request to get a streaming distribution configuration.
public struct GetStreamingDistributionConfigInput: Swift.Sendable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionConfigOutput: Swift.Sendable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's configuration information.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        eTag: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

public struct ListCachePoliciesInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of cache policies. The response includes cache policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of cache policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of cache policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.CachePolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.CachePolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

public struct ListCachePoliciesOutput: Swift.Sendable {
    /// A list of cache policies.
    public var cachePolicyList: CloudFrontClientTypes.CachePolicyList?

    public init(
        cachePolicyList: CloudFrontClientTypes.CachePolicyList? = nil
    )
    {
        self.cachePolicyList = cachePolicyList
    }
}

/// The request to list origin access identities.
public struct ListCloudFrontOriginAccessIdentitiesInput: Swift.Sendable {
    /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
    public var marker: Swift.String?
    /// The maximum number of origin access identities you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// Summary of the information about a CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentitySummary: Swift.Sendable, Swift.Equatable {
        /// The comment for this origin access identity, as originally specified when created.
        /// This member is required.
        public var comment: Swift.String?
        /// The ID for the origin access identity. For example: E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init(
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.comment = comment
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }
}

extension CloudFrontClientTypes {

    /// Lists the origin access identities for CloudFront.Send a GET request to the /CloudFront API version/origin-access-identity/cloudfront resource. The response includes a CloudFrontOriginAccessIdentityList element with zero or more CloudFrontOriginAccessIdentitySummary child elements. By default, your entire list of origin access identities is returned in one single page. If the list is long, you can paginate it using the MaxItems and Marker parameters.
    public struct CloudFrontOriginAccessIdentityList: Swift.Sendable, Swift.Equatable {
        /// A flag that indicates whether more origin access identities remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more items in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one CloudFrontOriginAccessIdentitySummary element for each origin access identity that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]?
        /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access identities you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your origin access identities where they left off.
        public var nextMarker: Swift.String?
        /// The number of CloudFront origin access identities that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

/// The returned result of the corresponding request.
public struct ListCloudFrontOriginAccessIdentitiesOutput: Swift.Sendable {
    /// The CloudFrontOriginAccessIdentityList type.
    public var cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?

    public init(
        cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityList
    }
}

public struct ListConflictingAliasesInput: Swift.Sendable {
    /// The alias (also called a CNAME) to search for conflicting aliases.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of conflicting aliases that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        alias: Swift.String? = nil,
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// An alias (also called a CNAME) and the CloudFront distribution and Amazon Web Services account ID that it's associated with. The distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don't own.
    public struct ConflictingAlias: Swift.Sendable {
        /// The (partially hidden) ID of the Amazon Web Services account that owns the distribution that's associated with the alias.
        public var accountId: Swift.String?
        /// An alias (also called a CNAME).
        public var alias: Swift.String?
        /// The (partially hidden) ID of the CloudFront distribution associated with the alias.
        public var distributionId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            alias: Swift.String? = nil,
            distributionId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.alias = alias
            self.distributionId = distributionId
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of aliases (also called CNAMEs) and the CloudFront distributions and Amazon Web Services accounts that they are associated with. In the list, the distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don't own.
    public struct ConflictingAliasesList: Swift.Sendable {
        /// Contains the conflicting aliases in the list.
        public var items: [CloudFrontClientTypes.ConflictingAlias]?
        /// The maximum number of conflicting aliases requested.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing conflicting aliases where you left off.
        public var nextMarker: Swift.String?
        /// The number of conflicting aliases returned in the response.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ConflictingAlias]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListConflictingAliasesOutput: Swift.Sendable {
    /// A list of conflicting aliases.
    public var conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?

    public init(
        conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList? = nil
    )
    {
        self.conflictingAliasesList = conflictingAliasesList
    }
}

public struct ListContinuousDeploymentPoliciesInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of continuous deployment policies. The response includes policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of continuous deployment policies that you want returned in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A summary of the information about your continuous deployment policies.
    public struct ContinuousDeploymentPolicySummary: Swift.Sendable {
        /// The continuous deployment policy.
        /// This member is required.
        public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?

        public init(
            continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil
        )
        {
            self.continuousDeploymentPolicy = continuousDeploymentPolicy
        }
    }
}

extension CloudFrontClientTypes {

    /// Contains a list of continuous deployment policies.
    public struct ContinuousDeploymentPolicyList: Swift.Sendable {
        /// A list of continuous deployment policy items.
        public var items: [CloudFrontClientTypes.ContinuousDeploymentPolicySummary]?
        /// The maximum number of continuous deployment policies that were specified in your request.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Indicates the next page of continuous deployment policies. To get the next page of the list, use this value in the Marker field of your request.
        public var nextMarker: Swift.String?
        /// The total number of continuous deployment policies in your Amazon Web Services account, regardless of the MaxItems value.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ContinuousDeploymentPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListContinuousDeploymentPoliciesOutput: Swift.Sendable {
    /// A list of continuous deployment policies.
    public var continuousDeploymentPolicyList: CloudFrontClientTypes.ContinuousDeploymentPolicyList?

    public init(
        continuousDeploymentPolicyList: CloudFrontClientTypes.ContinuousDeploymentPolicyList? = nil
    )
    {
        self.continuousDeploymentPolicyList = continuousDeploymentPolicyList
    }
}

/// The request to list your distributions.
public struct ListDistributionsInput: Swift.Sendable {
    /// Use this when paginating results to indicate where to begin in your list of distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page).
    public var marker: Swift.String?
    /// The maximum number of distributions you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A summary of the information about a CloudFront distribution.
    public struct DistributionSummary: Swift.Sendable, Swift.Equatable {
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains zero or more CacheBehavior elements.
        /// This member is required.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// A complex type that contains zero or more CustomErrorResponses elements.
        /// This member is required.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The domain name that corresponds to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 will automatically use an earlier version.
        /// This member is required.
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// The identifier for the distribution. For example: EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your distribution.
        /// This member is required.
        public var isIPV6Enabled: Swift.Bool?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        /// This member is required.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// A Boolean that indicates whether this is a staging distribution. When this value is true, this is a staging distribution. When this value is false, this is not a staging distribution.
        /// This member is required.
        public var staging: Swift.Bool?
        /// The current status of the distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers.
        /// This member is required.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// The Web ACL Id (if any) associated with the distribution.
        /// This member is required.
        public var webACLId: Swift.String?

        public init(
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            arn: Swift.String? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            id: Swift.String? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            staging: Swift.Bool? = nil,
            status: Swift.String? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliasICPRecordals = aliasICPRecordals
            self.aliases = aliases
            self.arn = arn
            self.cacheBehaviors = cacheBehaviors
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.domainName = domainName
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.id = id
            self.isIPV6Enabled = isIPV6Enabled
            self.lastModifiedTime = lastModifiedTime
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.staging = staging
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }
}

extension CloudFrontClientTypes {

    /// A distribution list.
    public struct DistributionList: Swift.Sendable, Swift.Equatable {
        /// A flag that indicates whether more distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one DistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.DistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.DistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

/// The returned result of the corresponding request.
public struct ListDistributionsOutput: Swift.Sendable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

public struct ListDistributionsByCachePolicyIdInput: Swift.Sendable {
    /// The ID of the cache policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var cachePolicyId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        cachePolicyId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.cachePolicyId = cachePolicyId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A list of distribution IDs.
    public struct DistributionIdList: Swift.Sendable {
        /// A flag that indicates whether more distribution IDs remain to be listed. If your results were truncated, you can make a subsequent request using the Marker request field to retrieve more distribution IDs in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the distribution IDs in the list.
        public var items: [Swift.String]?
        /// The value provided in the Marker request field.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of distribution IDs requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Contains the value that you should use in the Marker field of a subsequent request to continue listing distribution IDs where you left off.
        public var nextMarker: Swift.String?
        /// The total number of distribution IDs returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListDistributionsByCachePolicyIdOutput: Swift.Sendable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

public struct ListDistributionsByKeyGroupInput: Swift.Sendable {
    /// The ID of the key group whose associated distribution IDs you are listing.
    /// This member is required.
    public var keyGroupId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        keyGroupId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.marker = marker
        self.maxItems = maxItems
    }
}

public struct ListDistributionsByKeyGroupOutput: Swift.Sendable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

public struct ListDistributionsByOriginRequestPolicyIdInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?
    /// The ID of the origin request policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var originRequestPolicyId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        originRequestPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.originRequestPolicyId = originRequestPolicyId
    }
}

public struct ListDistributionsByOriginRequestPolicyIdOutput: Swift.Sendable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

public struct ListDistributionsByRealtimeLogConfigInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of distributions. The response includes distributions in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distributions that you want in the response.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigArn: Swift.String?
    /// The name of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        realtimeLogConfigArn: Swift.String? = nil,
        realtimeLogConfigName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.realtimeLogConfigName = realtimeLogConfigName
    }
}

public struct ListDistributionsByRealtimeLogConfigOutput: Swift.Sendable {
    /// A distribution list.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want to get in the response.
    public var maxItems: Swift.Int?
    /// The ID of the response headers policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var responseHeadersPolicyId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        responseHeadersPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.responseHeadersPolicyId = responseHeadersPolicyId
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdOutput: Swift.Sendable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

/// The request to list distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdInput: Swift.Sendable {
    /// Use Marker and MaxItems to control pagination of results. If you have more than MaxItems distributions that satisfy the request, the response includes a NextMarker element. To get the next page of results, submit another request. For the value of Marker, specify the value of NextMarker from the last response. (For the first request, omit Marker.)
    public var marker: Swift.String?
    /// The maximum number of distributions that you want CloudFront to return in the response body. The maximum and default values are both 100.
    public var maxItems: Swift.Int?
    /// The ID of the WAF web ACL that you want to list the associated distributions. If you specify "null" for the ID, the request returns a list of the distributions that aren't associated with a web ACL. For WAFV2, this is the ARN of the web ACL, such as arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/a1b2c3d4-5678-90ab-cdef-EXAMPLE11111. For WAF Classic, this is the ID of the web ACL, such as a1b2c3d4-5678-90ab-cdef-EXAMPLE11111.
    /// This member is required.
    public var webACLId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        webACLId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.webACLId = webACLId
    }
}

/// The response to a request to list the distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdOutput: Swift.Sendable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

public struct ListFieldLevelEncryptionConfigsInput: Swift.Sendable {
    /// Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last configuration on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption configurations you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A summary of a field-level encryption item.
    public struct FieldLevelEncryptionSummary: Swift.Sendable {
        /// An optional comment about the field-level encryption item. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A summary of a content type-profile mapping.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// The unique ID of a field-level encryption item.
        /// This member is required.
        public var id: Swift.String?
        /// The last time that the summary of field-level encryption items was modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// A summary of a query argument-profile mapping.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init(
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }
}

extension CloudFrontClientTypes {

    /// List of field-level encryption configurations.
    public struct FieldLevelEncryptionList: Swift.Sendable {
        /// An array of field-level encryption items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]?
        /// The maximum number of elements you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your configurations where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListFieldLevelEncryptionConfigsOutput: Swift.Sendable {
    /// Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.
    public var fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?

    public init(
        fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList? = nil
    )
    {
        self.fieldLevelEncryptionList = fieldLevelEncryptionList
    }
}

public struct ListFieldLevelEncryptionProfilesInput: Swift.Sendable {
    /// Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last profile on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption profiles you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// The field-level encryption profile summary.
    public struct FieldLevelEncryptionProfileSummary: Swift.Sendable {
        /// An optional comment for the field-level encryption profile summary. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// ID for the field-level encryption profile summary.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the field-level encryption profile summary was last updated.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// Name for the field-level encryption profile summary.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }
}

extension CloudFrontClientTypes {

    /// List of field-level encryption profiles.
    public struct FieldLevelEncryptionProfileList: Swift.Sendable {
        /// The field-level encryption profile items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]?
        /// The maximum number of field-level encryption profiles you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your profiles where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption profiles.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListFieldLevelEncryptionProfilesOutput: Swift.Sendable {
    /// Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.
    public var fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?

    public init(
        fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList? = nil
    )
    {
        self.fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileList
    }
}

public struct ListFunctionsInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of functions. The response includes functions in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of functions that you want in the response.
    public var maxItems: Swift.Int?
    /// An optional filter to return only the functions that are in the specified stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.stage = stage
    }
}

extension CloudFrontClientTypes {

    /// A list of CloudFront functions.
    public struct FunctionList: Swift.Sendable {
        /// Contains the functions in the list.
        public var items: [CloudFrontClientTypes.FunctionSummary]?
        /// The maximum number of functions requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing functions where you left off.
        public var nextMarker: Swift.String?
        /// The number of functions returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FunctionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListFunctionsOutput: Swift.Sendable {
    /// A list of CloudFront functions.
    public var functionList: CloudFrontClientTypes.FunctionList?

    public init(
        functionList: CloudFrontClientTypes.FunctionList? = nil
    )
    {
        self.functionList = functionList
    }
}

/// The request to list invalidations.
public struct ListInvalidationsInput: Swift.Sendable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this parameter when paginating results to indicate where to begin in your list of invalidation batches. Because the results are returned in decreasing order from most recent to oldest, the most recent results are on the first page, the second page will contain earlier results, and so on. To get the next page of results, set Marker to the value of the NextMarker from the current page's response. This value is the same as the ID of the last invalidation batch on that page.
    public var marker: Swift.String?
    /// The maximum number of invalidation batches that you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A summary of an invalidation request.
    public struct InvalidationSummary: Swift.Sendable, Swift.Equatable {
        /// The time that an invalidation request was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique ID for an invalidation request.
        /// This member is required.
        public var id: Swift.String?
        /// The status of an invalidation request.
        /// This member is required.
        public var status: Swift.String?

        public init(
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.status = status
        }
    }
}

extension CloudFrontClientTypes {

    /// The InvalidationList complex type describes the list of invalidation objects. For more information about invalidation, see [Invalidating Objects (Web Distributions Only)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html) in the Amazon CloudFront Developer Guide.
    public struct InvalidationList: Swift.Sendable, Swift.Equatable {
        /// A flag that indicates whether more invalidation batch requests remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more invalidation batches in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one InvalidationSummary element for each invalidation batch created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.InvalidationSummary]?
        /// The value that you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value that you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value that you can use for the Marker request parameter to continue listing your invalidation batches where they left off.
        public var nextMarker: Swift.String?
        /// The number of invalidation batches that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.InvalidationSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

/// The returned result of the corresponding request.
public struct ListInvalidationsOutput: Swift.Sendable {
    /// Information about invalidation batches.
    public var invalidationList: CloudFrontClientTypes.InvalidationList?

    public init(
        invalidationList: CloudFrontClientTypes.InvalidationList? = nil
    )
    {
        self.invalidationList = invalidationList
    }
}

public struct ListKeyGroupsInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of key groups. The response includes key groups in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of key groups that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// Contains information about a key group.
    public struct KeyGroupSummary: Swift.Sendable {
        /// A key group.
        /// This member is required.
        public var keyGroup: CloudFrontClientTypes.KeyGroup?

        public init(
            keyGroup: CloudFrontClientTypes.KeyGroup? = nil
        )
        {
            self.keyGroup = keyGroup
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of key groups.
    public struct KeyGroupList: Swift.Sendable {
        /// A list of key groups.
        public var items: [CloudFrontClientTypes.KeyGroupSummary]?
        /// The maximum number of key groups requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing key groups.
        public var nextMarker: Swift.String?
        /// The number of key groups returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.KeyGroupSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListKeyGroupsOutput: Swift.Sendable {
    /// A list of key groups.
    public var keyGroupList: CloudFrontClientTypes.KeyGroupList?

    public init(
        keyGroupList: CloudFrontClientTypes.KeyGroupList? = nil
    )
    {
        self.keyGroupList = keyGroupList
    }
}

public struct ListKeyValueStoresInput: Swift.Sendable {
    /// The marker associated with the key value stores list.
    public var marker: Swift.String?
    /// The maximum number of items in the key value stores list.
    public var maxItems: Swift.Int?
    /// The status of the request for the key value stores list.
    public var status: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        status: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.status = status
    }
}

extension CloudFrontClientTypes {

    /// The key value store list.
    public struct KeyValueStoreList: Swift.Sendable, Swift.Equatable {
        /// The items of the key value store list.
        public var items: [CloudFrontClientTypes.KeyValueStore]?
        /// The maximum number of items in the key value store list.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// The next marker associated with the key value store list.
        public var nextMarker: Swift.String?
        /// The quantity of the key value store list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.KeyValueStore]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListKeyValueStoresOutput: Swift.Sendable {
    /// The resulting key value stores list.
    public var keyValueStoreList: CloudFrontClientTypes.KeyValueStoreList?

    public init(
        keyValueStoreList: CloudFrontClientTypes.KeyValueStoreList? = nil
    )
    {
        self.keyValueStoreList = keyValueStoreList
    }
}

public struct ListOriginAccessControlsInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of origin access controls. The response includes the items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of origin access controls that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A CloudFront origin access control.
    public struct OriginAccessControlSummary: Swift.Sendable {
        /// A description of the origin access control.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the origin access control.
        /// This member is required.
        public var id: Swift.String?
        /// A unique name that identifies the origin access control.
        /// This member is required.
        public var name: Swift.String?
        /// The type of origin that this origin access control is for.
        /// This member is required.
        public var originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes?
        /// A value that specifies which requests CloudFront signs (adds authentication information to). This field can have one of the following values:
        ///
        /// * never – CloudFront doesn't sign any origin requests.
        ///
        /// * always – CloudFront signs all origin requests, overwriting the Authorization header from the viewer request if necessary.
        ///
        /// * no-override – If the viewer request doesn't contain the Authorization header, CloudFront signs the origin request. If the viewer request contains the Authorization header, CloudFront doesn't sign the origin request, but instead passes along the Authorization header that it received in the viewer request.
        /// This member is required.
        public var signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors?
        /// The signing protocol of the origin access control. The signing protocol determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
        /// This member is required.
        public var signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes? = nil,
            signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors? = nil,
            signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.originAccessControlOriginType = originAccessControlOriginType
            self.signingBehavior = signingBehavior
            self.signingProtocol = signingProtocol
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of CloudFront origin access controls.
    public struct OriginAccessControlList: Swift.Sendable {
        /// If there are more items in the list than are in this response, this value is true.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the origin access controls in the list.
        public var items: [CloudFrontClientTypes.OriginAccessControlSummary]?
        /// The value of the Marker field that was provided in the request.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access controls requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value to use in the Marker field of another request to continue listing origin access controls.
        public var nextMarker: Swift.String?
        /// The number of origin access controls returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.OriginAccessControlSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListOriginAccessControlsOutput: Swift.Sendable {
    /// A list of origin access controls.
    public var originAccessControlList: CloudFrontClientTypes.OriginAccessControlList?

    public init(
        originAccessControlList: CloudFrontClientTypes.OriginAccessControlList? = nil
    )
    {
        self.originAccessControlList = originAccessControlList
    }
}

extension CloudFrontClientTypes {

    public enum OriginRequestPolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyType] {
            return [
                .custom,
                .managed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListOriginRequestPoliciesInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of origin request policies. The response includes origin request policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of origin request policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of origin request policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.OriginRequestPolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

extension CloudFrontClientTypes {

    /// Contains an origin request policy.
    public struct OriginRequestPolicySummary: Swift.Sendable {
        /// The origin request policy.
        /// This member is required.
        public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
        /// The type of origin request policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.OriginRequestPolicyType?

        public init(
            originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil,
            type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
        )
        {
            self.originRequestPolicy = originRequestPolicy
            self.type = type
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of origin request policies.
    public struct OriginRequestPolicyList: Swift.Sendable {
        /// Contains the origin request policies in the list.
        public var items: [CloudFrontClientTypes.OriginRequestPolicySummary]?
        /// The maximum number of origin request policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing origin request policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of origin request policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginRequestPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListOriginRequestPoliciesOutput: Swift.Sendable {
    /// A list of origin request policies.
    public var originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?

    public init(
        originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList? = nil
    )
    {
        self.originRequestPolicyList = originRequestPolicyList
    }
}

public struct ListPublicKeysInput: Swift.Sendable {
    /// Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last public key on that page).
    public var marker: Swift.String?
    /// The maximum number of public keys you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// Contains information about a public key.
    public struct PublicKeySummary: Swift.Sendable {
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The public key.
        /// This member is required.
        public var encodedKey: Swift.String?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            encodedKey: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.createdTime = createdTime
            self.encodedKey = encodedKey
            self.id = id
            self.name = name
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of public keys that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyList: Swift.Sendable {
        /// A list of public keys.
        public var items: [CloudFrontClientTypes.PublicKeySummary]?
        /// The maximum number of public keys you want in the response.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your public keys where you left off.
        public var nextMarker: Swift.String?
        /// The number of public keys in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.PublicKeySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListPublicKeysOutput: Swift.Sendable {
    /// Returns a list of all public keys that have been added to CloudFront for this account.
    public var publicKeyList: CloudFrontClientTypes.PublicKeyList?

    public init(
        publicKeyList: CloudFrontClientTypes.PublicKeyList? = nil
    )
    {
        self.publicKeyList = publicKeyList
    }
}

public struct ListRealtimeLogConfigsInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of real-time log configurations. The response includes real-time log configurations in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of real-time log configurations that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A list of real-time log configurations.
    public struct RealtimeLogConfigs: Swift.Sendable {
        /// A flag that indicates whether there are more real-time log configurations than are contained in this list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the list of real-time log configurations.
        public var items: [CloudFrontClientTypes.RealtimeLogConfig]?
        /// This parameter indicates where this list of real-time log configurations begins. This list includes real-time log configurations that occur after the marker.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of real-time log configurations requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing real-time log configurations where you left off.
        public var nextMarker: Swift.String?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.RealtimeLogConfig]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
        }
    }
}

public struct ListRealtimeLogConfigsOutput: Swift.Sendable {
    /// A list of real-time log configurations.
    public var realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?

    public init(
        realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs? = nil
    )
    {
        self.realtimeLogConfigs = realtimeLogConfigs
    }
}

extension CloudFrontClientTypes {

    public enum ResponseHeadersPolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyType] {
            return [
                .custom,
                .managed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListResponseHeadersPoliciesInput: Swift.Sendable {
    /// Use this field when paginating results to indicate where to begin in your list of response headers policies. The response includes response headers policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of response headers policies that you want to get in the response.
    public var maxItems: Swift.Int?
    /// A filter to get only the specified kind of response headers policies. Valid values are:
    ///
    /// * managed – Gets only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Gets only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

extension CloudFrontClientTypes {

    /// Contains a response headers policy.
    public struct ResponseHeadersPolicySummary: Swift.Sendable {
        /// The response headers policy.
        /// This member is required.
        public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
        /// The type of response headers policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

        public init(
            responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil,
            type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
        )
        {
            self.responseHeadersPolicy = responseHeadersPolicy
            self.type = type
        }
    }
}

extension CloudFrontClientTypes {

    /// A list of response headers policies.
    public struct ResponseHeadersPolicyList: Swift.Sendable {
        /// The response headers policies in the list.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]?
        /// The maximum number of response headers policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing response headers policies where you left off.
        public var nextMarker: Swift.String?
        /// The number of response headers policies returned.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

public struct ListResponseHeadersPoliciesOutput: Swift.Sendable {
    /// A list of response headers policies.
    public var responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList?

    public init(
        responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList? = nil
    )
    {
        self.responseHeadersPolicyList = responseHeadersPolicyList
    }
}

/// The request to list your streaming distributions.
public struct ListStreamingDistributionsInput: Swift.Sendable {
    /// The value that you provided for the Marker request parameter.
    public var marker: Swift.String?
    /// The value that you provided for the MaxItems request parameter.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension CloudFrontClientTypes {

    /// A summary of the information for a CloudFront streaming distribution.
    public struct StreamingDistributionSummary: Swift.Sendable, Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The ARN (Amazon Resource Name) for the streaming distribution. For example: arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// The domain name corresponding to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept end user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The identifier for the distribution, for example, EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// Indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that specifies the Amazon Web Services accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items.If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            arn: Swift.String? = nil,
            comment: Swift.String? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            status: Swift.String? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.arn = arn
            self.comment = comment
            self.domainName = domainName
            self.enabled = enabled
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.status = status
            self.trustedSigners = trustedSigners
        }
    }
}

extension CloudFrontClientTypes {

    /// A streaming distribution list.
    public struct StreamingDistributionList: Swift.Sendable, Swift.Equatable {
        /// A flag that indicates whether more streaming distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one StreamingDistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.StreamingDistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your RTMP distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of streaming distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.StreamingDistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }
}

/// The returned result of the corresponding request.
public struct ListStreamingDistributionsOutput: Swift.Sendable {
    /// The StreamingDistributionList type.
    public var streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?

    public init(
        streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList? = nil
    )
    {
        self.streamingDistributionList = streamingDistributionList
    }
}

/// The request to list tags for a CloudFront resource.
public struct ListTagsForResourceInput: Swift.Sendable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

/// The returned result of the corresponding request.
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init(
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.tags = tags
    }
}

public struct PublishFunctionInput: Swift.Sendable {
    /// The current version (ETag value) of the function that you are publishing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are publishing.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

public struct PublishFunctionOutput: Swift.Sendable {
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.functionSummary = functionSummary
    }
}

/// The request to add tags to a CloudFront resource.
public struct TagResourceInput: Swift.Sendable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init(
        resource: Swift.String? = nil,
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

/// The CloudFront function failed.
public struct TestFunctionFailed: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TestFunctionFailed" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TestFunctionInput: Swift.Sendable {
    /// The event object to test the function with. For more information about the structure of the event object, see [Testing functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var eventObject: Foundation.Data?
    /// The current version (ETag value) of the function that you are testing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are testing.
    /// This member is required.
    public var name: Swift.String?
    /// The stage of the function that you are testing, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        eventObject: Foundation.Data? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.eventObject = eventObject
        self.ifMatch = ifMatch
        self.name = name
        self.stage = stage
    }
}

extension TestFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionInput(ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)), eventObject: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes {

    /// Contains the result of testing a CloudFront function with TestFunction.
    public struct TestResult: Swift.Sendable {
        /// The amount of time that the function took to run as a percentage of the maximum allowed time. For example, a compute utilization of 35 means that the function completed in 35% of the maximum allowed time.
        public var computeUtilization: Swift.String?
        /// If the result of testing the function was an error, this field contains the error message.
        public var functionErrorMessage: Swift.String?
        /// Contains the log lines that the function wrote (if any) when running the test.
        public var functionExecutionLogs: [Swift.String]?
        /// The event object returned by the function. For more information about the structure of the event object, see [Event object structure](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html) in the Amazon CloudFront Developer Guide.
        public var functionOutput: Swift.String?
        /// Contains configuration information and metadata about the CloudFront function that was tested.
        public var functionSummary: CloudFrontClientTypes.FunctionSummary?

        public init(
            computeUtilization: Swift.String? = nil,
            functionErrorMessage: Swift.String? = nil,
            functionExecutionLogs: [Swift.String]? = nil,
            functionOutput: Swift.String? = nil,
            functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
        )
        {
            self.computeUtilization = computeUtilization
            self.functionErrorMessage = functionErrorMessage
            self.functionExecutionLogs = functionExecutionLogs
            self.functionOutput = functionOutput
            self.functionSummary = functionSummary
        }
    }
}

extension CloudFrontClientTypes.TestResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestResult(computeUtilization: \(Swift.String(describing: computeUtilization)), functionSummary: \(Swift.String(describing: functionSummary)), functionErrorMessage: \"CONTENT_REDACTED\", functionExecutionLogs: \"CONTENT_REDACTED\", functionOutput: \"CONTENT_REDACTED\")"}
}

public struct TestFunctionOutput: Swift.Sendable {
    /// An object that represents the result of running the function with the provided event object.
    public var testResult: CloudFrontClientTypes.TestResult?

    public init(
        testResult: CloudFrontClientTypes.TestResult? = nil
    )
    {
        self.testResult = testResult
    }
}

extension CloudFrontClientTypes {

    /// A complex type that contains zero or more Tag elements.
    public struct TagKeys: Swift.Sendable {
        /// A complex type that contains Tag key elements.
        public var items: [Swift.String]?

        public init(
            items: [Swift.String]? = nil
        )
        {
            self.items = items
        }
    }
}

/// The request to remove tags from a CloudFront resource.
public struct UntagResourceInput: Swift.Sendable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag key elements.
    /// This member is required.
    public var tagKeys: CloudFrontClientTypes.TagKeys?

    public init(
        resource: Swift.String? = nil,
        tagKeys: CloudFrontClientTypes.TagKeys? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

public struct UpdateCachePolicyInput: Swift.Sendable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The unique identifier for the cache policy that you are updating. The identifier is returned in a cache behavior's CachePolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are updating. The version is returned in the cache policy's ETag field in the response to GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

public struct UpdateCachePolicyOutput: Swift.Sendable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

/// The request to update an origin access identity.
public struct UpdateCloudFrontOriginAccessIdentityInput: Swift.Sendable {
    /// The identity's configuration information.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The identity's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the identity's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The returned result of the corresponding request.
public struct UpdateCloudFrontOriginAccessIdentityOutput: Swift.Sendable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

public struct UpdateContinuousDeploymentPolicyInput: Swift.Sendable {
    /// The continuous deployment policy configuration.
    /// This member is required.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
    /// The identifier of the continuous deployment policy that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the continuous deployment policy that you are updating.
    public var ifMatch: Swift.String?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

public struct UpdateContinuousDeploymentPolicyOutput: Swift.Sendable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
    }
}

/// The request to update a distribution.
public struct UpdateDistributionInput: Swift.Sendable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

/// The returned result of the corresponding request.
public struct UpdateDistributionOutput: Swift.Sendable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

public struct UpdateDistributionWithStagingConfigInput: Swift.Sendable {
    /// The identifier of the primary distribution to which you are copying a staging distribution's configuration.
    /// This member is required.
    public var id: Swift.String?
    /// The current versions (ETag values) of both primary and staging distributions. Provide these in the following format: ,
    public var ifMatch: Swift.String?
    /// The identifier of the staging distribution whose configuration you are copying to the primary distribution.
    public var stagingDistributionId: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        stagingDistributionId: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.stagingDistributionId = stagingDistributionId
    }
}

public struct UpdateDistributionWithStagingConfigOutput: Swift.Sendable {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the primary distribution (after it's updated).
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

public struct UpdateFieldLevelEncryptionConfigInput: Swift.Sendable {
    /// Request to update a field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
    /// The ID of the configuration you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

public struct UpdateFieldLevelEncryptionConfigOutput: Swift.Sendable {
    /// The value of the ETag header that you received when updating the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the results of updating the configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

public struct UpdateFieldLevelEncryptionProfileInput: Swift.Sendable {
    /// Request to update a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
    /// The ID of the field-level encryption profile request.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

public struct UpdateFieldLevelEncryptionProfileOutput: Swift.Sendable {
    /// The result of the field-level encryption profile request.
    public var eTag: Swift.String?
    /// Return the results of updating the profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

public struct UpdateFunctionInput: Swift.Sendable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: Foundation.Data?
    /// Configuration information about the function.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// The current version (ETag value) of the function that you are updating, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are updating.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionCode: Foundation.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.ifMatch = ifMatch
        self.name = name
    }
}

extension UpdateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionInput(functionConfig: \(Swift.String(describing: functionConfig)), ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), functionCode: \"CONTENT_REDACTED\")"}
}

public struct UpdateFunctionOutput: Swift.Sendable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

public struct UpdateKeyGroupInput: Swift.Sendable {
    /// The identifier of the key group that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are updating. The version is the key group's ETag value.
    public var ifMatch: Swift.String?
    /// The key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.keyGroupConfig = keyGroupConfig
    }
}

public struct UpdateKeyGroupOutput: Swift.Sendable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just updated.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

public struct UpdateKeyValueStoreInput: Swift.Sendable {
    /// The comment of the key value store to update.
    /// This member is required.
    public var comment: Swift.String?
    /// The key value store to update, if a match occurs.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the key value store to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        comment: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.comment = comment
        self.ifMatch = ifMatch
        self.name = name
    }
}

public struct UpdateKeyValueStoreOutput: Swift.Sendable {
    /// The ETag of the resulting key value store.
    public var eTag: Swift.String?
    /// The resulting key value store to update.
    public var keyValueStore: CloudFrontClientTypes.KeyValueStore?

    public init(
        eTag: Swift.String? = nil,
        keyValueStore: CloudFrontClientTypes.KeyValueStore? = nil
    )
    {
        self.eTag = eTag
        self.keyValueStore = keyValueStore
    }
}

public struct UpdateOriginAccessControlInput: Swift.Sendable {
    /// The unique identifier of the origin access control that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the origin access control that you are updating.
    public var ifMatch: Swift.String?
    /// An origin access control.
    /// This member is required.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originAccessControlConfig = originAccessControlConfig
    }
}

public struct UpdateOriginAccessControlOutput: Swift.Sendable {
    /// The new version of the origin access control after it has been updated.
    public var eTag: Swift.String?
    /// The origin access control after it has been updated.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControl = originAccessControl
    }
}

public struct UpdateOriginRequestPolicyInput: Swift.Sendable {
    /// The unique identifier for the origin request policy that you are updating. The identifier is returned in a cache behavior's OriginRequestPolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are updating. The version is returned in the origin request policy's ETag field in the response to GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

public struct UpdateOriginRequestPolicyOutput: Swift.Sendable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

public struct UpdatePublicKeyInput: Swift.Sendable {
    /// The identifier of the public key that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// A public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.publicKeyConfig = publicKeyConfig
    }
}

public struct UpdatePublicKeyOutput: Swift.Sendable {
    /// The identifier of the current version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

public struct UpdateRealtimeLogConfigInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this real-time log configuration.
    public var arn: Swift.String?
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    public var fields: [Swift.String]?
    /// The name for this real-time log configuration.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    public var samplingRate: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

public struct UpdateRealtimeLogConfigOutput: Swift.Sendable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

public struct UpdateResponseHeadersPolicyInput: Swift.Sendable {
    /// The identifier for the response headers policy that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are updating. The version is returned in the cache policy's ETag field in the response to GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?
    /// A response headers policy configuration.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

public struct UpdateResponseHeadersPolicyOutput: Swift.Sendable {
    /// The current version of the response headers policy.
    public var eTag: Swift.String?
    /// A response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

/// The request to update a streaming distribution.
public struct UpdateStreamingDistributionInput: Swift.Sendable {
    /// The streaming distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the streaming distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

/// The returned result of the corresponding request.
public struct UpdateStreamingDistributionOutput: Swift.Sendable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

extension AssociateAliasInput {

    static func urlPathProvider(_ value: AssociateAliasInput) -> Swift.String? {
        guard let targetDistributionId = value.targetDistributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(targetDistributionId.urlPercentEncoding())/associate-alias"
    }
}

extension AssociateAliasInput {

    static func queryItemProvider(_ value: AssociateAliasInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let alias = value.alias else {
            let message = "Creating a URL Query Item failed. alias is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let aliasQueryItem = Smithy.URIQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
        items.append(aliasQueryItem)
        return items
    }
}

extension CopyDistributionInput {

    static func urlPathProvider(_ value: CopyDistributionInput) -> Swift.String? {
        guard let primaryDistributionId = value.primaryDistributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(primaryDistributionId.urlPercentEncoding())/copy"
    }
}

extension CopyDistributionInput {

    static func headerProvider(_ value: CopyDistributionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let staging = value.staging {
            items.add(SmithyHTTPAPI.Header(name: "Staging", value: Swift.String(staging)))
        }
        return items
    }
}

extension CreateCachePolicyInput {

    static func urlPathProvider(_ value: CreateCachePolicyInput) -> Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

extension CreateCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: CreateCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

extension CreateContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: CreateContinuousDeploymentPolicyInput) -> Swift.String? {
        return "/2020-05-31/continuous-deployment-policy"
    }
}

extension CreateDistributionInput {

    static func urlPathProvider(_ value: CreateDistributionInput) -> Swift.String? {
        return "/2020-05-31/distribution"
    }
}

extension CreateDistributionWithTagsInput {

    static func urlPathProvider(_ value: CreateDistributionWithTagsInput) -> Swift.String? {
        return "/2020-05-31/distribution"
    }
}

extension CreateDistributionWithTagsInput {

    static func queryItemProvider(_ value: CreateDistributionWithTagsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "WithTags", value: nil))
        return items
    }
}

extension CreateFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: CreateFieldLevelEncryptionConfigInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

extension CreateFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: CreateFieldLevelEncryptionProfileInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

extension CreateFunctionInput {

    static func urlPathProvider(_ value: CreateFunctionInput) -> Swift.String? {
        return "/2020-05-31/function"
    }
}

extension CreateInvalidationInput {

    static func urlPathProvider(_ value: CreateInvalidationInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

extension CreateKeyGroupInput {

    static func urlPathProvider(_ value: CreateKeyGroupInput) -> Swift.String? {
        return "/2020-05-31/key-group"
    }
}

extension CreateKeyValueStoreInput {

    static func urlPathProvider(_ value: CreateKeyValueStoreInput) -> Swift.String? {
        return "/2020-05-31/key-value-store"
    }
}

extension CreateMonitoringSubscriptionInput {

    static func urlPathProvider(_ value: CreateMonitoringSubscriptionInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

extension CreateOriginAccessControlInput {

    static func urlPathProvider(_ value: CreateOriginAccessControlInput) -> Swift.String? {
        return "/2020-05-31/origin-access-control"
    }
}

extension CreateOriginRequestPolicyInput {

    static func urlPathProvider(_ value: CreateOriginRequestPolicyInput) -> Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

extension CreatePublicKeyInput {

    static func urlPathProvider(_ value: CreatePublicKeyInput) -> Swift.String? {
        return "/2020-05-31/public-key"
    }
}

extension CreateRealtimeLogConfigInput {

    static func urlPathProvider(_ value: CreateRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

extension CreateResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: CreateResponseHeadersPolicyInput) -> Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

extension CreateStreamingDistributionInput {

    static func urlPathProvider(_ value: CreateStreamingDistributionInput) -> Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

extension CreateStreamingDistributionWithTagsInput {

    static func urlPathProvider(_ value: CreateStreamingDistributionWithTagsInput) -> Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

extension CreateStreamingDistributionWithTagsInput {

    static func queryItemProvider(_ value: CreateStreamingDistributionWithTagsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "WithTags", value: nil))
        return items
    }
}

extension DeleteCachePolicyInput {

    static func urlPathProvider(_ value: DeleteCachePolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

extension DeleteCachePolicyInput {

    static func headerProvider(_ value: DeleteCachePolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: DeleteCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput {

    static func headerProvider(_ value: DeleteCloudFrontOriginAccessIdentityInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: DeleteContinuousDeploymentPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

extension DeleteContinuousDeploymentPolicyInput {

    static func headerProvider(_ value: DeleteContinuousDeploymentPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteDistributionInput {

    static func urlPathProvider(_ value: DeleteDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

extension DeleteDistributionInput {

    static func headerProvider(_ value: DeleteDistributionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: DeleteFieldLevelEncryptionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

extension DeleteFieldLevelEncryptionConfigInput {

    static func headerProvider(_ value: DeleteFieldLevelEncryptionConfigInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: DeleteFieldLevelEncryptionProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

extension DeleteFieldLevelEncryptionProfileInput {

    static func headerProvider(_ value: DeleteFieldLevelEncryptionProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFunctionInput {

    static func urlPathProvider(_ value: DeleteFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

extension DeleteFunctionInput {

    static func headerProvider(_ value: DeleteFunctionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteKeyGroupInput {

    static func urlPathProvider(_ value: DeleteKeyGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

extension DeleteKeyGroupInput {

    static func headerProvider(_ value: DeleteKeyGroupInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteKeyValueStoreInput {

    static func urlPathProvider(_ value: DeleteKeyValueStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/key-value-store/\(name.urlPercentEncoding())"
    }
}

extension DeleteKeyValueStoreInput {

    static func headerProvider(_ value: DeleteKeyValueStoreInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteMonitoringSubscriptionInput {

    static func urlPathProvider(_ value: DeleteMonitoringSubscriptionInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

extension DeleteOriginAccessControlInput {

    static func urlPathProvider(_ value: DeleteOriginAccessControlInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())"
    }
}

extension DeleteOriginAccessControlInput {

    static func headerProvider(_ value: DeleteOriginAccessControlInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteOriginRequestPolicyInput {

    static func urlPathProvider(_ value: DeleteOriginRequestPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

extension DeleteOriginRequestPolicyInput {

    static func headerProvider(_ value: DeleteOriginRequestPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeletePublicKeyInput {

    static func urlPathProvider(_ value: DeletePublicKeyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

extension DeletePublicKeyInput {

    static func headerProvider(_ value: DeletePublicKeyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteRealtimeLogConfigInput {

    static func urlPathProvider(_ value: DeleteRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/delete-realtime-log-config"
    }
}

extension DeleteResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: DeleteResponseHeadersPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

extension DeleteResponseHeadersPolicyInput {

    static func headerProvider(_ value: DeleteResponseHeadersPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteStreamingDistributionInput {

    static func urlPathProvider(_ value: DeleteStreamingDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

extension DeleteStreamingDistributionInput {

    static func headerProvider(_ value: DeleteStreamingDistributionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DescribeFunctionInput {

    static func urlPathProvider(_ value: DescribeFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/describe"
    }
}

extension DescribeFunctionInput {

    static func queryItemProvider(_ value: DescribeFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let stage = value.stage {
            let stageQueryItem = Smithy.URIQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        return items
    }
}

extension DescribeKeyValueStoreInput {

    static func urlPathProvider(_ value: DescribeKeyValueStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/key-value-store/\(name.urlPercentEncoding())"
    }
}

extension GetCachePolicyInput {

    static func urlPathProvider(_ value: GetCachePolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

extension GetCachePolicyConfigInput {

    static func urlPathProvider(_ value: GetCachePolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())/config"
    }
}

extension GetCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: GetCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

extension GetCloudFrontOriginAccessIdentityConfigInput {

    static func urlPathProvider(_ value: GetCloudFrontOriginAccessIdentityConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

extension GetContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: GetContinuousDeploymentPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

extension GetContinuousDeploymentPolicyConfigInput {

    static func urlPathProvider(_ value: GetContinuousDeploymentPolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())/config"
    }
}

extension GetDistributionInput {

    static func urlPathProvider(_ value: GetDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

extension GetDistributionConfigInput {

    static func urlPathProvider(_ value: GetDistributionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

extension GetFieldLevelEncryptionInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

extension GetFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

extension GetFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

extension GetFieldLevelEncryptionProfileConfigInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionProfileConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

extension GetFunctionInput {

    static func urlPathProvider(_ value: GetFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

extension GetFunctionInput {

    static func queryItemProvider(_ value: GetFunctionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let stage = value.stage {
            let stageQueryItem = Smithy.URIQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        return items
    }
}

extension GetInvalidationInput {

    static func urlPathProvider(_ value: GetInvalidationInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation/\(id.urlPercentEncoding())"
    }
}

extension GetKeyGroupInput {

    static func urlPathProvider(_ value: GetKeyGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

extension GetKeyGroupConfigInput {

    static func urlPathProvider(_ value: GetKeyGroupConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())/config"
    }
}

extension GetMonitoringSubscriptionInput {

    static func urlPathProvider(_ value: GetMonitoringSubscriptionInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

extension GetOriginAccessControlInput {

    static func urlPathProvider(_ value: GetOriginAccessControlInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())"
    }
}

extension GetOriginAccessControlConfigInput {

    static func urlPathProvider(_ value: GetOriginAccessControlConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())/config"
    }
}

extension GetOriginRequestPolicyInput {

    static func urlPathProvider(_ value: GetOriginRequestPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

extension GetOriginRequestPolicyConfigInput {

    static func urlPathProvider(_ value: GetOriginRequestPolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())/config"
    }
}

extension GetPublicKeyInput {

    static func urlPathProvider(_ value: GetPublicKeyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

extension GetPublicKeyConfigInput {

    static func urlPathProvider(_ value: GetPublicKeyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

extension GetRealtimeLogConfigInput {

    static func urlPathProvider(_ value: GetRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/get-realtime-log-config"
    }
}

extension GetResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: GetResponseHeadersPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

extension GetResponseHeadersPolicyConfigInput {

    static func urlPathProvider(_ value: GetResponseHeadersPolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())/config"
    }
}

extension GetStreamingDistributionInput {

    static func urlPathProvider(_ value: GetStreamingDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

extension GetStreamingDistributionConfigInput {

    static func urlPathProvider(_ value: GetStreamingDistributionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

extension ListCachePoliciesInput {

    static func urlPathProvider(_ value: ListCachePoliciesInput) -> Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

extension ListCachePoliciesInput {

    static func queryItemProvider(_ value: ListCachePoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput {

    static func urlPathProvider(_ value: ListCloudFrontOriginAccessIdentitiesInput) -> Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput {

    static func queryItemProvider(_ value: ListCloudFrontOriginAccessIdentitiesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListConflictingAliasesInput {

    static func urlPathProvider(_ value: ListConflictingAliasesInput) -> Swift.String? {
        return "/2020-05-31/conflicting-alias"
    }
}

extension ListConflictingAliasesInput {

    static func queryItemProvider(_ value: ListConflictingAliasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let alias = value.alias else {
            let message = "Creating a URL Query Item failed. alias is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let aliasQueryItem = Smithy.URIQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
        items.append(aliasQueryItem)
        guard let distributionId = value.distributionId else {
            let message = "Creating a URL Query Item failed. distributionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let distributionIdQueryItem = Smithy.URIQueryItem(name: "DistributionId".urlPercentEncoding(), value: Swift.String(distributionId).urlPercentEncoding())
        items.append(distributionIdQueryItem)
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListContinuousDeploymentPoliciesInput {

    static func urlPathProvider(_ value: ListContinuousDeploymentPoliciesInput) -> Swift.String? {
        return "/2020-05-31/continuous-deployment-policy"
    }
}

extension ListContinuousDeploymentPoliciesInput {

    static func queryItemProvider(_ value: ListContinuousDeploymentPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsInput {

    static func urlPathProvider(_ value: ListDistributionsInput) -> Swift.String? {
        return "/2020-05-31/distribution"
    }
}

extension ListDistributionsInput {

    static func queryItemProvider(_ value: ListDistributionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByCachePolicyIdInput {

    static func urlPathProvider(_ value: ListDistributionsByCachePolicyIdInput) -> Swift.String? {
        guard let cachePolicyId = value.cachePolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByCachePolicyId/\(cachePolicyId.urlPercentEncoding())"
    }
}

extension ListDistributionsByCachePolicyIdInput {

    static func queryItemProvider(_ value: ListDistributionsByCachePolicyIdInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByKeyGroupInput {

    static func urlPathProvider(_ value: ListDistributionsByKeyGroupInput) -> Swift.String? {
        guard let keyGroupId = value.keyGroupId else {
            return nil
        }
        return "/2020-05-31/distributionsByKeyGroupId/\(keyGroupId.urlPercentEncoding())"
    }
}

extension ListDistributionsByKeyGroupInput {

    static func queryItemProvider(_ value: ListDistributionsByKeyGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput {

    static func urlPathProvider(_ value: ListDistributionsByOriginRequestPolicyIdInput) -> Swift.String? {
        guard let originRequestPolicyId = value.originRequestPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByOriginRequestPolicyId/\(originRequestPolicyId.urlPercentEncoding())"
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput {

    static func queryItemProvider(_ value: ListDistributionsByOriginRequestPolicyIdInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByRealtimeLogConfigInput {

    static func urlPathProvider(_ value: ListDistributionsByRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/distributionsByRealtimeLogConfig"
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput {

    static func urlPathProvider(_ value: ListDistributionsByResponseHeadersPolicyIdInput) -> Swift.String? {
        guard let responseHeadersPolicyId = value.responseHeadersPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByResponseHeadersPolicyId/\(responseHeadersPolicyId.urlPercentEncoding())"
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput {

    static func queryItemProvider(_ value: ListDistributionsByResponseHeadersPolicyIdInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByWebACLIdInput {

    static func urlPathProvider(_ value: ListDistributionsByWebACLIdInput) -> Swift.String? {
        guard let webACLId = value.webACLId else {
            return nil
        }
        return "/2020-05-31/distributionsByWebACLId/\(webACLId.urlPercentEncoding())"
    }
}

extension ListDistributionsByWebACLIdInput {

    static func queryItemProvider(_ value: ListDistributionsByWebACLIdInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFieldLevelEncryptionConfigsInput {

    static func urlPathProvider(_ value: ListFieldLevelEncryptionConfigsInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

extension ListFieldLevelEncryptionConfigsInput {

    static func queryItemProvider(_ value: ListFieldLevelEncryptionConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFieldLevelEncryptionProfilesInput {

    static func urlPathProvider(_ value: ListFieldLevelEncryptionProfilesInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

extension ListFieldLevelEncryptionProfilesInput {

    static func queryItemProvider(_ value: ListFieldLevelEncryptionProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput {

    static func urlPathProvider(_ value: ListFunctionsInput) -> Swift.String? {
        return "/2020-05-31/function"
    }
}

extension ListFunctionsInput {

    static func queryItemProvider(_ value: ListFunctionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let stage = value.stage {
            let stageQueryItem = Smithy.URIQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListInvalidationsInput {

    static func urlPathProvider(_ value: ListInvalidationsInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

extension ListInvalidationsInput {

    static func queryItemProvider(_ value: ListInvalidationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListKeyGroupsInput {

    static func urlPathProvider(_ value: ListKeyGroupsInput) -> Swift.String? {
        return "/2020-05-31/key-group"
    }
}

extension ListKeyGroupsInput {

    static func queryItemProvider(_ value: ListKeyGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListKeyValueStoresInput {

    static func urlPathProvider(_ value: ListKeyValueStoresInput) -> Swift.String? {
        return "/2020-05-31/key-value-store"
    }
}

extension ListKeyValueStoresInput {

    static func queryItemProvider(_ value: ListKeyValueStoresInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListOriginAccessControlsInput {

    static func urlPathProvider(_ value: ListOriginAccessControlsInput) -> Swift.String? {
        return "/2020-05-31/origin-access-control"
    }
}

extension ListOriginAccessControlsInput {

    static func queryItemProvider(_ value: ListOriginAccessControlsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListOriginRequestPoliciesInput {

    static func urlPathProvider(_ value: ListOriginRequestPoliciesInput) -> Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

extension ListOriginRequestPoliciesInput {

    static func queryItemProvider(_ value: ListOriginRequestPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListPublicKeysInput {

    static func urlPathProvider(_ value: ListPublicKeysInput) -> Swift.String? {
        return "/2020-05-31/public-key"
    }
}

extension ListPublicKeysInput {

    static func queryItemProvider(_ value: ListPublicKeysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListRealtimeLogConfigsInput {

    static func urlPathProvider(_ value: ListRealtimeLogConfigsInput) -> Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

extension ListRealtimeLogConfigsInput {

    static func queryItemProvider(_ value: ListRealtimeLogConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension ListResponseHeadersPoliciesInput {

    static func urlPathProvider(_ value: ListResponseHeadersPoliciesInput) -> Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

extension ListResponseHeadersPoliciesInput {

    static func queryItemProvider(_ value: ListResponseHeadersPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListStreamingDistributionsInput {

    static func urlPathProvider(_ value: ListStreamingDistributionsInput) -> Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

extension ListStreamingDistributionsInput {

    static func queryItemProvider(_ value: ListStreamingDistributionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/2020-05-31/tagging"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resource = value.resource else {
            let message = "Creating a URL Query Item failed. resource is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceQueryItem = Smithy.URIQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
        items.append(resourceQueryItem)
        return items
    }
}

extension PublishFunctionInput {

    static func urlPathProvider(_ value: PublishFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/publish"
    }
}

extension PublishFunctionInput {

    static func headerProvider(_ value: PublishFunctionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/2020-05-31/tagging"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "Operation", value: "Tag"))
        guard let resource = value.resource else {
            let message = "Creating a URL Query Item failed. resource is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceQueryItem = Smithy.URIQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
        items.append(resourceQueryItem)
        return items
    }
}

extension TestFunctionInput {

    static func urlPathProvider(_ value: TestFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/test"
    }
}

extension TestFunctionInput {

    static func headerProvider(_ value: TestFunctionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/2020-05-31/tagging"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "Operation", value: "Untag"))
        guard let resource = value.resource else {
            let message = "Creating a URL Query Item failed. resource is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceQueryItem = Smithy.URIQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
        items.append(resourceQueryItem)
        return items
    }
}

extension UpdateCachePolicyInput {

    static func urlPathProvider(_ value: UpdateCachePolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

extension UpdateCachePolicyInput {

    static func headerProvider(_ value: UpdateCachePolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: UpdateCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput {

    static func headerProvider(_ value: UpdateCloudFrontOriginAccessIdentityInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: UpdateContinuousDeploymentPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

extension UpdateContinuousDeploymentPolicyInput {

    static func headerProvider(_ value: UpdateContinuousDeploymentPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionInput {

    static func urlPathProvider(_ value: UpdateDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

extension UpdateDistributionInput {

    static func headerProvider(_ value: UpdateDistributionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionWithStagingConfigInput {

    static func urlPathProvider(_ value: UpdateDistributionWithStagingConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/promote-staging-config"
    }
}

extension UpdateDistributionWithStagingConfigInput {

    static func headerProvider(_ value: UpdateDistributionWithStagingConfigInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionWithStagingConfigInput {

    static func queryItemProvider(_ value: UpdateDistributionWithStagingConfigInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let stagingDistributionId = value.stagingDistributionId {
            let stagingDistributionIdQueryItem = Smithy.URIQueryItem(name: "StagingDistributionId".urlPercentEncoding(), value: Swift.String(stagingDistributionId).urlPercentEncoding())
            items.append(stagingDistributionIdQueryItem)
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: UpdateFieldLevelEncryptionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

extension UpdateFieldLevelEncryptionConfigInput {

    static func headerProvider(_ value: UpdateFieldLevelEncryptionConfigInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: UpdateFieldLevelEncryptionProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

extension UpdateFieldLevelEncryptionProfileInput {

    static func headerProvider(_ value: UpdateFieldLevelEncryptionProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFunctionInput {

    static func urlPathProvider(_ value: UpdateFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

extension UpdateFunctionInput {

    static func headerProvider(_ value: UpdateFunctionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeyGroupInput {

    static func urlPathProvider(_ value: UpdateKeyGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

extension UpdateKeyGroupInput {

    static func headerProvider(_ value: UpdateKeyGroupInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeyValueStoreInput {

    static func urlPathProvider(_ value: UpdateKeyValueStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/key-value-store/\(name.urlPercentEncoding())"
    }
}

extension UpdateKeyValueStoreInput {

    static func headerProvider(_ value: UpdateKeyValueStoreInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateOriginAccessControlInput {

    static func urlPathProvider(_ value: UpdateOriginAccessControlInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())/config"
    }
}

extension UpdateOriginAccessControlInput {

    static func headerProvider(_ value: UpdateOriginAccessControlInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateOriginRequestPolicyInput {

    static func urlPathProvider(_ value: UpdateOriginRequestPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

extension UpdateOriginRequestPolicyInput {

    static func headerProvider(_ value: UpdateOriginRequestPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdatePublicKeyInput {

    static func urlPathProvider(_ value: UpdatePublicKeyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

extension UpdatePublicKeyInput {

    static func headerProvider(_ value: UpdatePublicKeyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateRealtimeLogConfigInput {

    static func urlPathProvider(_ value: UpdateRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

extension UpdateResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: UpdateResponseHeadersPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

extension UpdateResponseHeadersPolicyInput {

    static func headerProvider(_ value: UpdateResponseHeadersPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateStreamingDistributionInput {

    static func urlPathProvider(_ value: UpdateStreamingDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

extension UpdateStreamingDistributionInput {

    static func headerProvider(_ value: UpdateStreamingDistributionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension CopyDistributionInput {

    static func write(value: CopyDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Enabled"].write(value.enabled)
    }
}

extension CreateCachePolicyInput {

    static func write(value: CreateCachePolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CachePolicyConfig"].write(value.cachePolicyConfig, with: CloudFrontClientTypes.CachePolicyConfig.write(value:to:))
    }
}

extension CreateCloudFrontOriginAccessIdentityInput {

    static func write(value: CreateCloudFrontOriginAccessIdentityInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CloudFrontOriginAccessIdentityConfig"].write(value.cloudFrontOriginAccessIdentityConfig, with: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.write(value:to:))
    }
}

extension CreateContinuousDeploymentPolicyInput {

    static func write(value: CreateContinuousDeploymentPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ContinuousDeploymentPolicyConfig"].write(value.continuousDeploymentPolicyConfig, with: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.write(value:to:))
    }
}

extension CreateDistributionInput {

    static func write(value: CreateDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["DistributionConfig"].write(value.distributionConfig, with: CloudFrontClientTypes.DistributionConfig.write(value:to:))
    }
}

extension CreateDistributionWithTagsInput {

    static func write(value: CreateDistributionWithTagsInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["DistributionConfigWithTags"].write(value.distributionConfigWithTags, with: CloudFrontClientTypes.DistributionConfigWithTags.write(value:to:))
    }
}

extension CreateFieldLevelEncryptionConfigInput {

    static func write(value: CreateFieldLevelEncryptionConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FieldLevelEncryptionConfig"].write(value.fieldLevelEncryptionConfig, with: CloudFrontClientTypes.FieldLevelEncryptionConfig.write(value:to:))
    }
}

extension CreateFieldLevelEncryptionProfileInput {

    static func write(value: CreateFieldLevelEncryptionProfileInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FieldLevelEncryptionProfileConfig"].write(value.fieldLevelEncryptionProfileConfig, with: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.write(value:to:))
    }
}

extension CreateFunctionInput {

    static func write(value: CreateFunctionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FunctionCode"].write(value.functionCode)
        try writer["FunctionConfig"].write(value.functionConfig, with: CloudFrontClientTypes.FunctionConfig.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension CreateInvalidationInput {

    static func write(value: CreateInvalidationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["InvalidationBatch"].write(value.invalidationBatch, with: CloudFrontClientTypes.InvalidationBatch.write(value:to:))
    }
}

extension CreateKeyGroupInput {

    static func write(value: CreateKeyGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["KeyGroupConfig"].write(value.keyGroupConfig, with: CloudFrontClientTypes.KeyGroupConfig.write(value:to:))
    }
}

extension CreateKeyValueStoreInput {

    static func write(value: CreateKeyValueStoreInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
        try writer["ImportSource"].write(value.importSource, with: CloudFrontClientTypes.ImportSource.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension CreateMonitoringSubscriptionInput {

    static func write(value: CreateMonitoringSubscriptionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["MonitoringSubscription"].write(value.monitoringSubscription, with: CloudFrontClientTypes.MonitoringSubscription.write(value:to:))
    }
}

extension CreateOriginAccessControlInput {

    static func write(value: CreateOriginAccessControlInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["OriginAccessControlConfig"].write(value.originAccessControlConfig, with: CloudFrontClientTypes.OriginAccessControlConfig.write(value:to:))
    }
}

extension CreateOriginRequestPolicyInput {

    static func write(value: CreateOriginRequestPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["OriginRequestPolicyConfig"].write(value.originRequestPolicyConfig, with: CloudFrontClientTypes.OriginRequestPolicyConfig.write(value:to:))
    }
}

extension CreatePublicKeyInput {

    static func write(value: CreatePublicKeyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["PublicKeyConfig"].write(value.publicKeyConfig, with: CloudFrontClientTypes.PublicKeyConfig.write(value:to:))
    }
}

extension CreateRealtimeLogConfigInput {

    static func write(value: CreateRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["EndPoints"].writeList(value.endPoints, memberWritingClosure: CloudFrontClientTypes.EndPoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Fields"].writeList(value.fields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Field", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["SamplingRate"].write(value.samplingRate)
    }
}

extension CreateResponseHeadersPolicyInput {

    static func write(value: CreateResponseHeadersPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ResponseHeadersPolicyConfig"].write(value.responseHeadersPolicyConfig, with: CloudFrontClientTypes.ResponseHeadersPolicyConfig.write(value:to:))
    }
}

extension CreateStreamingDistributionInput {

    static func write(value: CreateStreamingDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["StreamingDistributionConfig"].write(value.streamingDistributionConfig, with: CloudFrontClientTypes.StreamingDistributionConfig.write(value:to:))
    }
}

extension CreateStreamingDistributionWithTagsInput {

    static func write(value: CreateStreamingDistributionWithTagsInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["StreamingDistributionConfigWithTags"].write(value.streamingDistributionConfigWithTags, with: CloudFrontClientTypes.StreamingDistributionConfigWithTags.write(value:to:))
    }
}

extension DeleteRealtimeLogConfigInput {

    static func write(value: DeleteRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ARN"].write(value.arn)
        try writer["Name"].write(value.name)
    }
}

extension GetRealtimeLogConfigInput {

    static func write(value: GetRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ARN"].write(value.arn)
        try writer["Name"].write(value.name)
    }
}

extension ListDistributionsByRealtimeLogConfigInput {

    static func write(value: ListDistributionsByRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["RealtimeLogConfigArn"].write(value.realtimeLogConfigArn)
        try writer["RealtimeLogConfigName"].write(value.realtimeLogConfigName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Tags"].write(value.tags, with: CloudFrontClientTypes.Tags.write(value:to:))
    }
}

extension TestFunctionInput {

    static func write(value: TestFunctionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["EventObject"].write(value.eventObject)
        try writer["Stage"].write(value.stage)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].write(value.tagKeys, with: CloudFrontClientTypes.TagKeys.write(value:to:))
    }
}

extension UpdateCachePolicyInput {

    static func write(value: UpdateCachePolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CachePolicyConfig"].write(value.cachePolicyConfig, with: CloudFrontClientTypes.CachePolicyConfig.write(value:to:))
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput {

    static func write(value: UpdateCloudFrontOriginAccessIdentityInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CloudFrontOriginAccessIdentityConfig"].write(value.cloudFrontOriginAccessIdentityConfig, with: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.write(value:to:))
    }
}

extension UpdateContinuousDeploymentPolicyInput {

    static func write(value: UpdateContinuousDeploymentPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ContinuousDeploymentPolicyConfig"].write(value.continuousDeploymentPolicyConfig, with: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.write(value:to:))
    }
}

extension UpdateDistributionInput {

    static func write(value: UpdateDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["DistributionConfig"].write(value.distributionConfig, with: CloudFrontClientTypes.DistributionConfig.write(value:to:))
    }
}

extension UpdateFieldLevelEncryptionConfigInput {

    static func write(value: UpdateFieldLevelEncryptionConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FieldLevelEncryptionConfig"].write(value.fieldLevelEncryptionConfig, with: CloudFrontClientTypes.FieldLevelEncryptionConfig.write(value:to:))
    }
}

extension UpdateFieldLevelEncryptionProfileInput {

    static func write(value: UpdateFieldLevelEncryptionProfileInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FieldLevelEncryptionProfileConfig"].write(value.fieldLevelEncryptionProfileConfig, with: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.write(value:to:))
    }
}

extension UpdateFunctionInput {

    static func write(value: UpdateFunctionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FunctionCode"].write(value.functionCode)
        try writer["FunctionConfig"].write(value.functionConfig, with: CloudFrontClientTypes.FunctionConfig.write(value:to:))
    }
}

extension UpdateKeyGroupInput {

    static func write(value: UpdateKeyGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["KeyGroupConfig"].write(value.keyGroupConfig, with: CloudFrontClientTypes.KeyGroupConfig.write(value:to:))
    }
}

extension UpdateKeyValueStoreInput {

    static func write(value: UpdateKeyValueStoreInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
    }
}

extension UpdateOriginAccessControlInput {

    static func write(value: UpdateOriginAccessControlInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["OriginAccessControlConfig"].write(value.originAccessControlConfig, with: CloudFrontClientTypes.OriginAccessControlConfig.write(value:to:))
    }
}

extension UpdateOriginRequestPolicyInput {

    static func write(value: UpdateOriginRequestPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["OriginRequestPolicyConfig"].write(value.originRequestPolicyConfig, with: CloudFrontClientTypes.OriginRequestPolicyConfig.write(value:to:))
    }
}

extension UpdatePublicKeyInput {

    static func write(value: UpdatePublicKeyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["PublicKeyConfig"].write(value.publicKeyConfig, with: CloudFrontClientTypes.PublicKeyConfig.write(value:to:))
    }
}

extension UpdateRealtimeLogConfigInput {

    static func write(value: UpdateRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ARN"].write(value.arn)
        try writer["EndPoints"].writeList(value.endPoints, memberWritingClosure: CloudFrontClientTypes.EndPoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Fields"].writeList(value.fields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Field", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["SamplingRate"].write(value.samplingRate)
    }
}

extension UpdateResponseHeadersPolicyInput {

    static func write(value: UpdateResponseHeadersPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ResponseHeadersPolicyConfig"].write(value.responseHeadersPolicyConfig, with: CloudFrontClientTypes.ResponseHeadersPolicyConfig.write(value:to:))
    }
}

extension UpdateStreamingDistributionInput {

    static func write(value: UpdateStreamingDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["StreamingDistributionConfig"].write(value.streamingDistributionConfig, with: CloudFrontClientTypes.StreamingDistributionConfig.write(value:to:))
    }
}

extension AssociateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAliasOutput {
        return AssociateAliasOutput()
    }
}

extension CopyDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CopyDistributionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.distribution = try reader.readIfPresent(with: CloudFrontClientTypes.Distribution.read(from:))
        return value
    }
}

extension CreateCachePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCachePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCachePolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.cachePolicy = try reader.readIfPresent(with: CloudFrontClientTypes.CachePolicy.read(from:))
        return value
    }
}

extension CreateCloudFrontOriginAccessIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCloudFrontOriginAccessIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCloudFrontOriginAccessIdentityOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.cloudFrontOriginAccessIdentity = try reader.readIfPresent(with: CloudFrontClientTypes.CloudFrontOriginAccessIdentity.read(from:))
        return value
    }
}

extension CreateContinuousDeploymentPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContinuousDeploymentPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContinuousDeploymentPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.continuousDeploymentPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentPolicy.read(from:))
        return value
    }
}

extension CreateDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDistributionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.distribution = try reader.readIfPresent(with: CloudFrontClientTypes.Distribution.read(from:))
        return value
    }
}

extension CreateDistributionWithTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDistributionWithTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDistributionWithTagsOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.distribution = try reader.readIfPresent(with: CloudFrontClientTypes.Distribution.read(from:))
        return value
    }
}

extension CreateFieldLevelEncryptionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFieldLevelEncryptionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFieldLevelEncryptionConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.fieldLevelEncryption = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryption.read(from:))
        return value
    }
}

extension CreateFieldLevelEncryptionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFieldLevelEncryptionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFieldLevelEncryptionProfileOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.fieldLevelEncryptionProfile = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionProfile.read(from:))
        return value
    }
}

extension CreateFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.functionSummary = try reader.readIfPresent(with: CloudFrontClientTypes.FunctionSummary.read(from:))
        return value
    }
}

extension CreateInvalidationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInvalidationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInvalidationOutput()
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.invalidation = try reader.readIfPresent(with: CloudFrontClientTypes.Invalidation.read(from:))
        return value
    }
}

extension CreateKeyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKeyGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKeyGroupOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.keyGroup = try reader.readIfPresent(with: CloudFrontClientTypes.KeyGroup.read(from:))
        return value
    }
}

extension CreateKeyValueStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKeyValueStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKeyValueStoreOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.keyValueStore = try reader.readIfPresent(with: CloudFrontClientTypes.KeyValueStore.read(from:))
        return value
    }
}

extension CreateMonitoringSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMonitoringSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMonitoringSubscriptionOutput()
        value.monitoringSubscription = try reader.readIfPresent(with: CloudFrontClientTypes.MonitoringSubscription.read(from:))
        return value
    }
}

extension CreateOriginAccessControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOriginAccessControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOriginAccessControlOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.originAccessControl = try reader.readIfPresent(with: CloudFrontClientTypes.OriginAccessControl.read(from:))
        return value
    }
}

extension CreateOriginRequestPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOriginRequestPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOriginRequestPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.originRequestPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicy.read(from:))
        return value
    }
}

extension CreatePublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePublicKeyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.publicKey = try reader.readIfPresent(with: CloudFrontClientTypes.PublicKey.read(from:))
        return value
    }
}

extension CreateRealtimeLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRealtimeLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRealtimeLogConfigOutput()
        value.realtimeLogConfig = try reader["RealtimeLogConfig"].readIfPresent(with: CloudFrontClientTypes.RealtimeLogConfig.read(from:))
        return value
    }
}

extension CreateResponseHeadersPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResponseHeadersPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResponseHeadersPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.responseHeadersPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicy.read(from:))
        return value
    }
}

extension CreateStreamingDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamingDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamingDistributionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.streamingDistribution = try reader.readIfPresent(with: CloudFrontClientTypes.StreamingDistribution.read(from:))
        return value
    }
}

extension CreateStreamingDistributionWithTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamingDistributionWithTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamingDistributionWithTagsOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            value.location = locationHeaderValue
        }
        value.streamingDistribution = try reader.readIfPresent(with: CloudFrontClientTypes.StreamingDistribution.read(from:))
        return value
    }
}

extension DeleteCachePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCachePolicyOutput {
        return DeleteCachePolicyOutput()
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCloudFrontOriginAccessIdentityOutput {
        return DeleteCloudFrontOriginAccessIdentityOutput()
    }
}

extension DeleteContinuousDeploymentPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContinuousDeploymentPolicyOutput {
        return DeleteContinuousDeploymentPolicyOutput()
    }
}

extension DeleteDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDistributionOutput {
        return DeleteDistributionOutput()
    }
}

extension DeleteFieldLevelEncryptionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFieldLevelEncryptionConfigOutput {
        return DeleteFieldLevelEncryptionConfigOutput()
    }
}

extension DeleteFieldLevelEncryptionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFieldLevelEncryptionProfileOutput {
        return DeleteFieldLevelEncryptionProfileOutput()
    }
}

extension DeleteFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionOutput {
        return DeleteFunctionOutput()
    }
}

extension DeleteKeyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKeyGroupOutput {
        return DeleteKeyGroupOutput()
    }
}

extension DeleteKeyValueStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKeyValueStoreOutput {
        return DeleteKeyValueStoreOutput()
    }
}

extension DeleteMonitoringSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMonitoringSubscriptionOutput {
        return DeleteMonitoringSubscriptionOutput()
    }
}

extension DeleteOriginAccessControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOriginAccessControlOutput {
        return DeleteOriginAccessControlOutput()
    }
}

extension DeleteOriginRequestPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOriginRequestPolicyOutput {
        return DeleteOriginRequestPolicyOutput()
    }
}

extension DeletePublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePublicKeyOutput {
        return DeletePublicKeyOutput()
    }
}

extension DeleteRealtimeLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRealtimeLogConfigOutput {
        return DeleteRealtimeLogConfigOutput()
    }
}

extension DeleteResponseHeadersPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResponseHeadersPolicyOutput {
        return DeleteResponseHeadersPolicyOutput()
    }
}

extension DeleteStreamingDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStreamingDistributionOutput {
        return DeleteStreamingDistributionOutput()
    }
}

extension DescribeFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFunctionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.functionSummary = try reader.readIfPresent(with: CloudFrontClientTypes.FunctionSummary.read(from:))
        return value
    }
}

extension DescribeKeyValueStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeKeyValueStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeKeyValueStoreOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.keyValueStore = try reader.readIfPresent(with: CloudFrontClientTypes.KeyValueStore.read(from:))
        return value
    }
}

extension GetCachePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCachePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetCachePolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.cachePolicy = try reader.readIfPresent(with: CloudFrontClientTypes.CachePolicy.read(from:))
        return value
    }
}

extension GetCachePolicyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCachePolicyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetCachePolicyConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.cachePolicyConfig = try reader.readIfPresent(with: CloudFrontClientTypes.CachePolicyConfig.read(from:))
        return value
    }
}

extension GetCloudFrontOriginAccessIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudFrontOriginAccessIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudFrontOriginAccessIdentityOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.cloudFrontOriginAccessIdentity = try reader.readIfPresent(with: CloudFrontClientTypes.CloudFrontOriginAccessIdentity.read(from:))
        return value
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudFrontOriginAccessIdentityConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudFrontOriginAccessIdentityConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.cloudFrontOriginAccessIdentityConfig = try reader.readIfPresent(with: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.read(from:))
        return value
    }
}

extension GetContinuousDeploymentPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContinuousDeploymentPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetContinuousDeploymentPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.continuousDeploymentPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentPolicy.read(from:))
        return value
    }
}

extension GetContinuousDeploymentPolicyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContinuousDeploymentPolicyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetContinuousDeploymentPolicyConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.continuousDeploymentPolicyConfig = try reader.readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.read(from:))
        return value
    }
}

extension GetDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetDistributionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.distribution = try reader.readIfPresent(with: CloudFrontClientTypes.Distribution.read(from:))
        return value
    }
}

extension GetDistributionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDistributionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetDistributionConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.distributionConfig = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionConfig.read(from:))
        return value
    }
}

extension GetFieldLevelEncryptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFieldLevelEncryptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetFieldLevelEncryptionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.fieldLevelEncryption = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryption.read(from:))
        return value
    }
}

extension GetFieldLevelEncryptionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFieldLevelEncryptionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetFieldLevelEncryptionConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.fieldLevelEncryptionConfig = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionConfig.read(from:))
        return value
    }
}

extension GetFieldLevelEncryptionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFieldLevelEncryptionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetFieldLevelEncryptionProfileOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.fieldLevelEncryptionProfile = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionProfile.read(from:))
        return value
    }
}

extension GetFieldLevelEncryptionProfileConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFieldLevelEncryptionProfileConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetFieldLevelEncryptionProfileConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.fieldLevelEncryptionProfileConfig = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.read(from:))
        return value
    }
}

extension GetFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionOutput {
        var value = GetFunctionOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.functionCode = data
        case .stream(let stream):
            value.functionCode = try stream.readToEnd()
        case .noStream:
            value.functionCode = nil
        }
        return value
    }
}

extension GetInvalidationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvalidationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvalidationOutput()
        value.invalidation = try reader.readIfPresent(with: CloudFrontClientTypes.Invalidation.read(from:))
        return value
    }
}

extension GetKeyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKeyGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetKeyGroupOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.keyGroup = try reader.readIfPresent(with: CloudFrontClientTypes.KeyGroup.read(from:))
        return value
    }
}

extension GetKeyGroupConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKeyGroupConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetKeyGroupConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.keyGroupConfig = try reader.readIfPresent(with: CloudFrontClientTypes.KeyGroupConfig.read(from:))
        return value
    }
}

extension GetMonitoringSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMonitoringSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetMonitoringSubscriptionOutput()
        value.monitoringSubscription = try reader.readIfPresent(with: CloudFrontClientTypes.MonitoringSubscription.read(from:))
        return value
    }
}

extension GetOriginAccessControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOriginAccessControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetOriginAccessControlOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.originAccessControl = try reader.readIfPresent(with: CloudFrontClientTypes.OriginAccessControl.read(from:))
        return value
    }
}

extension GetOriginAccessControlConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOriginAccessControlConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetOriginAccessControlConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.originAccessControlConfig = try reader.readIfPresent(with: CloudFrontClientTypes.OriginAccessControlConfig.read(from:))
        return value
    }
}

extension GetOriginRequestPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOriginRequestPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetOriginRequestPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.originRequestPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicy.read(from:))
        return value
    }
}

extension GetOriginRequestPolicyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOriginRequestPolicyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetOriginRequestPolicyConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.originRequestPolicyConfig = try reader.readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicyConfig.read(from:))
        return value
    }
}

extension GetPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetPublicKeyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.publicKey = try reader.readIfPresent(with: CloudFrontClientTypes.PublicKey.read(from:))
        return value
    }
}

extension GetPublicKeyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPublicKeyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetPublicKeyConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.publicKeyConfig = try reader.readIfPresent(with: CloudFrontClientTypes.PublicKeyConfig.read(from:))
        return value
    }
}

extension GetRealtimeLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRealtimeLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetRealtimeLogConfigOutput()
        value.realtimeLogConfig = try reader["RealtimeLogConfig"].readIfPresent(with: CloudFrontClientTypes.RealtimeLogConfig.read(from:))
        return value
    }
}

extension GetResponseHeadersPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResponseHeadersPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetResponseHeadersPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.responseHeadersPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicy.read(from:))
        return value
    }
}

extension GetResponseHeadersPolicyConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResponseHeadersPolicyConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetResponseHeadersPolicyConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.responseHeadersPolicyConfig = try reader.readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyConfig.read(from:))
        return value
    }
}

extension GetStreamingDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamingDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamingDistributionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.streamingDistribution = try reader.readIfPresent(with: CloudFrontClientTypes.StreamingDistribution.read(from:))
        return value
    }
}

extension GetStreamingDistributionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamingDistributionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamingDistributionConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.streamingDistributionConfig = try reader.readIfPresent(with: CloudFrontClientTypes.StreamingDistributionConfig.read(from:))
        return value
    }
}

extension ListCachePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCachePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListCachePoliciesOutput()
        value.cachePolicyList = try reader.readIfPresent(with: CloudFrontClientTypes.CachePolicyList.read(from:))
        return value
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCloudFrontOriginAccessIdentitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListCloudFrontOriginAccessIdentitiesOutput()
        value.cloudFrontOriginAccessIdentityList = try reader.readIfPresent(with: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList.read(from:))
        return value
    }
}

extension ListConflictingAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConflictingAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListConflictingAliasesOutput()
        value.conflictingAliasesList = try reader.readIfPresent(with: CloudFrontClientTypes.ConflictingAliasesList.read(from:))
        return value
    }
}

extension ListContinuousDeploymentPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContinuousDeploymentPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListContinuousDeploymentPoliciesOutput()
        value.continuousDeploymentPolicyList = try reader.readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentPolicyList.read(from:))
        return value
    }
}

extension ListDistributionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionsOutput()
        value.distributionList = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionList.read(from:))
        return value
    }
}

extension ListDistributionsByCachePolicyIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionsByCachePolicyIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionsByCachePolicyIdOutput()
        value.distributionIdList = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionIdList.read(from:))
        return value
    }
}

extension ListDistributionsByKeyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionsByKeyGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionsByKeyGroupOutput()
        value.distributionIdList = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionIdList.read(from:))
        return value
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionsByOriginRequestPolicyIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionsByOriginRequestPolicyIdOutput()
        value.distributionIdList = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionIdList.read(from:))
        return value
    }
}

extension ListDistributionsByRealtimeLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionsByRealtimeLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionsByRealtimeLogConfigOutput()
        value.distributionList = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionList.read(from:))
        return value
    }
}

extension ListDistributionsByResponseHeadersPolicyIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionsByResponseHeadersPolicyIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionsByResponseHeadersPolicyIdOutput()
        value.distributionIdList = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionIdList.read(from:))
        return value
    }
}

extension ListDistributionsByWebACLIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDistributionsByWebACLIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListDistributionsByWebACLIdOutput()
        value.distributionList = try reader.readIfPresent(with: CloudFrontClientTypes.DistributionList.read(from:))
        return value
    }
}

extension ListFieldLevelEncryptionConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFieldLevelEncryptionConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListFieldLevelEncryptionConfigsOutput()
        value.fieldLevelEncryptionList = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionList.read(from:))
        return value
    }
}

extension ListFieldLevelEncryptionProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFieldLevelEncryptionProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListFieldLevelEncryptionProfilesOutput()
        value.fieldLevelEncryptionProfileList = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionProfileList.read(from:))
        return value
    }
}

extension ListFunctionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionsOutput()
        value.functionList = try reader.readIfPresent(with: CloudFrontClientTypes.FunctionList.read(from:))
        return value
    }
}

extension ListInvalidationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvalidationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvalidationsOutput()
        value.invalidationList = try reader.readIfPresent(with: CloudFrontClientTypes.InvalidationList.read(from:))
        return value
    }
}

extension ListKeyGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKeyGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListKeyGroupsOutput()
        value.keyGroupList = try reader.readIfPresent(with: CloudFrontClientTypes.KeyGroupList.read(from:))
        return value
    }
}

extension ListKeyValueStoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKeyValueStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListKeyValueStoresOutput()
        value.keyValueStoreList = try reader.readIfPresent(with: CloudFrontClientTypes.KeyValueStoreList.read(from:))
        return value
    }
}

extension ListOriginAccessControlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOriginAccessControlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListOriginAccessControlsOutput()
        value.originAccessControlList = try reader.readIfPresent(with: CloudFrontClientTypes.OriginAccessControlList.read(from:))
        return value
    }
}

extension ListOriginRequestPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOriginRequestPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListOriginRequestPoliciesOutput()
        value.originRequestPolicyList = try reader.readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicyList.read(from:))
        return value
    }
}

extension ListPublicKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPublicKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListPublicKeysOutput()
        value.publicKeyList = try reader.readIfPresent(with: CloudFrontClientTypes.PublicKeyList.read(from:))
        return value
    }
}

extension ListRealtimeLogConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRealtimeLogConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListRealtimeLogConfigsOutput()
        value.realtimeLogConfigs = try reader.readIfPresent(with: CloudFrontClientTypes.RealtimeLogConfigs.read(from:))
        return value
    }
}

extension ListResponseHeadersPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResponseHeadersPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListResponseHeadersPoliciesOutput()
        value.responseHeadersPolicyList = try reader.readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyList.read(from:))
        return value
    }
}

extension ListStreamingDistributionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamingDistributionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamingDistributionsOutput()
        value.streamingDistributionList = try reader.readIfPresent(with: CloudFrontClientTypes.StreamingDistributionList.read(from:))
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader.readIfPresent(with: CloudFrontClientTypes.Tags.read(from:))
        return value
    }
}

extension PublishFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = PublishFunctionOutput()
        value.functionSummary = try reader.readIfPresent(with: CloudFrontClientTypes.FunctionSummary.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = TestFunctionOutput()
        value.testResult = try reader.readIfPresent(with: CloudFrontClientTypes.TestResult.read(from:))
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCachePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCachePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCachePolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.cachePolicy = try reader.readIfPresent(with: CloudFrontClientTypes.CachePolicy.read(from:))
        return value
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCloudFrontOriginAccessIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCloudFrontOriginAccessIdentityOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.cloudFrontOriginAccessIdentity = try reader.readIfPresent(with: CloudFrontClientTypes.CloudFrontOriginAccessIdentity.read(from:))
        return value
    }
}

extension UpdateContinuousDeploymentPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContinuousDeploymentPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateContinuousDeploymentPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.continuousDeploymentPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentPolicy.read(from:))
        return value
    }
}

extension UpdateDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDistributionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.distribution = try reader.readIfPresent(with: CloudFrontClientTypes.Distribution.read(from:))
        return value
    }
}

extension UpdateDistributionWithStagingConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDistributionWithStagingConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDistributionWithStagingConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.distribution = try reader.readIfPresent(with: CloudFrontClientTypes.Distribution.read(from:))
        return value
    }
}

extension UpdateFieldLevelEncryptionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFieldLevelEncryptionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFieldLevelEncryptionConfigOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.fieldLevelEncryption = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryption.read(from:))
        return value
    }
}

extension UpdateFieldLevelEncryptionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFieldLevelEncryptionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFieldLevelEncryptionProfileOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.fieldLevelEncryptionProfile = try reader.readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionProfile.read(from:))
        return value
    }
}

extension UpdateFunctionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFunctionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETtag") {
            value.eTag = eTagHeaderValue
        }
        value.functionSummary = try reader.readIfPresent(with: CloudFrontClientTypes.FunctionSummary.read(from:))
        return value
    }
}

extension UpdateKeyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKeyGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKeyGroupOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.keyGroup = try reader.readIfPresent(with: CloudFrontClientTypes.KeyGroup.read(from:))
        return value
    }
}

extension UpdateKeyValueStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKeyValueStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKeyValueStoreOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.keyValueStore = try reader.readIfPresent(with: CloudFrontClientTypes.KeyValueStore.read(from:))
        return value
    }
}

extension UpdateOriginAccessControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOriginAccessControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOriginAccessControlOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.originAccessControl = try reader.readIfPresent(with: CloudFrontClientTypes.OriginAccessControl.read(from:))
        return value
    }
}

extension UpdateOriginRequestPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOriginRequestPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOriginRequestPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.originRequestPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicy.read(from:))
        return value
    }
}

extension UpdatePublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePublicKeyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.publicKey = try reader.readIfPresent(with: CloudFrontClientTypes.PublicKey.read(from:))
        return value
    }
}

extension UpdateRealtimeLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRealtimeLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRealtimeLogConfigOutput()
        value.realtimeLogConfig = try reader["RealtimeLogConfig"].readIfPresent(with: CloudFrontClientTypes.RealtimeLogConfig.read(from:))
        return value
    }
}

extension UpdateResponseHeadersPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResponseHeadersPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResponseHeadersPolicyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.responseHeadersPolicy = try reader.readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicy.read(from:))
        return value
    }
}

extension UpdateStreamingDistributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStreamingDistributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStreamingDistributionOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.streamingDistribution = try reader.readIfPresent(with: CloudFrontClientTypes.StreamingDistribution.read(from:))
        return value
    }
}

enum AssociateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "TooManyDistributionCNAMEs": return try TooManyDistributionCNAMEs.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CopyDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "DistributionAlreadyExists": return try DistributionAlreadyExists.makeError(baseError: baseError)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidDefaultRootObject": return try InvalidDefaultRootObject.makeError(baseError: baseError)
            case "InvalidErrorCode": return try InvalidErrorCode.makeError(baseError: baseError)
            case "InvalidForwardCookies": return try InvalidForwardCookies.makeError(baseError: baseError)
            case "InvalidFunctionAssociation": return try InvalidFunctionAssociation.makeError(baseError: baseError)
            case "InvalidGeoRestrictionParameter": return try InvalidGeoRestrictionParameter.makeError(baseError: baseError)
            case "InvalidHeadersForS3Origin": return try InvalidHeadersForS3Origin.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "InvalidLambdaFunctionAssociation": return try InvalidLambdaFunctionAssociation.makeError(baseError: baseError)
            case "InvalidLocationCode": return try InvalidLocationCode.makeError(baseError: baseError)
            case "InvalidMinimumProtocolVersion": return try InvalidMinimumProtocolVersion.makeError(baseError: baseError)
            case "InvalidOrigin": return try InvalidOrigin.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "InvalidOriginKeepaliveTimeout": return try InvalidOriginKeepaliveTimeout.makeError(baseError: baseError)
            case "InvalidOriginReadTimeout": return try InvalidOriginReadTimeout.makeError(baseError: baseError)
            case "InvalidProtocolSettings": return try InvalidProtocolSettings.makeError(baseError: baseError)
            case "InvalidQueryStringParameters": return try InvalidQueryStringParameters.makeError(baseError: baseError)
            case "InvalidRelativePath": return try InvalidRelativePath.makeError(baseError: baseError)
            case "InvalidRequiredProtocol": return try InvalidRequiredProtocol.makeError(baseError: baseError)
            case "InvalidResponseCode": return try InvalidResponseCode.makeError(baseError: baseError)
            case "InvalidTTLOrder": return try InvalidTTLOrder.makeError(baseError: baseError)
            case "InvalidViewerCertificate": return try InvalidViewerCertificate.makeError(baseError: baseError)
            case "InvalidWebACLId": return try InvalidWebACLId.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "NoSuchOrigin": return try NoSuchOrigin.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "RealtimeLogConfigOwnerMismatch": return try RealtimeLogConfigOwnerMismatch.makeError(baseError: baseError)
            case "TooManyCacheBehaviors": return try TooManyCacheBehaviors.makeError(baseError: baseError)
            case "TooManyCertificates": return try TooManyCertificates.makeError(baseError: baseError)
            case "TooManyCookieNamesInWhiteList": return try TooManyCookieNamesInWhiteList.makeError(baseError: baseError)
            case "TooManyDistributionCNAMEs": return try TooManyDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyDistributions": return try TooManyDistributions.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToCachePolicy": return try TooManyDistributionsAssociatedToCachePolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToKeyGroup": return try TooManyDistributionsAssociatedToKeyGroup.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try TooManyDistributionsAssociatedToOriginAccessControl.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try TooManyDistributionsAssociatedToOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try TooManyDistributionsAssociatedToResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsWithFunctionAssociations": return try TooManyDistributionsWithFunctionAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithLambdaAssociations": return try TooManyDistributionsWithLambdaAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithSingleFunctionARN": return try TooManyDistributionsWithSingleFunctionARN.makeError(baseError: baseError)
            case "TooManyFunctionAssociations": return try TooManyFunctionAssociations.makeError(baseError: baseError)
            case "TooManyHeadersInForwardedValues": return try TooManyHeadersInForwardedValues.makeError(baseError: baseError)
            case "TooManyKeyGroupsAssociatedToDistribution": return try TooManyKeyGroupsAssociatedToDistribution.makeError(baseError: baseError)
            case "TooManyLambdaFunctionAssociations": return try TooManyLambdaFunctionAssociations.makeError(baseError: baseError)
            case "TooManyOriginCustomHeaders": return try TooManyOriginCustomHeaders.makeError(baseError: baseError)
            case "TooManyOriginGroupsPerDistribution": return try TooManyOriginGroupsPerDistribution.makeError(baseError: baseError)
            case "TooManyOrigins": return try TooManyOrigins.makeError(baseError: baseError)
            case "TooManyQueryStringParameters": return try TooManyQueryStringParameters.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedKeyGroupDoesNotExist": return try TrustedKeyGroupDoesNotExist.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCachePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CachePolicyAlreadyExists": return try CachePolicyAlreadyExists.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "TooManyCachePolicies": return try TooManyCachePolicies.makeError(baseError: baseError)
            case "TooManyCookiesInCachePolicy": return try TooManyCookiesInCachePolicy.makeError(baseError: baseError)
            case "TooManyHeadersInCachePolicy": return try TooManyHeadersInCachePolicy.makeError(baseError: baseError)
            case "TooManyQueryStringsInCachePolicy": return try TooManyQueryStringsInCachePolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCloudFrontOriginAccessIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudFrontOriginAccessIdentityAlreadyExists": return try CloudFrontOriginAccessIdentityAlreadyExists.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "TooManyCloudFrontOriginAccessIdentities": return try TooManyCloudFrontOriginAccessIdentities.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContinuousDeploymentPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "ContinuousDeploymentPolicyAlreadyExists": return try ContinuousDeploymentPolicyAlreadyExists.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "StagingDistributionInUse": return try StagingDistributionInUse.makeError(baseError: baseError)
            case "TooManyContinuousDeploymentPolicies": return try TooManyContinuousDeploymentPolicies.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "ContinuousDeploymentPolicyInUse": return try ContinuousDeploymentPolicyInUse.makeError(baseError: baseError)
            case "DistributionAlreadyExists": return try DistributionAlreadyExists.makeError(baseError: baseError)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.makeError(baseError: baseError)
            case "IllegalOriginAccessConfiguration": return try IllegalOriginAccessConfiguration.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidDefaultRootObject": return try InvalidDefaultRootObject.makeError(baseError: baseError)
            case "InvalidDomainNameForOriginAccessControl": return try InvalidDomainNameForOriginAccessControl.makeError(baseError: baseError)
            case "InvalidErrorCode": return try InvalidErrorCode.makeError(baseError: baseError)
            case "InvalidForwardCookies": return try InvalidForwardCookies.makeError(baseError: baseError)
            case "InvalidFunctionAssociation": return try InvalidFunctionAssociation.makeError(baseError: baseError)
            case "InvalidGeoRestrictionParameter": return try InvalidGeoRestrictionParameter.makeError(baseError: baseError)
            case "InvalidHeadersForS3Origin": return try InvalidHeadersForS3Origin.makeError(baseError: baseError)
            case "InvalidLambdaFunctionAssociation": return try InvalidLambdaFunctionAssociation.makeError(baseError: baseError)
            case "InvalidLocationCode": return try InvalidLocationCode.makeError(baseError: baseError)
            case "InvalidMinimumProtocolVersion": return try InvalidMinimumProtocolVersion.makeError(baseError: baseError)
            case "InvalidOrigin": return try InvalidOrigin.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "InvalidOriginKeepaliveTimeout": return try InvalidOriginKeepaliveTimeout.makeError(baseError: baseError)
            case "InvalidOriginReadTimeout": return try InvalidOriginReadTimeout.makeError(baseError: baseError)
            case "InvalidProtocolSettings": return try InvalidProtocolSettings.makeError(baseError: baseError)
            case "InvalidQueryStringParameters": return try InvalidQueryStringParameters.makeError(baseError: baseError)
            case "InvalidRelativePath": return try InvalidRelativePath.makeError(baseError: baseError)
            case "InvalidRequiredProtocol": return try InvalidRequiredProtocol.makeError(baseError: baseError)
            case "InvalidResponseCode": return try InvalidResponseCode.makeError(baseError: baseError)
            case "InvalidTTLOrder": return try InvalidTTLOrder.makeError(baseError: baseError)
            case "InvalidViewerCertificate": return try InvalidViewerCertificate.makeError(baseError: baseError)
            case "InvalidWebACLId": return try InvalidWebACLId.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "NoSuchOrigin": return try NoSuchOrigin.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            case "RealtimeLogConfigOwnerMismatch": return try RealtimeLogConfigOwnerMismatch.makeError(baseError: baseError)
            case "TooManyCacheBehaviors": return try TooManyCacheBehaviors.makeError(baseError: baseError)
            case "TooManyCertificates": return try TooManyCertificates.makeError(baseError: baseError)
            case "TooManyCookieNamesInWhiteList": return try TooManyCookieNamesInWhiteList.makeError(baseError: baseError)
            case "TooManyDistributionCNAMEs": return try TooManyDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyDistributions": return try TooManyDistributions.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToCachePolicy": return try TooManyDistributionsAssociatedToCachePolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToKeyGroup": return try TooManyDistributionsAssociatedToKeyGroup.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try TooManyDistributionsAssociatedToOriginAccessControl.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try TooManyDistributionsAssociatedToOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try TooManyDistributionsAssociatedToResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsWithFunctionAssociations": return try TooManyDistributionsWithFunctionAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithLambdaAssociations": return try TooManyDistributionsWithLambdaAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithSingleFunctionARN": return try TooManyDistributionsWithSingleFunctionARN.makeError(baseError: baseError)
            case "TooManyFunctionAssociations": return try TooManyFunctionAssociations.makeError(baseError: baseError)
            case "TooManyHeadersInForwardedValues": return try TooManyHeadersInForwardedValues.makeError(baseError: baseError)
            case "TooManyKeyGroupsAssociatedToDistribution": return try TooManyKeyGroupsAssociatedToDistribution.makeError(baseError: baseError)
            case "TooManyLambdaFunctionAssociations": return try TooManyLambdaFunctionAssociations.makeError(baseError: baseError)
            case "TooManyOriginCustomHeaders": return try TooManyOriginCustomHeaders.makeError(baseError: baseError)
            case "TooManyOriginGroupsPerDistribution": return try TooManyOriginGroupsPerDistribution.makeError(baseError: baseError)
            case "TooManyOrigins": return try TooManyOrigins.makeError(baseError: baseError)
            case "TooManyQueryStringParameters": return try TooManyQueryStringParameters.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedKeyGroupDoesNotExist": return try TrustedKeyGroupDoesNotExist.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDistributionWithTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "ContinuousDeploymentPolicyInUse": return try ContinuousDeploymentPolicyInUse.makeError(baseError: baseError)
            case "DistributionAlreadyExists": return try DistributionAlreadyExists.makeError(baseError: baseError)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.makeError(baseError: baseError)
            case "IllegalOriginAccessConfiguration": return try IllegalOriginAccessConfiguration.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidDefaultRootObject": return try InvalidDefaultRootObject.makeError(baseError: baseError)
            case "InvalidDomainNameForOriginAccessControl": return try InvalidDomainNameForOriginAccessControl.makeError(baseError: baseError)
            case "InvalidErrorCode": return try InvalidErrorCode.makeError(baseError: baseError)
            case "InvalidForwardCookies": return try InvalidForwardCookies.makeError(baseError: baseError)
            case "InvalidFunctionAssociation": return try InvalidFunctionAssociation.makeError(baseError: baseError)
            case "InvalidGeoRestrictionParameter": return try InvalidGeoRestrictionParameter.makeError(baseError: baseError)
            case "InvalidHeadersForS3Origin": return try InvalidHeadersForS3Origin.makeError(baseError: baseError)
            case "InvalidLambdaFunctionAssociation": return try InvalidLambdaFunctionAssociation.makeError(baseError: baseError)
            case "InvalidLocationCode": return try InvalidLocationCode.makeError(baseError: baseError)
            case "InvalidMinimumProtocolVersion": return try InvalidMinimumProtocolVersion.makeError(baseError: baseError)
            case "InvalidOrigin": return try InvalidOrigin.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "InvalidOriginKeepaliveTimeout": return try InvalidOriginKeepaliveTimeout.makeError(baseError: baseError)
            case "InvalidOriginReadTimeout": return try InvalidOriginReadTimeout.makeError(baseError: baseError)
            case "InvalidProtocolSettings": return try InvalidProtocolSettings.makeError(baseError: baseError)
            case "InvalidQueryStringParameters": return try InvalidQueryStringParameters.makeError(baseError: baseError)
            case "InvalidRelativePath": return try InvalidRelativePath.makeError(baseError: baseError)
            case "InvalidRequiredProtocol": return try InvalidRequiredProtocol.makeError(baseError: baseError)
            case "InvalidResponseCode": return try InvalidResponseCode.makeError(baseError: baseError)
            case "InvalidTagging": return try InvalidTagging.makeError(baseError: baseError)
            case "InvalidTTLOrder": return try InvalidTTLOrder.makeError(baseError: baseError)
            case "InvalidViewerCertificate": return try InvalidViewerCertificate.makeError(baseError: baseError)
            case "InvalidWebACLId": return try InvalidWebACLId.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "NoSuchOrigin": return try NoSuchOrigin.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            case "RealtimeLogConfigOwnerMismatch": return try RealtimeLogConfigOwnerMismatch.makeError(baseError: baseError)
            case "TooManyCacheBehaviors": return try TooManyCacheBehaviors.makeError(baseError: baseError)
            case "TooManyCertificates": return try TooManyCertificates.makeError(baseError: baseError)
            case "TooManyCookieNamesInWhiteList": return try TooManyCookieNamesInWhiteList.makeError(baseError: baseError)
            case "TooManyDistributionCNAMEs": return try TooManyDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyDistributions": return try TooManyDistributions.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToCachePolicy": return try TooManyDistributionsAssociatedToCachePolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToKeyGroup": return try TooManyDistributionsAssociatedToKeyGroup.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try TooManyDistributionsAssociatedToOriginAccessControl.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try TooManyDistributionsAssociatedToOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try TooManyDistributionsAssociatedToResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsWithFunctionAssociations": return try TooManyDistributionsWithFunctionAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithLambdaAssociations": return try TooManyDistributionsWithLambdaAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithSingleFunctionARN": return try TooManyDistributionsWithSingleFunctionARN.makeError(baseError: baseError)
            case "TooManyFunctionAssociations": return try TooManyFunctionAssociations.makeError(baseError: baseError)
            case "TooManyHeadersInForwardedValues": return try TooManyHeadersInForwardedValues.makeError(baseError: baseError)
            case "TooManyKeyGroupsAssociatedToDistribution": return try TooManyKeyGroupsAssociatedToDistribution.makeError(baseError: baseError)
            case "TooManyLambdaFunctionAssociations": return try TooManyLambdaFunctionAssociations.makeError(baseError: baseError)
            case "TooManyOriginCustomHeaders": return try TooManyOriginCustomHeaders.makeError(baseError: baseError)
            case "TooManyOriginGroupsPerDistribution": return try TooManyOriginGroupsPerDistribution.makeError(baseError: baseError)
            case "TooManyOrigins": return try TooManyOrigins.makeError(baseError: baseError)
            case "TooManyQueryStringParameters": return try TooManyQueryStringParameters.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedKeyGroupDoesNotExist": return try TrustedKeyGroupDoesNotExist.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFieldLevelEncryptionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FieldLevelEncryptionConfigAlreadyExists": return try FieldLevelEncryptionConfigAlreadyExists.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionProfile": return try NoSuchFieldLevelEncryptionProfile.makeError(baseError: baseError)
            case "QueryArgProfileEmpty": return try QueryArgProfileEmpty.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionConfigs": return try TooManyFieldLevelEncryptionConfigs.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionContentTypeProfiles": return try TooManyFieldLevelEncryptionContentTypeProfiles.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionQueryArgProfiles": return try TooManyFieldLevelEncryptionQueryArgProfiles.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFieldLevelEncryptionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FieldLevelEncryptionProfileAlreadyExists": return try FieldLevelEncryptionProfileAlreadyExists.makeError(baseError: baseError)
            case "FieldLevelEncryptionProfileSizeExceeded": return try FieldLevelEncryptionProfileSizeExceeded.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchPublicKey": return try NoSuchPublicKey.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionEncryptionEntities": return try TooManyFieldLevelEncryptionEncryptionEntities.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionFieldPatterns": return try TooManyFieldLevelEncryptionFieldPatterns.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionProfiles": return try TooManyFieldLevelEncryptionProfiles.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FunctionAlreadyExists": return try FunctionAlreadyExists.makeError(baseError: baseError)
            case "FunctionSizeLimitExceeded": return try FunctionSizeLimitExceeded.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "TooManyFunctions": return try TooManyFunctions.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInvalidationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "BatchTooLarge": return try BatchTooLarge.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "TooManyInvalidationsInProgress": return try TooManyInvalidationsInProgress.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKeyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "KeyGroupAlreadyExists": return try KeyGroupAlreadyExists.makeError(baseError: baseError)
            case "TooManyKeyGroups": return try TooManyKeyGroups.makeError(baseError: baseError)
            case "TooManyPublicKeysInKeyGroup": return try TooManyPublicKeysInKeyGroup.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKeyValueStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "EntityAlreadyExists": return try EntityAlreadyExists.makeError(baseError: baseError)
            case "EntityLimitExceeded": return try EntityLimitExceeded.makeError(baseError: baseError)
            case "EntitySizeLimitExceeded": return try EntitySizeLimitExceeded.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMonitoringSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "MonitoringSubscriptionAlreadyExists": return try MonitoringSubscriptionAlreadyExists.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOriginAccessControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "OriginAccessControlAlreadyExists": return try OriginAccessControlAlreadyExists.makeError(baseError: baseError)
            case "TooManyOriginAccessControls": return try TooManyOriginAccessControls.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOriginRequestPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "OriginRequestPolicyAlreadyExists": return try OriginRequestPolicyAlreadyExists.makeError(baseError: baseError)
            case "TooManyCookiesInOriginRequestPolicy": return try TooManyCookiesInOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyHeadersInOriginRequestPolicy": return try TooManyHeadersInOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyOriginRequestPolicies": return try TooManyOriginRequestPolicies.makeError(baseError: baseError)
            case "TooManyQueryStringsInOriginRequestPolicy": return try TooManyQueryStringsInOriginRequestPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "PublicKeyAlreadyExists": return try PublicKeyAlreadyExists.makeError(baseError: baseError)
            case "TooManyPublicKeys": return try TooManyPublicKeys.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRealtimeLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "RealtimeLogConfigAlreadyExists": return try RealtimeLogConfigAlreadyExists.makeError(baseError: baseError)
            case "TooManyRealtimeLogConfigs": return try TooManyRealtimeLogConfigs.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResponseHeadersPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "ResponseHeadersPolicyAlreadyExists": return try ResponseHeadersPolicyAlreadyExists.makeError(baseError: baseError)
            case "TooLongCSPInResponseHeadersPolicy": return try TooLongCSPInResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyCustomHeadersInResponseHeadersPolicy": return try TooManyCustomHeadersInResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyRemoveHeadersInResponseHeadersPolicy": return try TooManyRemoveHeadersInResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyResponseHeadersPolicies": return try TooManyResponseHeadersPolicies.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamingDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidOrigin": return try InvalidOrigin.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "StreamingDistributionAlreadyExists": return try StreamingDistributionAlreadyExists.makeError(baseError: baseError)
            case "TooManyStreamingDistributionCNAMEs": return try TooManyStreamingDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyStreamingDistributions": return try TooManyStreamingDistributions.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamingDistributionWithTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidOrigin": return try InvalidOrigin.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "InvalidTagging": return try InvalidTagging.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "StreamingDistributionAlreadyExists": return try StreamingDistributionAlreadyExists.makeError(baseError: baseError)
            case "TooManyStreamingDistributionCNAMEs": return try TooManyStreamingDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyStreamingDistributions": return try TooManyStreamingDistributions.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCachePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CachePolicyInUse": return try CachePolicyInUse.makeError(baseError: baseError)
            case "IllegalDelete": return try IllegalDelete.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCloudFrontOriginAccessIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CloudFrontOriginAccessIdentityInUse": return try CloudFrontOriginAccessIdentityInUse.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchCloudFrontOriginAccessIdentity": return try NoSuchCloudFrontOriginAccessIdentity.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContinuousDeploymentPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "ContinuousDeploymentPolicyInUse": return try ContinuousDeploymentPolicyInUse.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "DistributionNotDisabled": return try DistributionNotDisabled.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFieldLevelEncryptionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "FieldLevelEncryptionConfigInUse": return try FieldLevelEncryptionConfigInUse.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFieldLevelEncryptionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "FieldLevelEncryptionProfileInUse": return try FieldLevelEncryptionProfileInUse.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionProfile": return try NoSuchFieldLevelEncryptionProfile.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FunctionInUse": return try FunctionInUse.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFunctionExists": return try NoSuchFunctionExists.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKeyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKeyValueStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CannotDeleteEntityWhileInUse": return try CannotDeleteEntityWhileInUse.makeError(baseError: baseError)
            case "EntityNotFound": return try EntityNotFound.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMonitoringSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "NoSuchMonitoringSubscription": return try NoSuchMonitoringSubscription.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOriginAccessControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchOriginAccessControl": return try NoSuchOriginAccessControl.makeError(baseError: baseError)
            case "OriginAccessControlInUse": return try OriginAccessControlInUse.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOriginRequestPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalDelete": return try IllegalDelete.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            case "OriginRequestPolicyInUse": return try OriginRequestPolicyInUse.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchPublicKey": return try NoSuchPublicKey.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "PublicKeyInUse": return try PublicKeyInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRealtimeLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            case "RealtimeLogConfigInUse": return try RealtimeLogConfigInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResponseHeadersPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalDelete": return try IllegalDelete.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "ResponseHeadersPolicyInUse": return try ResponseHeadersPolicyInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStreamingDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchStreamingDistribution": return try NoSuchStreamingDistribution.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "StreamingDistributionNotDisabled": return try StreamingDistributionNotDisabled.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchFunctionExists": return try NoSuchFunctionExists.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeKeyValueStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "EntityNotFound": return try EntityNotFound.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCachePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCachePolicyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudFrontOriginAccessIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchCloudFrontOriginAccessIdentity": return try NoSuchCloudFrontOriginAccessIdentity.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudFrontOriginAccessIdentityConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchCloudFrontOriginAccessIdentity": return try NoSuchCloudFrontOriginAccessIdentity.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContinuousDeploymentPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContinuousDeploymentPolicyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDistributionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFieldLevelEncryptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFieldLevelEncryptionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFieldLevelEncryptionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionProfile": return try NoSuchFieldLevelEncryptionProfile.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFieldLevelEncryptionProfileConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionProfile": return try NoSuchFieldLevelEncryptionProfile.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchFunctionExists": return try NoSuchFunctionExists.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvalidationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "NoSuchInvalidation": return try NoSuchInvalidation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKeyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKeyGroupConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMonitoringSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "NoSuchMonitoringSubscription": return try NoSuchMonitoringSubscription.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOriginAccessControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchOriginAccessControl": return try NoSuchOriginAccessControl.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOriginAccessControlConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchOriginAccessControl": return try NoSuchOriginAccessControl.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOriginRequestPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOriginRequestPolicyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchPublicKey": return try NoSuchPublicKey.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPublicKeyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchPublicKey": return try NoSuchPublicKey.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRealtimeLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResponseHeadersPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResponseHeadersPolicyConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamingDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchStreamingDistribution": return try NoSuchStreamingDistribution.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamingDistributionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "NoSuchStreamingDistribution": return try NoSuchStreamingDistribution.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCachePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCloudFrontOriginAccessIdentitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConflictingAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContinuousDeploymentPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionsByCachePolicyIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionsByKeyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionsByOriginRequestPolicyIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionsByRealtimeLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionsByResponseHeadersPolicyIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDistributionsByWebACLIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidWebACLId": return try InvalidWebACLId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFieldLevelEncryptionConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFieldLevelEncryptionProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvalidationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKeyGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKeyValueStoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOriginAccessControlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOriginRequestPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPublicKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRealtimeLogConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResponseHeadersPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamingDistributionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidTagging": return try InvalidTagging.makeError(baseError: baseError)
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFunctionExists": return try NoSuchFunctionExists.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidTagging": return try InvalidTagging.makeError(baseError: baseError)
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFunctionExists": return try NoSuchFunctionExists.makeError(baseError: baseError)
            case "TestFunctionFailed": return try TestFunctionFailed.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidTagging": return try InvalidTagging.makeError(baseError: baseError)
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCachePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CachePolicyAlreadyExists": return try CachePolicyAlreadyExists.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "TooManyCookiesInCachePolicy": return try TooManyCookiesInCachePolicy.makeError(baseError: baseError)
            case "TooManyHeadersInCachePolicy": return try TooManyHeadersInCachePolicy.makeError(baseError: baseError)
            case "TooManyQueryStringsInCachePolicy": return try TooManyQueryStringsInCachePolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCloudFrontOriginAccessIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchCloudFrontOriginAccessIdentity": return try NoSuchCloudFrontOriginAccessIdentity.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContinuousDeploymentPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "StagingDistributionInUse": return try StagingDistributionInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "ContinuousDeploymentPolicyInUse": return try ContinuousDeploymentPolicyInUse.makeError(baseError: baseError)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.makeError(baseError: baseError)
            case "IllegalOriginAccessConfiguration": return try IllegalOriginAccessConfiguration.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidDefaultRootObject": return try InvalidDefaultRootObject.makeError(baseError: baseError)
            case "InvalidDomainNameForOriginAccessControl": return try InvalidDomainNameForOriginAccessControl.makeError(baseError: baseError)
            case "InvalidErrorCode": return try InvalidErrorCode.makeError(baseError: baseError)
            case "InvalidForwardCookies": return try InvalidForwardCookies.makeError(baseError: baseError)
            case "InvalidFunctionAssociation": return try InvalidFunctionAssociation.makeError(baseError: baseError)
            case "InvalidGeoRestrictionParameter": return try InvalidGeoRestrictionParameter.makeError(baseError: baseError)
            case "InvalidHeadersForS3Origin": return try InvalidHeadersForS3Origin.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "InvalidLambdaFunctionAssociation": return try InvalidLambdaFunctionAssociation.makeError(baseError: baseError)
            case "InvalidLocationCode": return try InvalidLocationCode.makeError(baseError: baseError)
            case "InvalidMinimumProtocolVersion": return try InvalidMinimumProtocolVersion.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "InvalidOriginKeepaliveTimeout": return try InvalidOriginKeepaliveTimeout.makeError(baseError: baseError)
            case "InvalidOriginReadTimeout": return try InvalidOriginReadTimeout.makeError(baseError: baseError)
            case "InvalidQueryStringParameters": return try InvalidQueryStringParameters.makeError(baseError: baseError)
            case "InvalidRelativePath": return try InvalidRelativePath.makeError(baseError: baseError)
            case "InvalidRequiredProtocol": return try InvalidRequiredProtocol.makeError(baseError: baseError)
            case "InvalidResponseCode": return try InvalidResponseCode.makeError(baseError: baseError)
            case "InvalidTTLOrder": return try InvalidTTLOrder.makeError(baseError: baseError)
            case "InvalidViewerCertificate": return try InvalidViewerCertificate.makeError(baseError: baseError)
            case "InvalidWebACLId": return try InvalidWebACLId.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            case "NoSuchContinuousDeploymentPolicy": return try NoSuchContinuousDeploymentPolicy.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "NoSuchOrigin": return try NoSuchOrigin.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "RealtimeLogConfigOwnerMismatch": return try RealtimeLogConfigOwnerMismatch.makeError(baseError: baseError)
            case "StagingDistributionInUse": return try StagingDistributionInUse.makeError(baseError: baseError)
            case "TooManyCacheBehaviors": return try TooManyCacheBehaviors.makeError(baseError: baseError)
            case "TooManyCertificates": return try TooManyCertificates.makeError(baseError: baseError)
            case "TooManyCookieNamesInWhiteList": return try TooManyCookieNamesInWhiteList.makeError(baseError: baseError)
            case "TooManyDistributionCNAMEs": return try TooManyDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToCachePolicy": return try TooManyDistributionsAssociatedToCachePolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToKeyGroup": return try TooManyDistributionsAssociatedToKeyGroup.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try TooManyDistributionsAssociatedToOriginAccessControl.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try TooManyDistributionsAssociatedToOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try TooManyDistributionsAssociatedToResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsWithFunctionAssociations": return try TooManyDistributionsWithFunctionAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithLambdaAssociations": return try TooManyDistributionsWithLambdaAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithSingleFunctionARN": return try TooManyDistributionsWithSingleFunctionARN.makeError(baseError: baseError)
            case "TooManyFunctionAssociations": return try TooManyFunctionAssociations.makeError(baseError: baseError)
            case "TooManyHeadersInForwardedValues": return try TooManyHeadersInForwardedValues.makeError(baseError: baseError)
            case "TooManyKeyGroupsAssociatedToDistribution": return try TooManyKeyGroupsAssociatedToDistribution.makeError(baseError: baseError)
            case "TooManyLambdaFunctionAssociations": return try TooManyLambdaFunctionAssociations.makeError(baseError: baseError)
            case "TooManyOriginCustomHeaders": return try TooManyOriginCustomHeaders.makeError(baseError: baseError)
            case "TooManyOriginGroupsPerDistribution": return try TooManyOriginGroupsPerDistribution.makeError(baseError: baseError)
            case "TooManyOrigins": return try TooManyOrigins.makeError(baseError: baseError)
            case "TooManyQueryStringParameters": return try TooManyQueryStringParameters.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedKeyGroupDoesNotExist": return try TrustedKeyGroupDoesNotExist.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDistributionWithStagingConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidDefaultRootObject": return try InvalidDefaultRootObject.makeError(baseError: baseError)
            case "InvalidErrorCode": return try InvalidErrorCode.makeError(baseError: baseError)
            case "InvalidForwardCookies": return try InvalidForwardCookies.makeError(baseError: baseError)
            case "InvalidFunctionAssociation": return try InvalidFunctionAssociation.makeError(baseError: baseError)
            case "InvalidGeoRestrictionParameter": return try InvalidGeoRestrictionParameter.makeError(baseError: baseError)
            case "InvalidHeadersForS3Origin": return try InvalidHeadersForS3Origin.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "InvalidLambdaFunctionAssociation": return try InvalidLambdaFunctionAssociation.makeError(baseError: baseError)
            case "InvalidLocationCode": return try InvalidLocationCode.makeError(baseError: baseError)
            case "InvalidMinimumProtocolVersion": return try InvalidMinimumProtocolVersion.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "InvalidOriginKeepaliveTimeout": return try InvalidOriginKeepaliveTimeout.makeError(baseError: baseError)
            case "InvalidOriginReadTimeout": return try InvalidOriginReadTimeout.makeError(baseError: baseError)
            case "InvalidQueryStringParameters": return try InvalidQueryStringParameters.makeError(baseError: baseError)
            case "InvalidRelativePath": return try InvalidRelativePath.makeError(baseError: baseError)
            case "InvalidRequiredProtocol": return try InvalidRequiredProtocol.makeError(baseError: baseError)
            case "InvalidResponseCode": return try InvalidResponseCode.makeError(baseError: baseError)
            case "InvalidTTLOrder": return try InvalidTTLOrder.makeError(baseError: baseError)
            case "InvalidViewerCertificate": return try InvalidViewerCertificate.makeError(baseError: baseError)
            case "InvalidWebACLId": return try InvalidWebACLId.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchCachePolicy": return try NoSuchCachePolicy.makeError(baseError: baseError)
            case "NoSuchDistribution": return try NoSuchDistribution.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "NoSuchOrigin": return try NoSuchOrigin.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "RealtimeLogConfigOwnerMismatch": return try RealtimeLogConfigOwnerMismatch.makeError(baseError: baseError)
            case "TooManyCacheBehaviors": return try TooManyCacheBehaviors.makeError(baseError: baseError)
            case "TooManyCertificates": return try TooManyCertificates.makeError(baseError: baseError)
            case "TooManyCookieNamesInWhiteList": return try TooManyCookieNamesInWhiteList.makeError(baseError: baseError)
            case "TooManyDistributionCNAMEs": return try TooManyDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToCachePolicy": return try TooManyDistributionsAssociatedToCachePolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToKeyGroup": return try TooManyDistributionsAssociatedToKeyGroup.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try TooManyDistributionsAssociatedToOriginAccessControl.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try TooManyDistributionsAssociatedToOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try TooManyDistributionsAssociatedToResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyDistributionsWithFunctionAssociations": return try TooManyDistributionsWithFunctionAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithLambdaAssociations": return try TooManyDistributionsWithLambdaAssociations.makeError(baseError: baseError)
            case "TooManyDistributionsWithSingleFunctionARN": return try TooManyDistributionsWithSingleFunctionARN.makeError(baseError: baseError)
            case "TooManyFunctionAssociations": return try TooManyFunctionAssociations.makeError(baseError: baseError)
            case "TooManyHeadersInForwardedValues": return try TooManyHeadersInForwardedValues.makeError(baseError: baseError)
            case "TooManyKeyGroupsAssociatedToDistribution": return try TooManyKeyGroupsAssociatedToDistribution.makeError(baseError: baseError)
            case "TooManyLambdaFunctionAssociations": return try TooManyLambdaFunctionAssociations.makeError(baseError: baseError)
            case "TooManyOriginCustomHeaders": return try TooManyOriginCustomHeaders.makeError(baseError: baseError)
            case "TooManyOriginGroupsPerDistribution": return try TooManyOriginGroupsPerDistribution.makeError(baseError: baseError)
            case "TooManyOrigins": return try TooManyOrigins.makeError(baseError: baseError)
            case "TooManyQueryStringParameters": return try TooManyQueryStringParameters.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedKeyGroupDoesNotExist": return try TrustedKeyGroupDoesNotExist.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFieldLevelEncryptionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionConfig": return try NoSuchFieldLevelEncryptionConfig.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionProfile": return try NoSuchFieldLevelEncryptionProfile.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "QueryArgProfileEmpty": return try QueryArgProfileEmpty.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionContentTypeProfiles": return try TooManyFieldLevelEncryptionContentTypeProfiles.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionQueryArgProfiles": return try TooManyFieldLevelEncryptionQueryArgProfiles.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFieldLevelEncryptionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "FieldLevelEncryptionProfileAlreadyExists": return try FieldLevelEncryptionProfileAlreadyExists.makeError(baseError: baseError)
            case "FieldLevelEncryptionProfileSizeExceeded": return try FieldLevelEncryptionProfileSizeExceeded.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFieldLevelEncryptionProfile": return try NoSuchFieldLevelEncryptionProfile.makeError(baseError: baseError)
            case "NoSuchPublicKey": return try NoSuchPublicKey.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionEncryptionEntities": return try TooManyFieldLevelEncryptionEncryptionEntities.makeError(baseError: baseError)
            case "TooManyFieldLevelEncryptionFieldPatterns": return try TooManyFieldLevelEncryptionFieldPatterns.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FunctionSizeLimitExceeded": return try FunctionSizeLimitExceeded.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchFunctionExists": return try NoSuchFunctionExists.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKeyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "KeyGroupAlreadyExists": return try KeyGroupAlreadyExists.makeError(baseError: baseError)
            case "NoSuchResource": return try NoSuchResource.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "TooManyPublicKeysInKeyGroup": return try TooManyPublicKeysInKeyGroup.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKeyValueStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "EntityNotFound": return try EntityNotFound.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOriginAccessControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchOriginAccessControl": return try NoSuchOriginAccessControl.makeError(baseError: baseError)
            case "OriginAccessControlAlreadyExists": return try OriginAccessControlAlreadyExists.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOriginRequestPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchOriginRequestPolicy": return try NoSuchOriginRequestPolicy.makeError(baseError: baseError)
            case "OriginRequestPolicyAlreadyExists": return try OriginRequestPolicyAlreadyExists.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "TooManyCookiesInOriginRequestPolicy": return try TooManyCookiesInOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyHeadersInOriginRequestPolicy": return try TooManyHeadersInOriginRequestPolicy.makeError(baseError: baseError)
            case "TooManyQueryStringsInOriginRequestPolicy": return try TooManyQueryStringsInOriginRequestPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CannotChangeImmutablePublicKeyFields": return try CannotChangeImmutablePublicKeyFields.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchPublicKey": return try NoSuchPublicKey.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRealtimeLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "NoSuchRealtimeLogConfig": return try NoSuchRealtimeLogConfig.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResponseHeadersPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "NoSuchResponseHeadersPolicy": return try NoSuchResponseHeadersPolicy.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "ResponseHeadersPolicyAlreadyExists": return try ResponseHeadersPolicyAlreadyExists.makeError(baseError: baseError)
            case "TooLongCSPInResponseHeadersPolicy": return try TooLongCSPInResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyCustomHeadersInResponseHeadersPolicy": return try TooManyCustomHeadersInResponseHeadersPolicy.makeError(baseError: baseError)
            case "TooManyRemoveHeadersInResponseHeadersPolicy": return try TooManyRemoveHeadersInResponseHeadersPolicy.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStreamingDistributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDenied.makeError(baseError: baseError)
            case "CNAMEAlreadyExists": return try CNAMEAlreadyExists.makeError(baseError: baseError)
            case "IllegalUpdate": return try IllegalUpdate.makeError(baseError: baseError)
            case "InconsistentQuantities": return try InconsistentQuantities.makeError(baseError: baseError)
            case "InvalidArgument": return try InvalidArgument.makeError(baseError: baseError)
            case "InvalidIfMatchVersion": return try InvalidIfMatchVersion.makeError(baseError: baseError)
            case "InvalidOriginAccessControl": return try InvalidOriginAccessControl.makeError(baseError: baseError)
            case "InvalidOriginAccessIdentity": return try InvalidOriginAccessIdentity.makeError(baseError: baseError)
            case "MissingBody": return try MissingBody.makeError(baseError: baseError)
            case "NoSuchStreamingDistribution": return try NoSuchStreamingDistribution.makeError(baseError: baseError)
            case "PreconditionFailed": return try PreconditionFailed.makeError(baseError: baseError)
            case "TooManyStreamingDistributionCNAMEs": return try TooManyStreamingDistributionCNAMEs.makeError(baseError: baseError)
            case "TooManyTrustedSigners": return try TooManyTrustedSigners.makeError(baseError: baseError)
            case "TrustedSignerDoesNotExist": return try TrustedSignerDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDenied {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> AccessDenied {
        let reader = baseError.errorBodyReader
        var value = AccessDenied()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalUpdate {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> IllegalUpdate {
        let reader = baseError.errorBodyReader
        var value = IllegalUpdate()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchDistribution {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchDistribution {
        let reader = baseError.errorBodyReader
        var value = NoSuchDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArgument {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidArgument {
        let reader = baseError.errorBodyReader
        var value = InvalidArgument()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionCNAMEs {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionCNAMEs {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionCNAMEs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsAssociatedToOriginRequestPolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsAssociatedToOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRelativePath {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidRelativePath {
        let reader = baseError.errorBodyReader
        var value = InvalidRelativePath()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyQueryStringParameters {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyQueryStringParameters {
        let reader = baseError.errorBodyReader
        var value = TooManyQueryStringParameters()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOriginAccessControl {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidOriginAccessControl {
        let reader = baseError.errorBodyReader
        var value = InvalidOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyLambdaFunctionAssociations {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyLambdaFunctionAssociations {
        let reader = baseError.errorBodyReader
        var value = TooManyLambdaFunctionAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InconsistentQuantities {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InconsistentQuantities {
        let reader = baseError.errorBodyReader
        var value = InconsistentQuantities()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidWebACLId {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidWebACLId {
        let reader = baseError.errorBodyReader
        var value = InvalidWebACLId()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTTLOrder {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidTTLOrder {
        let reader = baseError.errorBodyReader
        var value = InvalidTTLOrder()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributions {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributions {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributions()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsWithFunctionAssociations {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsWithFunctionAssociations {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsWithFunctionAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyHeadersInForwardedValues {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyHeadersInForwardedValues {
        let reader = baseError.errorBodyReader
        var value = TooManyHeadersInForwardedValues()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidIfMatchVersion {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidIfMatchVersion {
        let reader = baseError.errorBodyReader
        var value = InvalidIfMatchVersion()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsAssociatedToFieldLevelEncryptionConfig()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOriginAccessIdentity {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidOriginAccessIdentity {
        let reader = baseError.errorBodyReader
        var value = InvalidOriginAccessIdentity()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailed {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> PreconditionFailed {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailed()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DistributionAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> DistributionAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = DistributionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RealtimeLogConfigOwnerMismatch {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> RealtimeLogConfigOwnerMismatch {
        let reader = baseError.errorBodyReader
        var value = RealtimeLogConfigOwnerMismatch()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCacheBehaviors {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCacheBehaviors {
        let reader = baseError.errorBodyReader
        var value = TooManyCacheBehaviors()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchOrigin {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchOrigin {
        let reader = baseError.errorBodyReader
        var value = NoSuchOrigin()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsAssociatedToCachePolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsAssociatedToCachePolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsAssociatedToCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidViewerCertificate {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidViewerCertificate {
        let reader = baseError.errorBodyReader
        var value = InvalidViewerCertificate()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFunctionAssociation {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidFunctionAssociation {
        let reader = baseError.errorBodyReader
        var value = InvalidFunctionAssociation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchResponseHeadersPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchResponseHeadersPolicy {
        let reader = baseError.errorBodyReader
        var value = NoSuchResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDefaultRootObject {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidDefaultRootObject {
        let reader = baseError.errorBodyReader
        var value = InvalidDefaultRootObject()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchCachePolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchCachePolicy {
        let reader = baseError.errorBodyReader
        var value = NoSuchCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidProtocolSettings {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidProtocolSettings {
        let reader = baseError.errorBodyReader
        var value = InvalidProtocolSettings()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidMinimumProtocolVersion {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidMinimumProtocolVersion {
        let reader = baseError.errorBodyReader
        var value = InvalidMinimumProtocolVersion()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidLambdaFunctionAssociation {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidLambdaFunctionAssociation {
        let reader = baseError.errorBodyReader
        var value = InvalidLambdaFunctionAssociation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResponseCode {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidResponseCode {
        let reader = baseError.errorBodyReader
        var value = InvalidResponseCode()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchOriginRequestPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchOriginRequestPolicy {
        let reader = baseError.errorBodyReader
        var value = NoSuchOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchFieldLevelEncryptionConfig {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchFieldLevelEncryptionConfig {
        let reader = baseError.errorBodyReader
        var value = NoSuchFieldLevelEncryptionConfig()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidHeadersForS3Origin {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidHeadersForS3Origin {
        let reader = baseError.errorBodyReader
        var value = InvalidHeadersForS3Origin()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TrustedSignerDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TrustedSignerDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = TrustedSignerDoesNotExist()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCookieNamesInWhiteList {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCookieNamesInWhiteList {
        let reader = baseError.errorBodyReader
        var value = TooManyCookieNamesInWhiteList()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsAssociatedToKeyGroup {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsAssociatedToKeyGroup {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsAssociatedToKeyGroup()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsAssociatedToOriginAccessControl {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsAssociatedToOriginAccessControl {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsAssociatedToOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyOrigins {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyOrigins {
        let reader = baseError.errorBodyReader
        var value = TooManyOrigins()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTrustedSigners {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyTrustedSigners {
        let reader = baseError.errorBodyReader
        var value = TooManyTrustedSigners()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsWithSingleFunctionARN {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsWithSingleFunctionARN {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsWithSingleFunctionARN()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MissingBody {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> MissingBody {
        let reader = baseError.errorBodyReader
        var value = MissingBody()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidGeoRestrictionParameter {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidGeoRestrictionParameter {
        let reader = baseError.errorBodyReader
        var value = InvalidGeoRestrictionParameter()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchRealtimeLogConfig {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchRealtimeLogConfig {
        let reader = baseError.errorBodyReader
        var value = NoSuchRealtimeLogConfig()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOriginReadTimeout {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidOriginReadTimeout {
        let reader = baseError.errorBodyReader
        var value = InvalidOriginReadTimeout()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCertificates {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCertificates {
        let reader = baseError.errorBodyReader
        var value = TooManyCertificates()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidLocationCode {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidLocationCode {
        let reader = baseError.errorBodyReader
        var value = InvalidLocationCode()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidQueryStringParameters {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidQueryStringParameters {
        let reader = baseError.errorBodyReader
        var value = InvalidQueryStringParameters()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CNAMEAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> CNAMEAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = CNAMEAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
        let reader = baseError.errorBodyReader
        var value = IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidErrorCode {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidErrorCode {
        let reader = baseError.errorBodyReader
        var value = InvalidErrorCode()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyKeyGroupsAssociatedToDistribution {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyKeyGroupsAssociatedToDistribution {
        let reader = baseError.errorBodyReader
        var value = TooManyKeyGroupsAssociatedToDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsWithLambdaAssociations {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsWithLambdaAssociations {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsWithLambdaAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyOriginCustomHeaders {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyOriginCustomHeaders {
        let reader = baseError.errorBodyReader
        var value = TooManyOriginCustomHeaders()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TrustedKeyGroupDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TrustedKeyGroupDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = TrustedKeyGroupDoesNotExist()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOriginKeepaliveTimeout {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidOriginKeepaliveTimeout {
        let reader = baseError.errorBodyReader
        var value = InvalidOriginKeepaliveTimeout()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidForwardCookies {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidForwardCookies {
        let reader = baseError.errorBodyReader
        var value = InvalidForwardCookies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOrigin {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidOrigin {
        let reader = baseError.errorBodyReader
        var value = InvalidOrigin()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyDistributionsAssociatedToResponseHeadersPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyDistributionsAssociatedToResponseHeadersPolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyDistributionsAssociatedToResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyOriginGroupsPerDistribution {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyOriginGroupsPerDistribution {
        let reader = baseError.errorBodyReader
        var value = TooManyOriginGroupsPerDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequiredProtocol {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidRequiredProtocol {
        let reader = baseError.errorBodyReader
        var value = InvalidRequiredProtocol()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFunctionAssociations {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFunctionAssociations {
        let reader = baseError.errorBodyReader
        var value = TooManyFunctionAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCookiesInCachePolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCookiesInCachePolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyCookiesInCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyHeadersInCachePolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyHeadersInCachePolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyHeadersInCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCachePolicies {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCachePolicies {
        let reader = baseError.errorBodyReader
        var value = TooManyCachePolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyQueryStringsInCachePolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyQueryStringsInCachePolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyQueryStringsInCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CachePolicyAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> CachePolicyAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = CachePolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudFrontOriginAccessIdentityAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> CloudFrontOriginAccessIdentityAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = CloudFrontOriginAccessIdentityAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCloudFrontOriginAccessIdentities {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCloudFrontOriginAccessIdentities {
        let reader = baseError.errorBodyReader
        var value = TooManyCloudFrontOriginAccessIdentities()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyContinuousDeploymentPolicies {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyContinuousDeploymentPolicies {
        let reader = baseError.errorBodyReader
        var value = TooManyContinuousDeploymentPolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StagingDistributionInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> StagingDistributionInUse {
        let reader = baseError.errorBodyReader
        var value = StagingDistributionInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContinuousDeploymentPolicyAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> ContinuousDeploymentPolicyAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = ContinuousDeploymentPolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchContinuousDeploymentPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchContinuousDeploymentPolicy {
        let reader = baseError.errorBodyReader
        var value = NoSuchContinuousDeploymentPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ContinuousDeploymentPolicyInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> ContinuousDeploymentPolicyInUse {
        let reader = baseError.errorBodyReader
        var value = ContinuousDeploymentPolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalOriginAccessConfiguration {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> IllegalOriginAccessConfiguration {
        let reader = baseError.errorBodyReader
        var value = IllegalOriginAccessConfiguration()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDomainNameForOriginAccessControl {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidDomainNameForOriginAccessControl {
        let reader = baseError.errorBodyReader
        var value = InvalidDomainNameForOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTagging {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> InvalidTagging {
        let reader = baseError.errorBodyReader
        var value = InvalidTagging()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryArgProfileEmpty {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> QueryArgProfileEmpty {
        let reader = baseError.errorBodyReader
        var value = QueryArgProfileEmpty()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FieldLevelEncryptionConfigAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FieldLevelEncryptionConfigAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = FieldLevelEncryptionConfigAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFieldLevelEncryptionContentTypeProfiles {
        let reader = baseError.errorBodyReader
        var value = TooManyFieldLevelEncryptionContentTypeProfiles()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchFieldLevelEncryptionProfile {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchFieldLevelEncryptionProfile {
        let reader = baseError.errorBodyReader
        var value = NoSuchFieldLevelEncryptionProfile()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFieldLevelEncryptionConfigs {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFieldLevelEncryptionConfigs {
        let reader = baseError.errorBodyReader
        var value = TooManyFieldLevelEncryptionConfigs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFieldLevelEncryptionQueryArgProfiles {
        let reader = baseError.errorBodyReader
        var value = TooManyFieldLevelEncryptionQueryArgProfiles()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FieldLevelEncryptionProfileAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FieldLevelEncryptionProfileAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = FieldLevelEncryptionProfileAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFieldLevelEncryptionFieldPatterns {
        let reader = baseError.errorBodyReader
        var value = TooManyFieldLevelEncryptionFieldPatterns()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchPublicKey {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchPublicKey {
        let reader = baseError.errorBodyReader
        var value = NoSuchPublicKey()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFieldLevelEncryptionEncryptionEntities {
        let reader = baseError.errorBodyReader
        var value = TooManyFieldLevelEncryptionEncryptionEntities()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFieldLevelEncryptionProfiles {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFieldLevelEncryptionProfiles {
        let reader = baseError.errorBodyReader
        var value = TooManyFieldLevelEncryptionProfiles()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FieldLevelEncryptionProfileSizeExceeded {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FieldLevelEncryptionProfileSizeExceeded {
        let reader = baseError.errorBodyReader
        var value = FieldLevelEncryptionProfileSizeExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperation {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> UnsupportedOperation {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyFunctions {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyFunctions {
        let reader = baseError.errorBodyReader
        var value = TooManyFunctions()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FunctionAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FunctionAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = FunctionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FunctionSizeLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FunctionSizeLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = FunctionSizeLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyInvalidationsInProgress {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyInvalidationsInProgress {
        let reader = baseError.errorBodyReader
        var value = TooManyInvalidationsInProgress()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BatchTooLarge {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> BatchTooLarge {
        let reader = baseError.errorBodyReader
        var value = BatchTooLarge()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KeyGroupAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> KeyGroupAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = KeyGroupAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyKeyGroups {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyKeyGroups {
        let reader = baseError.errorBodyReader
        var value = TooManyKeyGroups()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyPublicKeysInKeyGroup {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyPublicKeysInKeyGroup {
        let reader = baseError.errorBodyReader
        var value = TooManyPublicKeysInKeyGroup()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> EntityLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = EntityLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntitySizeLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> EntitySizeLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = EntitySizeLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> EntityAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = EntityAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MonitoringSubscriptionAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> MonitoringSubscriptionAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = MonitoringSubscriptionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyOriginAccessControls {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyOriginAccessControls {
        let reader = baseError.errorBodyReader
        var value = TooManyOriginAccessControls()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OriginAccessControlAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> OriginAccessControlAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = OriginAccessControlAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyHeadersInOriginRequestPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyHeadersInOriginRequestPolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyHeadersInOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyOriginRequestPolicies {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyOriginRequestPolicies {
        let reader = baseError.errorBodyReader
        var value = TooManyOriginRequestPolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyQueryStringsInOriginRequestPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyQueryStringsInOriginRequestPolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyQueryStringsInOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OriginRequestPolicyAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> OriginRequestPolicyAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = OriginRequestPolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCookiesInOriginRequestPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCookiesInOriginRequestPolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyCookiesInOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyPublicKeys {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyPublicKeys {
        let reader = baseError.errorBodyReader
        var value = TooManyPublicKeys()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PublicKeyAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> PublicKeyAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = PublicKeyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRealtimeLogConfigs {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyRealtimeLogConfigs {
        let reader = baseError.errorBodyReader
        var value = TooManyRealtimeLogConfigs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RealtimeLogConfigAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> RealtimeLogConfigAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = RealtimeLogConfigAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyCustomHeadersInResponseHeadersPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyCustomHeadersInResponseHeadersPolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyCustomHeadersInResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooLongCSPInResponseHeadersPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooLongCSPInResponseHeadersPolicy {
        let reader = baseError.errorBodyReader
        var value = TooLongCSPInResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRemoveHeadersInResponseHeadersPolicy {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyRemoveHeadersInResponseHeadersPolicy {
        let reader = baseError.errorBodyReader
        var value = TooManyRemoveHeadersInResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyResponseHeadersPolicies {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyResponseHeadersPolicies {
        let reader = baseError.errorBodyReader
        var value = TooManyResponseHeadersPolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResponseHeadersPolicyAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> ResponseHeadersPolicyAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = ResponseHeadersPolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyStreamingDistributions {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyStreamingDistributions {
        let reader = baseError.errorBodyReader
        var value = TooManyStreamingDistributions()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StreamingDistributionAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> StreamingDistributionAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = StreamingDistributionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyStreamingDistributionCNAMEs {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TooManyStreamingDistributionCNAMEs {
        let reader = baseError.errorBodyReader
        var value = TooManyStreamingDistributionCNAMEs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalDelete {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> IllegalDelete {
        let reader = baseError.errorBodyReader
        var value = IllegalDelete()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CachePolicyInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> CachePolicyInUse {
        let reader = baseError.errorBodyReader
        var value = CachePolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudFrontOriginAccessIdentityInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> CloudFrontOriginAccessIdentityInUse {
        let reader = baseError.errorBodyReader
        var value = CloudFrontOriginAccessIdentityInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchCloudFrontOriginAccessIdentity {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchCloudFrontOriginAccessIdentity {
        let reader = baseError.errorBodyReader
        var value = NoSuchCloudFrontOriginAccessIdentity()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DistributionNotDisabled {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> DistributionNotDisabled {
        let reader = baseError.errorBodyReader
        var value = DistributionNotDisabled()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FieldLevelEncryptionConfigInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FieldLevelEncryptionConfigInUse {
        let reader = baseError.errorBodyReader
        var value = FieldLevelEncryptionConfigInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FieldLevelEncryptionProfileInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FieldLevelEncryptionProfileInUse {
        let reader = baseError.errorBodyReader
        var value = FieldLevelEncryptionProfileInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchFunctionExists {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchFunctionExists {
        let reader = baseError.errorBodyReader
        var value = NoSuchFunctionExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FunctionInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> FunctionInUse {
        let reader = baseError.errorBodyReader
        var value = FunctionInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchResource {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchResource {
        let reader = baseError.errorBodyReader
        var value = NoSuchResource()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> ResourceInUse {
        let reader = baseError.errorBodyReader
        var value = ResourceInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CannotDeleteEntityWhileInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> CannotDeleteEntityWhileInUse {
        let reader = baseError.errorBodyReader
        var value = CannotDeleteEntityWhileInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityNotFound {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> EntityNotFound {
        let reader = baseError.errorBodyReader
        var value = EntityNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchMonitoringSubscription {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchMonitoringSubscription {
        let reader = baseError.errorBodyReader
        var value = NoSuchMonitoringSubscription()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchOriginAccessControl {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchOriginAccessControl {
        let reader = baseError.errorBodyReader
        var value = NoSuchOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OriginAccessControlInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> OriginAccessControlInUse {
        let reader = baseError.errorBodyReader
        var value = OriginAccessControlInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OriginRequestPolicyInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> OriginRequestPolicyInUse {
        let reader = baseError.errorBodyReader
        var value = OriginRequestPolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PublicKeyInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> PublicKeyInUse {
        let reader = baseError.errorBodyReader
        var value = PublicKeyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RealtimeLogConfigInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> RealtimeLogConfigInUse {
        let reader = baseError.errorBodyReader
        var value = RealtimeLogConfigInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResponseHeadersPolicyInUse {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> ResponseHeadersPolicyInUse {
        let reader = baseError.errorBodyReader
        var value = ResponseHeadersPolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StreamingDistributionNotDisabled {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> StreamingDistributionNotDisabled {
        let reader = baseError.errorBodyReader
        var value = StreamingDistributionNotDisabled()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchStreamingDistribution {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchStreamingDistribution {
        let reader = baseError.errorBodyReader
        var value = NoSuchStreamingDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchInvalidation {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> NoSuchInvalidation {
        let reader = baseError.errorBodyReader
        var value = NoSuchInvalidation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TestFunctionFailed {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> TestFunctionFailed {
        let reader = baseError.errorBodyReader
        var value = TestFunctionFailed()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CannotChangeImmutablePublicKeyFields {

    static func makeError(baseError: AWSClientRuntime.RestXMLError) throws -> CannotChangeImmutablePublicKeyFields {
        let reader = baseError.errorBodyReader
        var value = CannotChangeImmutablePublicKeyFields()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudFrontClientTypes.Distribution {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Distribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Distribution()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["ARN"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.inProgressInvalidationBatches = try reader["InProgressInvalidationBatches"].readIfPresent() ?? 0
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.activeTrustedSigners = try reader["ActiveTrustedSigners"].readIfPresent(with: CloudFrontClientTypes.ActiveTrustedSigners.read(from:))
        value.activeTrustedKeyGroups = try reader["ActiveTrustedKeyGroups"].readIfPresent(with: CloudFrontClientTypes.ActiveTrustedKeyGroups.read(from:))
        value.distributionConfig = try reader["DistributionConfig"].readIfPresent(with: CloudFrontClientTypes.DistributionConfig.read(from:))
        value.aliasICPRecordals = try reader["AliasICPRecordals"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.AliasICPRecordal.read(from:), memberNodeInfo: "AliasICPRecordal", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.AliasICPRecordal {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.AliasICPRecordal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.AliasICPRecordal()
        value.cname = try reader["CNAME"].readIfPresent()
        value.icpRecordalStatus = try reader["ICPRecordalStatus"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.DistributionConfig {

    static func write(value: CloudFrontClientTypes.DistributionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Aliases"].write(value.aliases, with: CloudFrontClientTypes.Aliases.write(value:to:))
        try writer["CacheBehaviors"].write(value.cacheBehaviors, with: CloudFrontClientTypes.CacheBehaviors.write(value:to:))
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["ContinuousDeploymentPolicyId"].write(value.continuousDeploymentPolicyId)
        try writer["CustomErrorResponses"].write(value.customErrorResponses, with: CloudFrontClientTypes.CustomErrorResponses.write(value:to:))
        try writer["DefaultCacheBehavior"].write(value.defaultCacheBehavior, with: CloudFrontClientTypes.DefaultCacheBehavior.write(value:to:))
        try writer["DefaultRootObject"].write(value.defaultRootObject)
        try writer["Enabled"].write(value.enabled)
        try writer["HttpVersion"].write(value.httpVersion)
        try writer["IsIPV6Enabled"].write(value.isIPV6Enabled)
        try writer["Logging"].write(value.logging, with: CloudFrontClientTypes.LoggingConfig.write(value:to:))
        try writer["OriginGroups"].write(value.originGroups, with: CloudFrontClientTypes.OriginGroups.write(value:to:))
        try writer["Origins"].write(value.origins, with: CloudFrontClientTypes.Origins.write(value:to:))
        try writer["PriceClass"].write(value.priceClass)
        try writer["Restrictions"].write(value.restrictions, with: CloudFrontClientTypes.Restrictions.write(value:to:))
        try writer["Staging"].write(value.staging)
        try writer["ViewerCertificate"].write(value.viewerCertificate, with: CloudFrontClientTypes.ViewerCertificate.write(value:to:))
        try writer["WebACLId"].write(value.webACLId)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.DistributionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.DistributionConfig()
        value.callerReference = try reader["CallerReference"].readIfPresent() ?? ""
        value.aliases = try reader["Aliases"].readIfPresent(with: CloudFrontClientTypes.Aliases.read(from:))
        value.defaultRootObject = try reader["DefaultRootObject"].readIfPresent()
        value.origins = try reader["Origins"].readIfPresent(with: CloudFrontClientTypes.Origins.read(from:))
        value.originGroups = try reader["OriginGroups"].readIfPresent(with: CloudFrontClientTypes.OriginGroups.read(from:))
        value.defaultCacheBehavior = try reader["DefaultCacheBehavior"].readIfPresent(with: CloudFrontClientTypes.DefaultCacheBehavior.read(from:))
        value.cacheBehaviors = try reader["CacheBehaviors"].readIfPresent(with: CloudFrontClientTypes.CacheBehaviors.read(from:))
        value.customErrorResponses = try reader["CustomErrorResponses"].readIfPresent(with: CloudFrontClientTypes.CustomErrorResponses.read(from:))
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        value.logging = try reader["Logging"].readIfPresent(with: CloudFrontClientTypes.LoggingConfig.read(from:))
        value.priceClass = try reader["PriceClass"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.viewerCertificate = try reader["ViewerCertificate"].readIfPresent(with: CloudFrontClientTypes.ViewerCertificate.read(from:))
        value.restrictions = try reader["Restrictions"].readIfPresent(with: CloudFrontClientTypes.Restrictions.read(from:))
        value.webACLId = try reader["WebACLId"].readIfPresent()
        value.httpVersion = try reader["HttpVersion"].readIfPresent()
        value.isIPV6Enabled = try reader["IsIPV6Enabled"].readIfPresent()
        value.continuousDeploymentPolicyId = try reader["ContinuousDeploymentPolicyId"].readIfPresent()
        value.staging = try reader["Staging"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.Restrictions {

    static func write(value: CloudFrontClientTypes.Restrictions?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["GeoRestriction"].write(value.geoRestriction, with: CloudFrontClientTypes.GeoRestriction.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Restrictions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Restrictions()
        value.geoRestriction = try reader["GeoRestriction"].readIfPresent(with: CloudFrontClientTypes.GeoRestriction.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.GeoRestriction {

    static func write(value: CloudFrontClientTypes.GeoRestriction?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Location", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
        try writer["RestrictionType"].write(value.restrictionType)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.GeoRestriction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.GeoRestriction()
        value.restrictionType = try reader["RestrictionType"].readIfPresent() ?? .sdkUnknown("")
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Location", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ViewerCertificate {

    static func write(value: CloudFrontClientTypes.ViewerCertificate?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ACMCertificateArn"].write(value.acmCertificateArn)
        try writer["Certificate"].write(value.certificate)
        try writer["CertificateSource"].write(value.certificateSource)
        try writer["CloudFrontDefaultCertificate"].write(value.cloudFrontDefaultCertificate)
        try writer["IAMCertificateId"].write(value.iamCertificateId)
        try writer["MinimumProtocolVersion"].write(value.minimumProtocolVersion)
        try writer["SSLSupportMethod"].write(value.sslSupportMethod)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ViewerCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ViewerCertificate()
        value.cloudFrontDefaultCertificate = try reader["CloudFrontDefaultCertificate"].readIfPresent()
        value.iamCertificateId = try reader["IAMCertificateId"].readIfPresent()
        value.acmCertificateArn = try reader["ACMCertificateArn"].readIfPresent()
        value.sslSupportMethod = try reader["SSLSupportMethod"].readIfPresent()
        value.minimumProtocolVersion = try reader["MinimumProtocolVersion"].readIfPresent()
        value.certificate = try reader["Certificate"].readIfPresent()
        value.certificateSource = try reader["CertificateSource"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.LoggingConfig {

    static func write(value: CloudFrontClientTypes.LoggingConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["Enabled"].write(value.enabled)
        try writer["IncludeCookies"].write(value.includeCookies)
        try writer["Prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.LoggingConfig()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.includeCookies = try reader["IncludeCookies"].readIfPresent() ?? false
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.`prefix` = try reader["Prefix"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.CustomErrorResponses {

    static func write(value: CloudFrontClientTypes.CustomErrorResponses?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.CustomErrorResponse.write(value:to:), memberNodeInfo: "CustomErrorResponse", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CustomErrorResponses {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CustomErrorResponses()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CustomErrorResponse.read(from:), memberNodeInfo: "CustomErrorResponse", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.CustomErrorResponse {

    static func write(value: CloudFrontClientTypes.CustomErrorResponse?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ErrorCachingMinTTL"].write(value.errorCachingMinTTL)
        try writer["ErrorCode"].write(value.errorCode)
        try writer["ResponseCode"].write(value.responseCode)
        try writer["ResponsePagePath"].write(value.responsePagePath)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CustomErrorResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CustomErrorResponse()
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? 0
        value.responsePagePath = try reader["ResponsePagePath"].readIfPresent()
        value.responseCode = try reader["ResponseCode"].readIfPresent()
        value.errorCachingMinTTL = try reader["ErrorCachingMinTTL"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.CacheBehaviors {

    static func write(value: CloudFrontClientTypes.CacheBehaviors?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.CacheBehavior.write(value:to:), memberNodeInfo: "CacheBehavior", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CacheBehaviors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CacheBehaviors()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CacheBehavior.read(from:), memberNodeInfo: "CacheBehavior", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.CacheBehavior {

    static func write(value: CloudFrontClientTypes.CacheBehavior?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["AllowedMethods"].write(value.allowedMethods, with: CloudFrontClientTypes.AllowedMethods.write(value:to:))
        try writer["CachePolicyId"].write(value.cachePolicyId)
        try writer["Compress"].write(value.compress)
        try writer["DefaultTTL"].write(value.defaultTTL)
        try writer["FieldLevelEncryptionId"].write(value.fieldLevelEncryptionId)
        try writer["ForwardedValues"].write(value.forwardedValues, with: CloudFrontClientTypes.ForwardedValues.write(value:to:))
        try writer["FunctionAssociations"].write(value.functionAssociations, with: CloudFrontClientTypes.FunctionAssociations.write(value:to:))
        try writer["LambdaFunctionAssociations"].write(value.lambdaFunctionAssociations, with: CloudFrontClientTypes.LambdaFunctionAssociations.write(value:to:))
        try writer["MaxTTL"].write(value.maxTTL)
        try writer["MinTTL"].write(value.minTTL)
        try writer["OriginRequestPolicyId"].write(value.originRequestPolicyId)
        try writer["PathPattern"].write(value.pathPattern)
        try writer["RealtimeLogConfigArn"].write(value.realtimeLogConfigArn)
        try writer["ResponseHeadersPolicyId"].write(value.responseHeadersPolicyId)
        try writer["SmoothStreaming"].write(value.smoothStreaming)
        try writer["TargetOriginId"].write(value.targetOriginId)
        try writer["TrustedKeyGroups"].write(value.trustedKeyGroups, with: CloudFrontClientTypes.TrustedKeyGroups.write(value:to:))
        try writer["TrustedSigners"].write(value.trustedSigners, with: CloudFrontClientTypes.TrustedSigners.write(value:to:))
        try writer["ViewerProtocolPolicy"].write(value.viewerProtocolPolicy)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CacheBehavior {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CacheBehavior()
        value.pathPattern = try reader["PathPattern"].readIfPresent() ?? ""
        value.targetOriginId = try reader["TargetOriginId"].readIfPresent() ?? ""
        value.trustedSigners = try reader["TrustedSigners"].readIfPresent(with: CloudFrontClientTypes.TrustedSigners.read(from:))
        value.trustedKeyGroups = try reader["TrustedKeyGroups"].readIfPresent(with: CloudFrontClientTypes.TrustedKeyGroups.read(from:))
        value.viewerProtocolPolicy = try reader["ViewerProtocolPolicy"].readIfPresent() ?? .sdkUnknown("")
        value.allowedMethods = try reader["AllowedMethods"].readIfPresent(with: CloudFrontClientTypes.AllowedMethods.read(from:))
        value.smoothStreaming = try reader["SmoothStreaming"].readIfPresent()
        value.compress = try reader["Compress"].readIfPresent()
        value.lambdaFunctionAssociations = try reader["LambdaFunctionAssociations"].readIfPresent(with: CloudFrontClientTypes.LambdaFunctionAssociations.read(from:))
        value.functionAssociations = try reader["FunctionAssociations"].readIfPresent(with: CloudFrontClientTypes.FunctionAssociations.read(from:))
        value.fieldLevelEncryptionId = try reader["FieldLevelEncryptionId"].readIfPresent()
        value.realtimeLogConfigArn = try reader["RealtimeLogConfigArn"].readIfPresent()
        value.cachePolicyId = try reader["CachePolicyId"].readIfPresent()
        value.originRequestPolicyId = try reader["OriginRequestPolicyId"].readIfPresent()
        value.responseHeadersPolicyId = try reader["ResponseHeadersPolicyId"].readIfPresent()
        value.forwardedValues = try reader["ForwardedValues"].readIfPresent(with: CloudFrontClientTypes.ForwardedValues.read(from:))
        value.minTTL = try reader["MinTTL"].readIfPresent()
        value.defaultTTL = try reader["DefaultTTL"].readIfPresent()
        value.maxTTL = try reader["MaxTTL"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.ForwardedValues {

    static func write(value: CloudFrontClientTypes.ForwardedValues?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Cookies"].write(value.cookies, with: CloudFrontClientTypes.CookiePreference.write(value:to:))
        try writer["Headers"].write(value.headers, with: CloudFrontClientTypes.Headers.write(value:to:))
        try writer["QueryString"].write(value.queryString)
        try writer["QueryStringCacheKeys"].write(value.queryStringCacheKeys, with: CloudFrontClientTypes.QueryStringCacheKeys.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ForwardedValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ForwardedValues()
        value.queryString = try reader["QueryString"].readIfPresent() ?? false
        value.cookies = try reader["Cookies"].readIfPresent(with: CloudFrontClientTypes.CookiePreference.read(from:))
        value.headers = try reader["Headers"].readIfPresent(with: CloudFrontClientTypes.Headers.read(from:))
        value.queryStringCacheKeys = try reader["QueryStringCacheKeys"].readIfPresent(with: CloudFrontClientTypes.QueryStringCacheKeys.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.QueryStringCacheKeys {

    static func write(value: CloudFrontClientTypes.QueryStringCacheKeys?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.QueryStringCacheKeys {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.QueryStringCacheKeys()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Name", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.Headers {

    static func write(value: CloudFrontClientTypes.Headers?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Headers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Headers()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Name", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.CookiePreference {

    static func write(value: CloudFrontClientTypes.CookiePreference?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Forward"].write(value.forward)
        try writer["WhitelistedNames"].write(value.whitelistedNames, with: CloudFrontClientTypes.CookieNames.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CookiePreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CookiePreference()
        value.forward = try reader["Forward"].readIfPresent() ?? .sdkUnknown("")
        value.whitelistedNames = try reader["WhitelistedNames"].readIfPresent(with: CloudFrontClientTypes.CookieNames.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CookieNames {

    static func write(value: CloudFrontClientTypes.CookieNames?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CookieNames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CookieNames()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Name", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.FunctionAssociations {

    static func write(value: CloudFrontClientTypes.FunctionAssociations?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.FunctionAssociation.write(value:to:), memberNodeInfo: "FunctionAssociation", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FunctionAssociations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FunctionAssociations()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FunctionAssociation.read(from:), memberNodeInfo: "FunctionAssociation", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.FunctionAssociation {

    static func write(value: CloudFrontClientTypes.FunctionAssociation?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["EventType"].write(value.eventType)
        try writer["FunctionARN"].write(value.functionARN)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FunctionAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FunctionAssociation()
        value.functionARN = try reader["FunctionARN"].readIfPresent() ?? ""
        value.eventType = try reader["EventType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociations {

    static func write(value: CloudFrontClientTypes.LambdaFunctionAssociations?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.LambdaFunctionAssociation.write(value:to:), memberNodeInfo: "LambdaFunctionAssociation", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.LambdaFunctionAssociations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.LambdaFunctionAssociations()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.LambdaFunctionAssociation.read(from:), memberNodeInfo: "LambdaFunctionAssociation", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociation {

    static func write(value: CloudFrontClientTypes.LambdaFunctionAssociation?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["EventType"].write(value.eventType)
        try writer["IncludeBody"].write(value.includeBody)
        try writer["LambdaFunctionARN"].write(value.lambdaFunctionARN)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.LambdaFunctionAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.LambdaFunctionAssociation()
        value.lambdaFunctionARN = try reader["LambdaFunctionARN"].readIfPresent() ?? ""
        value.eventType = try reader["EventType"].readIfPresent() ?? .sdkUnknown("")
        value.includeBody = try reader["IncludeBody"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.AllowedMethods {

    static func write(value: CloudFrontClientTypes.AllowedMethods?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CachedMethods"].write(value.cachedMethods, with: CloudFrontClientTypes.CachedMethods.write(value:to:))
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CloudFrontClientTypes.Method>().write(value:to:), memberNodeInfo: "Method", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.AllowedMethods {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.AllowedMethods()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CloudFrontClientTypes.Method>().read(from:), memberNodeInfo: "Method", isFlattened: false) ?? []
        value.cachedMethods = try reader["CachedMethods"].readIfPresent(with: CloudFrontClientTypes.CachedMethods.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CachedMethods {

    static func write(value: CloudFrontClientTypes.CachedMethods?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CloudFrontClientTypes.Method>().write(value:to:), memberNodeInfo: "Method", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachedMethods {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachedMethods()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CloudFrontClientTypes.Method>().read(from:), memberNodeInfo: "Method", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups {

    static func write(value: CloudFrontClientTypes.TrustedKeyGroups?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "KeyGroup", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.TrustedKeyGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.TrustedKeyGroups()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "KeyGroup", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.TrustedSigners {

    static func write(value: CloudFrontClientTypes.TrustedSigners?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "AwsAccountNumber", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.TrustedSigners {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.TrustedSigners()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "AwsAccountNumber", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.DefaultCacheBehavior {

    static func write(value: CloudFrontClientTypes.DefaultCacheBehavior?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["AllowedMethods"].write(value.allowedMethods, with: CloudFrontClientTypes.AllowedMethods.write(value:to:))
        try writer["CachePolicyId"].write(value.cachePolicyId)
        try writer["Compress"].write(value.compress)
        try writer["DefaultTTL"].write(value.defaultTTL)
        try writer["FieldLevelEncryptionId"].write(value.fieldLevelEncryptionId)
        try writer["ForwardedValues"].write(value.forwardedValues, with: CloudFrontClientTypes.ForwardedValues.write(value:to:))
        try writer["FunctionAssociations"].write(value.functionAssociations, with: CloudFrontClientTypes.FunctionAssociations.write(value:to:))
        try writer["LambdaFunctionAssociations"].write(value.lambdaFunctionAssociations, with: CloudFrontClientTypes.LambdaFunctionAssociations.write(value:to:))
        try writer["MaxTTL"].write(value.maxTTL)
        try writer["MinTTL"].write(value.minTTL)
        try writer["OriginRequestPolicyId"].write(value.originRequestPolicyId)
        try writer["RealtimeLogConfigArn"].write(value.realtimeLogConfigArn)
        try writer["ResponseHeadersPolicyId"].write(value.responseHeadersPolicyId)
        try writer["SmoothStreaming"].write(value.smoothStreaming)
        try writer["TargetOriginId"].write(value.targetOriginId)
        try writer["TrustedKeyGroups"].write(value.trustedKeyGroups, with: CloudFrontClientTypes.TrustedKeyGroups.write(value:to:))
        try writer["TrustedSigners"].write(value.trustedSigners, with: CloudFrontClientTypes.TrustedSigners.write(value:to:))
        try writer["ViewerProtocolPolicy"].write(value.viewerProtocolPolicy)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.DefaultCacheBehavior {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.DefaultCacheBehavior()
        value.targetOriginId = try reader["TargetOriginId"].readIfPresent() ?? ""
        value.trustedSigners = try reader["TrustedSigners"].readIfPresent(with: CloudFrontClientTypes.TrustedSigners.read(from:))
        value.trustedKeyGroups = try reader["TrustedKeyGroups"].readIfPresent(with: CloudFrontClientTypes.TrustedKeyGroups.read(from:))
        value.viewerProtocolPolicy = try reader["ViewerProtocolPolicy"].readIfPresent() ?? .sdkUnknown("")
        value.allowedMethods = try reader["AllowedMethods"].readIfPresent(with: CloudFrontClientTypes.AllowedMethods.read(from:))
        value.smoothStreaming = try reader["SmoothStreaming"].readIfPresent()
        value.compress = try reader["Compress"].readIfPresent()
        value.lambdaFunctionAssociations = try reader["LambdaFunctionAssociations"].readIfPresent(with: CloudFrontClientTypes.LambdaFunctionAssociations.read(from:))
        value.functionAssociations = try reader["FunctionAssociations"].readIfPresent(with: CloudFrontClientTypes.FunctionAssociations.read(from:))
        value.fieldLevelEncryptionId = try reader["FieldLevelEncryptionId"].readIfPresent()
        value.realtimeLogConfigArn = try reader["RealtimeLogConfigArn"].readIfPresent()
        value.cachePolicyId = try reader["CachePolicyId"].readIfPresent()
        value.originRequestPolicyId = try reader["OriginRequestPolicyId"].readIfPresent()
        value.responseHeadersPolicyId = try reader["ResponseHeadersPolicyId"].readIfPresent()
        value.forwardedValues = try reader["ForwardedValues"].readIfPresent(with: CloudFrontClientTypes.ForwardedValues.read(from:))
        value.minTTL = try reader["MinTTL"].readIfPresent()
        value.defaultTTL = try reader["DefaultTTL"].readIfPresent()
        value.maxTTL = try reader["MaxTTL"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.OriginGroups {

    static func write(value: CloudFrontClientTypes.OriginGroups?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginGroup.write(value:to:), memberNodeInfo: "OriginGroup", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginGroups()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginGroup.read(from:), memberNodeInfo: "OriginGroup", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.OriginGroup {

    static func write(value: CloudFrontClientTypes.OriginGroup?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FailoverCriteria"].write(value.failoverCriteria, with: CloudFrontClientTypes.OriginGroupFailoverCriteria.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Members"].write(value.members, with: CloudFrontClientTypes.OriginGroupMembers.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginGroup()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.failoverCriteria = try reader["FailoverCriteria"].readIfPresent(with: CloudFrontClientTypes.OriginGroupFailoverCriteria.read(from:))
        value.members = try reader["Members"].readIfPresent(with: CloudFrontClientTypes.OriginGroupMembers.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.OriginGroupMembers {

    static func write(value: CloudFrontClientTypes.OriginGroupMembers?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginGroupMember.write(value:to:), memberNodeInfo: "OriginGroupMember", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginGroupMembers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginGroupMembers()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginGroupMember.read(from:), memberNodeInfo: "OriginGroupMember", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.OriginGroupMember {

    static func write(value: CloudFrontClientTypes.OriginGroupMember?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["OriginId"].write(value.originId)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginGroupMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginGroupMember()
        value.originId = try reader["OriginId"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria {

    static func write(value: CloudFrontClientTypes.OriginGroupFailoverCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["StatusCodes"].write(value.statusCodes, with: CloudFrontClientTypes.StatusCodes.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginGroupFailoverCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginGroupFailoverCriteria()
        value.statusCodes = try reader["StatusCodes"].readIfPresent(with: CloudFrontClientTypes.StatusCodes.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.StatusCodes {

    static func write(value: CloudFrontClientTypes.StatusCodes?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "StatusCode", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.StatusCodes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.StatusCodes()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "StatusCode", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.Origins {

    static func write(value: CloudFrontClientTypes.Origins?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.Origin.write(value:to:), memberNodeInfo: "Origin", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Origins {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Origins()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Origin.read(from:), memberNodeInfo: "Origin", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.Origin {

    static func write(value: CloudFrontClientTypes.Origin?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ConnectionAttempts"].write(value.connectionAttempts)
        try writer["ConnectionTimeout"].write(value.connectionTimeout)
        try writer["CustomHeaders"].write(value.customHeaders, with: CloudFrontClientTypes.CustomHeaders.write(value:to:))
        try writer["CustomOriginConfig"].write(value.customOriginConfig, with: CloudFrontClientTypes.CustomOriginConfig.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Id"].write(value.id)
        try writer["OriginAccessControlId"].write(value.originAccessControlId)
        try writer["OriginPath"].write(value.originPath)
        try writer["OriginShield"].write(value.originShield, with: CloudFrontClientTypes.OriginShield.write(value:to:))
        try writer["S3OriginConfig"].write(value.s3OriginConfig, with: CloudFrontClientTypes.S3OriginConfig.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Origin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Origin()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.originPath = try reader["OriginPath"].readIfPresent()
        value.customHeaders = try reader["CustomHeaders"].readIfPresent(with: CloudFrontClientTypes.CustomHeaders.read(from:))
        value.s3OriginConfig = try reader["S3OriginConfig"].readIfPresent(with: CloudFrontClientTypes.S3OriginConfig.read(from:))
        value.customOriginConfig = try reader["CustomOriginConfig"].readIfPresent(with: CloudFrontClientTypes.CustomOriginConfig.read(from:))
        value.connectionAttempts = try reader["ConnectionAttempts"].readIfPresent()
        value.connectionTimeout = try reader["ConnectionTimeout"].readIfPresent()
        value.originShield = try reader["OriginShield"].readIfPresent(with: CloudFrontClientTypes.OriginShield.read(from:))
        value.originAccessControlId = try reader["OriginAccessControlId"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.OriginShield {

    static func write(value: CloudFrontClientTypes.OriginShield?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["OriginShieldRegion"].write(value.originShieldRegion)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginShield {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginShield()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.originShieldRegion = try reader["OriginShieldRegion"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.CustomOriginConfig {

    static func write(value: CloudFrontClientTypes.CustomOriginConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["HTTPPort"].write(value.httpPort)
        try writer["HTTPSPort"].write(value.httpsPort)
        try writer["OriginKeepaliveTimeout"].write(value.originKeepaliveTimeout)
        try writer["OriginProtocolPolicy"].write(value.originProtocolPolicy)
        try writer["OriginReadTimeout"].write(value.originReadTimeout)
        try writer["OriginSslProtocols"].write(value.originSslProtocols, with: CloudFrontClientTypes.OriginSslProtocols.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CustomOriginConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CustomOriginConfig()
        value.httpPort = try reader["HTTPPort"].readIfPresent() ?? 0
        value.httpsPort = try reader["HTTPSPort"].readIfPresent() ?? 0
        value.originProtocolPolicy = try reader["OriginProtocolPolicy"].readIfPresent() ?? .sdkUnknown("")
        value.originSslProtocols = try reader["OriginSslProtocols"].readIfPresent(with: CloudFrontClientTypes.OriginSslProtocols.read(from:))
        value.originReadTimeout = try reader["OriginReadTimeout"].readIfPresent()
        value.originKeepaliveTimeout = try reader["OriginKeepaliveTimeout"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.OriginSslProtocols {

    static func write(value: CloudFrontClientTypes.OriginSslProtocols?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CloudFrontClientTypes.SslProtocol>().write(value:to:), memberNodeInfo: "SslProtocol", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginSslProtocols {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginSslProtocols()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CloudFrontClientTypes.SslProtocol>().read(from:), memberNodeInfo: "SslProtocol", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.S3OriginConfig {

    static func write(value: CloudFrontClientTypes.S3OriginConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["OriginAccessIdentity"].write(value.originAccessIdentity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.S3OriginConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.S3OriginConfig()
        value.originAccessIdentity = try reader["OriginAccessIdentity"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.CustomHeaders {

    static func write(value: CloudFrontClientTypes.CustomHeaders?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginCustomHeader.write(value:to:), memberNodeInfo: "OriginCustomHeader", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CustomHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CustomHeaders()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginCustomHeader.read(from:), memberNodeInfo: "OriginCustomHeader", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.OriginCustomHeader {

    static func write(value: CloudFrontClientTypes.OriginCustomHeader?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["HeaderName"].write(value.headerName)
        try writer["HeaderValue"].write(value.headerValue)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginCustomHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginCustomHeader()
        value.headerName = try reader["HeaderName"].readIfPresent() ?? ""
        value.headerValue = try reader["HeaderValue"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.Aliases {

    static func write(value: CloudFrontClientTypes.Aliases?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "CNAME", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Aliases {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Aliases()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "CNAME", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ActiveTrustedKeyGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ActiveTrustedKeyGroups()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KGKeyPairIds.read(from:), memberNodeInfo: "KeyGroup", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.KGKeyPairIds {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KGKeyPairIds {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KGKeyPairIds()
        value.keyGroupId = try reader["KeyGroupId"].readIfPresent()
        value.keyPairIds = try reader["KeyPairIds"].readIfPresent(with: CloudFrontClientTypes.KeyPairIds.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.KeyPairIds {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyPairIds {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyPairIds()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "KeyPairId", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ActiveTrustedSigners {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ActiveTrustedSigners {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ActiveTrustedSigners()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Signer.read(from:), memberNodeInfo: "Signer", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.Signer {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Signer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Signer()
        value.awsAccountNumber = try reader["AwsAccountNumber"].readIfPresent()
        value.keyPairIds = try reader["KeyPairIds"].readIfPresent(with: CloudFrontClientTypes.KeyPairIds.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CachePolicy {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachePolicy()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.cachePolicyConfig = try reader["CachePolicyConfig"].readIfPresent(with: CloudFrontClientTypes.CachePolicyConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CachePolicyConfig {

    static func write(value: CloudFrontClientTypes.CachePolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
        try writer["DefaultTTL"].write(value.defaultTTL)
        try writer["MaxTTL"].write(value.maxTTL)
        try writer["MinTTL"].write(value.minTTL)
        try writer["Name"].write(value.name)
        try writer["ParametersInCacheKeyAndForwardedToOrigin"].write(value.parametersInCacheKeyAndForwardedToOrigin, with: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachePolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachePolicyConfig()
        value.comment = try reader["Comment"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.defaultTTL = try reader["DefaultTTL"].readIfPresent()
        value.maxTTL = try reader["MaxTTL"].readIfPresent()
        value.minTTL = try reader["MinTTL"].readIfPresent() ?? 0
        value.parametersInCacheKeyAndForwardedToOrigin = try reader["ParametersInCacheKeyAndForwardedToOrigin"].readIfPresent(with: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin {

    static func write(value: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CookiesConfig"].write(value.cookiesConfig, with: CloudFrontClientTypes.CachePolicyCookiesConfig.write(value:to:))
        try writer["EnableAcceptEncodingBrotli"].write(value.enableAcceptEncodingBrotli)
        try writer["EnableAcceptEncodingGzip"].write(value.enableAcceptEncodingGzip)
        try writer["HeadersConfig"].write(value.headersConfig, with: CloudFrontClientTypes.CachePolicyHeadersConfig.write(value:to:))
        try writer["QueryStringsConfig"].write(value.queryStringsConfig, with: CloudFrontClientTypes.CachePolicyQueryStringsConfig.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin()
        value.enableAcceptEncodingGzip = try reader["EnableAcceptEncodingGzip"].readIfPresent() ?? false
        value.enableAcceptEncodingBrotli = try reader["EnableAcceptEncodingBrotli"].readIfPresent()
        value.headersConfig = try reader["HeadersConfig"].readIfPresent(with: CloudFrontClientTypes.CachePolicyHeadersConfig.read(from:))
        value.cookiesConfig = try reader["CookiesConfig"].readIfPresent(with: CloudFrontClientTypes.CachePolicyCookiesConfig.read(from:))
        value.queryStringsConfig = try reader["QueryStringsConfig"].readIfPresent(with: CloudFrontClientTypes.CachePolicyQueryStringsConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig {

    static func write(value: CloudFrontClientTypes.CachePolicyQueryStringsConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["QueryStringBehavior"].write(value.queryStringBehavior)
        try writer["QueryStrings"].write(value.queryStrings, with: CloudFrontClientTypes.QueryStringNames.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachePolicyQueryStringsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachePolicyQueryStringsConfig()
        value.queryStringBehavior = try reader["QueryStringBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.queryStrings = try reader["QueryStrings"].readIfPresent(with: CloudFrontClientTypes.QueryStringNames.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.QueryStringNames {

    static func write(value: CloudFrontClientTypes.QueryStringNames?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.QueryStringNames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.QueryStringNames()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Name", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig {

    static func write(value: CloudFrontClientTypes.CachePolicyCookiesConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CookieBehavior"].write(value.cookieBehavior)
        try writer["Cookies"].write(value.cookies, with: CloudFrontClientTypes.CookieNames.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachePolicyCookiesConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachePolicyCookiesConfig()
        value.cookieBehavior = try reader["CookieBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.cookies = try reader["Cookies"].readIfPresent(with: CloudFrontClientTypes.CookieNames.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig {

    static func write(value: CloudFrontClientTypes.CachePolicyHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["HeaderBehavior"].write(value.headerBehavior)
        try writer["Headers"].write(value.headers, with: CloudFrontClientTypes.Headers.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachePolicyHeadersConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachePolicyHeadersConfig()
        value.headerBehavior = try reader["HeaderBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.headers = try reader["Headers"].readIfPresent(with: CloudFrontClientTypes.Headers.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CloudFrontOriginAccessIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentity()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.s3CanonicalUserId = try reader["S3CanonicalUserId"].readIfPresent() ?? ""
        value.cloudFrontOriginAccessIdentityConfig = try reader["CloudFrontOriginAccessIdentityConfig"].readIfPresent(with: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig {

    static func write(value: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig()
        value.callerReference = try reader["CallerReference"].readIfPresent() ?? ""
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicy {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContinuousDeploymentPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContinuousDeploymentPolicy()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.continuousDeploymentPolicyConfig = try reader["ContinuousDeploymentPolicyConfig"].readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyConfig {

    static func write(value: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["StagingDistributionDnsNames"].write(value.stagingDistributionDnsNames, with: CloudFrontClientTypes.StagingDistributionDnsNames.write(value:to:))
        try writer["TrafficConfig"].write(value.trafficConfig, with: CloudFrontClientTypes.TrafficConfig.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContinuousDeploymentPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContinuousDeploymentPolicyConfig()
        value.stagingDistributionDnsNames = try reader["StagingDistributionDnsNames"].readIfPresent(with: CloudFrontClientTypes.StagingDistributionDnsNames.read(from:))
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.trafficConfig = try reader["TrafficConfig"].readIfPresent(with: CloudFrontClientTypes.TrafficConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.TrafficConfig {

    static func write(value: CloudFrontClientTypes.TrafficConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["SingleHeaderConfig"].write(value.singleHeaderConfig, with: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig.write(value:to:))
        try writer["SingleWeightConfig"].write(value.singleWeightConfig, with: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.TrafficConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.TrafficConfig()
        value.singleWeightConfig = try reader["SingleWeightConfig"].readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig.read(from:))
        value.singleHeaderConfig = try reader["SingleHeaderConfig"].readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig {

    static func write(value: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Header"].write(value.header)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig()
        value.header = try reader["Header"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig {

    static func write(value: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["SessionStickinessConfig"].write(value.sessionStickinessConfig, with: CloudFrontClientTypes.SessionStickinessConfig.write(value:to:))
        try writer["Weight"].write(value.weight)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig()
        value.weight = try reader["Weight"].readIfPresent() ?? 0.0
        value.sessionStickinessConfig = try reader["SessionStickinessConfig"].readIfPresent(with: CloudFrontClientTypes.SessionStickinessConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.SessionStickinessConfig {

    static func write(value: CloudFrontClientTypes.SessionStickinessConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["IdleTTL"].write(value.idleTTL)
        try writer["MaximumTTL"].write(value.maximumTTL)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.SessionStickinessConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.SessionStickinessConfig()
        value.idleTTL = try reader["IdleTTL"].readIfPresent() ?? 0
        value.maximumTTL = try reader["MaximumTTL"].readIfPresent() ?? 0
        return value
    }
}

extension CloudFrontClientTypes.StagingDistributionDnsNames {

    static func write(value: CloudFrontClientTypes.StagingDistributionDnsNames?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "DnsName", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.StagingDistributionDnsNames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.StagingDistributionDnsNames()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "DnsName", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryption()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.fieldLevelEncryptionConfig = try reader["FieldLevelEncryptionConfig"].readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig {

    static func write(value: CloudFrontClientTypes.FieldLevelEncryptionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["ContentTypeProfileConfig"].write(value.contentTypeProfileConfig, with: CloudFrontClientTypes.ContentTypeProfileConfig.write(value:to:))
        try writer["QueryArgProfileConfig"].write(value.queryArgProfileConfig, with: CloudFrontClientTypes.QueryArgProfileConfig.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryptionConfig()
        value.callerReference = try reader["CallerReference"].readIfPresent() ?? ""
        value.comment = try reader["Comment"].readIfPresent()
        value.queryArgProfileConfig = try reader["QueryArgProfileConfig"].readIfPresent(with: CloudFrontClientTypes.QueryArgProfileConfig.read(from:))
        value.contentTypeProfileConfig = try reader["ContentTypeProfileConfig"].readIfPresent(with: CloudFrontClientTypes.ContentTypeProfileConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.ContentTypeProfileConfig {

    static func write(value: CloudFrontClientTypes.ContentTypeProfileConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ContentTypeProfiles"].write(value.contentTypeProfiles, with: CloudFrontClientTypes.ContentTypeProfiles.write(value:to:))
        try writer["ForwardWhenContentTypeIsUnknown"].write(value.forwardWhenContentTypeIsUnknown)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContentTypeProfileConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContentTypeProfileConfig()
        value.forwardWhenContentTypeIsUnknown = try reader["ForwardWhenContentTypeIsUnknown"].readIfPresent() ?? false
        value.contentTypeProfiles = try reader["ContentTypeProfiles"].readIfPresent(with: CloudFrontClientTypes.ContentTypeProfiles.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.ContentTypeProfiles {

    static func write(value: CloudFrontClientTypes.ContentTypeProfiles?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ContentTypeProfile.write(value:to:), memberNodeInfo: "ContentTypeProfile", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContentTypeProfiles {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContentTypeProfiles()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ContentTypeProfile.read(from:), memberNodeInfo: "ContentTypeProfile", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ContentTypeProfile {

    static func write(value: CloudFrontClientTypes.ContentTypeProfile?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ContentType"].write(value.contentType)
        try writer["Format"].write(value.format)
        try writer["ProfileId"].write(value.profileId)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContentTypeProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContentTypeProfile()
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.profileId = try reader["ProfileId"].readIfPresent()
        value.contentType = try reader["ContentType"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.QueryArgProfileConfig {

    static func write(value: CloudFrontClientTypes.QueryArgProfileConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ForwardWhenQueryArgProfileIsUnknown"].write(value.forwardWhenQueryArgProfileIsUnknown)
        try writer["QueryArgProfiles"].write(value.queryArgProfiles, with: CloudFrontClientTypes.QueryArgProfiles.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.QueryArgProfileConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.QueryArgProfileConfig()
        value.forwardWhenQueryArgProfileIsUnknown = try reader["ForwardWhenQueryArgProfileIsUnknown"].readIfPresent() ?? false
        value.queryArgProfiles = try reader["QueryArgProfiles"].readIfPresent(with: CloudFrontClientTypes.QueryArgProfiles.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.QueryArgProfiles {

    static func write(value: CloudFrontClientTypes.QueryArgProfiles?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.QueryArgProfile.write(value:to:), memberNodeInfo: "QueryArgProfile", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.QueryArgProfiles {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.QueryArgProfiles()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.QueryArgProfile.read(from:), memberNodeInfo: "QueryArgProfile", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.QueryArgProfile {

    static func write(value: CloudFrontClientTypes.QueryArgProfile?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ProfileId"].write(value.profileId)
        try writer["QueryArg"].write(value.queryArg)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.QueryArgProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.QueryArgProfile()
        value.queryArg = try reader["QueryArg"].readIfPresent() ?? ""
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryptionProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryptionProfile()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.fieldLevelEncryptionProfileConfig = try reader["FieldLevelEncryptionProfileConfig"].readIfPresent(with: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig {

    static func write(value: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["EncryptionEntities"].write(value.encryptionEntities, with: CloudFrontClientTypes.EncryptionEntities.write(value:to:))
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryptionProfileConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryptionProfileConfig()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.callerReference = try reader["CallerReference"].readIfPresent() ?? ""
        value.comment = try reader["Comment"].readIfPresent()
        value.encryptionEntities = try reader["EncryptionEntities"].readIfPresent(with: CloudFrontClientTypes.EncryptionEntities.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.EncryptionEntities {

    static func write(value: CloudFrontClientTypes.EncryptionEntities?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.EncryptionEntity.write(value:to:), memberNodeInfo: "EncryptionEntity", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.EncryptionEntities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.EncryptionEntities()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.EncryptionEntity.read(from:), memberNodeInfo: "EncryptionEntity", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.EncryptionEntity {

    static func write(value: CloudFrontClientTypes.EncryptionEntity?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FieldPatterns"].write(value.fieldPatterns, with: CloudFrontClientTypes.FieldPatterns.write(value:to:))
        try writer["ProviderId"].write(value.providerId)
        try writer["PublicKeyId"].write(value.publicKeyId)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.EncryptionEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.EncryptionEntity()
        value.publicKeyId = try reader["PublicKeyId"].readIfPresent() ?? ""
        value.providerId = try reader["ProviderId"].readIfPresent() ?? ""
        value.fieldPatterns = try reader["FieldPatterns"].readIfPresent(with: CloudFrontClientTypes.FieldPatterns.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.FieldPatterns {

    static func write(value: CloudFrontClientTypes.FieldPatterns?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "FieldPattern", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldPatterns {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldPatterns()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "FieldPattern", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.FunctionSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FunctionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FunctionSummary()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent()
        value.functionConfig = try reader["FunctionConfig"].readIfPresent(with: CloudFrontClientTypes.FunctionConfig.read(from:))
        value.functionMetadata = try reader["FunctionMetadata"].readIfPresent(with: CloudFrontClientTypes.FunctionMetadata.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.FunctionMetadata {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FunctionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FunctionMetadata()
        value.functionARN = try reader["FunctionARN"].readIfPresent() ?? ""
        value.stage = try reader["Stage"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CloudFrontClientTypes.FunctionConfig {

    static func write(value: CloudFrontClientTypes.FunctionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
        try writer["KeyValueStoreAssociations"].write(value.keyValueStoreAssociations, with: CloudFrontClientTypes.KeyValueStoreAssociations.write(value:to:))
        try writer["Runtime"].write(value.runtime)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FunctionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FunctionConfig()
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        value.runtime = try reader["Runtime"].readIfPresent() ?? .sdkUnknown("")
        value.keyValueStoreAssociations = try reader["KeyValueStoreAssociations"].readIfPresent(with: CloudFrontClientTypes.KeyValueStoreAssociations.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.KeyValueStoreAssociations {

    static func write(value: CloudFrontClientTypes.KeyValueStoreAssociations?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.KeyValueStoreAssociation.write(value:to:), memberNodeInfo: "KeyValueStoreAssociation", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyValueStoreAssociations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyValueStoreAssociations()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KeyValueStoreAssociation.read(from:), memberNodeInfo: "KeyValueStoreAssociation", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.KeyValueStoreAssociation {

    static func write(value: CloudFrontClientTypes.KeyValueStoreAssociation?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["KeyValueStoreARN"].write(value.keyValueStoreARN)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyValueStoreAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyValueStoreAssociation()
        value.keyValueStoreARN = try reader["KeyValueStoreARN"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.Invalidation {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Invalidation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Invalidation()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.invalidationBatch = try reader["InvalidationBatch"].readIfPresent(with: CloudFrontClientTypes.InvalidationBatch.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.InvalidationBatch {

    static func write(value: CloudFrontClientTypes.InvalidationBatch?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Paths"].write(value.paths, with: CloudFrontClientTypes.Paths.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.InvalidationBatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.InvalidationBatch()
        value.paths = try reader["Paths"].readIfPresent(with: CloudFrontClientTypes.Paths.read(from:))
        value.callerReference = try reader["CallerReference"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.Paths {

    static func write(value: CloudFrontClientTypes.Paths?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Path", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Paths {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Paths()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Path", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.KeyGroup {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyGroup()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.keyGroupConfig = try reader["KeyGroupConfig"].readIfPresent(with: CloudFrontClientTypes.KeyGroupConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.KeyGroupConfig {

    static func write(value: CloudFrontClientTypes.KeyGroupConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "PublicKey", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyGroupConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyGroupConfig()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "PublicKey", isFlattened: false) ?? []
        value.comment = try reader["Comment"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.KeyValueStore {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyValueStore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyValueStore()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        value.arn = try reader["ARN"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CloudFrontClientTypes.MonitoringSubscription {

    static func write(value: CloudFrontClientTypes.MonitoringSubscription?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["RealtimeMetricsSubscriptionConfig"].write(value.realtimeMetricsSubscriptionConfig, with: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.MonitoringSubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.MonitoringSubscription()
        value.realtimeMetricsSubscriptionConfig = try reader["RealtimeMetricsSubscriptionConfig"].readIfPresent(with: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig {

    static func write(value: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["RealtimeMetricsSubscriptionStatus"].write(value.realtimeMetricsSubscriptionStatus)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig()
        value.realtimeMetricsSubscriptionStatus = try reader["RealtimeMetricsSubscriptionStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudFrontClientTypes.OriginAccessControl {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginAccessControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginAccessControl()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.originAccessControlConfig = try reader["OriginAccessControlConfig"].readIfPresent(with: CloudFrontClientTypes.OriginAccessControlConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.OriginAccessControlConfig {

    static func write(value: CloudFrontClientTypes.OriginAccessControlConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["OriginAccessControlOriginType"].write(value.originAccessControlOriginType)
        try writer["SigningBehavior"].write(value.signingBehavior)
        try writer["SigningProtocol"].write(value.signingProtocol)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginAccessControlConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginAccessControlConfig()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.signingProtocol = try reader["SigningProtocol"].readIfPresent() ?? .sdkUnknown("")
        value.signingBehavior = try reader["SigningBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.originAccessControlOriginType = try reader["OriginAccessControlOriginType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginRequestPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginRequestPolicy()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.originRequestPolicyConfig = try reader["OriginRequestPolicyConfig"].readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicyConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig {

    static func write(value: CloudFrontClientTypes.OriginRequestPolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
        try writer["CookiesConfig"].write(value.cookiesConfig, with: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.write(value:to:))
        try writer["HeadersConfig"].write(value.headersConfig, with: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["QueryStringsConfig"].write(value.queryStringsConfig, with: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginRequestPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginRequestPolicyConfig()
        value.comment = try reader["Comment"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.headersConfig = try reader["HeadersConfig"].readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.read(from:))
        value.cookiesConfig = try reader["CookiesConfig"].readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.read(from:))
        value.queryStringsConfig = try reader["QueryStringsConfig"].readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig {

    static func write(value: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["QueryStringBehavior"].write(value.queryStringBehavior)
        try writer["QueryStrings"].write(value.queryStrings, with: CloudFrontClientTypes.QueryStringNames.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig()
        value.queryStringBehavior = try reader["QueryStringBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.queryStrings = try reader["QueryStrings"].readIfPresent(with: CloudFrontClientTypes.QueryStringNames.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig {

    static func write(value: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CookieBehavior"].write(value.cookieBehavior)
        try writer["Cookies"].write(value.cookies, with: CloudFrontClientTypes.CookieNames.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginRequestPolicyCookiesConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginRequestPolicyCookiesConfig()
        value.cookieBehavior = try reader["CookieBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.cookies = try reader["Cookies"].readIfPresent(with: CloudFrontClientTypes.CookieNames.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig {

    static func write(value: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["HeaderBehavior"].write(value.headerBehavior)
        try writer["Headers"].write(value.headers, with: CloudFrontClientTypes.Headers.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginRequestPolicyHeadersConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginRequestPolicyHeadersConfig()
        value.headerBehavior = try reader["HeaderBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.headers = try reader["Headers"].readIfPresent(with: CloudFrontClientTypes.Headers.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.PublicKey {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.PublicKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.PublicKey()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.publicKeyConfig = try reader["PublicKeyConfig"].readIfPresent(with: CloudFrontClientTypes.PublicKeyConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.PublicKeyConfig {

    static func write(value: CloudFrontClientTypes.PublicKeyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["EncodedKey"].write(value.encodedKey)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.PublicKeyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.PublicKeyConfig()
        value.callerReference = try reader["CallerReference"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.encodedKey = try reader["EncodedKey"].readIfPresent() ?? ""
        value.comment = try reader["Comment"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.RealtimeLogConfig {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.RealtimeLogConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.RealtimeLogConfig()
        value.arn = try reader["ARN"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.samplingRate = try reader["SamplingRate"].readIfPresent() ?? 0
        value.endPoints = try reader["EndPoints"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.EndPoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Field", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.EndPoint {

    static func write(value: CloudFrontClientTypes.EndPoint?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["KinesisStreamConfig"].write(value.kinesisStreamConfig, with: CloudFrontClientTypes.KinesisStreamConfig.write(value:to:))
        try writer["StreamType"].write(value.streamType)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.EndPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.EndPoint()
        value.streamType = try reader["StreamType"].readIfPresent() ?? ""
        value.kinesisStreamConfig = try reader["KinesisStreamConfig"].readIfPresent(with: CloudFrontClientTypes.KinesisStreamConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.KinesisStreamConfig {

    static func write(value: CloudFrontClientTypes.KinesisStreamConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["RoleARN"].write(value.roleARN)
        try writer["StreamARN"].write(value.streamARN)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KinesisStreamConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KinesisStreamConfig()
        value.roleARN = try reader["RoleARN"].readIfPresent() ?? ""
        value.streamARN = try reader["StreamARN"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicy {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicy()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.responseHeadersPolicyConfig = try reader["ResponseHeadersPolicyConfig"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyConfig {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
        try writer["CorsConfig"].write(value.corsConfig, with: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig.write(value:to:))
        try writer["CustomHeadersConfig"].write(value.customHeadersConfig, with: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RemoveHeadersConfig"].write(value.removeHeadersConfig, with: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig.write(value:to:))
        try writer["SecurityHeadersConfig"].write(value.securityHeadersConfig, with: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig.write(value:to:))
        try writer["ServerTimingHeadersConfig"].write(value.serverTimingHeadersConfig, with: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyConfig()
        value.comment = try reader["Comment"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.corsConfig = try reader["CorsConfig"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig.read(from:))
        value.securityHeadersConfig = try reader["SecurityHeadersConfig"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig.read(from:))
        value.serverTimingHeadersConfig = try reader["ServerTimingHeadersConfig"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig.read(from:))
        value.customHeadersConfig = try reader["CustomHeadersConfig"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig.read(from:))
        value.removeHeadersConfig = try reader["RemoveHeadersConfig"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader.write(value:to:), memberNodeInfo: "ResponseHeadersPolicyRemoveHeader", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader.read(from:), memberNodeInfo: "ResponseHeadersPolicyRemoveHeader", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Header"].write(value.header)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader()
        value.header = try reader["Header"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader.write(value:to:), memberNodeInfo: "ResponseHeadersPolicyCustomHeader", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader.read(from:), memberNodeInfo: "ResponseHeadersPolicyCustomHeader", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Header"].write(value.header)
        try writer["Override"].write(value.`override`)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader()
        value.header = try reader["Header"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.`override` = try reader["Override"].readIfPresent() ?? false
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["SamplingRate"].write(value.samplingRate)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.samplingRate = try reader["SamplingRate"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ContentSecurityPolicy"].write(value.contentSecurityPolicy, with: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy.write(value:to:))
        try writer["ContentTypeOptions"].write(value.contentTypeOptions, with: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions.write(value:to:))
        try writer["FrameOptions"].write(value.frameOptions, with: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions.write(value:to:))
        try writer["ReferrerPolicy"].write(value.referrerPolicy, with: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy.write(value:to:))
        try writer["StrictTransportSecurity"].write(value.strictTransportSecurity, with: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity.write(value:to:))
        try writer["XSSProtection"].write(value.xssProtection, with: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig()
        value.xssProtection = try reader["XSSProtection"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection.read(from:))
        value.frameOptions = try reader["FrameOptions"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions.read(from:))
        value.referrerPolicy = try reader["ReferrerPolicy"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy.read(from:))
        value.contentSecurityPolicy = try reader["ContentSecurityPolicy"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy.read(from:))
        value.contentTypeOptions = try reader["ContentTypeOptions"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions.read(from:))
        value.strictTransportSecurity = try reader["StrictTransportSecurity"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["AccessControlMaxAgeSec"].write(value.accessControlMaxAgeSec)
        try writer["IncludeSubdomains"].write(value.includeSubdomains)
        try writer["Override"].write(value.`override`)
        try writer["Preload"].write(value.preload)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity()
        value.`override` = try reader["Override"].readIfPresent() ?? false
        value.includeSubdomains = try reader["IncludeSubdomains"].readIfPresent()
        value.preload = try reader["Preload"].readIfPresent()
        value.accessControlMaxAgeSec = try reader["AccessControlMaxAgeSec"].readIfPresent() ?? 0
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Override"].write(value.`override`)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions()
        value.`override` = try reader["Override"].readIfPresent() ?? false
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ContentSecurityPolicy"].write(value.contentSecurityPolicy)
        try writer["Override"].write(value.`override`)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy()
        value.`override` = try reader["Override"].readIfPresent() ?? false
        value.contentSecurityPolicy = try reader["ContentSecurityPolicy"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Override"].write(value.`override`)
        try writer["ReferrerPolicy"].write(value.referrerPolicy)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy()
        value.`override` = try reader["Override"].readIfPresent() ?? false
        value.referrerPolicy = try reader["ReferrerPolicy"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["FrameOption"].write(value.frameOption)
        try writer["Override"].write(value.`override`)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions()
        value.`override` = try reader["Override"].readIfPresent() ?? false
        value.frameOption = try reader["FrameOption"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["ModeBlock"].write(value.modeBlock)
        try writer["Override"].write(value.`override`)
        try writer["Protection"].write(value.protection)
        try writer["ReportUri"].write(value.reportUri)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection()
        value.`override` = try reader["Override"].readIfPresent() ?? false
        value.protection = try reader["Protection"].readIfPresent() ?? false
        value.modeBlock = try reader["ModeBlock"].readIfPresent()
        value.reportUri = try reader["ReportUri"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["AccessControlAllowCredentials"].write(value.accessControlAllowCredentials)
        try writer["AccessControlAllowHeaders"].write(value.accessControlAllowHeaders, with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders.write(value:to:))
        try writer["AccessControlAllowMethods"].write(value.accessControlAllowMethods, with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods.write(value:to:))
        try writer["AccessControlAllowOrigins"].write(value.accessControlAllowOrigins, with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins.write(value:to:))
        try writer["AccessControlExposeHeaders"].write(value.accessControlExposeHeaders, with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders.write(value:to:))
        try writer["AccessControlMaxAgeSec"].write(value.accessControlMaxAgeSec)
        try writer["OriginOverride"].write(value.originOverride)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig()
        value.accessControlAllowOrigins = try reader["AccessControlAllowOrigins"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins.read(from:))
        value.accessControlAllowHeaders = try reader["AccessControlAllowHeaders"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders.read(from:))
        value.accessControlAllowMethods = try reader["AccessControlAllowMethods"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods.read(from:))
        value.accessControlAllowCredentials = try reader["AccessControlAllowCredentials"].readIfPresent() ?? false
        value.accessControlExposeHeaders = try reader["AccessControlExposeHeaders"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders.read(from:))
        value.accessControlMaxAgeSec = try reader["AccessControlMaxAgeSec"].readIfPresent()
        value.originOverride = try reader["OriginOverride"].readIfPresent() ?? false
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Header", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Header", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues>().write(value:to:), memberNodeInfo: "Method", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues>().read(from:), memberNodeInfo: "Method", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Header", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Header", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins {

    static func write(value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Origin", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins()
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "Origin", isFlattened: false) ?? []
        return value
    }
}

extension CloudFrontClientTypes.StreamingDistribution {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.StreamingDistribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.StreamingDistribution()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["ARN"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.activeTrustedSigners = try reader["ActiveTrustedSigners"].readIfPresent(with: CloudFrontClientTypes.ActiveTrustedSigners.read(from:))
        value.streamingDistributionConfig = try reader["StreamingDistributionConfig"].readIfPresent(with: CloudFrontClientTypes.StreamingDistributionConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig {

    static func write(value: CloudFrontClientTypes.StreamingDistributionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Aliases"].write(value.aliases, with: CloudFrontClientTypes.Aliases.write(value:to:))
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["Enabled"].write(value.enabled)
        try writer["Logging"].write(value.logging, with: CloudFrontClientTypes.StreamingLoggingConfig.write(value:to:))
        try writer["PriceClass"].write(value.priceClass)
        try writer["S3Origin"].write(value.s3Origin, with: CloudFrontClientTypes.S3Origin.write(value:to:))
        try writer["TrustedSigners"].write(value.trustedSigners, with: CloudFrontClientTypes.TrustedSigners.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.StreamingDistributionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.StreamingDistributionConfig()
        value.callerReference = try reader["CallerReference"].readIfPresent() ?? ""
        value.s3Origin = try reader["S3Origin"].readIfPresent(with: CloudFrontClientTypes.S3Origin.read(from:))
        value.aliases = try reader["Aliases"].readIfPresent(with: CloudFrontClientTypes.Aliases.read(from:))
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        value.logging = try reader["Logging"].readIfPresent(with: CloudFrontClientTypes.StreamingLoggingConfig.read(from:))
        value.trustedSigners = try reader["TrustedSigners"].readIfPresent(with: CloudFrontClientTypes.TrustedSigners.read(from:))
        value.priceClass = try reader["PriceClass"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension CloudFrontClientTypes.StreamingLoggingConfig {

    static func write(value: CloudFrontClientTypes.StreamingLoggingConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["Enabled"].write(value.enabled)
        try writer["Prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.StreamingLoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.StreamingLoggingConfig()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.`prefix` = try reader["Prefix"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.S3Origin {

    static func write(value: CloudFrontClientTypes.S3Origin?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["OriginAccessIdentity"].write(value.originAccessIdentity)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.S3Origin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.S3Origin()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.originAccessIdentity = try reader["OriginAccessIdentity"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.CachePolicyList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachePolicyList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachePolicyList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CachePolicySummary.read(from:), memberNodeInfo: "CachePolicySummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.CachePolicySummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CachePolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CachePolicySummary()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.cachePolicy = try reader["CachePolicy"].readIfPresent(with: CloudFrontClientTypes.CachePolicy.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CloudFrontOriginAccessIdentityList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentityList()
        value.marker = try reader["Marker"].readIfPresent() ?? ""
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary.read(from:), memberNodeInfo: "CloudFrontOriginAccessIdentitySummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.s3CanonicalUserId = try reader["S3CanonicalUserId"].readIfPresent() ?? ""
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.ConflictingAliasesList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ConflictingAliasesList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ConflictingAliasesList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent()
        value.quantity = try reader["Quantity"].readIfPresent()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ConflictingAlias.read(from:), memberNodeInfo: "ConflictingAlias", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ConflictingAlias {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ConflictingAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ConflictingAlias()
        value.alias = try reader["Alias"].readIfPresent()
        value.distributionId = try reader["DistributionId"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContinuousDeploymentPolicyList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContinuousDeploymentPolicyList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicySummary.read(from:), memberNodeInfo: "ContinuousDeploymentPolicySummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicySummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ContinuousDeploymentPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ContinuousDeploymentPolicySummary()
        value.continuousDeploymentPolicy = try reader["ContinuousDeploymentPolicy"].readIfPresent(with: CloudFrontClientTypes.ContinuousDeploymentPolicy.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.DistributionList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.DistributionList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.DistributionList()
        value.marker = try reader["Marker"].readIfPresent() ?? ""
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.DistributionSummary.read(from:), memberNodeInfo: "DistributionSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.DistributionSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.DistributionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.DistributionSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["ARN"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.aliases = try reader["Aliases"].readIfPresent(with: CloudFrontClientTypes.Aliases.read(from:))
        value.origins = try reader["Origins"].readIfPresent(with: CloudFrontClientTypes.Origins.read(from:))
        value.originGroups = try reader["OriginGroups"].readIfPresent(with: CloudFrontClientTypes.OriginGroups.read(from:))
        value.defaultCacheBehavior = try reader["DefaultCacheBehavior"].readIfPresent(with: CloudFrontClientTypes.DefaultCacheBehavior.read(from:))
        value.cacheBehaviors = try reader["CacheBehaviors"].readIfPresent(with: CloudFrontClientTypes.CacheBehaviors.read(from:))
        value.customErrorResponses = try reader["CustomErrorResponses"].readIfPresent(with: CloudFrontClientTypes.CustomErrorResponses.read(from:))
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        value.priceClass = try reader["PriceClass"].readIfPresent() ?? .sdkUnknown("")
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.viewerCertificate = try reader["ViewerCertificate"].readIfPresent(with: CloudFrontClientTypes.ViewerCertificate.read(from:))
        value.restrictions = try reader["Restrictions"].readIfPresent(with: CloudFrontClientTypes.Restrictions.read(from:))
        value.webACLId = try reader["WebACLId"].readIfPresent() ?? ""
        value.httpVersion = try reader["HttpVersion"].readIfPresent() ?? .sdkUnknown("")
        value.isIPV6Enabled = try reader["IsIPV6Enabled"].readIfPresent() ?? false
        value.aliasICPRecordals = try reader["AliasICPRecordals"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.AliasICPRecordal.read(from:), memberNodeInfo: "AliasICPRecordal", isFlattened: false)
        value.staging = try reader["Staging"].readIfPresent() ?? false
        return value
    }
}

extension CloudFrontClientTypes.DistributionIdList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.DistributionIdList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.DistributionIdList()
        value.marker = try reader["Marker"].readIfPresent() ?? ""
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "DistributionId", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryptionList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryptionList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FieldLevelEncryptionSummary.read(from:), memberNodeInfo: "FieldLevelEncryptionSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryptionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryptionSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.comment = try reader["Comment"].readIfPresent()
        value.queryArgProfileConfig = try reader["QueryArgProfileConfig"].readIfPresent(with: CloudFrontClientTypes.QueryArgProfileConfig.read(from:))
        value.contentTypeProfileConfig = try reader["ContentTypeProfileConfig"].readIfPresent(with: CloudFrontClientTypes.ContentTypeProfileConfig.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryptionProfileList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryptionProfileList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileSummary.read(from:), memberNodeInfo: "FieldLevelEncryptionProfileSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FieldLevelEncryptionProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FieldLevelEncryptionProfileSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.encryptionEntities = try reader["EncryptionEntities"].readIfPresent(with: CloudFrontClientTypes.EncryptionEntities.read(from:))
        value.comment = try reader["Comment"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.FunctionList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.FunctionList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.FunctionList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FunctionSummary.read(from:), memberNodeInfo: "FunctionSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.InvalidationList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.InvalidationList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.InvalidationList()
        value.marker = try reader["Marker"].readIfPresent() ?? ""
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.InvalidationSummary.read(from:), memberNodeInfo: "InvalidationSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.InvalidationSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.InvalidationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.InvalidationSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontClientTypes.KeyGroupList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyGroupList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyGroupList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KeyGroupSummary.read(from:), memberNodeInfo: "KeyGroupSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.KeyGroupSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyGroupSummary()
        value.keyGroup = try reader["KeyGroup"].readIfPresent(with: CloudFrontClientTypes.KeyGroup.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.KeyValueStoreList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.KeyValueStoreList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.KeyValueStoreList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KeyValueStore.read(from:), memberNodeInfo: "KeyValueStore", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.OriginAccessControlList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginAccessControlList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginAccessControlList()
        value.marker = try reader["Marker"].readIfPresent() ?? ""
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginAccessControlSummary.read(from:), memberNodeInfo: "OriginAccessControlSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.OriginAccessControlSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginAccessControlSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginAccessControlSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.signingProtocol = try reader["SigningProtocol"].readIfPresent() ?? .sdkUnknown("")
        value.signingBehavior = try reader["SigningBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.originAccessControlOriginType = try reader["OriginAccessControlOriginType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginRequestPolicyList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginRequestPolicyList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginRequestPolicySummary.read(from:), memberNodeInfo: "OriginRequestPolicySummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.OriginRequestPolicySummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.OriginRequestPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.OriginRequestPolicySummary()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.originRequestPolicy = try reader["OriginRequestPolicy"].readIfPresent(with: CloudFrontClientTypes.OriginRequestPolicy.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.PublicKeyList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.PublicKeyList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.PublicKeyList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.PublicKeySummary.read(from:), memberNodeInfo: "PublicKeySummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.PublicKeySummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.PublicKeySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.PublicKeySummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.encodedKey = try reader["EncodedKey"].readIfPresent() ?? ""
        value.comment = try reader["Comment"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.RealtimeLogConfigs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.RealtimeLogConfigs()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.RealtimeLogConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.marker = try reader["Marker"].readIfPresent() ?? ""
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicyList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicyList()
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ResponseHeadersPolicySummary.read(from:), memberNodeInfo: "ResponseHeadersPolicySummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicySummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.ResponseHeadersPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.ResponseHeadersPolicySummary()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.responseHeadersPolicy = try reader["ResponseHeadersPolicy"].readIfPresent(with: CloudFrontClientTypes.ResponseHeadersPolicy.read(from:))
        return value
    }
}

extension CloudFrontClientTypes.StreamingDistributionList {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.StreamingDistributionList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.StreamingDistributionList()
        value.marker = try reader["Marker"].readIfPresent() ?? ""
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent() ?? 0
        value.isTruncated = try reader["IsTruncated"].readIfPresent() ?? false
        value.quantity = try reader["Quantity"].readIfPresent() ?? 0
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.StreamingDistributionSummary.read(from:), memberNodeInfo: "StreamingDistributionSummary", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.StreamingDistributionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.StreamingDistributionSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["ARN"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.s3Origin = try reader["S3Origin"].readIfPresent(with: CloudFrontClientTypes.S3Origin.read(from:))
        value.aliases = try reader["Aliases"].readIfPresent(with: CloudFrontClientTypes.Aliases.read(from:))
        value.trustedSigners = try reader["TrustedSigners"].readIfPresent(with: CloudFrontClientTypes.TrustedSigners.read(from:))
        value.comment = try reader["Comment"].readIfPresent() ?? ""
        value.priceClass = try reader["PriceClass"].readIfPresent() ?? .sdkUnknown("")
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension CloudFrontClientTypes.Tags {

    static func write(value: CloudFrontClientTypes.Tags?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.Tag.write(value:to:), memberNodeInfo: "Tag", isFlattened: false)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Tags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Tags()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Tag.read(from:), memberNodeInfo: "Tag", isFlattened: false)
        return value
    }
}

extension CloudFrontClientTypes.Tag {

    static func write(value: CloudFrontClientTypes.Tag?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.TestResult {

    static func read(from reader: SmithyXML.Reader) throws -> CloudFrontClientTypes.TestResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontClientTypes.TestResult()
        value.functionSummary = try reader["FunctionSummary"].readIfPresent(with: CloudFrontClientTypes.FunctionSummary.read(from:))
        value.computeUtilization = try reader["ComputeUtilization"].readIfPresent()
        value.functionExecutionLogs = try reader["FunctionExecutionLogs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.functionErrorMessage = try reader["FunctionErrorMessage"].readIfPresent()
        value.functionOutput = try reader["FunctionOutput"].readIfPresent()
        return value
    }
}

extension CloudFrontClientTypes.DistributionConfigWithTags {

    static func write(value: CloudFrontClientTypes.DistributionConfigWithTags?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["DistributionConfig"].write(value.distributionConfig, with: CloudFrontClientTypes.DistributionConfig.write(value:to:))
        try writer["Tags"].write(value.tags, with: CloudFrontClientTypes.Tags.write(value:to:))
    }
}

extension CloudFrontClientTypes.ImportSource {

    static func write(value: CloudFrontClientTypes.ImportSource?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["SourceARN"].write(value.sourceARN)
        try writer["SourceType"].write(value.sourceType)
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags {

    static func write(value: CloudFrontClientTypes.StreamingDistributionConfigWithTags?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["StreamingDistributionConfig"].write(value.streamingDistributionConfig, with: CloudFrontClientTypes.StreamingDistributionConfig.write(value:to:))
        try writer["Tags"].write(value.tags, with: CloudFrontClientTypes.Tags.write(value:to:))
    }
}

extension CloudFrontClientTypes.TagKeys {

    static func write(value: CloudFrontClientTypes.TagKeys?, to writer: SmithyXML.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "Key", isFlattened: false)
    }
}

public enum CloudFrontClientTypes {}
