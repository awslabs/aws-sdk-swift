// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDenied {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<AccessDeniedBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access denied.
public struct AccessDenied: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for kgkeypairids0 in items {
                try itemsContainer.encode(kgkeypairids0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KGKeyPairIds].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KGKeyPairIds]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KGKeyPairIds]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups, and the public keys in each key group, that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups, including the identifiers of the public keys in each key group that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.KGKeyPairIds]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.KGKeyPairIds]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ActiveTrustedSigners: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for signer0 in items {
                try itemsContainer.encode(signer0, forKey: ClientRuntime.Key("Signer"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Signer{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Signer>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Signer].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Signer]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Signer]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedSigners: Swift.Equatable {
        /// This field is true if any of the Amazon Web Services accounts in the list are configured as trusted signers. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services accounts and the identifiers of active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.Signer]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.Signer]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AliasICPRecordal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cname = "CNAME"
        case icpRecordalStatus = "ICPRecordalStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cname = cname {
            try container.encode(cname, forKey: ClientRuntime.Key("CNAME"))
        }
        if let icpRecordalStatus = icpRecordalStatus {
            try container.encode(icpRecordalStatus, forKey: ClientRuntime.Key("ICPRecordalStatus"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cname)
        cname = cnameDecoded
        let icpRecordalStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ICPRecordalStatus.self, forKey: .icpRecordalStatus)
        icpRecordalStatus = icpRecordalStatusDecoded
    }
}

extension CloudFrontClientTypes.AliasICPRecordal: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure it yourself. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
    public struct AliasICPRecordal: Swift.Equatable {
        /// A domain name associated with a distribution.
        public var cname: Swift.String?
        /// The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to APPROVED for all CNAMEs (aliases) in regions outside of China. The status values returned are the following:
        ///
        /// * APPROVED indicates that the associated CNAME has a valid ICP recordal number. Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.
        ///
        /// * SUSPENDED indicates that the associated CNAME does not have a valid ICP recordal number.
        ///
        /// * PENDING indicates that CloudFront can't determine the ICP recordal status of the CNAME associated with the distribution because there was an error in trying to determine the status. You can try again to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.
        public var icpRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus?

        public init(
            cname: Swift.String? = nil,
            icpRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus? = nil
        )
        {
            self.cname = cname
            self.icpRecordalStatus = icpRecordalStatus
        }
    }

}

extension CloudFrontClientTypes.Aliases: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("CNAME"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CNAME{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CNAME>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Aliases: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
    public struct Aliases: Swift.Equatable {
        /// A complex type that contains the CNAME aliases, if any, that you want to associate with this distribution.
        public var items: [Swift.String]?
        /// The number of CNAME aliases, if any, that you want to associate with this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AllowedMethods: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachedMethods = "CachedMethods"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachedMethods = cachedMethods {
            try container.encode(cachedMethods, forKey: ClientRuntime.Key("CachedMethods"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for enumContainer0 in itemsContainer {
                        itemsBuffer?.append(enumContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let cachedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachedMethods.self, forKey: .cachedMethods)
        cachedMethods = cachedMethodsDecoded
    }
}

extension CloudFrontClientTypes.AllowedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
    ///
    /// * CloudFront forwards only GET and HEAD requests.
    ///
    /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
    ///
    /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
    ///
    ///
    /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
    public struct AllowedMethods: Swift.Equatable {
        /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
        ///
        /// * CloudFront caches responses to GET and HEAD requests.
        ///
        /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
        ///
        ///
        /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        public var cachedMethods: CloudFrontClientTypes.CachedMethods?
        /// A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD, and OPTIONS requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            cachedMethods: CloudFrontClientTypes.CachedMethods? = nil,
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.cachedMethods = cachedMethods
            self.items = items
            self.quantity = quantity
        }
    }

}

extension AssociateAliasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let alias = alias else {
                let message = "Creating a URL Query Item failed. alias is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
            return items
        }
    }
}

extension AssociateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetDistributionId = targetDistributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(targetDistributionId.urlPercentEncoding())/associate-alias"
    }
}

public struct AssociateAliasInput: Swift.Equatable {
    /// The alias (also known as a CNAME) to add to the target distribution.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the distribution that you're associating the alias with.
    /// This member is required.
    public var targetDistributionId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        targetDistributionId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.targetDistributionId = targetDistributionId
    }
}

struct AssociateAliasInputBody: Swift.Equatable {
}

extension AssociateAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateAliasOutput: Swift.Equatable {

    public init() { }
}

enum AssociateAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension BatchTooLarge {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<BatchTooLargeBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Invalidation batch specified is too large.
public struct BatchTooLarge: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchTooLarge" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BatchTooLargeBody: Swift.Equatable {
    let message: Swift.String?
}

extension BatchTooLargeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CNAMEAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CNAMEAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The CNAME specified is already defined for CloudFront.
public struct CNAMEAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CNAMEAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CNAMEAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CNAMEAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case pathPattern = "PathPattern"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case responseHeadersPolicyId = "ResponseHeadersPolicyId"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let pathPattern = pathPattern {
            try container.encode(pathPattern, forKey: ClientRuntime.Key("PathPattern"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let responseHeadersPolicyId = responseHeadersPolicyId {
            try container.encode(responseHeadersPolicyId, forKey: ClientRuntime.Key("ResponseHeadersPolicyId"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPattern)
        pathPattern = pathPatternDecoded
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let responseHeadersPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseHeadersPolicyId)
        responseHeadersPolicyId = responseHeadersPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes how CloudFront processes requests. You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to serve objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin is never used. For the current quota (formerly known as limit) on the number of cache behaviors that you can add to a distribution, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) in the Amazon CloudFront Developer Guide. If you don't want to specify any cache behaviors, include only an empty CacheBehaviors element. Don't include an empty CacheBehavior element because this is invalid. To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty CacheBehaviors element. To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution. For more information about cache behaviors, see [Cache Behavior Settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior) in the Amazon CloudFront Developer Guide.
    public struct CacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to this cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for this cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [ Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to this cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The pattern (for example, images/*.jpg) that specifies which requests to apply the behavior to. When CloudFront receives a viewer request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. You can optionally include a slash (/) at the beginning of the path pattern. For example, /images/*.jpg. CloudFront behavior is the same with or without the leading /. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior. For more information, see [Path Pattern](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var pathPattern: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they match this cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in the trusted signer's Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init(
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            pathPattern: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.pathPattern = pathPattern
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension CloudFrontClientTypes.CacheBehaviors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachebehavior0 in items {
                try itemsContainer.encode(cachebehavior0, forKey: ClientRuntime.Key("CacheBehavior"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CacheBehavior{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheBehavior>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CacheBehavior].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CacheBehavior]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CacheBehavior]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CacheBehaviors: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more CacheBehavior elements.
    public struct CacheBehaviors: Swift.Equatable {
        /// Optional: A complex type that contains cache behaviors for this distribution. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.CacheBehavior]?
        /// The number of cache behaviors for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CacheBehavior]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CachePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.CachePolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A cache policy. When it's attached to a cache behavior, the cache policy determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find a valid object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicy: Swift.Equatable {
        /// The cache policy configuration.
        /// This member is required.
        public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
        /// The unique identifier for the cache policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the cache policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.cachePolicyConfig = cachePolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CachePolicyAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CachePolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use UpdateCachePolicy.
public struct CachePolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CachePolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CachePolicyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CachePolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case defaultTTL = "DefaultTTL"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case name = "Name"
        case parametersInCacheKeyAndForwardedToOrigin = "ParametersInCacheKeyAndForwardedToOrigin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin {
            try container.encode(parametersInCacheKeyAndForwardedToOrigin, forKey: ClientRuntime.Key("ParametersInCacheKeyAndForwardedToOrigin"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let parametersInCacheKeyAndForwardedToOriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.self, forKey: .parametersInCacheKeyAndForwardedToOrigin)
        parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOriginDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A cache policy configuration. This configuration determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find a valid object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicyConfig: Swift.Equatable {
        /// A comment to describe the cache policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value as the object's time to live (TTL) only when the origin does not send Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 86400 seconds (one day). If the value of MinTTL is more than 86400 seconds, then the default value for this field is the same as the value of MinTTL.
        public var defaultTTL: Swift.Int?
        /// The maximum amount of time, in seconds, that objects stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value only when the origin sends Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 31536000 seconds (one year). If the value of MinTTL or DefaultTTL is more than 31536000 seconds, then the default value for this field is the same as the value of DefaultTTL.
        public var maxTTL: Swift.Int?
        /// The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var minTTL: Swift.Int?
        /// A unique name to identify the cache policy.
        /// This member is required.
        public var name: Swift.String?
        /// The HTTP headers, cookies, and URL query strings to include in the cache key. The values included in the cache key are also included in requests that CloudFront sends to the origin.
        public var parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?

        public init(
            comment: Swift.String? = nil,
            defaultTTL: Swift.Int? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            name: Swift.String? = nil,
            parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin? = nil
        )
        {
            self.comment = comment
            self.defaultTTL = defaultTTL
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.name = name
            self.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyCookieBehavior(rawValue: rawValue) ?? CachePolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyCookiesConfig: Swift.Equatable {
        /// Determines whether any cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none  No cookies in viewer requests are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist  Only the cookies in viewer requests that are listed in the CookieNames type are included in the cache key and in requests that CloudFront sends to the origin.
        ///
        /// * allExcept  All cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin, except for those that are listed in the CookieNames type, which are not included.
        ///
        /// * all  All cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init(
            cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyHeaderBehavior] {
            return [
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyHeaderBehavior(rawValue: rawValue) ?? CachePolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none  No HTTP headers are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist  Only the HTTP headers that are listed in the Headers type are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init(
            headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension CachePolicyInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CachePolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot delete the cache policy because it is attached to one or more cache behaviors.
public struct CachePolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CachePolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CachePolicyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension CachePolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachepolicysummary0 in items {
                try itemsContainer.encode(cachepolicysummary0, forKey: ClientRuntime.Key("CachePolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CachePolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CachePolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CachePolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CachePolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CachePolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachePolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of cache policies.
    public struct CachePolicyList: Swift.Equatable {
        /// Contains the cache policies in the list.
        public var items: [CloudFrontClientTypes.CachePolicySummary]?
        /// The maximum number of cache policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing cache policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of cache policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CachePolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyQueryStringBehavior(rawValue: rawValue) ?? CachePolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none  No query strings in viewer requests are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist  Only the query strings in viewer requests that are listed in the QueryStringNames type are included in the cache key and in requests that CloudFront sends to the origin.
        ///
        /// * allExcept  All query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin, except those that are listed in the QueryStringNames type, which are not included.
        ///
        /// * all  All query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in the cache key and in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the CachePolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init(
            queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.CachePolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicy = cachePolicy {
            try container.encode(cachePolicy, forKey: ClientRuntime.Key("CachePolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyType.self, forKey: .type)
        type = typeDecoded
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension CloudFrontClientTypes.CachePolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a cache policy.
    public struct CachePolicySummary: Swift.Equatable {
        /// The cache policy.
        /// This member is required.
        public var cachePolicy: CloudFrontClientTypes.CachePolicy?
        /// The type of cache policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.CachePolicyType?

        public init(
            cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
            type: CloudFrontClientTypes.CachePolicyType? = nil
        )
        {
            self.cachePolicy = cachePolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyType(rawValue: rawValue) ?? CachePolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for enumContainer0 in itemsContainer {
                        itemsBuffer?.append(enumContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
    ///
    /// * CloudFront caches responses to GET and HEAD requests.
    ///
    /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
    ///
    ///
    /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
    public struct CachedMethods: Swift.Equatable {
        /// A complex type that contains the HTTP methods that you want CloudFront to cache responses to.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods for which you want CloudFront to cache responses. Valid values are 2 (for caching responses to GET and HEAD requests) and 3 (for caching responses to GET, HEAD, and OPTIONS requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CannotChangeImmutablePublicKeyFields {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CannotChangeImmutablePublicKeyFieldsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't change the value of a public key.
public struct CannotChangeImmutablePublicKeyFields: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotChangeImmutablePublicKeyFields" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CannotChangeImmutablePublicKeyFieldsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotChangeImmutablePublicKeyFieldsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum CertificateSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acm
        case cloudfront
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateSource] {
            return [
                .acm,
                .cloudfront,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acm: return "acm"
            case .cloudfront: return "cloudfront"
            case .iam: return "iam"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateSource(rawValue: rawValue) ?? CertificateSource.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentity: Swift.Equatable {
        /// The current configuration information for the identity.
        public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
        /// The ID for the origin access identity, for example, E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, used when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init(
            cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontOriginAccessIdentityAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CloudFrontOriginAccessIdentityAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
public struct CloudFrontOriginAccessIdentityAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudFrontOriginAccessIdentityAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Origin access identity configuration. Send a GET request to the /CloudFront API version/CloudFront/identity ID/config resource.
    public struct CloudFrontOriginAccessIdentityConfig: Swift.Equatable {
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the CloudFrontOriginAccessIdentityConfig object), a new origin access identity is created. If the CallerReference is a value already sent in a previous identity request, and the content of the CloudFrontOriginAccessIdentityConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create an identity, but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the origin access identity. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
        }
    }

}

extension CloudFrontOriginAccessIdentityInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CloudFrontOriginAccessIdentityInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Origin Access Identity specified is already in use.
public struct CloudFrontOriginAccessIdentityInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudFrontOriginAccessIdentityInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudFrontOriginAccessIdentityInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cloudfrontoriginaccessidentitysummary0 in items {
                try itemsContainer.encode(cloudfrontoriginaccessidentitysummary0, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentitySummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CloudFrontOriginAccessIdentitySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CloudFrontOriginAccessIdentitySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Lists the origin access identities for CloudFront.Send a GET request to the /CloudFront API version/origin-access-identity/cloudfront resource. The response includes a CloudFrontOriginAccessIdentityList element with zero or more CloudFrontOriginAccessIdentitySummary child elements. By default, your entire list of origin access identities is returned in one single page. If the list is long, you can paginate it using the MaxItems and Marker parameters.
    public struct CloudFrontOriginAccessIdentityList: Swift.Equatable {
        /// A flag that indicates whether more origin access identities remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more items in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one CloudFrontOriginAccessIdentitySummary element for each origin access identity that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]?
        /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access identities you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your origin access identities where they left off.
        public var nextMarker: Swift.String?
        /// The number of CloudFront origin access identities that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Summary of the information about a CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentitySummary: Swift.Equatable {
        /// The comment for this origin access identity, as originally specified when created.
        /// This member is required.
        public var comment: Swift.String?
        /// The ID for the origin access identity. For example: E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init(
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.comment = comment
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alias = "Alias"
        case distributionId = "DistributionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let alias = alias {
            try container.encode(alias, forKey: ClientRuntime.Key("Alias"))
        }
        if let distributionId = distributionId {
            try container.encode(distributionId, forKey: ClientRuntime.Key("DistributionId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let distributionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionId)
        distributionId = distributionIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension CloudFrontClientTypes.ConflictingAlias: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An alias (also called a CNAME) and the CloudFront distribution and Amazon Web Services account ID that it's associated with. The distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don't own.
    public struct ConflictingAlias: Swift.Equatable {
        /// The (partially hidden) ID of the Amazon Web Services account that owns the distribution that's associated with the alias.
        public var accountId: Swift.String?
        /// An alias (also called a CNAME).
        public var alias: Swift.String?
        /// The (partially hidden) ID of the CloudFront distribution associated with the alias.
        public var distributionId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            alias: Swift.String? = nil,
            distributionId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.alias = alias
            self.distributionId = distributionId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAliasesList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for conflictingalias0 in items {
                try itemsContainer.encode(conflictingalias0, forKey: ClientRuntime.Key("ConflictingAlias"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ConflictingAlias{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ConflictingAlias>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ConflictingAlias].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ConflictingAlias]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ConflictingAlias]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ConflictingAliasesList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of aliases (also called CNAMEs) and the CloudFront distributions and Amazon Web Services accounts that they are associated with. In the list, the distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don't own.
    public struct ConflictingAliasesList: Swift.Equatable {
        /// Contains the conflicting aliases in the list.
        public var items: [CloudFrontClientTypes.ConflictingAlias]?
        /// The maximum number of conflicting aliases requested.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing conflicting aliases where you left off.
        public var nextMarker: Swift.String?
        /// The number of conflicting aliases returned in the response.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ConflictingAlias]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case format = "Format"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentType = contentType {
            try container.encode(contentType, forKey: ClientRuntime.Key("ContentType"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A field-level encryption content type profile.
    public struct ContentTypeProfile: Swift.Equatable {
        /// The content type for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var contentType: Swift.String?
        /// The format for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var format: CloudFrontClientTypes.Format?
        /// The profile ID for a field-level encryption content type-profile mapping.
        public var profileId: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            format: CloudFrontClientTypes.Format? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.format = format
            self.profileId = profileId
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentTypeProfiles = "ContentTypeProfiles"
        case forwardWhenContentTypeIsUnknown = "ForwardWhenContentTypeIsUnknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentTypeProfiles = contentTypeProfiles {
            try container.encode(contentTypeProfiles, forKey: ClientRuntime.Key("ContentTypeProfiles"))
        }
        if let forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown {
            try container.encode(forwardWhenContentTypeIsUnknown, forKey: ClientRuntime.Key("ForwardWhenContentTypeIsUnknown"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenContentTypeIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenContentTypeIsUnknown)
        forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknownDecoded
        let contentTypeProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfiles.self, forKey: .contentTypeProfiles)
        contentTypeProfiles = contentTypeProfilesDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The configuration for a field-level encryption content type-profile mapping.
    public struct ContentTypeProfileConfig: Swift.Equatable {
        /// The configuration for a field-level encryption content type-profile.
        public var contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles?
        /// The setting in a field-level encryption content type-profile mapping that specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
        /// This member is required.
        public var forwardWhenContentTypeIsUnknown: Swift.Bool?

        public init(
            contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles? = nil,
            forwardWhenContentTypeIsUnknown: Swift.Bool? = nil
        )
        {
            self.contentTypeProfiles = contentTypeProfiles
            self.forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for contenttypeprofile0 in items {
                try itemsContainer.encode(contenttypeprofile0, forKey: ClientRuntime.Key("ContentTypeProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ContentTypeProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ContentTypeProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ContentTypeProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ContentTypeProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ContentTypeProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ContentTypeProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Field-level encryption content type-profile.
    public struct ContentTypeProfiles: Swift.Equatable {
        /// Items in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.ContentTypeProfile]?
        /// The number of field-level encryption content type-profile mappings.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ContentTypeProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContinuousDeploymentPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicyConfig = "ContinuousDeploymentPolicyConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig {
            try container.encode(continuousDeploymentPolicyConfig, forKey: ClientRuntime.Key("ContinuousDeploymentPolicyConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let continuousDeploymentPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.self, forKey: .continuousDeploymentPolicyConfig)
        continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A continuous deployment policy.
    public struct ContinuousDeploymentPolicy: Swift.Equatable {
        /// Contains the configuration for a continuous deployment policy.
        /// This member is required.
        public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
        /// The identifier of the continuous deployment policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the continuous deployment policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension ContinuousDeploymentPolicyAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ContinuousDeploymentPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A continuous deployment policy with this configuration already exists.
public struct ContinuousDeploymentPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContinuousDeploymentPolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ContinuousDeploymentPolicyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContinuousDeploymentPolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case stagingDistributionDnsNames = "StagingDistributionDnsNames"
        case trafficConfig = "TrafficConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let stagingDistributionDnsNames = stagingDistributionDnsNames {
            try container.encode(stagingDistributionDnsNames, forKey: ClientRuntime.Key("StagingDistributionDnsNames"))
        }
        if let trafficConfig = trafficConfig {
            try container.encode(trafficConfig, forKey: ClientRuntime.Key("TrafficConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingDistributionDnsNamesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StagingDistributionDnsNames.self, forKey: .stagingDistributionDnsNames)
        stagingDistributionDnsNames = stagingDistributionDnsNamesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let trafficConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrafficConfig.self, forKey: .trafficConfig)
        trafficConfig = trafficConfigDecoded
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains the configuration for a continuous deployment policy.
    public struct ContinuousDeploymentPolicyConfig: Swift.Equatable {
        /// A Boolean that indicates whether this continuous deployment policy is enabled (in effect). When this value is true, this policy is enabled and in effect. When this value is false, this policy is not enabled and has no effect.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The CloudFront domain name of the staging distribution. For example: d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var stagingDistributionDnsNames: CloudFrontClientTypes.StagingDistributionDnsNames?
        /// Contains the parameters for routing production traffic from your primary to staging distributions.
        public var trafficConfig: CloudFrontClientTypes.TrafficConfig?

        public init(
            enabled: Swift.Bool? = nil,
            stagingDistributionDnsNames: CloudFrontClientTypes.StagingDistributionDnsNames? = nil,
            trafficConfig: CloudFrontClientTypes.TrafficConfig? = nil
        )
        {
            self.enabled = enabled
            self.stagingDistributionDnsNames = stagingDistributionDnsNames
            self.trafficConfig = trafficConfig
        }
    }

}

extension ContinuousDeploymentPolicyInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ContinuousDeploymentPolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot delete a continuous deployment policy that is associated with a primary distribution.
public struct ContinuousDeploymentPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContinuousDeploymentPolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ContinuousDeploymentPolicyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContinuousDeploymentPolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for continuousdeploymentpolicysummary0 in items {
                try itemsContainer.encode(continuousdeploymentpolicysummary0, forKey: ClientRuntime.Key("ContinuousDeploymentPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ContinuousDeploymentPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ContinuousDeploymentPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ContinuousDeploymentPolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ContinuousDeploymentPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ContinuousDeploymentPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of continuous deployment policies.
    public struct ContinuousDeploymentPolicyList: Swift.Equatable {
        /// A list of continuous deployment policy items.
        public var items: [CloudFrontClientTypes.ContinuousDeploymentPolicySummary]?
        /// The maximum number of continuous deployment policies that were specified in your request.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Indicates the next page of continuous deployment policies. To get the next page of the list, use this value in the Marker field of your request.
        public var nextMarker: Swift.String?
        /// The total number of continuous deployment policies in your Amazon Web Services account, regardless of the MaxItems value.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ContinuousDeploymentPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContinuousDeploymentPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicy = "ContinuousDeploymentPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let continuousDeploymentPolicy = continuousDeploymentPolicy {
            try container.encode(continuousDeploymentPolicy, forKey: ClientRuntime.Key("ContinuousDeploymentPolicy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicy.self, forKey: .continuousDeploymentPolicy)
        continuousDeploymentPolicy = continuousDeploymentPolicyDecoded
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information about your continuous deployment policies.
    public struct ContinuousDeploymentPolicySummary: Swift.Equatable {
        /// The continuous deployment policy.
        /// This member is required.
        public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?

        public init(
            continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil
        )
        {
            self.continuousDeploymentPolicy = continuousDeploymentPolicy
        }
    }

}

extension CloudFrontClientTypes {
    public enum ContinuousDeploymentPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case singleheader
        case singleweight
        case sdkUnknown(Swift.String)

        public static var allCases: [ContinuousDeploymentPolicyType] {
            return [
                .singleheader,
                .singleweight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singleheader: return "SingleHeader"
            case .singleweight: return "SingleWeight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContinuousDeploymentPolicyType(rawValue: rawValue) ?? ContinuousDeploymentPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case header = "Header"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let header = header {
            try container.encode(header, forKey: ClientRuntime.Key("Header"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .header)
        header = headerDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This configuration determines which HTTP requests are sent to the staging distribution. If the HTTP request contains a header and value that matches what you specify here, the request is sent to the staging distribution. Otherwise the request is sent to the primary distribution.
    public struct ContinuousDeploymentSingleHeaderConfig: Swift.Equatable {
        /// The request header name that you want CloudFront to send to your staging distribution. The header must contain the prefix aws-cf-cd-.
        /// This member is required.
        public var header: Swift.String?
        /// The request header value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            header: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.header = header
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionStickinessConfig = "SessionStickinessConfig"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let sessionStickinessConfig = sessionStickinessConfig {
            try container.encode(sessionStickinessConfig, forKey: ClientRuntime.Key("SessionStickinessConfig"))
        }
        if let weight = weight {
            try container.encode(weight, forKey: ClientRuntime.Key("Weight"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .weight)
        weight = weightDecoded
        let sessionStickinessConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.SessionStickinessConfig.self, forKey: .sessionStickinessConfig)
        sessionStickinessConfig = sessionStickinessConfigDecoded
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains the percentage of traffic to send to a staging distribution.
    public struct ContinuousDeploymentSingleWeightConfig: Swift.Equatable {
        /// Session stickiness provides the ability to define multiple requests from a single viewer as a single session. This prevents the potentially inconsistent experience of sending some of a given user's requests to your staging distribution, while others are sent to your primary distribution. Define the session duration using TTL values.
        public var sessionStickinessConfig: CloudFrontClientTypes.SessionStickinessConfig?
        /// The percentage of traffic to send to a staging distribution, expressed as a decimal number between 0 and .15.
        /// This member is required.
        public var weight: Swift.Float?

        public init(
            sessionStickinessConfig: CloudFrontClientTypes.SessionStickinessConfig? = nil,
            weight: Swift.Float? = nil
        )
        {
            self.sessionStickinessConfig = sessionStickinessConfig
            self.weight = weight
        }
    }

}

extension CloudFrontClientTypes.CookieNames: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CookieNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of cookie names.
    public struct CookieNames: Swift.Equatable {
        /// A list of cookie names.
        public var items: [Swift.String]?
        /// The number of cookie names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookiePreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forward = "Forward"
        case whitelistedNames = "WhitelistedNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forward = forward {
            try container.encode(forward, forKey: ClientRuntime.Key("Forward"))
        }
        if let whitelistedNames = whitelistedNames {
            try container.encode(whitelistedNames, forKey: ClientRuntime.Key("WhitelistedNames"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ItemSelection.self, forKey: .forward)
        forward = forwardDecoded
        let whitelistedNamesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .whitelistedNames)
        whitelistedNames = whitelistedNamesDecoded
    }
}

extension CloudFrontClientTypes.CookiePreference: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use CookiesConfig in a cache policy. See CachePolicy. If you want to send cookies to the origin but not include them in the cache key, use CookiesConfig in an origin request policy. See OriginRequestPolicy. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [Caching Content Based on Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
    public struct CookiePreference: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Specifies which cookies to forward to the origin for this cache behavior: all, none, or the list of cookies specified in the WhitelistedNames complex type. Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an Amazon S3 origin, specify none for the Forward element.
        /// This member is required.
        public var forward: CloudFrontClientTypes.ItemSelection?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Required if you specify whitelist for the value of Forward. A complex type that specifies how many different cookies you want CloudFront to forward to the origin for this cache behavior and, if you want to forward selected cookies, the names of those cookies. If you specify all or none for the value of Forward, omit WhitelistedNames. If you change the value of Forward from whitelist to all or none and you don't delete the WhitelistedNames element and its child elements, CloudFront deletes them automatically. For the current limit on the number of cookie names that you can whitelist for each cache behavior, see [ CloudFront Limits](https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront) in the Amazon Web Services General Reference.
        public var whitelistedNames: CloudFrontClientTypes.CookieNames?

        public init(
            forward: CloudFrontClientTypes.ItemSelection? = nil,
            whitelistedNames: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.forward = forward
            self.whitelistedNames = whitelistedNames
        }
    }

}

extension CopyDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CopyDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
    }
}

extension CopyDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let staging = staging {
            items.add(Header(name: "Staging", value: Swift.String(staging)))
        }
        return items
    }
}

extension CopyDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let primaryDistributionId = primaryDistributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(primaryDistributionId.urlPercentEncoding())/copy"
    }
}

public struct CopyDistributionInput: Swift.Equatable {
    /// A value that uniquely identifies a request to create a resource. This helps to prevent CloudFront from creating a duplicate resource if you accidentally resubmit an identical request.
    /// This member is required.
    public var callerReference: Swift.String?
    /// A Boolean flag to specify the state of the staging distribution when it's created. When you set this value to True, the staging distribution is enabled. When you set this value to False, the staging distribution is disabled. If you omit this field, the default value is True.
    public var enabled: Swift.Bool?
    /// The version identifier of the primary distribution whose configuration you are copying. This is the ETag value returned in the response to GetDistribution and GetDistributionConfig.
    public var ifMatch: Swift.String?
    /// The identifier of the primary distribution whose configuration you are copying. To get a distribution ID, use ListDistributions.
    /// This member is required.
    public var primaryDistributionId: Swift.String?
    /// The type of distribution that your primary distribution will be copied to. The only valid value is True, indicating that you are copying to a staging distribution.
    public var staging: Swift.Bool?

    public init(
        callerReference: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ifMatch: Swift.String? = nil,
        primaryDistributionId: Swift.String? = nil,
        staging: Swift.Bool? = nil
    )
    {
        self.callerReference = callerReference
        self.enabled = enabled
        self.ifMatch = ifMatch
        self.primaryDistributionId = primaryDistributionId
        self.staging = staging
    }
}

struct CopyDistributionInputBody: Swift.Equatable {
    let callerReference: Swift.String?
    let enabled: Swift.Bool?
}

extension CopyDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case enabled = "Enabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CopyDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
            self.distribution = output
        } else {
            self.distribution = nil
        }
    }
}

public struct CopyDistributionOutput: Swift.Equatable {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The version identifier for the current version of the staging distribution.
    public var eTag: Swift.String?
    /// The URL of the staging distribution.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CopyDistributionOutputBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension CopyDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

enum CopyDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DistributionAlreadyExists": return try await DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidErrorCode": return try await InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidForwardCookies": return try await InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLocationCode": return try await InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOrigin": return try await InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidProtocolSettings": return try await InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRelativePath": return try await InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidResponseCode": return try await InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTTLOrder": return try await InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidViewerCertificate": return try await InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidWebACLId": return try await InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOrigin": return try await NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCertificates": return try await TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributions": return try await TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOrigins": return try await TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateCachePolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let cachePolicyConfigData = try xmlEncoder.encode(cachePolicyConfig, withRootKey: "CachePolicyConfig")
                let cachePolicyConfigBody = ClientRuntime.HttpBody.data(cachePolicyConfigData)
                input.builder.withBody(cachePolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let cachePolicyConfigData = "{}".data(using: .utf8)!
                    let cachePolicyConfigBody = ClientRuntime.HttpBody.data(cachePolicyConfigData)
                    input.builder.withBody(cachePolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCachePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

extension CreateCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

public struct CreateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
    }
}

struct CreateCachePolicyInputBody: Swift.Equatable {
    let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension CreateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CreateCachePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
            self.cachePolicy = output
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct CreateCachePolicyOutput: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the cache policy just created.
    public var location: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCachePolicyOutputBody: Swift.Equatable {
    let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension CreateCachePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

enum CreateCachePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CachePolicyAlreadyExists": return try await CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCachePolicies": return try await TooManyCachePolicies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookiesInCachePolicy": return try await TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInCachePolicy": return try await TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringsInCachePolicy": return try await TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let cloudFrontOriginAccessIdentityConfigData = try xmlEncoder.encode(cloudFrontOriginAccessIdentityConfig, withRootKey: "CloudFrontOriginAccessIdentityConfig")
                let cloudFrontOriginAccessIdentityConfigBody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigData)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let cloudFrontOriginAccessIdentityConfigData = "{}".data(using: .utf8)!
                    let cloudFrontOriginAccessIdentityConfigBody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigData)
                    input.builder.withBody(cloudFrontOriginAccessIdentityConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCloudFrontOriginAccessIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

extension CreateCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

/// The request to create a new origin access identity (OAI). An origin access identity is a special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or just some of your Amazon S3 content. For more information, see [ Restricting Access to Amazon S3 Content by Using an Origin Access Identity](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
public struct CreateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The current configuration information for the identity.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
    }
}

struct CreateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension CreateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CreateCloudFrontOriginAccessIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
            self.cloudFrontOriginAccessIdentity = output
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateCloudFrontOriginAccessIdentityOutput: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new origin access identity just created.
    public var location: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCloudFrontOriginAccessIdentityOutputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension CreateCloudFrontOriginAccessIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

enum CreateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "CloudFrontOriginAccessIdentityAlreadyExists": return try await CloudFrontOriginAccessIdentityAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCloudFrontOriginAccessIdentities": return try await TooManyCloudFrontOriginAccessIdentities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateContinuousDeploymentPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContinuousDeploymentPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContinuousDeploymentPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateContinuousDeploymentPolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let continuousDeploymentPolicyConfig = input.operationInput.continuousDeploymentPolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let continuousDeploymentPolicyConfigData = try xmlEncoder.encode(continuousDeploymentPolicyConfig, withRootKey: "ContinuousDeploymentPolicyConfig")
                let continuousDeploymentPolicyConfigBody = ClientRuntime.HttpBody.data(continuousDeploymentPolicyConfigData)
                input.builder.withBody(continuousDeploymentPolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let continuousDeploymentPolicyConfigData = "{}".data(using: .utf8)!
                    let continuousDeploymentPolicyConfigBody = ClientRuntime.HttpBody.data(continuousDeploymentPolicyConfigData)
                    input.builder.withBody(continuousDeploymentPolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContinuousDeploymentPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContinuousDeploymentPolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateContinuousDeploymentPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateContinuousDeploymentPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicyConfig = "ContinuousDeploymentPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig {
            try container.encode(continuousDeploymentPolicyConfig, forKey: ClientRuntime.Key("ContinuousDeploymentPolicyConfig"))
        }
    }
}

extension CreateContinuousDeploymentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/continuous-deployment-policy"
    }
}

public struct CreateContinuousDeploymentPolicyInput: Swift.Equatable {
    /// Contains the configuration for a continuous deployment policy.
    /// This member is required.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
    }
}

struct CreateContinuousDeploymentPolicyInputBody: Swift.Equatable {
    let continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
}

extension CreateContinuousDeploymentPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicyConfig = "ContinuousDeploymentPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.self, forKey: .continuousDeploymentPolicyConfig)
        continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfigDecoded
    }
}

extension CreateContinuousDeploymentPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ContinuousDeploymentPolicy = try responseDecoder.decode(responseBody: data)
            self.continuousDeploymentPolicy = output
        } else {
            self.continuousDeploymentPolicy = nil
        }
    }
}

public struct CreateContinuousDeploymentPolicyOutput: Swift.Equatable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?
    /// The location of the continuous deployment policy.
    public var location: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
        self.location = location
    }
}

struct CreateContinuousDeploymentPolicyOutputBody: Swift.Equatable {
    let continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
}

extension CreateContinuousDeploymentPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicy = "ContinuousDeploymentPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicy.self, forKey: .continuousDeploymentPolicy)
        continuousDeploymentPolicy = continuousDeploymentPolicyDecoded
    }
}

enum CreateContinuousDeploymentPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ContinuousDeploymentPolicyAlreadyExists": return try await ContinuousDeploymentPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "StagingDistributionInUse": return try await StagingDistributionInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyContinuousDeploymentPolicies": return try await TooManyContinuousDeploymentPolicies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateDistributionOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let distributionConfig = input.operationInput.distributionConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let distributionConfigData = try xmlEncoder.encode(distributionConfig, withRootKey: "DistributionConfig")
                let distributionConfigBody = ClientRuntime.HttpBody.data(distributionConfigData)
                input.builder.withBody(distributionConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let distributionConfigData = "{}".data(using: .utf8)!
                    let distributionConfigBody = ClientRuntime.HttpBody.data(distributionConfigData)
                    input.builder.withBody(distributionConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

extension CreateDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to create a new distribution.
public struct CreateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil
    )
    {
        self.distributionConfig = distributionConfig
    }
}

struct CreateDistributionInputBody: Swift.Equatable {
    let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension CreateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension CreateDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
            self.distribution = output
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionOutputBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

enum CreateDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DistributionAlreadyExists": return try await DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalOriginAccessConfiguration": return try await IllegalOriginAccessConfiguration(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDomainNameForOriginAccessControl": return try await InvalidDomainNameForOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidErrorCode": return try await InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidForwardCookies": return try await InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLocationCode": return try await InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOrigin": return try await InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidProtocolSettings": return try await InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRelativePath": return try await InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidResponseCode": return try await InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTTLOrder": return try await InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidViewerCertificate": return try await InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidWebACLId": return try await InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOrigin": return try await NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCertificates": return try await TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributions": return try await TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOrigins": return try await TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateDistributionWithTagsOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let distributionConfigWithTags = input.operationInput.distributionConfigWithTags {
                let xmlEncoder = encoder as! XMLEncoder
                let distributionConfigWithTagsData = try xmlEncoder.encode(distributionConfigWithTags, withRootKey: "DistributionConfigWithTags")
                let distributionConfigWithTagsBody = ClientRuntime.HttpBody.data(distributionConfigWithTagsData)
                input.builder.withBody(distributionConfigWithTagsBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let distributionConfigWithTagsData = "{}".data(using: .utf8)!
                    let distributionConfigWithTagsBody = ClientRuntime.HttpBody.data(distributionConfigWithTagsData)
                    input.builder.withBody(distributionConfigWithTagsBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionWithTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfigWithTags = distributionConfigWithTags {
            try container.encode(distributionConfigWithTags, forKey: ClientRuntime.Key("DistributionConfigWithTags"))
        }
    }
}

extension CreateDistributionWithTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
            return items
        }
    }
}

extension CreateDistributionWithTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to create a new distribution with tags.
public struct CreateDistributionWithTagsInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?

    public init(
        distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags? = nil
    )
    {
        self.distributionConfigWithTags = distributionConfigWithTags
    }
}

struct CreateDistributionWithTagsInputBody: Swift.Equatable {
    let distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?
}

extension CreateDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfigWithTags.self, forKey: .distributionConfigWithTags)
        distributionConfigWithTags = distributionConfigWithTagsDecoded
    }
}

extension CreateDistributionWithTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
            self.distribution = output
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionWithTagsOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionWithTagsOutputBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionWithTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

enum CreateDistributionWithTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DistributionAlreadyExists": return try await DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalOriginAccessConfiguration": return try await IllegalOriginAccessConfiguration(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDomainNameForOriginAccessControl": return try await InvalidDomainNameForOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidErrorCode": return try await InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidForwardCookies": return try await InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLocationCode": return try await InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOrigin": return try await InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidProtocolSettings": return try await InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRelativePath": return try await InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidResponseCode": return try await InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTagging": return try await InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTTLOrder": return try await InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidViewerCertificate": return try await InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidWebACLId": return try await InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOrigin": return try await NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCertificates": return try await TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributions": return try await TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOrigins": return try await TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let fieldLevelEncryptionConfigData = try xmlEncoder.encode(fieldLevelEncryptionConfig, withRootKey: "FieldLevelEncryptionConfig")
                let fieldLevelEncryptionConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigData)
                input.builder.withBody(fieldLevelEncryptionConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let fieldLevelEncryptionConfigData = "{}".data(using: .utf8)!
                    let fieldLevelEncryptionConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigData)
                    input.builder.withBody(fieldLevelEncryptionConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

extension CreateFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

public struct CreateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The request to create a new field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init(
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct CreateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension CreateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CreateFieldLevelEncryptionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryption = output
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct CreateFieldLevelEncryptionConfigOutput: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
    /// The fully qualified URI of the new configuration resource just created.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
        self.location = location
    }
}

struct CreateFieldLevelEncryptionConfigOutputBody: Swift.Equatable {
    let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension CreateFieldLevelEncryptionConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

enum CreateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "FieldLevelEncryptionConfigAlreadyExists": return try await FieldLevelEncryptionConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "QueryArgProfileEmpty": return try await QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionConfigs": return try await TooManyFieldLevelEncryptionConfigs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionContentTypeProfiles": return try await TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionQueryArgProfiles": return try await TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let fieldLevelEncryptionProfileConfigData = try xmlEncoder.encode(fieldLevelEncryptionProfileConfig, withRootKey: "FieldLevelEncryptionProfileConfig")
                let fieldLevelEncryptionProfileConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigData)
                input.builder.withBody(fieldLevelEncryptionProfileConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let fieldLevelEncryptionProfileConfigData = "{}".data(using: .utf8)!
                    let fieldLevelEncryptionProfileConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigData)
                    input.builder.withBody(fieldLevelEncryptionProfileConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

extension CreateFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

public struct CreateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// The request to create a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init(
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct CreateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension CreateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CreateFieldLevelEncryptionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryptionProfile = output
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct CreateFieldLevelEncryptionProfileOutput: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
    /// The fully qualified URI of the new profile resource just created.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
        self.location = location
    }
}

struct CreateFieldLevelEncryptionProfileOutputBody: Swift.Equatable {
    let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension CreateFieldLevelEncryptionProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

enum CreateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "FieldLevelEncryptionProfileAlreadyExists": return try await FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "FieldLevelEncryptionProfileSizeExceeded": return try await FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchPublicKey": return try await NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionEncryptionEntities": return try await TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionFieldPatterns": return try await TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionProfiles": return try await TooManyFieldLevelEncryptionProfiles(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionInput(functionConfig: \(Swift.String(describing: functionConfig)), name: \(Swift.String(describing: name)), functionCode: \"CONTENT_REDACTED\")"}
}

extension CreateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

extension CreateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/function"
    }
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function, including an optional comment and the function's runtime.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// A name to identify the function.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.name = name
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    let name: Swift.String?
    let functionConfig: CloudFrontClientTypes.FunctionConfig?
    let functionCode: ClientRuntime.Data?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension CreateFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
            self.functionSummary = output
        } else {
            self.functionSummary = nil
        }
    }
}

public struct CreateFunctionOutput: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?
    /// The URL of the CloudFront function. Use the URL to manage the function with the CloudFront API.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
        self.location = location
    }
}

struct CreateFunctionOutputBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension CreateFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

enum CreateFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "FunctionAlreadyExists": return try await FunctionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "FunctionSizeLimitExceeded": return try await FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFunctions": return try await TooManyFunctions(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateInvalidationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateInvalidationOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let invalidationBatch = input.operationInput.invalidationBatch {
                let xmlEncoder = encoder as! XMLEncoder
                let invalidationBatchData = try xmlEncoder.encode(invalidationBatch, withRootKey: "InvalidationBatch")
                let invalidationBatchBody = ClientRuntime.HttpBody.data(invalidationBatchData)
                input.builder.withBody(invalidationBatchBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let invalidationBatchData = "{}".data(using: .utf8)!
                    let invalidationBatchBody = ClientRuntime.HttpBody.data(invalidationBatchData)
                    input.builder.withBody(invalidationBatchBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateInvalidationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateInvalidationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
    }
}

extension CreateInvalidationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

/// The request to create an invalidation.
public struct CreateInvalidationInput: Swift.Equatable {
    /// The distribution's id.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The batch information for the invalidation.
    /// This member is required.
    public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?

    public init(
        distributionId: Swift.String? = nil,
        invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil
    )
    {
        self.distributionId = distributionId
        self.invalidationBatch = invalidationBatch
    }
}

struct CreateInvalidationInputBody: Swift.Equatable {
    let invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
}

extension CreateInvalidationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CreateInvalidationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
            self.invalidation = output
        } else {
            self.invalidation = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateInvalidationOutput: Swift.Equatable {
    /// The invalidation's information.
    public var invalidation: CloudFrontClientTypes.Invalidation?
    /// The fully qualified URI of the distribution and invalidation batch request, including the Invalidation ID.
    public var location: Swift.String?

    public init(
        invalidation: CloudFrontClientTypes.Invalidation? = nil,
        location: Swift.String? = nil
    )
    {
        self.invalidation = invalidation
        self.location = location
    }
}

struct CreateInvalidationOutputBody: Swift.Equatable {
    let invalidation: CloudFrontClientTypes.Invalidation?
}

extension CreateInvalidationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

enum CreateInvalidationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "BatchTooLarge": return try await BatchTooLarge(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyInvalidationsInProgress": return try await TooManyInvalidationsInProgress(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateKeyGroupOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let keyGroupConfig = input.operationInput.keyGroupConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let keyGroupConfigData = try xmlEncoder.encode(keyGroupConfig, withRootKey: "KeyGroupConfig")
                let keyGroupConfigBody = ClientRuntime.HttpBody.data(keyGroupConfigData)
                input.builder.withBody(keyGroupConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let keyGroupConfigData = "{}".data(using: .utf8)!
                    let keyGroupConfigBody = ClientRuntime.HttpBody.data(keyGroupConfigData)
                    input.builder.withBody(keyGroupConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateKeyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

extension CreateKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/key-group"
    }
}

public struct CreateKeyGroupInput: Swift.Equatable {
    /// A key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.keyGroupConfig = keyGroupConfig
    }
}

struct CreateKeyGroupInputBody: Swift.Equatable {
    let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension CreateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CreateKeyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
            self.keyGroup = output
        } else {
            self.keyGroup = nil
        }
    }
}

public struct CreateKeyGroupOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just created.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?
    /// The URL of the key group.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
        self.location = location
    }
}

struct CreateKeyGroupOutputBody: Swift.Equatable {
    let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension CreateKeyGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

enum CreateKeyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "KeyGroupAlreadyExists": return try await KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyKeyGroups": return try await TooManyKeyGroups(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyPublicKeysInKeyGroup": return try await TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateMonitoringSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let monitoringSubscription = input.operationInput.monitoringSubscription {
                let xmlEncoder = encoder as! XMLEncoder
                let monitoringSubscriptionData = try xmlEncoder.encode(monitoringSubscription, withRootKey: "MonitoringSubscription")
                let monitoringSubscriptionBody = ClientRuntime.HttpBody.data(monitoringSubscriptionData)
                input.builder.withBody(monitoringSubscriptionBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let monitoringSubscriptionData = "{}".data(using: .utf8)!
                    let monitoringSubscriptionBody = ClientRuntime.HttpBody.data(monitoringSubscriptionData)
                    input.builder.withBody(monitoringSubscriptionBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateMonitoringSubscriptionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateMonitoringSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let monitoringSubscription = monitoringSubscription {
            try container.encode(monitoringSubscription, forKey: ClientRuntime.Key("MonitoringSubscription"))
        }
    }
}

extension CreateMonitoringSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct CreateMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are enabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    /// This member is required.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        distributionId: Swift.String? = nil,
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.distributionId = distributionId
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionInputBody: Swift.Equatable {
    let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension CreateMonitoringSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
            self.monitoringSubscription = output
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct CreateMonitoringSubscriptionOutput: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionOutputBody: Swift.Equatable {
    let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

enum CreateMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MonitoringSubscriptionAlreadyExists": return try await MonitoringSubscriptionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateOriginAccessControlInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginAccessControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginAccessControlInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateOriginAccessControlOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let originAccessControlConfig = input.operationInput.originAccessControlConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let originAccessControlConfigData = try xmlEncoder.encode(originAccessControlConfig, withRootKey: "OriginAccessControlConfig")
                let originAccessControlConfigBody = ClientRuntime.HttpBody.data(originAccessControlConfigData)
                input.builder.withBody(originAccessControlConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let originAccessControlConfigData = "{}".data(using: .utf8)!
                    let originAccessControlConfigBody = ClientRuntime.HttpBody.data(originAccessControlConfigData)
                    input.builder.withBody(originAccessControlConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginAccessControlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginAccessControlOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateOriginAccessControlInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateOriginAccessControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControlConfig = "OriginAccessControlConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originAccessControlConfig = originAccessControlConfig {
            try container.encode(originAccessControlConfig, forKey: ClientRuntime.Key("OriginAccessControlConfig"))
        }
    }
}

extension CreateOriginAccessControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-access-control"
    }
}

public struct CreateOriginAccessControlInput: Swift.Equatable {
    /// Contains the origin access control.
    /// This member is required.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.originAccessControlConfig = originAccessControlConfig
    }
}

struct CreateOriginAccessControlInputBody: Swift.Equatable {
    let originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?
}

extension CreateOriginAccessControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControlConfig = "OriginAccessControlConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessControlConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlConfig.self, forKey: .originAccessControlConfig)
        originAccessControlConfig = originAccessControlConfigDecoded
    }
}

extension CreateOriginAccessControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginAccessControl = try responseDecoder.decode(responseBody: data)
            self.originAccessControl = output
        } else {
            self.originAccessControl = nil
        }
    }
}

public struct CreateOriginAccessControlOutput: Swift.Equatable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// The URL of the origin access control.
    public var location: Swift.String?
    /// Contains an origin access control.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originAccessControl = originAccessControl
    }
}

struct CreateOriginAccessControlOutputBody: Swift.Equatable {
    let originAccessControl: CloudFrontClientTypes.OriginAccessControl?
}

extension CreateOriginAccessControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControl = "OriginAccessControl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessControlDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControl.self, forKey: .originAccessControl)
        originAccessControl = originAccessControlDecoded
    }
}

enum CreateOriginAccessControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "OriginAccessControlAlreadyExists": return try await OriginAccessControlAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginAccessControls": return try await TooManyOriginAccessControls(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let originRequestPolicyConfigData = try xmlEncoder.encode(originRequestPolicyConfig, withRootKey: "OriginRequestPolicyConfig")
                let originRequestPolicyConfigBody = ClientRuntime.HttpBody.data(originRequestPolicyConfigData)
                input.builder.withBody(originRequestPolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let originRequestPolicyConfigData = "{}".data(using: .utf8)!
                    let originRequestPolicyConfigBody = ClientRuntime.HttpBody.data(originRequestPolicyConfigData)
                    input.builder.withBody(originRequestPolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateOriginRequestPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

extension CreateOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

public struct CreateOriginRequestPolicyInput: Swift.Equatable {
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct CreateOriginRequestPolicyInputBody: Swift.Equatable {
    let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension CreateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CreateOriginRequestPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
            self.originRequestPolicy = output
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct CreateOriginRequestPolicyOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the origin request policy just created.
    public var location: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originRequestPolicy = originRequestPolicy
    }
}

struct CreateOriginRequestPolicyOutputBody: Swift.Equatable {
    let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension CreateOriginRequestPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

enum CreateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "OriginRequestPolicyAlreadyExists": return try await OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookiesInOriginRequestPolicy": return try await TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInOriginRequestPolicy": return try await TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginRequestPolicies": return try await TooManyOriginRequestPolicies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringsInOriginRequestPolicy": return try await TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreatePublicKeyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let publicKeyConfig = input.operationInput.publicKeyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let publicKeyConfigData = try xmlEncoder.encode(publicKeyConfig, withRootKey: "PublicKeyConfig")
                let publicKeyConfigBody = ClientRuntime.HttpBody.data(publicKeyConfigData)
                input.builder.withBody(publicKeyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let publicKeyConfigData = "{}".data(using: .utf8)!
                    let publicKeyConfigBody = ClientRuntime.HttpBody.data(publicKeyConfigData)
                    input.builder.withBody(publicKeyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreatePublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

extension CreatePublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/public-key"
    }
}

public struct CreatePublicKeyInput: Swift.Equatable {
    /// A CloudFront public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.publicKeyConfig = publicKeyConfig
    }
}

struct CreatePublicKeyInputBody: Swift.Equatable {
    let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension CreatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CreatePublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
            self.publicKey = output
        } else {
            self.publicKey = nil
        }
    }
}

public struct CreatePublicKeyOutput: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The URL of the public key.
    public var location: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.publicKey = publicKey
    }
}

struct CreatePublicKeyOutputBody: Swift.Equatable {
    let publicKey: CloudFrontClientTypes.PublicKey?
}

extension CreatePublicKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

enum CreatePublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PublicKeyAlreadyExists": return try await PublicKeyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyPublicKeys": return try await TooManyPublicKeys(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CreateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

extension CreateRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct CreateRealtimeLogConfigInput: Swift.Equatable {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    /// This member is required.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var fields: [Swift.String]?
    /// A unique name to identify this real-time log configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    /// This member is required.
    public var samplingRate: Swift.Int?

    public init(
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct CreateRealtimeLogConfigInputBody: Swift.Equatable {
    let endPoints: [CloudFrontClientTypes.EndPoint]?
    let fields: [Swift.String]?
    let name: Swift.String?
    let samplingRate: Swift.Int?
}

extension CreateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension CreateRealtimeLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRealtimeLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct CreateRealtimeLogConfigOutput: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct CreateRealtimeLogConfigOutputBody: Swift.Equatable {
    let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension CreateRealtimeLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

enum CreateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "RealtimeLogConfigAlreadyExists": return try await RealtimeLogConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRealtimeLogConfigs": return try await TooManyRealtimeLogConfigs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateResponseHeadersPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResponseHeadersPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResponseHeadersPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateResponseHeadersPolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let responseHeadersPolicyConfig = input.operationInput.responseHeadersPolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let responseHeadersPolicyConfigData = try xmlEncoder.encode(responseHeadersPolicyConfig, withRootKey: "ResponseHeadersPolicyConfig")
                let responseHeadersPolicyConfigBody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigData)
                input.builder.withBody(responseHeadersPolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let responseHeadersPolicyConfigData = "{}".data(using: .utf8)!
                    let responseHeadersPolicyConfigBody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigData)
                    input.builder.withBody(responseHeadersPolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResponseHeadersPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResponseHeadersPolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateResponseHeadersPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateResponseHeadersPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let responseHeadersPolicyConfig = responseHeadersPolicyConfig {
            try container.encode(responseHeadersPolicyConfig, forKey: ClientRuntime.Key("ResponseHeadersPolicyConfig"))
        }
    }
}

extension CreateResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

public struct CreateResponseHeadersPolicyInput: Swift.Equatable {
    /// Contains metadata about the response headers policy, and a set of configurations that specify the HTTP headers.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

struct CreateResponseHeadersPolicyInputBody: Swift.Equatable {
    let responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?
}

extension CreateResponseHeadersPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

extension CreateResponseHeadersPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ResponseHeadersPolicy = try responseDecoder.decode(responseBody: data)
            self.responseHeadersPolicy = output
        } else {
            self.responseHeadersPolicy = nil
        }
    }
}

public struct CreateResponseHeadersPolicyOutput: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// The URL of the response headers policy.
    public var location: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

struct CreateResponseHeadersPolicyOutputBody: Swift.Equatable {
    let responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
}

extension CreateResponseHeadersPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

enum CreateResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ResponseHeadersPolicyAlreadyExists": return try await ResponseHeadersPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooLongCSPInResponseHeadersPolicy": return try await TooLongCSPInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCustomHeadersInResponseHeadersPolicy": return try await TooManyCustomHeadersInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRemoveHeadersInResponseHeadersPolicy": return try await TooManyRemoveHeadersInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyResponseHeadersPolicies": return try await TooManyResponseHeadersPolicies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateStreamingDistributionOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let streamingDistributionConfigData = try xmlEncoder.encode(streamingDistributionConfig, withRootKey: "StreamingDistributionConfig")
                let streamingDistributionConfigBody = ClientRuntime.HttpBody.data(streamingDistributionConfigData)
                input.builder.withBody(streamingDistributionConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let streamingDistributionConfigData = "{}".data(using: .utf8)!
                    let streamingDistributionConfigBody = ClientRuntime.HttpBody.data(streamingDistributionConfigData)
                    input.builder.withBody(streamingDistributionConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

extension CreateStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to create a new streaming distribution.
public struct CreateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct CreateStreamingDistributionInputBody: Swift.Equatable {
    let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension CreateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CreateStreamingDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
            self.streamingDistribution = output
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionOutput: Swift.Equatable {
    /// The current version of the streaming distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionOutputBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

enum CreateStreamingDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOrigin": return try await InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "StreamingDistributionAlreadyExists": return try await StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyStreamingDistributionCNAMEs": return try await TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyStreamingDistributions": return try await TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct CreateStreamingDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let streamingDistributionConfigWithTags = input.operationInput.streamingDistributionConfigWithTags {
                let xmlEncoder = encoder as! XMLEncoder
                let streamingDistributionConfigWithTagsData = try xmlEncoder.encode(streamingDistributionConfigWithTags, withRootKey: "StreamingDistributionConfigWithTags")
                let streamingDistributionConfigWithTagsBody = ClientRuntime.HttpBody.data(streamingDistributionConfigWithTagsData)
                input.builder.withBody(streamingDistributionConfigWithTagsBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let streamingDistributionConfigWithTagsData = "{}".data(using: .utf8)!
                    let streamingDistributionConfigWithTagsBody = ClientRuntime.HttpBody.data(streamingDistributionConfigWithTagsData)
                    input.builder.withBody(streamingDistributionConfigWithTagsBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionWithTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfigWithTags = streamingDistributionConfigWithTags {
            try container.encode(streamingDistributionConfigWithTags, forKey: ClientRuntime.Key("StreamingDistributionConfigWithTags"))
        }
    }
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
            return items
        }
    }
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to create a new streaming distribution with tags.
public struct CreateStreamingDistributionWithTagsInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?

    public init(
        streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags? = nil
    )
    {
        self.streamingDistributionConfigWithTags = streamingDistributionConfigWithTags
    }
}

struct CreateStreamingDistributionWithTagsInputBody: Swift.Equatable {
    let streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?
}

extension CreateStreamingDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfigWithTags.self, forKey: .streamingDistributionConfigWithTags)
        streamingDistributionConfigWithTags = streamingDistributionConfigWithTagsDecoded
    }
}

extension CreateStreamingDistributionWithTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
            self.streamingDistribution = output
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionWithTagsOutput: Swift.Equatable {
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionWithTagsOutputBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionWithTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

enum CreateStreamingDistributionWithTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOrigin": return try await InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTagging": return try await InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "StreamingDistributionAlreadyExists": return try await StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyStreamingDistributionCNAMEs": return try await TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyStreamingDistributions": return try await TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCachingMinTTL = "ErrorCachingMinTTL"
        case errorCode = "ErrorCode"
        case responseCode = "ResponseCode"
        case responsePagePath = "ResponsePagePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let errorCachingMinTTL = errorCachingMinTTL {
            try container.encode(errorCachingMinTTL, forKey: ClientRuntime.Key("ErrorCachingMinTTL"))
        }
        if let errorCode = errorCode {
            try container.encode(errorCode, forKey: ClientRuntime.Key("ErrorCode"))
        }
        if let responseCode = responseCode {
            try container.encode(responseCode, forKey: ClientRuntime.Key("ResponseCode"))
        }
        if let responsePagePath = responsePagePath {
            try container.encode(responsePagePath, forKey: ClientRuntime.Key("ResponsePagePath"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let responsePagePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responsePagePath)
        responsePagePath = responsePagePathDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let errorCachingMinTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCachingMinTTL)
        errorCachingMinTTL = errorCachingMinTTLDecoded
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponse: Swift.Equatable {
        /// The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status code specified in ErrorCode. When this time period has elapsed, CloudFront queries your origin to see whether the problem that caused the error has been resolved and the requested object is now available. For more information, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var errorCachingMinTTL: Swift.Int?
        /// The HTTP status code for which you want to specify a custom error page and/or a caching duration.
        /// This member is required.
        public var errorCode: Swift.Int?
        /// The HTTP status code that you want CloudFront to return to the viewer along with the custom error page. There are a variety of reasons that you might want CloudFront to return a status code different from the status code that your origin returned to CloudFront, for example:
        ///
        /// * Some Internet devices (some firewalls and corporate proxies, for example) intercept HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you substitute 200, the response typically won't be intercepted.
        ///
        /// * If you don't care about distinguishing among different client errors or server errors, you can specify 400 or 500 as the ResponseCode for all 4xx or 5xx errors.
        ///
        /// * You might want to return a 200 status code (OK) and static website so your customers don't know that your website is down.
        ///
        ///
        /// If you specify a value for ResponseCode, you must also specify a value for ResponsePagePath.
        public var responseCode: Swift.String?
        /// The path to the custom error page that you want CloudFront to return to a viewer when your origin returns the HTTP status code specified by ErrorCode, for example, /4xx-errors/403-forbidden.html. If you want to store your objects and your custom error pages in different locations, your distribution must include a cache behavior for which the following is true:
        ///
        /// * The value of PathPattern matches the path to your custom error messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3 bucket in a directory named /4xx-errors. Your distribution must include a cache behavior for which the path pattern routes requests for your custom error pages to that location, for example, /4xx-errors/*.
        ///
        /// * The value of TargetOriginId specifies the value of the ID element for the origin that contains your custom error pages.
        ///
        ///
        /// If you specify a value for ResponsePagePath, you must also specify a value for ResponseCode. We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the files that you want to return to viewers because the origin server is unavailable.
        public var responsePagePath: Swift.String?

        public init(
            errorCachingMinTTL: Swift.Int? = nil,
            errorCode: Swift.Int? = nil,
            responseCode: Swift.String? = nil,
            responsePagePath: Swift.String? = nil
        )
        {
            self.errorCachingMinTTL = errorCachingMinTTL
            self.errorCode = errorCode
            self.responseCode = responseCode
            self.responsePagePath = responsePagePath
        }
    }

}

extension CloudFrontClientTypes.CustomErrorResponses: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for customerrorresponse0 in items {
                try itemsContainer.encode(customerrorresponse0, forKey: ClientRuntime.Key("CustomErrorResponse"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CustomErrorResponse{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomErrorResponse>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CustomErrorResponse].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CustomErrorResponse]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CustomErrorResponse]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomErrorResponses: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponses: Swift.Equatable {
        /// A complex type that contains a CustomErrorResponse element for each HTTP status code for which you want to specify a custom error page and/or a caching duration.
        public var items: [CloudFrontClientTypes.CustomErrorResponse]?
        /// The number of HTTP status codes for which you want to specify a custom error page and/or a caching duration. If Quantity is 0, you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CustomErrorResponse]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomHeaders: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origincustomheader0 in items {
                try itemsContainer.encode(origincustomheader0, forKey: ClientRuntime.Key("OriginCustomHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginCustomHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginCustomHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginCustomHeader].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginCustomHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginCustomHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains the list of Custom Headers for each origin.
    public struct CustomHeaders: Swift.Equatable {
        /// Optional: A list that contains one OriginCustomHeader element for each custom header that you want CloudFront to forward to the origin. If Quantity is 0, omit Items.
        public var items: [CloudFrontClientTypes.OriginCustomHeader]?
        /// The number of custom headers, if any, for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomOriginConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPort = "HTTPPort"
        case httpsPort = "HTTPSPort"
        case originKeepaliveTimeout = "OriginKeepaliveTimeout"
        case originProtocolPolicy = "OriginProtocolPolicy"
        case originReadTimeout = "OriginReadTimeout"
        case originSslProtocols = "OriginSslProtocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let httpPort = httpPort {
            try container.encode(httpPort, forKey: ClientRuntime.Key("HTTPPort"))
        }
        if let httpsPort = httpsPort {
            try container.encode(httpsPort, forKey: ClientRuntime.Key("HTTPSPort"))
        }
        if let originKeepaliveTimeout = originKeepaliveTimeout {
            try container.encode(originKeepaliveTimeout, forKey: ClientRuntime.Key("OriginKeepaliveTimeout"))
        }
        if let originProtocolPolicy = originProtocolPolicy {
            try container.encode(originProtocolPolicy, forKey: ClientRuntime.Key("OriginProtocolPolicy"))
        }
        if let originReadTimeout = originReadTimeout {
            try container.encode(originReadTimeout, forKey: ClientRuntime.Key("OriginReadTimeout"))
        }
        if let originSslProtocols = originSslProtocols {
            try container.encode(originSslProtocols, forKey: ClientRuntime.Key("OriginSslProtocols"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPort)
        httpPort = httpPortDecoded
        let httpsPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpsPort)
        httpsPort = httpsPortDecoded
        let originProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginProtocolPolicy.self, forKey: .originProtocolPolicy)
        originProtocolPolicy = originProtocolPolicyDecoded
        let originSslProtocolsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginSslProtocols.self, forKey: .originSslProtocols)
        originSslProtocols = originSslProtocolsDecoded
        let originReadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originReadTimeout)
        originReadTimeout = originReadTimeoutDecoded
        let originKeepaliveTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originKeepaliveTimeout)
        originKeepaliveTimeout = originKeepaliveTimeoutDecoded
    }
}

extension CloudFrontClientTypes.CustomOriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) is a custom origin.
    public struct CustomOriginConfig: Swift.Equatable {
        /// The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin listens on.
        /// This member is required.
        public var httpPort: Swift.Int?
        /// The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the origin listens on.
        /// This member is required.
        public var httpsPort: Swift.Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 5 seconds. For more information, see [Origin Keep-alive Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout) in the Amazon CloudFront Developer Guide.
        public var originKeepaliveTimeout: Swift.Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values are:
        ///
        /// * http-only  CloudFront always uses HTTP to connect to the origin.
        ///
        /// * match-viewer  CloudFront connects to the origin using the same protocol that the viewer used to connect to CloudFront.
        ///
        /// * https-only  CloudFront always uses HTTPS to connect to the origin.
        /// This member is required.
        public var originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the origin response timeout. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 30 seconds. For more information, see [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout) in the Amazon CloudFront Developer Guide.
        public var originReadTimeout: Swift.Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. Valid values include SSLv3, TLSv1, TLSv1.1, and TLSv1.2. For more information, see [Minimum Origin SSL Protocol](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols) in the Amazon CloudFront Developer Guide.
        public var originSslProtocols: CloudFrontClientTypes.OriginSslProtocols?

        public init(
            httpPort: Swift.Int? = nil,
            httpsPort: Swift.Int? = nil,
            originKeepaliveTimeout: Swift.Int? = nil,
            originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy? = nil,
            originReadTimeout: Swift.Int? = nil,
            originSslProtocols: CloudFrontClientTypes.OriginSslProtocols? = nil
        )
        {
            self.httpPort = httpPort
            self.httpsPort = httpsPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }

}

extension CloudFrontClientTypes.DefaultCacheBehavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case responseHeadersPolicyId = "ResponseHeadersPolicyId"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let responseHeadersPolicyId = responseHeadersPolicyId {
            try container.encode(responseHeadersPolicyId, forKey: ClientRuntime.Key("ResponseHeadersPolicyId"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let responseHeadersPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseHeadersPolicyId)
        responseHeadersPolicyId = responseHeadersPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.DefaultCacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if request URLs don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
    public struct DefaultCacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to the default cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for the default cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to the default cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they use the default cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in a trusted signer's Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init(
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension DeleteCachePolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy that you are deleting. To get the identifier, you can use ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are deleting. The version is the cache policy's ETag value, which you can get using ListCachePolicies, GetCachePolicy, or GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCachePolicyInputBody: Swift.Equatable {
}

extension DeleteCachePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCachePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCachePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCachePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CachePolicyInUse": return try await CachePolicyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalDelete": return try await IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

/// Deletes a origin access identity.
public struct DeleteCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The origin access identity's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header you received from a previous GET or PUT request. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CloudFrontOriginAccessIdentityInUse": return try await CloudFrontOriginAccessIdentityInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteContinuousDeploymentPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteContinuousDeploymentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteContinuousDeploymentPolicyInput: Swift.Equatable {
    /// The identifier of the continuous deployment policy that you are deleting.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the continuous deployment policy that you are deleting.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteContinuousDeploymentPolicyInputBody: Swift.Equatable {
}

extension DeleteContinuousDeploymentPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContinuousDeploymentPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContinuousDeploymentPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContinuousDeploymentPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

/// This action deletes a web distribution. To delete a web distribution using the CloudFront API, perform the following steps. To delete a web distribution using the CloudFront API:
///
/// * Disable the web distribution
///
/// * Submit a GET Distribution Config request to get the current configuration and the Etag header for the distribution.
///
/// * Update the XML document that was returned in the response to your GET Distribution Config request to change the value of Enabled to false.
///
/// * Submit a PUT Distribution Config request to update the configuration for your distribution. In the request body, include the XML document that you updated in Step 3. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 2.
///
/// * Review the response to the PUT Distribution Config request to confirm that the distribution was successfully disabled.
///
/// * Submit a GET Distribution request to confirm that your changes have propagated. When propagation is complete, the value of Status is Deployed.
///
/// * Submit a DELETE Distribution request. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 6.
///
/// * Review the response to your DELETE Distribution request to confirm that the distribution was successfully deleted.
///
///
/// For information about deleting a distribution using the CloudFront console, see [Deleting a Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html) in the Amazon CloudFront Developer Guide.
public struct DeleteDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteDistributionInputBody: Swift.Equatable {
}

extension DeleteDistributionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDistributionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "DistributionNotDisabled": return try await DistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteFieldLevelEncryptionConfigInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The ID of the configuration you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "FieldLevelEncryptionConfigInUse": return try await FieldLevelEncryptionConfigInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteFieldLevelEncryptionProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request the ID of the profile you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "FieldLevelEncryptionProfileInUse": return try await FieldLevelEncryptionProfileInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are deleting, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are deleting.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "FunctionInUse": return try await FunctionInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFunctionExists": return try await NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteKeyGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct DeleteKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are deleting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are deleting. The version is the key group's ETag value. To get the ETag, use GetKeyGroup or GetKeyGroupConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteKeyGroupInputBody: Swift.Equatable {
}

extension DeleteKeyGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKeyGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKeyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ResourceInUse": return try await ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteMonitoringSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct DeleteMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are disabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init(
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct DeleteMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension DeleteMonitoringSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMonitoringSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchMonitoringSubscription": return try await NoSuchMonitoringSubscription(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteOriginAccessControlInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteOriginAccessControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())"
    }
}

public struct DeleteOriginAccessControlInput: Swift.Equatable {
    /// The unique identifier of the origin access control that you are deleting.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the origin access control that you are deleting.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteOriginAccessControlInputBody: Swift.Equatable {
}

extension DeleteOriginAccessControlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginAccessControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOriginAccessControlOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOriginAccessControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "OriginAccessControlInUse": return try await OriginAccessControlInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteOriginRequestPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are deleting. To get the identifier, you can use ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are deleting. The version is the origin request policy's ETag value, which you can get using ListOriginRequestPolicies, GetOriginRequestPolicy, or GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteOriginRequestPolicyInputBody: Swift.Equatable {
}

extension DeleteOriginRequestPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOriginRequestPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOriginRequestPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalDelete": return try await IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "OriginRequestPolicyInUse": return try await OriginRequestPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeletePublicKeyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeletePublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

public struct DeletePublicKeyInput: Swift.Equatable {
    /// The ID of the public key you want to remove from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeletePublicKeyInputBody: Swift.Equatable {
}

extension DeletePublicKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePublicKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeletePublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchPublicKey": return try await NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PublicKeyInUse": return try await PublicKeyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

extension DeleteRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/delete-realtime-log-config"
    }
}

public struct DeleteRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to delete.
    public var arn: Swift.String?
    /// The name of the real-time log configuration to delete.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteRealtimeLogConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRealtimeLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRealtimeLogConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRealtimeLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "RealtimeLogConfigInUse": return try await RealtimeLogConfigInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteResponseHeadersPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy that you are deleting. To get the identifier, you can use ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are deleting. The version is the response headers policy's ETag value, which you can get using ListResponseHeadersPolicies, GetResponseHeadersPolicy, or GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteResponseHeadersPolicyInputBody: Swift.Equatable {
}

extension DeleteResponseHeadersPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResponseHeadersPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResponseHeadersPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalDelete": return try await IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ResponseHeadersPolicyInUse": return try await ResponseHeadersPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DeleteStreamingDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to delete a streaming distribution.
public struct DeleteStreamingDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the streaming distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteStreamingDistributionInputBody: Swift.Equatable {
}

extension DeleteStreamingDistributionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStreamingDistributionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStreamingDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "StreamingDistributionNotDisabled": return try await StreamingDistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension DescribeFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let stage = stage {
                let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
                items.append(stageQueryItem)
            }
            return items
        }
    }
}

extension DescribeFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/describe"
    }
}

public struct DescribeFunctionInput: Swift.Equatable {
    /// The name of the function that you are getting information about.
    /// This member is required.
    public var name: Swift.String?
    /// The function's stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct DescribeFunctionInputBody: Swift.Equatable {
}

extension DescribeFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
            self.functionSummary = output
        } else {
            self.functionSummary = nil
        }
    }
}

public struct DescribeFunctionOutput: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct DescribeFunctionOutputBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension DescribeFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

enum DescribeFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchFunctionExists": return try await NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.Distribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case activeTrustedKeyGroups = "ActiveTrustedKeyGroups"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case aliasICPRecordals = "AliasICPRecordals"
        case distributionConfig = "DistributionConfig"
        case domainName = "DomainName"
        case id = "Id"
        case inProgressInvalidationBatches = "InProgressInvalidationBatches"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedKeyGroups = activeTrustedKeyGroups {
            try container.encode(activeTrustedKeyGroups, forKey: ClientRuntime.Key("ActiveTrustedKeyGroups"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let inProgressInvalidationBatches = inProgressInvalidationBatches {
            try container.encode(inProgressInvalidationBatches, forKey: ClientRuntime.Key("InProgressInvalidationBatches"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let inProgressInvalidationBatchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressInvalidationBatches)
        inProgressInvalidationBatches = inProgressInvalidationBatchesDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let activeTrustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedKeyGroups.self, forKey: .activeTrustedKeyGroups)
        activeTrustedKeyGroups = activeTrustedKeyGroupsDecoded
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension CloudFrontClientTypes.Distribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public struct Distribution: Swift.Equatable {
        /// This field contains a list of key groups and the public keys in each key group that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. This field contains a list of Amazon Web Services account IDs and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// The distribution's Amazon Resource Name (ARN).
        /// This member is required.
        public var arn: Swift.String?
        /// The distribution's configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// The distribution's CloudFront domain name. For example: d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The distribution's identifier. For example: E1U5RQF7T870K0.
        /// This member is required.
        public var id: Swift.String?
        /// The number of invalidation batches currently in progress.
        /// This member is required.
        public var inProgressInvalidationBatches: Swift.Int?
        /// The date and time when the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The distribution's status. When the status is Deployed, the distribution's information is fully propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?

        public init(
            activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            arn: Swift.String? = nil,
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            inProgressInvalidationBatches: Swift.Int? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.activeTrustedKeyGroups = activeTrustedKeyGroups
            self.activeTrustedSigners = activeTrustedSigners
            self.aliasICPRecordals = aliasICPRecordals
            self.arn = arn
            self.distributionConfig = distributionConfig
            self.domainName = domainName
            self.id = id
            self.inProgressInvalidationBatches = inProgressInvalidationBatches
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

extension DistributionAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The caller reference you attempted to create the distribution with is associated with another distribution.
public struct DistributionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DistributionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DistributionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension DistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case continuousDeploymentPolicyId = "ContinuousDeploymentPolicyId"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case defaultRootObject = "DefaultRootObject"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case isIPV6Enabled = "IsIPV6Enabled"
        case logging = "Logging"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case staging = "Staging"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let continuousDeploymentPolicyId = continuousDeploymentPolicyId {
            try container.encode(continuousDeploymentPolicyId, forKey: ClientRuntime.Key("ContinuousDeploymentPolicyId"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let defaultRootObject = defaultRootObject {
            try container.encode(defaultRootObject, forKey: ClientRuntime.Key("DefaultRootObject"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let staging = staging {
            try container.encode(staging, forKey: ClientRuntime.Key("Staging"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let defaultRootObjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRootObject)
        defaultRootObject = defaultRootObjectDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
        let continuousDeploymentPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuousDeploymentPolicyId)
        continuousDeploymentPolicyId = continuousDeploymentPolicyIdDecoded
        let stagingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .staging)
        staging = stagingDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfig(aliases: \(Swift.String(describing: aliases)), cacheBehaviors: \(Swift.String(describing: cacheBehaviors)), callerReference: \(Swift.String(describing: callerReference)), continuousDeploymentPolicyId: \(Swift.String(describing: continuousDeploymentPolicyId)), customErrorResponses: \(Swift.String(describing: customErrorResponses)), defaultCacheBehavior: \(Swift.String(describing: defaultCacheBehavior)), defaultRootObject: \(Swift.String(describing: defaultRootObject)), enabled: \(Swift.String(describing: enabled)), httpVersion: \(Swift.String(describing: httpVersion)), isIPV6Enabled: \(Swift.String(describing: isIPV6Enabled)), logging: \(Swift.String(describing: logging)), originGroups: \(Swift.String(describing: originGroups)), origins: \(Swift.String(describing: origins)), priceClass: \(Swift.String(describing: priceClass)), restrictions: \(Swift.String(describing: restrictions)), staging: \(Swift.String(describing: staging)), viewerCertificate: \(Swift.String(describing: viewerCertificate)), webACLId: \(Swift.String(describing: webACLId)), comment: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes.DistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution configuration.
    public struct DistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A complex type that contains zero or more CacheBehavior elements.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the DistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the distribution. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?
        /// The identifier of a continuous deployment policy. For more information, see CreateContinuousDeploymentPolicy.
        public var continuousDeploymentPolicyId: Swift.String?
        /// A complex type that controls the following:
        ///
        /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
        ///
        /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
        ///
        ///
        /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution (https://www.example.com) instead of an object in your distribution (https://www.example.com/product-description.html). Specifying a default root object avoids exposing the contents of your distribution. Specify only the object name, for example, index.html. Don't add a / before the object name. If you don't want to specify a default root object when you create a distribution, include an empty DefaultRootObject element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty DefaultRootObject element. To replace the default root object, update the distribution configuration and specify the new object. For more information about the default root object, see [Creating a Default Root Object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html) in the Amazon CloudFront Developer Guide.
        public var defaultRootObject: Swift.String?
        /// From this field, you can enable or disable the selected distribution.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// (Optional) Specify the maximum HTTP version(s) that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 automatically use an earlier HTTP version. For viewers and CloudFront to use HTTP/2, viewers must support TLSv1.2 or later, and must support Server Name Indication (SNI). For viewers and CloudFront to use HTTP/3, viewers must support TLSv1.3 and Server Name Indication (SNI). CloudFront supports HTTP/3 connection migration to allow the viewer to switch networks without losing connection. For more information about connection migration, see [Connection Migration](https://www.rfc-editor.org/rfc/rfc9000.html#name-connection-migration) at RFC 9000. For more information about supported TLSv1.3 ciphers, see [Supported protocols and ciphers between viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html).
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your distribution, specify true. If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. In general, you should enable IPv6 if you have users on IPv6 networks who want to access your content. However, if you're using signed URLs or signed cookies to restrict access to your content, and if you're using a custom policy that includes the IpAddress parameter to restrict the IP addresses that can access your content, don't enable IPv6. If you want to restrict access to some content by IP address and not restrict access to other content (or restrict access but not by IP address), you can create two distributions. For more information, see [Creating a Signed URL Using a Custom Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html) in the Amazon CloudFront Developer Guide. If you're using an Route 53 Amazon Web Services Integration alias resource record set to route traffic to your CloudFront distribution, you need to create a second alias resource record set when both of the following are true:
        ///
        /// * You enable IPv6 for the distribution
        ///
        /// * You're using alternate domain names in the URLs for your objects
        ///
        ///
        /// For more information, see [Routing Traffic to an Amazon CloudFront Web Distribution by Using Your Domain Name](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html) in the Route 53 Amazon Web Services Integration Developer Guide. If you created a CNAME resource record set, either with Route 53 Amazon Web Services Integration or with another DNS service, you don't need to make any changes. A CNAME record will route traffic to your distribution regardless of the IP address format of the viewer request.
        public var isIPV6Enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the distribution. For more information about logging, see [Access Logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html) in the Amazon CloudFront Developer Guide.
        public var logging: CloudFrontClientTypes.LoggingConfig?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Viewers who are in or near regions that are excluded from your specified price class may encounter slower performance. For more information about price classes, see [Choosing the Price Class for a CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html) in the Amazon CloudFront Developer Guide. For information about CloudFront pricing, including how price classes (such as Price Class 100) map to CloudFront regions, see [Amazon CloudFront Pricing](http://aws.amazon.com/cloudfront/pricing/).
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// A Boolean that indicates whether this is a staging distribution. When this value is true, this is a staging distribution. When this value is false, this is not a staging distribution.
        public var staging: Swift.Bool?
        /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a. WAF is a web application firewall that lets you monitor the HTTP and HTTPS requests that are forwarded to CloudFront, and lets you control access to your content. Based on conditions that you specify, such as the IP addresses that requests originate from or the values of query strings, CloudFront responds to requests either with the requested content or with an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page when a request is blocked. For more information about WAF, see the [WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html).
        public var webACLId: Swift.String?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            continuousDeploymentPolicyId: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.LoggingConfig? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            staging: Swift.Bool? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.callerReference = callerReference
            self.comment = comment
            self.continuousDeploymentPolicyId = continuousDeploymentPolicyId
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.isIPV6Enabled = isIPV6Enabled
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.staging = staging
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.DistributionConfigWithTags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution Configuration and a list of tags to be associated with the distribution.
    public struct DistributionConfigWithTags: Swift.Equatable {
        /// A distribution configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init(
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.distributionConfig = distributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.DistributionIdList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("DistributionId"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionIdList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of distribution IDs.
    public struct DistributionIdList: Swift.Equatable {
        /// A flag that indicates whether more distribution IDs remain to be listed. If your results were truncated, you can make a subsequent request using the Marker request field to retrieve more distribution IDs in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the distribution IDs in the list.
        public var items: [Swift.String]?
        /// The value provided in the Marker request field.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of distribution IDs requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Contains the value that you should use in the Marker field of a subsequent request to continue listing distribution IDs where you left off.
        public var nextMarker: Swift.String?
        /// The total number of distribution IDs returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.DistributionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for distributionsummary0 in items {
                try itemsContainer.encode(distributionsummary0, forKey: ClientRuntime.Key("DistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.DistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.DistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.DistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution list.
    public struct DistributionList: Swift.Equatable {
        /// A flag that indicates whether more distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one DistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.DistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.DistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension DistributionNotDisabled {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct DistributionNotDisabled: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DistributionNotDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DistributionNotDisabledBody: Swift.Equatable {
    let message: Swift.String?
}

extension DistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case aliasICPRecordals = "AliasICPRecordals"
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case id = "Id"
        case isIPV6Enabled = "IsIPV6Enabled"
        case lastModifiedTime = "LastModifiedTime"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case staging = "Staging"
        case status = "Status"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let staging = staging {
            try container.encode(staging, forKey: ClientRuntime.Key("Staging"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
        let stagingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .staging)
        staging = stagingDecoded
    }
}

extension CloudFrontClientTypes.DistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information about a CloudFront distribution.
    public struct DistributionSummary: Swift.Equatable {
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains zero or more CacheBehavior elements.
        /// This member is required.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// A complex type that contains zero or more CustomErrorResponses elements.
        /// This member is required.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The domain name that corresponds to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 will automatically use an earlier version.
        /// This member is required.
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// The identifier for the distribution. For example: EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your distribution.
        /// This member is required.
        public var isIPV6Enabled: Swift.Bool?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        /// This member is required.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// Whether the primary distribution has a staging distribution enabled.
        /// This member is required.
        public var staging: Swift.Bool?
        /// The current status of the distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers.
        /// This member is required.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// The Web ACL Id (if any) associated with the distribution.
        /// This member is required.
        public var webACLId: Swift.String?

        public init(
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            arn: Swift.String? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            id: Swift.String? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            staging: Swift.Bool? = nil,
            status: Swift.String? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliasICPRecordals = aliasICPRecordals
            self.aliases = aliases
            self.arn = arn
            self.cacheBehaviors = cacheBehaviors
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.domainName = domainName
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.id = id
            self.isIPV6Enabled = isIPV6Enabled
            self.lastModifiedTime = lastModifiedTime
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.staging = staging
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for encryptionentity0 in items {
                try itemsContainer.encode(encryptionentity0, forKey: ClientRuntime.Key("EncryptionEntity"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct EncryptionEntity{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EncryptionEntity>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EncryptionEntity].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.EncryptionEntity]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.EncryptionEntity]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.EncryptionEntities: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes all of the encryption entities.
    public struct EncryptionEntities: Swift.Equatable {
        /// An array of field patterns in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.EncryptionEntity]?
        /// Number of field pattern items in a field-level encryption content type-profile mapping.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.EncryptionEntity]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPatterns = "FieldPatterns"
        case providerId = "ProviderId"
        case publicKeyId = "PublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldPatterns = fieldPatterns {
            try container.encode(fieldPatterns, forKey: ClientRuntime.Key("FieldPatterns"))
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: ClientRuntime.Key("ProviderId"))
        }
        if let publicKeyId = publicKeyId {
            try container.encode(publicKeyId, forKey: ClientRuntime.Key("PublicKeyId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKeyId)
        publicKeyId = publicKeyIdDecoded
        let providerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerId)
        providerId = providerIdDecoded
        let fieldPatternsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldPatterns.self, forKey: .fieldPatterns)
        fieldPatterns = fieldPatternsDecoded
    }
}

extension CloudFrontClientTypes.EncryptionEntity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications.
    public struct EncryptionEntity: Swift.Equatable {
        /// Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have both ABC* and AB*. Note that field patterns are case-sensitive.
        /// This member is required.
        public var fieldPatterns: CloudFrontClientTypes.FieldPatterns?
        /// The provider associated with the public key being used for encryption. This value must also be provided with the private key for applications to be able to decrypt data.
        /// This member is required.
        public var providerId: Swift.String?
        /// The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match the patterns.
        /// This member is required.
        public var publicKeyId: Swift.String?

        public init(
            fieldPatterns: CloudFrontClientTypes.FieldPatterns? = nil,
            providerId: Swift.String? = nil,
            publicKeyId: Swift.String? = nil
        )
        {
            self.fieldPatterns = fieldPatterns
            self.providerId = providerId
            self.publicKeyId = publicKeyId
        }
    }

}

extension CloudFrontClientTypes.EndPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamConfig = "KinesisStreamConfig"
        case streamType = "StreamType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let kinesisStreamConfig = kinesisStreamConfig {
            try container.encode(kinesisStreamConfig, forKey: ClientRuntime.Key("KinesisStreamConfig"))
        }
        if let streamType = streamType {
            try container.encode(streamType, forKey: ClientRuntime.Key("StreamType"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamType)
        streamType = streamTypeDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
    }
}

extension CloudFrontClientTypes.EndPoint: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data in a real-time log configuration.
    public struct EndPoint: Swift.Equatable {
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
        public var kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig?
        /// The type of data stream where you are sending real-time log data. The only valid value is Kinesis.
        /// This member is required.
        public var streamType: Swift.String?

        public init(
            kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig? = nil,
            streamType: Swift.String? = nil
        )
        {
            self.kinesisStreamConfig = kinesisStreamConfig
            self.streamType = streamType
        }
    }

}

extension CloudFrontClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case originRequest
        case originResponse
        case viewerRequest
        case viewerResponse
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .originRequest,
                .originResponse,
                .viewerRequest,
                .viewerResponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .originRequest: return "origin-request"
            case .originResponse: return "origin-response"
            case .viewerRequest: return "viewer-request"
            case .viewerResponse: return "viewer-response"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations and other options specified for field-level encryption.
    public struct FieldLevelEncryption: Swift.Equatable {
        /// A complex data type that includes the profile configurations specified for field-level encryption.
        /// This member is required.
        public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
        /// The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption configuration was changed.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations specified for field-level encryption.
    public struct FieldLevelEncryptionConfig: Swift.Equatable {
        /// A unique number that ensures the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment about the configuration. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default in a request if a query argument doesn't specify a profile to use.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a query argument in a request.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension FieldLevelEncryptionConfigAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified configuration for field-level encryption already exists.
public struct FieldLevelEncryptionConfigAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionConfigAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionConfigInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified configuration for field-level encryption is in use.
public struct FieldLevelEncryptionConfigInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionConfigInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FieldLevelEncryptionConfigInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionsummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionsummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encrpytion configurations.
    public struct FieldLevelEncryptionList: Swift.Equatable {
        /// An array of field-level encryption items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]?
        /// The maximum number of elements you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your configurations where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for field-level encryption profiles.
    public struct FieldLevelEncryptionProfile: Swift.Equatable {
        /// A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.
        /// This member is required.
        public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
        /// The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption profile was updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension FieldLevelEncryptionProfileAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified profile for field-level encryption already exists.
public struct FieldLevelEncryptionProfileAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type of profiles for the field-level encryption.
    public struct FieldLevelEncryptionProfileConfig: Swift.Equatable {
        /// A unique number that ensures that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment for the field-level encryption profile. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// Profile name for the field-level encryption profile.
        /// This member is required.
        public var name: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.name = name
        }
    }

}

extension FieldLevelEncryptionProfileInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified profile for field-level encryption is in use.
public struct FieldLevelEncryptionProfileInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FieldLevelEncryptionProfileInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionProfileInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionprofilesummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionprofilesummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionProfileSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionProfileSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionProfileSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encryption profiles.
    public struct FieldLevelEncryptionProfileList: Swift.Equatable {
        /// The field-level encryption profile items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]?
        /// The maximum number of field-level encryption profiles you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your profiles where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption profiles.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension FieldLevelEncryptionProfileSizeExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileSizeExceededBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum size of a profile for field-level encryption was exceeded.
public struct FieldLevelEncryptionProfileSizeExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileSizeExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FieldLevelEncryptionProfileSizeExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension FieldLevelEncryptionProfileSizeExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The field-level encryption profile summary.
    public struct FieldLevelEncryptionProfileSummary: Swift.Equatable {
        /// An optional comment for the field-level encryption profile summary. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// ID for the field-level encryption profile summary.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the the field-level encryption profile summary was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Name for the field-level encryption profile summary.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of a field-level encryption item.
    public struct FieldLevelEncryptionSummary: Swift.Equatable {
        /// An optional comment about the field-level encryption item. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A summary of a content type-profile mapping.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// The unique ID of a field-level encryption item.
        /// This member is required.
        public var id: Swift.String?
        /// The last time that the summary of field-level encryption items was modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A summary of a query argument-profile mapping.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init(
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension CloudFrontClientTypes.FieldPatterns: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("FieldPattern"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldPattern{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldPattern>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldPatterns: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the field patterns to match for field-level encryption.
    public struct FieldPatterns: Swift.Equatable {
        /// An array of the field-level encryption field patterns.
        public var items: [Swift.String]?
        /// The number of field-level encryption field patterns.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case urlencoded
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .urlencoded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .urlencoded: return "URLEncoded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ForwardedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookies = "Cookies"
        case headers = "Headers"
        case queryString = "QueryString"
        case queryStringCacheKeys = "QueryStringCacheKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
        if let queryString = queryString {
            try container.encode(queryString, forKey: ClientRuntime.Key("QueryString"))
        }
        if let queryStringCacheKeys = queryStringCacheKeys {
            try container.encode(queryStringCacheKeys, forKey: ClientRuntime.Key("QueryStringCacheKeys"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .queryString)
        queryString = queryStringDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookiePreference.self, forKey: .cookies)
        cookies = cookiesDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
        let queryStringCacheKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringCacheKeys.self, forKey: .queryStringCacheKeys)
        queryStringCacheKeys = queryStringCacheKeysDecoded
    }
}

extension CloudFrontClientTypes.ForwardedValues: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
    public struct ForwardedValues: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var cookies: CloudFrontClientTypes.CookiePreference?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include headers in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send headers to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies the Headers, if any, that you want CloudFront to forward to the origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches separate versions of a specified object that is based on the header values in viewer requests. For more information, see [ Caching Content Based on Request Headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html) in the Amazon CloudFront Developer Guide.
        public var headers: CloudFrontClientTypes.Headers?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior and cache based on the query string parameters. CloudFront behavior depends on the value of QueryString and on the values that you specify for QueryStringCacheKeys, if any: If you specify true for QueryString and you don't specify any values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin and caches based on all query string parameters. Depending on how many query string parameters and values you have, this can adversely affect performance because CloudFront must forward more requests to the origin. If you specify true for QueryString and you specify one or more values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin, but it only caches based on the query string parameters that you specify. If you specify false for QueryString, CloudFront doesn't forward any query string parameters to the origin, and doesn't cache based on query string parameters. For more information, see [Configuring CloudFront to Cache Based on Query String Parameters](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var queryString: Swift.Bool?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for this cache behavior.
        public var queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys?

        public init(
            cookies: CloudFrontClientTypes.CookiePreference? = nil,
            headers: CloudFrontClientTypes.Headers? = nil,
            queryString: Swift.Bool? = nil,
            queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys? = nil
        )
        {
            self.cookies = cookies
            self.headers = headers
            self.queryString = queryString
            self.queryStringCacheKeys = queryStringCacheKeys
        }
    }

}

extension CloudFrontClientTypes {
    public enum FrameOptionsList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deny
        case sameorigin
        case sdkUnknown(Swift.String)

        public static var allCases: [FrameOptionsList] {
            return [
                .deny,
                .sameorigin,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case .sameorigin: return "SAMEORIGIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrameOptionsList(rawValue: rawValue) ?? FrameOptionsList.sdkUnknown(rawValue)
        }
    }
}

extension FunctionAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use UpdateFunction.
public struct FunctionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FunctionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension FunctionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case functionARN = "FunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront function that is associated with a cache behavior in a CloudFront distribution.
    public struct FunctionAssociation: Swift.Equatable {
        /// The event type of the function, either viewer-request or viewer-response. You cannot use origin-facing event types (origin-request and origin-response) with a CloudFront function.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// The Amazon Resource Name (ARN) of the function.
        /// This member is required.
        public var functionARN: Swift.String?

        public init(
            eventType: CloudFrontClientTypes.EventType? = nil,
            functionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.functionARN = functionARN
        }
    }

}

extension CloudFrontClientTypes.FunctionAssociations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionassociation0 in items {
                try itemsContainer.encode(functionassociation0, forKey: ClientRuntime.Key("FunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
    public struct FunctionAssociations: Swift.Equatable {
        /// The CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var items: [CloudFrontClientTypes.FunctionAssociation]?
        /// The number of CloudFront functions in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case runtime = "Runtime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let runtime = runtime {
            try container.encode(runtime, forKey: ClientRuntime.Key("Runtime"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
    }
}

extension CloudFrontClientTypes.FunctionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information about a CloudFront function.
    public struct FunctionConfig: Swift.Equatable {
        /// A comment to describe the function.
        /// This member is required.
        public var comment: Swift.String?
        /// The function's runtime environment verion.
        /// This member is required.
        public var runtime: CloudFrontClientTypes.FunctionRuntime?

        public init(
            comment: Swift.String? = nil,
            runtime: CloudFrontClientTypes.FunctionRuntime? = nil
        )
        {
            self.comment = comment
            self.runtime = runtime
        }
    }

}

extension FunctionInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot delete the function because it's attached to one or more cache behaviors.
public struct FunctionInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FunctionInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension FunctionInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionsummary0 in items {
                try itemsContainer.encode(functionsummary0, forKey: ClientRuntime.Key("FunctionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions.
    public struct FunctionList: Swift.Equatable {
        /// Contains the functions in the list.
        public var items: [CloudFrontClientTypes.FunctionSummary]?
        /// The maximum number of functions requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing functions where you left off.
        public var nextMarker: Swift.String?
        /// The number of functions returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FunctionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case functionARN = "FunctionARN"
        case lastModifiedTime = "LastModifiedTime"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encodeTimestamp(createdTime, format: .dateTime, forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension CloudFrontClientTypes.FunctionMetadata: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains metadata about a CloudFront function.
    public struct FunctionMetadata: Swift.Equatable {
        /// The date and time when the function was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the function.
        /// This member is required.
        public var functionARN: Swift.String?
        /// The date and time when the function was most recently updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The stage that the function is in, either DEVELOPMENT or LIVE. When a function is in the DEVELOPMENT stage, you can test the function with TestFunction, and update it with UpdateFunction. When a function is in the LIVE stage, you can attach the function to a distribution's cache behavior, using the function's ARN.
        public var stage: CloudFrontClientTypes.FunctionStage?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            functionARN: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            stage: CloudFrontClientTypes.FunctionStage? = nil
        )
        {
            self.createdTime = createdTime
            self.functionARN = functionARN
            self.lastModifiedTime = lastModifiedTime
            self.stage = stage
        }
    }

}

extension CloudFrontClientTypes {
    public enum FunctionRuntime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudfrontJs10
        case cloudfrontJs20
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionRuntime] {
            return [
                .cloudfrontJs10,
                .cloudfrontJs20,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontJs10: return "cloudfront-js-1.0"
            case .cloudfrontJs20: return "cloudfront-js-2.0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionRuntime(rawValue: rawValue) ?? FunctionRuntime.sdkUnknown(rawValue)
        }
    }
}

extension FunctionSizeLimitExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionSizeLimitExceededBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The function is too large. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct FunctionSizeLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionSizeLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FunctionSizeLimitExceededBody: Swift.Equatable {
    let message: Swift.String?
}

extension FunctionSizeLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum FunctionStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionStage] {
            return [
                .development,
                .live,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionStage(rawValue: rawValue) ?? FunctionStage.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FunctionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfig = "FunctionConfig"
        case functionMetadata = "FunctionMetadata"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let functionMetadata = functionMetadata {
            try container.encode(functionMetadata, forKey: ClientRuntime.Key("FunctionMetadata"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        let functionMetadataDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionMetadata.self, forKey: .functionMetadata)
        functionMetadata = functionMetadataDecoded
    }
}

extension CloudFrontClientTypes.FunctionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information and metadata about a CloudFront function.
    public struct FunctionSummary: Swift.Equatable {
        /// Contains configuration information about a CloudFront function.
        /// This member is required.
        public var functionConfig: CloudFrontClientTypes.FunctionConfig?
        /// Contains metadata about a CloudFront function.
        /// This member is required.
        public var functionMetadata: CloudFrontClientTypes.FunctionMetadata?
        /// The name of the CloudFront function.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the CloudFront function.
        public var status: Swift.String?

        public init(
            functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
            functionMetadata: CloudFrontClientTypes.FunctionMetadata? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.functionConfig = functionConfig
            self.functionMetadata = functionMetadata
            self.name = name
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.GeoRestriction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
        case restrictionType = "RestrictionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Location"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
        if let restrictionType = restrictionType {
            try container.encode(restrictionType, forKey: ClientRuntime.Key("RestrictionType"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restrictionTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestrictionType.self, forKey: .restrictionType)
        restrictionType = restrictionTypeDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Location{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Location>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.GeoRestriction: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
    public struct GeoRestriction: Swift.Equatable {
        /// A complex type that contains a Location element for each country in which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). The Location element is a two-letter, uppercase country code for a country that you want to include in your blacklist or whitelist. Include one Location element for each country. CloudFront and MaxMind both use ISO 3166 country codes. For the current list of countries and the corresponding codes, see ISO 3166-1-alpha-2 code on the International Organization for Standardization website. You can also refer to the country list on the CloudFront console, which includes both country names and codes.
        public var items: [Swift.String]?
        /// When geo restriction is enabled, this is the number of countries in your whitelist or blacklist. Otherwise, when it is not enabled, Quantity is 0, and you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?
        /// The method that you want to use to restrict distribution of your content by country:
        ///
        /// * none: No geo restriction is enabled, meaning access to content is not restricted by client geo location.
        ///
        /// * blacklist: The Location elements specify the countries in which you don't want CloudFront to distribute your content.
        ///
        /// * whitelist: The Location elements specify the countries in which you want CloudFront to distribute your content.
        /// This member is required.
        public var restrictionType: CloudFrontClientTypes.GeoRestrictionType?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil,
            restrictionType: CloudFrontClientTypes.GeoRestrictionType? = nil
        )
        {
            self.items = items
            self.quantity = quantity
            self.restrictionType = restrictionType
        }
    }

}

extension CloudFrontClientTypes {
    public enum GeoRestrictionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blacklist
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoRestrictionType] {
            return [
                .blacklist,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blacklist: return "blacklist"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoRestrictionType(rawValue: rawValue) ?? GeoRestrictionType.sdkUnknown(rawValue)
        }
    }
}

extension GetCachePolicyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetCachePolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyConfigInputBody: Swift.Equatable {
}

extension GetCachePolicyConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CachePolicyConfig = try responseDecoder.decode(responseBody: data)
            self.cachePolicyConfig = output
        } else {
            self.cachePolicyConfig = nil
        }
    }
}

public struct GetCachePolicyConfigOutput: Swift.Equatable {
    /// The cache policy configuration.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.eTag = eTag
    }
}

struct GetCachePolicyConfigOutputBody: Swift.Equatable {
    let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension GetCachePolicyConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

enum GetCachePolicyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyInputBody: Swift.Equatable {
}

extension GetCachePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
            self.cachePolicy = output
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct GetCachePolicyOutput: Swift.Equatable {
    /// The cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct GetCachePolicyOutputBody: Swift.Equatable {
    let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension GetCachePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

enum GetCachePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetCloudFrontOriginAccessIdentityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

/// The origin access identity's configuration information. For more information, see [CloudFrontOriginAccessIdentityConfig](https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html).
public struct GetCloudFrontOriginAccessIdentityConfigInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig = try responseDecoder.decode(responseBody: data)
            self.cloudFrontOriginAccessIdentityConfig = output
        } else {
            self.cloudFrontOriginAccessIdentityConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityConfigOutput: Swift.Equatable {
    /// The origin access identity's configuration information.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityConfigOutputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension GetCloudFrontOriginAccessIdentityConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

enum GetCloudFrontOriginAccessIdentityConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

/// The request to get an origin access identity's information.
public struct GetCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
            self.cloudFrontOriginAccessIdentity = output
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityOutput: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityOutputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension GetCloudFrontOriginAccessIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

enum GetCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetContinuousDeploymentPolicyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetContinuousDeploymentPolicyConfigInput: Swift.Equatable {
    /// The identifier of the continuous deployment policy whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetContinuousDeploymentPolicyConfigInputBody: Swift.Equatable {
}

extension GetContinuousDeploymentPolicyConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetContinuousDeploymentPolicyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig = try responseDecoder.decode(responseBody: data)
            self.continuousDeploymentPolicyConfig = output
        } else {
            self.continuousDeploymentPolicyConfig = nil
        }
    }
}

public struct GetContinuousDeploymentPolicyConfigOutput: Swift.Equatable {
    /// Contains the configuration for a continuous deployment policy.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
        self.eTag = eTag
    }
}

struct GetContinuousDeploymentPolicyConfigOutputBody: Swift.Equatable {
    let continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
}

extension GetContinuousDeploymentPolicyConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicyConfig = "ContinuousDeploymentPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.self, forKey: .continuousDeploymentPolicyConfig)
        continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfigDecoded
    }
}

enum GetContinuousDeploymentPolicyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetContinuousDeploymentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetContinuousDeploymentPolicyInput: Swift.Equatable {
    /// The identifier of the continuous deployment policy that you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetContinuousDeploymentPolicyInputBody: Swift.Equatable {
}

extension GetContinuousDeploymentPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetContinuousDeploymentPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ContinuousDeploymentPolicy = try responseDecoder.decode(responseBody: data)
            self.continuousDeploymentPolicy = output
        } else {
            self.continuousDeploymentPolicy = nil
        }
    }
}

public struct GetContinuousDeploymentPolicyOutput: Swift.Equatable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
    }
}

struct GetContinuousDeploymentPolicyOutputBody: Swift.Equatable {
    let continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
}

extension GetContinuousDeploymentPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicy = "ContinuousDeploymentPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicy.self, forKey: .continuousDeploymentPolicy)
        continuousDeploymentPolicy = continuousDeploymentPolicyDecoded
    }
}

enum GetContinuousDeploymentPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetDistributionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to get a distribution configuration.
public struct GetDistributionConfigInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionConfigInputBody: Swift.Equatable {
}

extension GetDistributionConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionConfig = try responseDecoder.decode(responseBody: data)
            self.distributionConfig = output
        } else {
            self.distributionConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionConfigOutput: Swift.Equatable {
    /// The distribution's configuration information.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.eTag = eTag
    }
}

struct GetDistributionConfigOutputBody: Swift.Equatable {
    let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension GetDistributionConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

enum GetDistributionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to get a distribution's information.
public struct GetDistributionInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionInputBody: Swift.Equatable {
}

extension GetDistributionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
            self.distribution = output
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct GetDistributionOutputBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension GetDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

enum GetDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

public struct GetFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryptionConfig = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryptionConfig = output
        } else {
            self.fieldLevelEncryptionConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionConfigOutput: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct GetFieldLevelEncryptionConfigOutputBody: Swift.Equatable {
    let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension GetFieldLevelEncryptionConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

enum GetFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetFieldLevelEncryptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

public struct GetFieldLevelEncryptionInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryption = output
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct GetFieldLevelEncryptionOutput: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct GetFieldLevelEncryptionOutputBody: Swift.Equatable {
    let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension GetFieldLevelEncryptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

enum GetFieldLevelEncryptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetFieldLevelEncryptionProfileConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

public struct GetFieldLevelEncryptionProfileConfigInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryptionProfileConfig = output
        } else {
            self.fieldLevelEncryptionProfileConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileConfigOutput: Swift.Equatable {
    /// The current version of the field-level encryption profile configuration result. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile configuration information.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct GetFieldLevelEncryptionProfileConfigOutputBody: Swift.Equatable {
    let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension GetFieldLevelEncryptionProfileConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

enum GetFieldLevelEncryptionProfileConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

public struct GetFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryptionProfile = output
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileOutput: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile information.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct GetFieldLevelEncryptionProfileOutputBody: Swift.Equatable {
    let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension GetFieldLevelEncryptionProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

enum GetFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetFunctionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let stage = stage {
                let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
                items.append(stageQueryItem)
            }
            return items
        }
    }
}

extension GetFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct GetFunctionInput: Swift.Equatable {
    /// The name of the function whose code you are getting.
    /// This member is required.
    public var name: Swift.String?
    /// The function's stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionOutput(contentType: \(Swift.String(describing: contentType)), eTag: \(Swift.String(describing: eTag)), functionCode: \"CONTENT_REDACTED\")"}
}

extension GetFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.functionCode = data
        case .stream(let stream):
            self.functionCode = try stream.readToEnd()
        case .none:
            self.functionCode = nil
        }
    }
}

public struct GetFunctionOutput: Swift.Equatable {
    /// The content type (media type) of the response.
    public var contentType: Swift.String?
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// The function code of a CloudFront function.
    public var functionCode: ClientRuntime.Data?

    public init(
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        functionCode: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.functionCode = functionCode
    }
}

struct GetFunctionOutputBody: Swift.Equatable {
    let functionCode: ClientRuntime.Data?
}

extension GetFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

enum GetFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchFunctionExists": return try await NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetInvalidationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation/\(id.urlPercentEncoding())"
    }
}

/// The request to get an invalidation's information.
public struct GetInvalidationInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The identifier for the invalidation request, for example, IDFDVBD632BHDS5.
    /// This member is required.
    public var id: Swift.String?

    public init(
        distributionId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
        self.id = id
    }
}

struct GetInvalidationInputBody: Swift.Equatable {
}

extension GetInvalidationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInvalidationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
            self.invalidation = output
        } else {
            self.invalidation = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetInvalidationOutput: Swift.Equatable {
    /// The invalidation's information. For more information, see [Invalidation Complex Type](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html).
    public var invalidation: CloudFrontClientTypes.Invalidation?

    public init(
        invalidation: CloudFrontClientTypes.Invalidation? = nil
    )
    {
        self.invalidation = invalidation
    }
}

struct GetInvalidationOutputBody: Swift.Equatable {
    let invalidation: CloudFrontClientTypes.Invalidation?
}

extension GetInvalidationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

enum GetInvalidationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchInvalidation": return try await NoSuchInvalidation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetKeyGroupConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())/config"
    }
}

public struct GetKeyGroupConfigInput: Swift.Equatable {
    /// The identifier of the key group whose configuration you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupConfigInputBody: Swift.Equatable {
}

extension GetKeyGroupConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.KeyGroupConfig = try responseDecoder.decode(responseBody: data)
            self.keyGroupConfig = output
        } else {
            self.keyGroupConfig = nil
        }
    }
}

public struct GetKeyGroupConfigOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group configuration.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        eTag: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.eTag = eTag
        self.keyGroupConfig = keyGroupConfig
    }
}

struct GetKeyGroupConfigOutputBody: Swift.Equatable {
    let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension GetKeyGroupConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

enum GetKeyGroupConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct GetKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupInputBody: Swift.Equatable {
}

extension GetKeyGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
            self.keyGroup = output
        } else {
            self.keyGroup = nil
        }
    }
}

public struct GetKeyGroupOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct GetKeyGroupOutputBody: Swift.Equatable {
    let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension GetKeyGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

enum GetKeyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetMonitoringSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct GetMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are getting metrics information for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init(
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct GetMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension GetMonitoringSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMonitoringSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
            self.monitoringSubscription = output
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct GetMonitoringSubscriptionOutput: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct GetMonitoringSubscriptionOutputBody: Swift.Equatable {
    let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension GetMonitoringSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

enum GetMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchMonitoringSubscription": return try await NoSuchMonitoringSubscription(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetOriginAccessControlConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())/config"
    }
}

public struct GetOriginAccessControlConfigInput: Swift.Equatable {
    /// The unique identifier of the origin access control.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginAccessControlConfigInputBody: Swift.Equatable {
}

extension GetOriginAccessControlConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginAccessControlConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginAccessControlConfig = try responseDecoder.decode(responseBody: data)
            self.originAccessControlConfig = output
        } else {
            self.originAccessControlConfig = nil
        }
    }
}

public struct GetOriginAccessControlConfigOutput: Swift.Equatable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// Contains an origin access control configuration.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        eTag: Swift.String? = nil,
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControlConfig = originAccessControlConfig
    }
}

struct GetOriginAccessControlConfigOutputBody: Swift.Equatable {
    let originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?
}

extension GetOriginAccessControlConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControlConfig = "OriginAccessControlConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessControlConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlConfig.self, forKey: .originAccessControlConfig)
        originAccessControlConfig = originAccessControlConfigDecoded
    }
}

enum GetOriginAccessControlConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetOriginAccessControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())"
    }
}

public struct GetOriginAccessControlInput: Swift.Equatable {
    /// The unique identifier of the origin access control.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginAccessControlInputBody: Swift.Equatable {
}

extension GetOriginAccessControlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginAccessControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginAccessControl = try responseDecoder.decode(responseBody: data)
            self.originAccessControl = output
        } else {
            self.originAccessControl = nil
        }
    }
}

public struct GetOriginAccessControlOutput: Swift.Equatable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// Contains an origin access control, including its unique identifier.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControl = originAccessControl
    }
}

struct GetOriginAccessControlOutputBody: Swift.Equatable {
    let originAccessControl: CloudFrontClientTypes.OriginAccessControl?
}

extension GetOriginAccessControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControl = "OriginAccessControl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessControlDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControl.self, forKey: .originAccessControl)
        originAccessControl = originAccessControlDecoded
    }
}

enum GetOriginAccessControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetOriginRequestPolicyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetOriginRequestPolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyConfigInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginRequestPolicyConfig = try responseDecoder.decode(responseBody: data)
            self.originRequestPolicyConfig = output
        } else {
            self.originRequestPolicyConfig = nil
        }
    }
}

public struct GetOriginRequestPolicyConfigOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy configuration.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct GetOriginRequestPolicyConfigOutputBody: Swift.Equatable {
    let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension GetOriginRequestPolicyConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

enum GetOriginRequestPolicyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
            self.originRequestPolicy = output
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct GetOriginRequestPolicyOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct GetOriginRequestPolicyOutputBody: Swift.Equatable {
    let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension GetOriginRequestPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

enum GetOriginRequestPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetPublicKeyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

public struct GetPublicKeyConfigInput: Swift.Equatable {
    /// The identifier of the public key whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyConfigInputBody: Swift.Equatable {
}

extension GetPublicKeyConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.PublicKeyConfig = try responseDecoder.decode(responseBody: data)
            self.publicKeyConfig = output
        } else {
            self.publicKeyConfig = nil
        }
    }
}

public struct GetPublicKeyConfigOutput: Swift.Equatable {
    /// The identifier for this version of the public key configuration.
    public var eTag: Swift.String?
    /// A public key configuration.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        eTag: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.eTag = eTag
        self.publicKeyConfig = publicKeyConfig
    }
}

struct GetPublicKeyConfigOutputBody: Swift.Equatable {
    let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension GetPublicKeyConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

enum GetPublicKeyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchPublicKey": return try await NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetPublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

public struct GetPublicKeyInput: Swift.Equatable {
    /// The identifier of the public key you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyInputBody: Swift.Equatable {
}

extension GetPublicKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
            self.publicKey = output
        } else {
            self.publicKey = nil
        }
    }
}

public struct GetPublicKeyOutput: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct GetPublicKeyOutputBody: Swift.Equatable {
    let publicKey: CloudFrontClientTypes.PublicKey?
}

extension GetPublicKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

enum GetPublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchPublicKey": return try await NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension GetRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

extension GetRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/get-realtime-log-config"
    }
}

public struct GetRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to get.
    public var arn: Swift.String?
    /// The name of the real-time log configuration to get.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct GetRealtimeLogConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension GetRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRealtimeLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRealtimeLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct GetRealtimeLogConfigOutput: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct GetRealtimeLogConfigOutputBody: Swift.Equatable {
    let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension GetRealtimeLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

enum GetRealtimeLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetResponseHeadersPolicyConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetResponseHeadersPolicyConfigInput: Swift.Equatable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetResponseHeadersPolicyConfigInputBody: Swift.Equatable {
}

extension GetResponseHeadersPolicyConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResponseHeadersPolicyConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ResponseHeadersPolicyConfig = try responseDecoder.decode(responseBody: data)
            self.responseHeadersPolicyConfig = output
        } else {
            self.responseHeadersPolicyConfig = nil
        }
    }
}

public struct GetResponseHeadersPolicyConfigOutput: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

struct GetResponseHeadersPolicyConfigOutputBody: Swift.Equatable {
    let responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?
}

extension GetResponseHeadersPolicyConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

enum GetResponseHeadersPolicyConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetResponseHeadersPolicyInputBody: Swift.Equatable {
}

extension GetResponseHeadersPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResponseHeadersPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ResponseHeadersPolicy = try responseDecoder.decode(responseBody: data)
            self.responseHeadersPolicy = output
        } else {
            self.responseHeadersPolicy = nil
        }
    }
}

public struct GetResponseHeadersPolicyOutput: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

struct GetResponseHeadersPolicyOutputBody: Swift.Equatable {
    let responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
}

extension GetResponseHeadersPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

enum GetResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetStreamingDistributionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

/// To request to get a streaming distribution configuration.
public struct GetStreamingDistributionConfigInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionConfigInputBody: Swift.Equatable {
}

extension GetStreamingDistributionConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.StreamingDistributionConfig = try responseDecoder.decode(responseBody: data)
            self.streamingDistributionConfig = output
        } else {
            self.streamingDistributionConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionConfigOutput: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's configuration information.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        eTag: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct GetStreamingDistributionConfigOutputBody: Swift.Equatable {
    let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension GetStreamingDistributionConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

enum GetStreamingDistributionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension GetStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to get a streaming distribution's information.
public struct GetStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionInputBody: Swift.Equatable {
}

extension GetStreamingDistributionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
            self.streamingDistribution = output
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionOutput: Swift.Equatable {
    /// The current version of the streaming distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct GetStreamingDistributionOutputBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension GetStreamingDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

enum GetStreamingDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.Headers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Headers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of HTTP header names.
    public struct Headers: Swift.Equatable {
        /// A list of HTTP header names.
        public var items: [Swift.String]?
        /// The number of header names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum HttpVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http11
        case http2
        case http2and3
        case http3
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpVersion] {
            return [
                .http11,
                .http2,
                .http2and3,
                .http3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http11: return "http1.1"
            case .http2: return "http2"
            case .http2and3: return "http2and3"
            case .http3: return "http3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpVersion(rawValue: rawValue) ?? HttpVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ICPRecordalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [ICPRecordalStatus] {
            return [
                .approved,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICPRecordalStatus(rawValue: rawValue) ?? ICPRecordalStatus.sdkUnknown(rawValue)
        }
    }
}

extension IllegalDelete {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalDeleteBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot delete a managed policy.
public struct IllegalDelete: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalDelete" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalDeleteBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalDeleteBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified configuration for field-level encryption can't be associated with the specified cache behavior.
public struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalOriginAccessConfiguration {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalOriginAccessConfigurationBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).
public struct IllegalOriginAccessConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalOriginAccessConfiguration" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalOriginAccessConfigurationBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalOriginAccessConfigurationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalUpdate {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalUpdateBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The update contains modifications that are not allowed.
public struct IllegalUpdate: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalUpdate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IllegalUpdateBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalUpdateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InconsistentQuantities {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InconsistentQuantitiesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value of Quantity and the size of Items don't match.
public struct InconsistentQuantities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InconsistentQuantities" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InconsistentQuantitiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension InconsistentQuantitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgument {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidArgumentBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An argument is invalid.
public struct InvalidArgument: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgument" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidArgumentBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDefaultRootObject {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDefaultRootObjectBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The default root object file name is too big or contains an invalid character.
public struct InvalidDefaultRootObject: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDefaultRootObject" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDefaultRootObjectBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDefaultRootObjectBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDomainNameForOriginAccessControl {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDomainNameForOriginAccessControlBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An origin access control is associated with an origin whose domain name is not supported.
public struct InvalidDomainNameForOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDomainNameForOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDomainNameForOriginAccessControlBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDomainNameForOriginAccessControlBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidErrorCode {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidErrorCodeBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An invalid error code was specified.
public struct InvalidErrorCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidErrorCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidErrorCodeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidErrorCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidForwardCookies {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidForwardCookiesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.
public struct InvalidForwardCookies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidForwardCookies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidForwardCookiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidForwardCookiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFunctionAssociation {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A CloudFront function association is invalid.
public struct InvalidFunctionAssociation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFunctionAssociation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidFunctionAssociationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGeoRestrictionParameter {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidGeoRestrictionParameterBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified geo restriction parameter is not valid.
public struct InvalidGeoRestrictionParameter: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidGeoRestrictionParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidGeoRestrictionParameterBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidGeoRestrictionParameterBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHeadersForS3Origin {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidHeadersForS3OriginBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The headers specified are not valid for an Amazon S3 origin.
public struct InvalidHeadersForS3Origin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidHeadersForS3Origin" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidHeadersForS3OriginBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidHeadersForS3OriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIfMatchVersion {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidIfMatchVersionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The If-Match version is missing or not valid.
public struct InvalidIfMatchVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidIfMatchVersion" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidIfMatchVersionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidIfMatchVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionAssociation {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidLambdaFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified Lambda@Edge function association is invalid.
public struct InvalidLambdaFunctionAssociation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLambdaFunctionAssociation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidLambdaFunctionAssociationBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLambdaFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLocationCode {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidLocationCodeBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The location code specified is not valid.
public struct InvalidLocationCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLocationCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidLocationCodeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLocationCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMinimumProtocolVersion {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidMinimumProtocolVersionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The minimum protocol version specified is not valid.
public struct InvalidMinimumProtocolVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMinimumProtocolVersion" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidMinimumProtocolVersionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMinimumProtocolVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrigin {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.
public struct InvalidOrigin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOrigin" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidOriginAccessControl {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginAccessControlBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The origin access control is not valid.
public struct InvalidOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOriginAccessControlBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginAccessControlBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginAccessIdentity {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The origin access identity is not valid or doesn't exist.
public struct InvalidOriginAccessIdentity: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginAccessIdentity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOriginAccessIdentityBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct InvalidOriginBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginKeepaliveTimeout {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginKeepaliveTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The keep alive timeout specified for the origin is not valid.
public struct InvalidOriginKeepaliveTimeout: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginKeepaliveTimeout" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOriginKeepaliveTimeoutBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginKeepaliveTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginReadTimeout {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginReadTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The read timeout specified for the origin is not valid.
public struct InvalidOriginReadTimeout: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginReadTimeout" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOriginReadTimeoutBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOriginReadTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProtocolSettings {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidProtocolSettingsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).
public struct InvalidProtocolSettings: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidProtocolSettings" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidProtocolSettingsBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidProtocolSettingsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStringParameters {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The query string parameters specified are not valid.
public struct InvalidQueryStringParameters: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryStringParameters" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidQueryStringParametersBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativePath {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRelativePathBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The relative path is too big, is not URL-encoded, or does not begin with a slash (/).
public struct InvalidRelativePath: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRelativePath" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRelativePathBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRelativePathBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequiredProtocol {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRequiredProtocolBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration.
public struct InvalidRequiredProtocol: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequiredProtocol" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequiredProtocolBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequiredProtocolBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResponseCode {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidResponseCodeBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A response code is not valid.
public struct InvalidResponseCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResponseCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResponseCodeBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResponseCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTTLOrder {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTTLOrderBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The TTL order specified is not valid.
public struct InvalidTTLOrder: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTTLOrder" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTTLOrderBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTTLOrderBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagging {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTaggingBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The tagging specified is not valid.
public struct InvalidTagging: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagging" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTaggingBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTaggingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidViewerCertificate {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidViewerCertificateBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A viewer certificate specified is not valid.
public struct InvalidViewerCertificate: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidViewerCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidViewerCertificateBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidViewerCertificateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebACLId {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidWebACLIdBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a.
public struct InvalidWebACLId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidWebACLId" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidWebACLIdBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidWebACLIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case invalidationBatch = "InvalidationBatch"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encodeTimestamp(createTime, format: .dateTime, forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An invalidation.
    public struct Invalidation: Swift.Equatable {
        /// The date and time the invalidation request was first made.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier for the invalidation request. For example: IDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The current invalidation information for the batch request.
        /// This member is required.
        public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
        /// The status of the invalidation request. When the invalidation batch is finished, the status is Completed.
        /// This member is required.
        public var status: Swift.String?

        public init(
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.invalidationBatch = invalidationBatch
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.InvalidationBatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case paths = "Paths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let paths = paths {
            try container.encode(paths, forKey: ClientRuntime.Key("Paths"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Paths.self, forKey: .paths)
        paths = pathsDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
    }
}

extension CloudFrontClientTypes.InvalidationBatch: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An invalidation batch.
    public struct InvalidationBatch: Swift.Equatable {
        /// A value that you specify to uniquely identify an invalidation request. CloudFront uses the value to prevent you from accidentally resubmitting an identical request. Whenever you create a new invalidation request, you must specify a new value for CallerReference and change other values in the request as applicable. One way to ensure that the value of CallerReference is unique is to use a timestamp, for example, 20120301090000. If you make a second invalidation request with the same value for CallerReference, and if the rest of the request is the same, CloudFront doesn't create a new invalidation request. Instead, CloudFront returns information about the invalidation request that you previously created with the same CallerReference. If CallerReference is a value you already sent in a previous invalidation batch request but the content of any Path is different from the original request, CloudFront returns an InvalidationBatchAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var paths: CloudFrontClientTypes.Paths?

        public init(
            callerReference: Swift.String? = nil,
            paths: CloudFrontClientTypes.Paths? = nil
        )
        {
            self.callerReference = callerReference
            self.paths = paths
        }
    }

}

extension CloudFrontClientTypes.InvalidationList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for invalidationsummary0 in items {
                try itemsContainer.encode(invalidationsummary0, forKey: ClientRuntime.Key("InvalidationSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct InvalidationSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InvalidationSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.InvalidationSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.InvalidationSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.InvalidationSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.InvalidationList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The InvalidationList complex type describes the list of invalidation objects. For more information about invalidation, see [Invalidating Objects (Web Distributions Only)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html) in the Amazon CloudFront Developer Guide.
    public struct InvalidationList: Swift.Equatable {
        /// A flag that indicates whether more invalidation batch requests remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more invalidation batches in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one InvalidationSummary element for each invalidation batch created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.InvalidationSummary]?
        /// The value that you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value that you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value that you can use for the Marker request parameter to continue listing your invalidation batches where they left off.
        public var nextMarker: Swift.String?
        /// The number of invalidation batches that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.InvalidationSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.InvalidationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encodeTimestamp(createTime, format: .dateTime, forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudFrontClientTypes.InvalidationSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of an invalidation request.
    public struct InvalidationSummary: Swift.Equatable {
        /// The time that an invalidation request was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID for an invalidation request.
        /// This member is required.
        public var id: Swift.String?
        /// The status of an invalidation request.
        /// This member is required.
        public var status: Swift.String?

        public init(
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.status = status
        }
    }

}

extension CloudFrontClientTypes {
    public enum ItemSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemSelection] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemSelection(rawValue: rawValue) ?? ItemSelection.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupId = "KeyGroupId"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupId = keyGroupId {
            try container.encode(keyGroupId, forKey: ClientRuntime.Key("KeyGroupId"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyGroupId)
        keyGroupId = keyGroupIdDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of identifiers for the public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct KGKeyPairIds: Swift.Equatable {
        /// The identifier of the key group that contains the public keys.
        public var keyGroupId: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init(
            keyGroupId: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.keyGroupId = keyGroupId
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes.KeyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case keyGroupConfig = "KeyGroupConfig"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CloudFrontClientTypes.KeyGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A key group. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroup: Swift.Equatable {
        /// The identifier for the key group.
        /// This member is required.
        public var id: Swift.String?
        /// The key group configuration.
        /// This member is required.
        public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
        /// The date and time when the key group was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            id: Swift.String? = nil,
            keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.id = id
            self.keyGroupConfig = keyGroupConfig
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension KeyGroupAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<KeyGroupAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A key group with this name already exists. You must provide a unique name. To modify an existing key group, use UpdateKeyGroup.
public struct KeyGroupAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KeyGroupAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KeyGroupAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension KeyGroupAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case items = "Items"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("PublicKey"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKey{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKey>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A key group configuration. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroupConfig: Swift.Equatable {
        /// A comment to describe the key group. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A list of the identifiers of the public keys in the key group.
        /// This member is required.
        public var items: [Swift.String]?
        /// A name to identify the key group.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            items: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.items = items
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.KeyGroupList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for keygroupsummary0 in items {
                try itemsContainer.encode(keygroupsummary0, forKey: ClientRuntime.Key("KeyGroupSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroupSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroupSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KeyGroupSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KeyGroupSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KeyGroupSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyGroupList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups.
    public struct KeyGroupList: Swift.Equatable {
        /// A list of key groups.
        public var items: [CloudFrontClientTypes.KeyGroupSummary]?
        /// The maximum number of key groups requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing key groups.
        public var nextMarker: Swift.String?
        /// The number of key groups returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.KeyGroupSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KeyGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroup = keyGroup {
            try container.encode(keyGroup, forKey: ClientRuntime.Key("KeyGroup"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a key group.
    public struct KeyGroupSummary: Swift.Equatable {
        /// A key group.
        /// This member is required.
        public var keyGroup: CloudFrontClientTypes.KeyGroup?

        public init(
            keyGroup: CloudFrontClientTypes.KeyGroup? = nil
        )
        {
            self.keyGroup = keyGroup
        }
    }

}

extension CloudFrontClientTypes.KeyPairIds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyPairId"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyPairId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyPairId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront key pair identifiers.
    public struct KeyPairIds: Swift.Equatable {
        /// A list of CloudFront key pair identifiers.
        public var items: [Swift.String]?
        /// The number of key pair identifiers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KinesisStreamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleARN = "RoleARN"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: ClientRuntime.Key("RoleARN"))
        }
        if let streamARN = streamARN {
            try container.encode(streamARN, forKey: ClientRuntime.Key("StreamARN"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension CloudFrontClientTypes.KinesisStreamConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public struct KinesisStreamConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that CloudFront can use to send real-time log data to your Kinesis data stream. For more information the IAM role, see [Real-time log configuration IAM role](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var roleARN: Swift.String?
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time log data.
        /// This member is required.
        public var streamARN: Swift.String?

        public init(
            roleARN: Swift.String? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.roleARN = roleARN
            self.streamARN = streamARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case includeBody = "IncludeBody"
        case lambdaFunctionARN = "LambdaFunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let includeBody = includeBody {
            try container.encode(includeBody, forKey: ClientRuntime.Key("IncludeBody"))
        }
        if let lambdaFunctionARN = lambdaFunctionARN {
            try container.encode(lambdaFunctionARN, forKey: ClientRuntime.Key("LambdaFunctionARN"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionARN)
        lambdaFunctionARN = lambdaFunctionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let includeBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeBody)
        includeBody = includeBodyDecoded
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains a Lambda@Edge function association.
    public struct LambdaFunctionAssociation: Swift.Equatable {
        /// Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:
        ///
        /// * viewer-request: The function executes when CloudFront receives a request from a viewer and before it checks to see whether the requested object is in the edge cache.
        ///
        /// * origin-request: The function executes only when CloudFront sends a request to your origin. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * origin-response: The function executes after CloudFront receives a response from the origin and before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * viewer-response: The function executes before CloudFront returns the requested object to the viewer. The function executes regardless of whether the object was already in the edge cache. If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// A flag that allows a Lambda@Edge function to have read access to the body content. For more information, see [Accessing the Request Body by Choosing the Include Body Option](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html) in the Amazon CloudFront Developer Guide.
        public var includeBody: Swift.Bool?
        /// The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias or $LATEST.
        /// This member is required.
        public var lambdaFunctionARN: Swift.String?

        public init(
            eventType: CloudFrontClientTypes.EventType? = nil,
            includeBody: Swift.Bool? = nil,
            lambdaFunctionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.includeBody = includeBody
            self.lambdaFunctionARN = lambdaFunctionARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for lambdafunctionassociation0 in items {
                try itemsContainer.encode(lambdafunctionassociation0, forKey: ClientRuntime.Key("LambdaFunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct LambdaFunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LambdaFunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.LambdaFunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.LambdaFunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.LambdaFunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that specifies a list of Lambda@Edge functions associations for a cache behavior. If you want to invoke one or more Lambda@Edge functions triggered by requests that match the PathPattern of the cache behavior, specify the applicable values for Quantity and Items. Note that there can be up to 4 LambdaFunctionAssociation items in this list (one for each possible value of EventType) and each EventType can be associated with only one function. If you don't want to invoke any Lambda@Edge functions for the requests that match PathPattern, specify 0 for Quantity and omit Items.
    public struct LambdaFunctionAssociations: Swift.Equatable {
        /// Optional: A complex type that contains LambdaFunctionAssociation items for this cache behavior. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.LambdaFunctionAssociation]?
        /// The number of Lambda@Edge function associations for this cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.LambdaFunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ListCachePoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListCachePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

public struct ListCachePoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of cache policies. The response includes cache policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of cache policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of cache policies. Valid values are:
    ///
    /// * managed  Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom  Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.CachePolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.CachePolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListCachePoliciesInputBody: Swift.Equatable {
}

extension ListCachePoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCachePoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CachePolicyList = try responseDecoder.decode(responseBody: data)
            self.cachePolicyList = output
        } else {
            self.cachePolicyList = nil
        }
    }
}

public struct ListCachePoliciesOutput: Swift.Equatable {
    /// A list of cache policies.
    public var cachePolicyList: CloudFrontClientTypes.CachePolicyList?

    public init(
        cachePolicyList: CloudFrontClientTypes.CachePolicyList? = nil
    )
    {
        self.cachePolicyList = cachePolicyList
    }
}

struct ListCachePoliciesOutputBody: Swift.Equatable {
    let cachePolicyList: CloudFrontClientTypes.CachePolicyList?
}

extension ListCachePoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyList = "CachePolicyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyList.self, forKey: .cachePolicyList)
        cachePolicyList = cachePolicyListDecoded
    }
}

enum ListCachePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

/// The request to list origin access identities.
public struct ListCloudFrontOriginAccessIdentitiesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
    public var marker: Swift.String?
    /// The maximum number of origin access identities you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Equatable {
}

extension ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList = try responseDecoder.decode(responseBody: data)
            self.cloudFrontOriginAccessIdentityList = output
        } else {
            self.cloudFrontOriginAccessIdentityList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListCloudFrontOriginAccessIdentitiesOutput: Swift.Equatable {
    /// The CloudFrontOriginAccessIdentityList type.
    public var cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?

    public init(
        cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityList
    }
}

struct ListCloudFrontOriginAccessIdentitiesOutputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?
}

extension ListCloudFrontOriginAccessIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityList = "CloudFrontOriginAccessIdentityList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityList.self, forKey: .cloudFrontOriginAccessIdentityList)
        cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityListDecoded
    }
}

enum ListCloudFrontOriginAccessIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListConflictingAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let alias = alias else {
                let message = "Creating a URL Query Item failed. alias is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
            guard let distributionId = distributionId else {
                let message = "Creating a URL Query Item failed. distributionId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let distributionIdQueryItem = ClientRuntime.URLQueryItem(name: "DistributionId".urlPercentEncoding(), value: Swift.String(distributionId).urlPercentEncoding())
            items.append(distributionIdQueryItem)
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListConflictingAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/conflicting-alias"
    }
}

public struct ListConflictingAliasesInput: Swift.Equatable {
    /// The alias (also called a CNAME) to search for conflicting aliases.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of conflicting aliases that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        alias: Swift.String? = nil,
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListConflictingAliasesInputBody: Swift.Equatable {
}

extension ListConflictingAliasesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConflictingAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ConflictingAliasesList = try responseDecoder.decode(responseBody: data)
            self.conflictingAliasesList = output
        } else {
            self.conflictingAliasesList = nil
        }
    }
}

public struct ListConflictingAliasesOutput: Swift.Equatable {
    /// A list of conflicting aliases.
    public var conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?

    public init(
        conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList? = nil
    )
    {
        self.conflictingAliasesList = conflictingAliasesList
    }
}

struct ListConflictingAliasesOutputBody: Swift.Equatable {
    let conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?
}

extension ListConflictingAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictingAliasesList = "ConflictingAliasesList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictingAliasesListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ConflictingAliasesList.self, forKey: .conflictingAliasesList)
        conflictingAliasesList = conflictingAliasesListDecoded
    }
}

enum ListConflictingAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListContinuousDeploymentPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListContinuousDeploymentPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/continuous-deployment-policy"
    }
}

public struct ListContinuousDeploymentPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of continuous deployment policies. The response includes policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of continuous deployment policies that you want returned in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListContinuousDeploymentPoliciesInputBody: Swift.Equatable {
}

extension ListContinuousDeploymentPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListContinuousDeploymentPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ContinuousDeploymentPolicyList = try responseDecoder.decode(responseBody: data)
            self.continuousDeploymentPolicyList = output
        } else {
            self.continuousDeploymentPolicyList = nil
        }
    }
}

public struct ListContinuousDeploymentPoliciesOutput: Swift.Equatable {
    /// A list of continuous deployment policies.
    public var continuousDeploymentPolicyList: CloudFrontClientTypes.ContinuousDeploymentPolicyList?

    public init(
        continuousDeploymentPolicyList: CloudFrontClientTypes.ContinuousDeploymentPolicyList? = nil
    )
    {
        self.continuousDeploymentPolicyList = continuousDeploymentPolicyList
    }
}

struct ListContinuousDeploymentPoliciesOutputBody: Swift.Equatable {
    let continuousDeploymentPolicyList: CloudFrontClientTypes.ContinuousDeploymentPolicyList?
}

extension ListContinuousDeploymentPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicyList = "ContinuousDeploymentPolicyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicyList.self, forKey: .continuousDeploymentPolicyList)
        continuousDeploymentPolicyList = continuousDeploymentPolicyListDecoded
    }
}

enum ListContinuousDeploymentPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListDistributionsByCachePolicyIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListDistributionsByCachePolicyIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let cachePolicyId = cachePolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByCachePolicyId/\(cachePolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByCachePolicyIdInput: Swift.Equatable {
    /// The ID of the cache policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var cachePolicyId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        cachePolicyId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.cachePolicyId = cachePolicyId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByCachePolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByCachePolicyIdInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByCachePolicyIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
            self.distributionIdList = output
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByCachePolicyIdOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByCachePolicyIdOutputBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByCachePolicyIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

enum ListDistributionsByCachePolicyIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListDistributionsByKeyGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListDistributionsByKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let keyGroupId = keyGroupId else {
            return nil
        }
        return "/2020-05-31/distributionsByKeyGroupId/\(keyGroupId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByKeyGroupInput: Swift.Equatable {
    /// The ID of the key group whose associated distribution IDs you are listing.
    /// This member is required.
    public var keyGroupId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        keyGroupId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByKeyGroupInputBody: Swift.Equatable {
}

extension ListDistributionsByKeyGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByKeyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
            self.distributionIdList = output
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByKeyGroupOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByKeyGroupOutputBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByKeyGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

enum ListDistributionsByKeyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let originRequestPolicyId = originRequestPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByOriginRequestPolicyId/\(originRequestPolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByOriginRequestPolicyIdInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?
    /// The ID of the origin request policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var originRequestPolicyId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        originRequestPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.originRequestPolicyId = originRequestPolicyId
    }
}

struct ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
            self.distributionIdList = output
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByOriginRequestPolicyIdOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByOriginRequestPolicyIdOutputBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByOriginRequestPolicyIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

enum ListDistributionsByOriginRequestPolicyIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListDistributionsByRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension ListDistributionsByRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let realtimeLogConfigName = realtimeLogConfigName {
            try container.encode(realtimeLogConfigName, forKey: ClientRuntime.Key("RealtimeLogConfigName"))
        }
    }
}

extension ListDistributionsByRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distributionsByRealtimeLogConfig"
    }
}

public struct ListDistributionsByRealtimeLogConfigInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distributions. The response includes distributions in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distributions that you want in the response.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigArn: Swift.String?
    /// The name of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        realtimeLogConfigArn: Swift.String? = nil,
        realtimeLogConfigName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.realtimeLogConfigName = realtimeLogConfigName
    }
}

struct ListDistributionsByRealtimeLogConfigInputBody: Swift.Equatable {
    let marker: Swift.String?
    let maxItems: Swift.Int?
    let realtimeLogConfigName: Swift.String?
    let realtimeLogConfigArn: Swift.String?
}

extension ListDistributionsByRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let realtimeLogConfigNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigName)
        realtimeLogConfigName = realtimeLogConfigNameDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
    }
}

extension ListDistributionsByRealtimeLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
            self.distributionList = output
        } else {
            self.distributionList = nil
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigOutput: Swift.Equatable {
    /// A distribution list.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByRealtimeLogConfigOutputBody: Swift.Equatable {
    let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByRealtimeLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

enum ListDistributionsByRealtimeLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let responseHeadersPolicyId = responseHeadersPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByResponseHeadersPolicyId/\(responseHeadersPolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want to get in the response.
    public var maxItems: Swift.Int?
    /// The ID of the response headers policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var responseHeadersPolicyId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        responseHeadersPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.responseHeadersPolicyId = responseHeadersPolicyId
    }
}

struct ListDistributionsByResponseHeadersPolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByResponseHeadersPolicyIdInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByResponseHeadersPolicyIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
            self.distributionIdList = output
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByResponseHeadersPolicyIdOutputBody: Swift.Equatable {
    let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByResponseHeadersPolicyIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

enum ListDistributionsByResponseHeadersPolicyIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListDistributionsByWebACLIdInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListDistributionsByWebACLIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let webACLId = webACLId else {
            return nil
        }
        return "/2020-05-31/distributionsByWebACLId/\(webACLId.urlPercentEncoding())"
    }
}

/// The request to list distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdInput: Swift.Equatable {
    /// Use Marker and MaxItems to control pagination of results. If you have more than MaxItems distributions that satisfy the request, the response includes a NextMarker element. To get the next page of results, submit another request. For the value of Marker, specify the value of NextMarker from the last response. (For the first request, omit Marker.)
    public var marker: Swift.String?
    /// The maximum number of distributions that you want CloudFront to return in the response body. The maximum and default values are both 100.
    public var maxItems: Swift.Int?
    /// The ID of the WAF web ACL that you want to list the associated distributions. If you specify "null" for the ID, the request returns a list of the distributions that aren't associated with a web ACL.
    /// This member is required.
    public var webACLId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        webACLId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.webACLId = webACLId
    }
}

struct ListDistributionsByWebACLIdInputBody: Swift.Equatable {
}

extension ListDistributionsByWebACLIdInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByWebACLIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
            self.distributionList = output
        } else {
            self.distributionList = nil
        }
    }
}

/// The response to a request to list the distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdOutput: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByWebACLIdOutputBody: Swift.Equatable {
    let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByWebACLIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

enum ListDistributionsByWebACLIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidWebACLId": return try await InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListDistributionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListDistributionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to list your distributions.
public struct ListDistributionsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page).
    public var marker: Swift.String?
    /// The maximum number of distributions you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsInputBody: Swift.Equatable {
}

extension ListDistributionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
            self.distributionList = output
        } else {
            self.distributionList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListDistributionsOutput: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsOutputBody: Swift.Equatable {
    let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

enum ListDistributionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListFieldLevelEncryptionConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListFieldLevelEncryptionConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

public struct ListFieldLevelEncryptionConfigsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last configuration on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption configurations you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionConfigsInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryptionList = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryptionList = output
        } else {
            self.fieldLevelEncryptionList = nil
        }
    }
}

public struct ListFieldLevelEncryptionConfigsOutput: Swift.Equatable {
    /// Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.
    public var fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?

    public init(
        fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList? = nil
    )
    {
        self.fieldLevelEncryptionList = fieldLevelEncryptionList
    }
}

struct ListFieldLevelEncryptionConfigsOutputBody: Swift.Equatable {
    let fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?
}

extension ListFieldLevelEncryptionConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionList = "FieldLevelEncryptionList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionList.self, forKey: .fieldLevelEncryptionList)
        fieldLevelEncryptionList = fieldLevelEncryptionListDecoded
    }
}

enum ListFieldLevelEncryptionConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListFieldLevelEncryptionProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListFieldLevelEncryptionProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

public struct ListFieldLevelEncryptionProfilesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last profile on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption profiles you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionProfilesInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryptionProfileList = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryptionProfileList = output
        } else {
            self.fieldLevelEncryptionProfileList = nil
        }
    }
}

public struct ListFieldLevelEncryptionProfilesOutput: Swift.Equatable {
    /// Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.
    public var fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?

    public init(
        fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList? = nil
    )
    {
        self.fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileList
    }
}

struct ListFieldLevelEncryptionProfilesOutputBody: Swift.Equatable {
    let fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?
}

extension ListFieldLevelEncryptionProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileList = "FieldLevelEncryptionProfileList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileList.self, forKey: .fieldLevelEncryptionProfileList)
        fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileListDecoded
    }
}

enum ListFieldLevelEncryptionProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListFunctionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let stage = stage {
                let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
                items.append(stageQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/function"
    }
}

public struct ListFunctionsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of functions. The response includes functions in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of functions that you want in the response.
    public var maxItems: Swift.Int?
    /// An optional filter to return only the functions that are in the specified stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.stage = stage
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FunctionList = try responseDecoder.decode(responseBody: data)
            self.functionList = output
        } else {
            self.functionList = nil
        }
    }
}

public struct ListFunctionsOutput: Swift.Equatable {
    /// A list of CloudFront functions.
    public var functionList: CloudFrontClientTypes.FunctionList?

    public init(
        functionList: CloudFrontClientTypes.FunctionList? = nil
    )
    {
        self.functionList = functionList
    }
}

struct ListFunctionsOutputBody: Swift.Equatable {
    let functionList: CloudFrontClientTypes.FunctionList?
}

extension ListFunctionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionList = "FunctionList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionList.self, forKey: .functionList)
        functionList = functionListDecoded
    }
}

enum ListFunctionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListInvalidationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListInvalidationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let distributionId = distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

/// The request to list invalidations.
public struct ListInvalidationsInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this parameter when paginating results to indicate where to begin in your list of invalidation batches. Because the results are returned in decreasing order from most recent to oldest, the most recent results are on the first page, the second page will contain earlier results, and so on. To get the next page of results, set Marker to the value of the NextMarker from the current page's response. This value is the same as the ID of the last invalidation batch on that page.
    public var marker: Swift.String?
    /// The maximum number of invalidation batches that you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListInvalidationsInputBody: Swift.Equatable {
}

extension ListInvalidationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListInvalidationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.InvalidationList = try responseDecoder.decode(responseBody: data)
            self.invalidationList = output
        } else {
            self.invalidationList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListInvalidationsOutput: Swift.Equatable {
    /// Information about invalidation batches.
    public var invalidationList: CloudFrontClientTypes.InvalidationList?

    public init(
        invalidationList: CloudFrontClientTypes.InvalidationList? = nil
    )
    {
        self.invalidationList = invalidationList
    }
}

struct ListInvalidationsOutputBody: Swift.Equatable {
    let invalidationList: CloudFrontClientTypes.InvalidationList?
}

extension ListInvalidationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationList = "InvalidationList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationList.self, forKey: .invalidationList)
        invalidationList = invalidationListDecoded
    }
}

enum ListInvalidationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListKeyGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListKeyGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/key-group"
    }
}

public struct ListKeyGroupsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of key groups. The response includes key groups in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of key groups that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListKeyGroupsInputBody: Swift.Equatable {
}

extension ListKeyGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKeyGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.KeyGroupList = try responseDecoder.decode(responseBody: data)
            self.keyGroupList = output
        } else {
            self.keyGroupList = nil
        }
    }
}

public struct ListKeyGroupsOutput: Swift.Equatable {
    /// A list of key groups.
    public var keyGroupList: CloudFrontClientTypes.KeyGroupList?

    public init(
        keyGroupList: CloudFrontClientTypes.KeyGroupList? = nil
    )
    {
        self.keyGroupList = keyGroupList
    }
}

struct ListKeyGroupsOutputBody: Swift.Equatable {
    let keyGroupList: CloudFrontClientTypes.KeyGroupList?
}

extension ListKeyGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupList = "KeyGroupList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupList.self, forKey: .keyGroupList)
        keyGroupList = keyGroupListDecoded
    }
}

enum ListKeyGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListOriginAccessControlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListOriginAccessControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-access-control"
    }
}

public struct ListOriginAccessControlsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of origin access controls. The response includes the items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of origin access controls that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListOriginAccessControlsInputBody: Swift.Equatable {
}

extension ListOriginAccessControlsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginAccessControlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginAccessControlList = try responseDecoder.decode(responseBody: data)
            self.originAccessControlList = output
        } else {
            self.originAccessControlList = nil
        }
    }
}

public struct ListOriginAccessControlsOutput: Swift.Equatable {
    /// A list of origin access controls.
    public var originAccessControlList: CloudFrontClientTypes.OriginAccessControlList?

    public init(
        originAccessControlList: CloudFrontClientTypes.OriginAccessControlList? = nil
    )
    {
        self.originAccessControlList = originAccessControlList
    }
}

struct ListOriginAccessControlsOutputBody: Swift.Equatable {
    let originAccessControlList: CloudFrontClientTypes.OriginAccessControlList?
}

extension ListOriginAccessControlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControlList = "OriginAccessControlList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessControlListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlList.self, forKey: .originAccessControlList)
        originAccessControlList = originAccessControlListDecoded
    }
}

enum ListOriginAccessControlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListOriginRequestPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListOriginRequestPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

public struct ListOriginRequestPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of origin request policies. The response includes origin request policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of origin request policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of origin request policies. Valid values are:
    ///
    /// * managed  Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom  Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.OriginRequestPolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListOriginRequestPoliciesInputBody: Swift.Equatable {
}

extension ListOriginRequestPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginRequestPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginRequestPolicyList = try responseDecoder.decode(responseBody: data)
            self.originRequestPolicyList = output
        } else {
            self.originRequestPolicyList = nil
        }
    }
}

public struct ListOriginRequestPoliciesOutput: Swift.Equatable {
    /// A list of origin request policies.
    public var originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?

    public init(
        originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList? = nil
    )
    {
        self.originRequestPolicyList = originRequestPolicyList
    }
}

struct ListOriginRequestPoliciesOutputBody: Swift.Equatable {
    let originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?
}

extension ListOriginRequestPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyList = "OriginRequestPolicyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyList.self, forKey: .originRequestPolicyList)
        originRequestPolicyList = originRequestPolicyListDecoded
    }
}

enum ListOriginRequestPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListPublicKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListPublicKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/public-key"
    }
}

public struct ListPublicKeysInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last public key on that page).
    public var marker: Swift.String?
    /// The maximum number of public keys you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListPublicKeysInputBody: Swift.Equatable {
}

extension ListPublicKeysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPublicKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.PublicKeyList = try responseDecoder.decode(responseBody: data)
            self.publicKeyList = output
        } else {
            self.publicKeyList = nil
        }
    }
}

public struct ListPublicKeysOutput: Swift.Equatable {
    /// Returns a list of all public keys that have been added to CloudFront for this account.
    public var publicKeyList: CloudFrontClientTypes.PublicKeyList?

    public init(
        publicKeyList: CloudFrontClientTypes.PublicKeyList? = nil
    )
    {
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputBody: Swift.Equatable {
    let publicKeyList: CloudFrontClientTypes.PublicKeyList?
}

extension ListPublicKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyList = "PublicKeyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyList.self, forKey: .publicKeyList)
        publicKeyList = publicKeyListDecoded
    }
}

enum ListPublicKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListRealtimeLogConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension ListRealtimeLogConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct ListRealtimeLogConfigsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of real-time log configurations. The response includes real-time log configurations in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of real-time log configurations that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListRealtimeLogConfigsInputBody: Swift.Equatable {
}

extension ListRealtimeLogConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRealtimeLogConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.RealtimeLogConfigs = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfigs = output
        } else {
            self.realtimeLogConfigs = nil
        }
    }
}

public struct ListRealtimeLogConfigsOutput: Swift.Equatable {
    /// A list of real-time log configurations.
    public var realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?

    public init(
        realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs? = nil
    )
    {
        self.realtimeLogConfigs = realtimeLogConfigs
    }
}

struct ListRealtimeLogConfigsOutputBody: Swift.Equatable {
    let realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?
}

extension ListRealtimeLogConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfigs = "RealtimeLogConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfigs.self, forKey: .realtimeLogConfigs)
        realtimeLogConfigs = realtimeLogConfigsDecoded
    }
}

enum ListRealtimeLogConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListResponseHeadersPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListResponseHeadersPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

public struct ListResponseHeadersPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of response headers policies. The response includes response headers policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of response headers policies that you want to get in the response.
    public var maxItems: Swift.Int?
    /// A filter to get only the specified kind of response headers policies. Valid values are:
    ///
    /// * managed  Gets only the managed policies created by Amazon Web Services.
    ///
    /// * custom  Gets only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListResponseHeadersPoliciesInputBody: Swift.Equatable {
}

extension ListResponseHeadersPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResponseHeadersPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ResponseHeadersPolicyList = try responseDecoder.decode(responseBody: data)
            self.responseHeadersPolicyList = output
        } else {
            self.responseHeadersPolicyList = nil
        }
    }
}

public struct ListResponseHeadersPoliciesOutput: Swift.Equatable {
    /// A list of response headers policies.
    public var responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList?

    public init(
        responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList? = nil
    )
    {
        self.responseHeadersPolicyList = responseHeadersPolicyList
    }
}

struct ListResponseHeadersPoliciesOutputBody: Swift.Equatable {
    let responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList?
}

extension ListResponseHeadersPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyList = "ResponseHeadersPolicyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyList.self, forKey: .responseHeadersPolicyList)
        responseHeadersPolicyList = responseHeadersPolicyListDecoded
    }
}

enum ListResponseHeadersPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListStreamingDistributionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListStreamingDistributionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to list your streaming distributions.
public struct ListStreamingDistributionsInput: Swift.Equatable {
    /// The value that you provided for the Marker request parameter.
    public var marker: Swift.String?
    /// The value that you provided for the MaxItems request parameter.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListStreamingDistributionsInputBody: Swift.Equatable {
}

extension ListStreamingDistributionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingDistributionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.StreamingDistributionList = try responseDecoder.decode(responseBody: data)
            self.streamingDistributionList = output
        } else {
            self.streamingDistributionList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListStreamingDistributionsOutput: Swift.Equatable {
    /// The StreamingDistributionList type.
    public var streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?

    public init(
        streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList? = nil
    )
    {
        self.streamingDistributionList = streamingDistributionList
    }
}

struct ListStreamingDistributionsOutputBody: Swift.Equatable {
    let streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?
}

extension ListStreamingDistributionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionList = "StreamingDistributionList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionList.self, forKey: .streamingDistributionList)
        streamingDistributionList = streamingDistributionListDecoded
    }
}

enum ListStreamingDistributionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resource = resource else {
                let message = "Creating a URL Query Item failed. resource is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            items.append(resourceQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to list tags for a CloudFront resource.
public struct ListTagsForResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Tags = try responseDecoder.decode(responseBody: data)
            self.tags = output
        } else {
            self.tags = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init(
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: CloudFrontClientTypes.Tags?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTagging": return try await InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.LoggingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case includeCookies = "IncludeCookies"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let includeCookies = includeCookies {
            try container.encode(includeCookies, forKey: ClientRuntime.Key("IncludeCookies"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includeCookiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCookies)
        includeCookies = includeCookiesDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension CloudFrontClientTypes.LoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for the distribution.
    public struct LoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a distribution or if you want to disable logging for an existing distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket, prefix, and IncludeCookies, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs, specify true for IncludeCookies. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you don't want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify false for IncludeCookies.
        /// This member is required.
        public var includeCookies: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            includeCookies: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.`prefix` = `prefix`
        }
    }

}

extension CloudFrontClientTypes {
    public enum Method: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [Method] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Method(rawValue: rawValue) ?? Method.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum MinimumProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv112016
        case tlsv12016
        case tlsv122018
        case tlsv122019
        case tlsv122021
        case sdkUnknown(Swift.String)

        public static var allCases: [MinimumProtocolVersion] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv112016,
                .tlsv12016,
                .tlsv122018,
                .tlsv122019,
                .tlsv122021,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv112016: return "TLSv1.1_2016"
            case .tlsv12016: return "TLSv1_2016"
            case .tlsv122018: return "TLSv1.2_2018"
            case .tlsv122019: return "TLSv1.2_2019"
            case .tlsv122021: return "TLSv1.2_2021"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MinimumProtocolVersion(rawValue: rawValue) ?? MinimumProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension MissingBody {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<MissingBodyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This operation requires a body. Ensure that the body is present and the Content-Type header is set.
public struct MissingBody: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingBody" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MissingBodyBody: Swift.Equatable {
    let message: Swift.String?
}

extension MissingBodyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionConfig = "RealtimeMetricsSubscriptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig {
            try container.encode(realtimeMetricsSubscriptionConfig, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.self, forKey: .realtimeMetricsSubscriptionConfig)
        realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfigDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public struct MonitoringSubscription: Swift.Equatable {
        /// A subscription configuration for additional CloudWatch metrics.
        public var realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?

        public init(
            realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig? = nil
        )
        {
            self.realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig
        }
    }

}

extension MonitoringSubscriptionAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<MonitoringSubscriptionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A monitoring subscription already exists for the specified distribution.
public struct MonitoringSubscriptionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MonitoringSubscriptionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MonitoringSubscriptionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension MonitoringSubscriptionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchCachePolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The cache policy does not exist.
public struct NoSuchCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchCloudFrontOriginAccessIdentity {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchCloudFrontOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified origin access identity does not exist.
public struct NoSuchCloudFrontOriginAccessIdentity: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchCloudFrontOriginAccessIdentity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchCloudFrontOriginAccessIdentityBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchCloudFrontOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchContinuousDeploymentPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchContinuousDeploymentPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The continuous deployment policy doesn't exist.
public struct NoSuchContinuousDeploymentPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchContinuousDeploymentPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchContinuousDeploymentPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchContinuousDeploymentPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchDistribution {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified distribution does not exist.
public struct NoSuchDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionConfig {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified configuration for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFieldLevelEncryptionConfig" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchFieldLevelEncryptionConfigBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionProfile {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFieldLevelEncryptionProfileBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified profile for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionProfile: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFieldLevelEncryptionProfile" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchFieldLevelEncryptionProfileBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionProfileBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFunctionExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFunctionExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The function does not exist.
public struct NoSuchFunctionExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFunctionExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchFunctionExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchFunctionExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchInvalidation {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchInvalidationBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified invalidation does not exist.
public struct NoSuchInvalidation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchInvalidation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchInvalidationBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchInvalidationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchMonitoringSubscription {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchMonitoringSubscriptionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A monitoring subscription does not exist for the specified distribution.
public struct NoSuchMonitoringSubscription: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchMonitoringSubscription" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchMonitoringSubscriptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchMonitoringSubscriptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrigin {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchOriginBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// No origin exists with the specified Origin Id.
public struct NoSuchOrigin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOrigin" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchOriginAccessControl {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchOriginAccessControlBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The origin access control does not exist.
public struct NoSuchOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchOriginAccessControlBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchOriginAccessControlBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct NoSuchOriginBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOriginRequestPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The origin request policy does not exist.
public struct NoSuchOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchPublicKey {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchPublicKeyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified public key doesn't exist.
public struct NoSuchPublicKey: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchPublicKey" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchPublicKeyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchPublicKeyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRealtimeLogConfig {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchRealtimeLogConfigBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The real-time log configuration does not exist.
public struct NoSuchRealtimeLogConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchRealtimeLogConfig" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchRealtimeLogConfigBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchRealtimeLogConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResource {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchResourceBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource that was specified is not valid.
public struct NoSuchResource: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResource" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchResourceBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchResourceBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResponseHeadersPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The response headers policy does not exist.
public struct NoSuchResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchStreamingDistribution {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchStreamingDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified streaming distribution does not exist.
public struct NoSuchStreamingDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchStreamingDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoSuchStreamingDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoSuchStreamingDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Origin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAttempts = "ConnectionAttempts"
        case connectionTimeout = "ConnectionTimeout"
        case customHeaders = "CustomHeaders"
        case customOriginConfig = "CustomOriginConfig"
        case domainName = "DomainName"
        case id = "Id"
        case originAccessControlId = "OriginAccessControlId"
        case originPath = "OriginPath"
        case originShield = "OriginShield"
        case s3OriginConfig = "S3OriginConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let connectionAttempts = connectionAttempts {
            try container.encode(connectionAttempts, forKey: ClientRuntime.Key("ConnectionAttempts"))
        }
        if let connectionTimeout = connectionTimeout {
            try container.encode(connectionTimeout, forKey: ClientRuntime.Key("ConnectionTimeout"))
        }
        if let customHeaders = customHeaders {
            try container.encode(customHeaders, forKey: ClientRuntime.Key("CustomHeaders"))
        }
        if let customOriginConfig = customOriginConfig {
            try container.encode(customOriginConfig, forKey: ClientRuntime.Key("CustomOriginConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let originAccessControlId = originAccessControlId {
            try container.encode(originAccessControlId, forKey: ClientRuntime.Key("OriginAccessControlId"))
        }
        if let originPath = originPath {
            try container.encode(originPath, forKey: ClientRuntime.Key("OriginPath"))
        }
        if let originShield = originShield {
            try container.encode(originShield, forKey: ClientRuntime.Key("OriginShield"))
        }
        if let s3OriginConfig = s3OriginConfig {
            try container.encode(s3OriginConfig, forKey: ClientRuntime.Key("S3OriginConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originPath)
        originPath = originPathDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomHeaders.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let s3OriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3OriginConfig.self, forKey: .s3OriginConfig)
        s3OriginConfig = s3OriginConfigDecoded
        let customOriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomOriginConfig.self, forKey: .customOriginConfig)
        customOriginConfig = customOriginConfigDecoded
        let connectionAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionAttempts)
        connectionAttempts = connectionAttemptsDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let originShieldDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginShield.self, forKey: .originShield)
        originShield = originShieldDecoded
        let originAccessControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessControlId)
        originAccessControlId = originAccessControlIdDecoded
    }
}

extension CloudFrontClientTypes.Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin. An origin is the location where content is stored, and from which CloudFront gets content to serve to viewers. To specify an origin:
    ///
    /// * Use S3OriginConfig to specify an Amazon S3 bucket that is not configured with static website hosting.
    ///
    /// * Use CustomOriginConfig to specify all other kinds of origins, including:
    ///
    /// * An Amazon S3 bucket that is configured with static website hosting
    ///
    /// * An Elastic Load Balancing load balancer
    ///
    /// * An AWS Elemental MediaPackage endpoint
    ///
    /// * An AWS Elemental MediaStore container
    ///
    /// * Any other HTTP server, running on an Amazon EC2 instance or any other kind of host
    ///
    ///
    ///
    ///
    ///
    /// For the current maximum number of origins that you can specify per distribution, see [General Quotas on Web Distributions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions) in the Amazon CloudFront Developer Guide (quotas were formerly referred to as limits).
    public struct Origin: Swift.Equatable {
        /// The number of times that CloudFront attempts to connect to the origin. The minimum number is 1, the maximum is 3, and the default (if you don't specify otherwise) is 3. For a custom origin (including an Amazon S3 bucket that's configured with static website hosting), this value also specifies the number of times that CloudFront attempts to get a response from the origin, in the case of an [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout). For more information, see [Origin Connection Attempts](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts) in the Amazon CloudFront Developer Guide.
        public var connectionAttempts: Swift.Int?
        /// The number of seconds that CloudFront waits when trying to establish a connection to the origin. The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you don't specify otherwise) is 10 seconds. For more information, see [Origin Connection Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout) in the Amazon CloudFront Developer Guide.
        public var connectionTimeout: Swift.Int?
        /// A list of HTTP header names and values that CloudFront adds to the requests that it sends to the origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html) in the Amazon CloudFront Developer Guide.
        public var customHeaders: CloudFrontClientTypes.CustomHeaders?
        /// Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public var customOriginConfig: CloudFrontClientTypes.CustomOriginConfig?
        /// The domain name for the origin. For more information, see [Origin Domain Name](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the origin. This value must be unique within the distribution. Use this value to specify the TargetOriginId in a CacheBehavior or DefaultCacheBehavior.
        /// This member is required.
        public var id: Swift.String?
        /// The unique identifier of an origin access control for this origin. For more information, see [Restricting access to an Amazon S3 origin](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        public var originAccessControlId: Swift.String?
        /// An optional path that CloudFront appends to the origin domain name when CloudFront requests content from the origin. For more information, see [Origin Path](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath) in the Amazon CloudFront Developer Guide.
        public var originPath: Swift.String?
        /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
        public var originShield: CloudFrontClientTypes.OriginShield?
        /// Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static website hosting. To specify any other type of origin, including an Amazon S3 bucket that is configured with static website hosting, use the CustomOriginConfig type instead.
        public var s3OriginConfig: CloudFrontClientTypes.S3OriginConfig?

        public init(
            connectionAttempts: Swift.Int? = nil,
            connectionTimeout: Swift.Int? = nil,
            customHeaders: CloudFrontClientTypes.CustomHeaders? = nil,
            customOriginConfig: CloudFrontClientTypes.CustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originAccessControlId: Swift.String? = nil,
            originPath: Swift.String? = nil,
            originShield: CloudFrontClientTypes.OriginShield? = nil,
            s3OriginConfig: CloudFrontClientTypes.S3OriginConfig? = nil
        )
        {
            self.connectionAttempts = connectionAttempts
            self.connectionTimeout = connectionTimeout
            self.customHeaders = customHeaders
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originAccessControlId = originAccessControlId
            self.originPath = originPath
            self.originShield = originShield
            self.s3OriginConfig = s3OriginConfig
        }
    }

}

extension CloudFrontClientTypes.OriginAccessControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case originAccessControlConfig = "OriginAccessControlConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let originAccessControlConfig = originAccessControlConfig {
            try container.encode(originAccessControlConfig, forKey: ClientRuntime.Key("OriginAccessControlConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originAccessControlConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlConfig.self, forKey: .originAccessControlConfig)
        originAccessControlConfig = originAccessControlConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginAccessControl: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront origin access control, including its unique identifier.
    public struct OriginAccessControl: Swift.Equatable {
        /// The unique identifier of the origin access control.
        /// This member is required.
        public var id: Swift.String?
        /// The origin access control.
        public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

        public init(
            id: Swift.String? = nil,
            originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
        )
        {
            self.id = id
            self.originAccessControlConfig = originAccessControlConfig
        }
    }

}

extension OriginAccessControlAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<OriginAccessControlAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An origin access control with the specified parameters already exists.
public struct OriginAccessControlAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginAccessControlAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OriginAccessControlAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension OriginAccessControlAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginAccessControlConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case originAccessControlOriginType = "OriginAccessControlOriginType"
        case signingBehavior = "SigningBehavior"
        case signingProtocol = "SigningProtocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let originAccessControlOriginType = originAccessControlOriginType {
            try container.encode(originAccessControlOriginType, forKey: ClientRuntime.Key("OriginAccessControlOriginType"))
        }
        if let signingBehavior = signingBehavior {
            try container.encode(signingBehavior, forKey: ClientRuntime.Key("SigningBehavior"))
        }
        if let signingProtocol = signingProtocol {
            try container.encode(signingProtocol, forKey: ClientRuntime.Key("SigningProtocol"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signingProtocolDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlSigningProtocols.self, forKey: .signingProtocol)
        signingProtocol = signingProtocolDecoded
        let signingBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlSigningBehaviors.self, forKey: .signingBehavior)
        signingBehavior = signingBehaviorDecoded
        let originAccessControlOriginTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlOriginTypes.self, forKey: .originAccessControlOriginType)
        originAccessControlOriginType = originAccessControlOriginTypeDecoded
    }
}

extension CloudFrontClientTypes.OriginAccessControlConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront origin access control configuration.
    public struct OriginAccessControlConfig: Swift.Equatable {
        /// A description of the origin access control.
        public var description: Swift.String?
        /// A name to identify the origin access control.
        /// This member is required.
        public var name: Swift.String?
        /// The type of origin that this origin access control is for.
        /// This member is required.
        public var originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes?
        /// Specifies which requests CloudFront signs (adds authentication information to). Specify always for the most common use case. For more information, see [origin access control advanced settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html#oac-advanced-settings) in the Amazon CloudFront Developer Guide. This field can have one of the following values:
        ///
        /// * always  CloudFront signs all origin requests, overwriting the Authorization header from the viewer request if one exists.
        ///
        /// * never  CloudFront doesn't sign any origin requests. This value turns off origin access control for all origins in all distributions that use this origin access control.
        ///
        /// * no-override  If the viewer request doesn't contain the Authorization header, then CloudFront signs the origin request. If the viewer request contains the Authorization header, then CloudFront doesn't sign the origin request and instead passes along the Authorization header from the viewer request. WARNING: To pass along the Authorization header from the viewer request, you must add the Authorization header to a [cache policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html) for all cache behaviors that use origins associated with this origin access control.
        /// This member is required.
        public var signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors?
        /// The signing protocol of the origin access control, which determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
        /// This member is required.
        public var signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes? = nil,
            signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors? = nil,
            signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols? = nil
        )
        {
            self.description = description
            self.name = name
            self.originAccessControlOriginType = originAccessControlOriginType
            self.signingBehavior = signingBehavior
            self.signingProtocol = signingProtocol
        }
    }

}

extension OriginAccessControlInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<OriginAccessControlInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot delete the origin access control because it's in use by one or more distributions.
public struct OriginAccessControlInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginAccessControlInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OriginAccessControlInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension OriginAccessControlInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginAccessControlList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for originaccesscontrolsummary0 in items {
                try itemsContainer.encode(originaccesscontrolsummary0, forKey: ClientRuntime.Key("OriginAccessControlSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginAccessControlSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginAccessControlSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginAccessControlSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginAccessControlSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginAccessControlSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginAccessControlList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront origin access controls.
    public struct OriginAccessControlList: Swift.Equatable {
        /// If there are more items in the list than are in this response, this value is true.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the origin access controls in the list.
        public var items: [CloudFrontClientTypes.OriginAccessControlSummary]?
        /// The value of the Marker field that was provided in the request.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access controls requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value to use in the Marker field of another request to continue listing origin access controls.
        public var nextMarker: Swift.String?
        /// The number of origin access controls returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.OriginAccessControlSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginAccessControlOriginTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mediastore
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlOriginTypes] {
            return [
                .mediastore,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mediastore: return "mediastore"
            case .s3: return "s3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginAccessControlOriginTypes(rawValue: rawValue) ?? OriginAccessControlOriginTypes.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum OriginAccessControlSigningBehaviors: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case never
        case noOverride
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlSigningBehaviors] {
            return [
                .always,
                .never,
                .noOverride,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "always"
            case .never: return "never"
            case .noOverride: return "no-override"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginAccessControlSigningBehaviors(rawValue: rawValue) ?? OriginAccessControlSigningBehaviors.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum OriginAccessControlSigningProtocols: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sigv4
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlSigningProtocols] {
            return [
                .sigv4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sigv4: return "sigv4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginAccessControlSigningProtocols(rawValue: rawValue) ?? OriginAccessControlSigningProtocols.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginAccessControlSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case originAccessControlOriginType = "OriginAccessControlOriginType"
        case signingBehavior = "SigningBehavior"
        case signingProtocol = "SigningProtocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let originAccessControlOriginType = originAccessControlOriginType {
            try container.encode(originAccessControlOriginType, forKey: ClientRuntime.Key("OriginAccessControlOriginType"))
        }
        if let signingBehavior = signingBehavior {
            try container.encode(signingBehavior, forKey: ClientRuntime.Key("SigningBehavior"))
        }
        if let signingProtocol = signingProtocol {
            try container.encode(signingProtocol, forKey: ClientRuntime.Key("SigningProtocol"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let signingProtocolDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlSigningProtocols.self, forKey: .signingProtocol)
        signingProtocol = signingProtocolDecoded
        let signingBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlSigningBehaviors.self, forKey: .signingBehavior)
        signingBehavior = signingBehaviorDecoded
        let originAccessControlOriginTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlOriginTypes.self, forKey: .originAccessControlOriginType)
        originAccessControlOriginType = originAccessControlOriginTypeDecoded
    }
}

extension CloudFrontClientTypes.OriginAccessControlSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront origin access control.
    public struct OriginAccessControlSummary: Swift.Equatable {
        /// A description of the origin access control.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the origin access control.
        /// This member is required.
        public var id: Swift.String?
        /// A unique name that identifies the origin access control.
        /// This member is required.
        public var name: Swift.String?
        /// The type of origin that this origin access control is for.
        /// This member is required.
        public var originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes?
        /// A value that specifies which requests CloudFront signs (adds authentication information to). This field can have one of the following values:
        ///
        /// * never  CloudFront doesn't sign any origin requests.
        ///
        /// * always  CloudFront signs all origin requests, overwriting the Authorization header from the viewer request if necessary.
        ///
        /// * no-override  If the viewer request doesn't contain the Authorization header, CloudFront signs the origin request. If the viewer request contains the Authorization header, CloudFront doesn't sign the origin request, but instead passes along the Authorization header that it received in the viewer request.
        /// This member is required.
        public var signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors?
        /// The signing protocol of the origin access control. The signing protocol determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
        /// This member is required.
        public var signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes? = nil,
            signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors? = nil,
            signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.originAccessControlOriginType = originAccessControlOriginType
            self.signingBehavior = signingBehavior
            self.signingProtocol = signingProtocol
        }
    }

}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerName = "HeaderName"
        case headerValue = "HeaderValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerName = headerName {
            try container.encode(headerName, forKey: ClientRuntime.Key("HeaderName"))
        }
        if let headerValue = headerValue {
            try container.encode(headerValue, forKey: ClientRuntime.Key("HeaderValue"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let headerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerValue)
        headerValue = headerValueDecoded
    }
}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginCustomHeader(headerName: \(Swift.String(describing: headerName)), headerValue: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes.OriginCustomHeader: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains HeaderName and HeaderValue elements, if any, for this distribution.
    public struct OriginCustomHeader: Swift.Equatable {
        /// The name of a header that you want CloudFront to send to your origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var headerName: Swift.String?
        /// The value for the header that you specified in the HeaderName field.
        /// This member is required.
        public var headerValue: Swift.String?

        public init(
            headerName: Swift.String? = nil,
            headerValue: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.headerValue = headerValue
        }
    }

}

extension CloudFrontClientTypes.OriginGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverCriteria = "FailoverCriteria"
        case id = "Id"
        case members = "Members"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let failoverCriteria = failoverCriteria {
            try container.encode(failoverCriteria, forKey: ClientRuntime.Key("FailoverCriteria"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let members = members {
            try container.encode(members, forKey: ClientRuntime.Key("Members"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let failoverCriteriaDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupFailoverCriteria.self, forKey: .failoverCriteria)
        failoverCriteria = failoverCriteriaDecoded
        let membersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupMembers.self, forKey: .members)
        members = membersDecoded
    }
}

extension CloudFrontClientTypes.OriginGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify. You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specifiy the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin under the failover conditions that you've chosen.
    public struct OriginGroup: Swift.Equatable {
        /// A complex type that contains information about the failover criteria for an origin group.
        /// This member is required.
        public var failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria?
        /// The origin group's ID.
        /// This member is required.
        public var id: Swift.String?
        /// A complex type that contains information about the origins in an origin group.
        /// This member is required.
        public var members: CloudFrontClientTypes.OriginGroupMembers?

        public init(
            failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria? = nil,
            id: Swift.String? = nil,
            members: CloudFrontClientTypes.OriginGroupMembers? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
            self.id = id
            self.members = members
        }
    }

}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let statusCodes = statusCodes {
            try container.encode(statusCodes, forKey: ClientRuntime.Key("StatusCodes"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes information about the failover criteria for an origin group, including the status codes for which CloudFront will failover from the primary origin to the second origin.
    public struct OriginGroupFailoverCriteria: Swift.Equatable {
        /// The status codes that, when returned from the primary origin, will trigger CloudFront to failover to the second origin.
        /// This member is required.
        public var statusCodes: CloudFrontClientTypes.StatusCodes?

        public init(
            statusCodes: CloudFrontClientTypes.StatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originId = "OriginId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originId = originId {
            try container.encode(originId, forKey: ClientRuntime.Key("OriginId"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originId)
        originId = originIdDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupMember: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin in an origin group.
    public struct OriginGroupMember: Swift.Equatable {
        /// The ID for an origin in an origin group.
        /// This member is required.
        public var originId: Swift.String?

        public init(
            originId: Swift.String? = nil
        )
        {
            self.originId = originId
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMembers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroupmember0 in items {
                try itemsContainer.encode(origingroupmember0, forKey: ClientRuntime.Key("OriginGroupMember"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroupMember{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroupMember>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroupMember].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroupMember]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroupMember]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroupMembers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origins included in an origin group.
    public struct OriginGroupMembers: Swift.Equatable {
        /// Items (origins) in an origin group.
        /// This member is required.
        public var items: [CloudFrontClientTypes.OriginGroupMember]?
        /// The number of origins in an origin group.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginGroupMember]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.OriginGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroup0 in items {
                try itemsContainer.encode(origingroup0, forKey: ClientRuntime.Key("OriginGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroup].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroup]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroup]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origin groups specified for a distribution.
    public struct OriginGroups: Swift.Equatable {
        /// The items (origin groups) in a distribution.
        public var items: [CloudFrontClientTypes.OriginGroup]?
        /// The number of origin groups.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginGroup]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpOnly
        case httpsOnly
        case matchViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginProtocolPolicy] {
            return [
                .httpOnly,
                .httpsOnly,
                .matchViewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpOnly: return "http-only"
            case .httpsOnly: return "https-only"
            case .matchViewer: return "match-viewer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginProtocolPolicy(rawValue: rawValue) ?? OriginProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy. When it's attached to a cache behavior, the origin request policy determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can't find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicy: Swift.Equatable {
        /// The unique identifier for the origin request policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the origin request policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The origin request policy configuration.
        /// This member is required.
        public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

        public init(
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.originRequestPolicyConfig = originRequestPolicyConfig
        }
    }

}

extension OriginRequestPolicyAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<OriginRequestPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use UpdateOriginRequestPolicy.
public struct OriginRequestPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginRequestPolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OriginRequestPolicyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension OriginRequestPolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case cookiesConfig = "CookiesConfig"
        case headersConfig = "HeadersConfig"
        case name = "Name"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy configuration. This configuration determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can't find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicyConfig: Swift.Equatable {
        /// A comment to describe the origin request policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The cookies from viewer requests to include in origin requests.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?
        /// The HTTP headers to include in origin requests. These can include headers from viewer requests and additional headers added by CloudFront.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?
        /// A unique name to identify the origin request policy.
        /// This member is required.
        public var name: Swift.String?
        /// The URL query strings from viewer requests to include in origin requests.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?

        public init(
            comment: Swift.String? = nil,
            cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig? = nil,
            headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig? = nil,
            name: Swift.String? = nil,
            queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig? = nil
        )
        {
            self.comment = comment
            self.cookiesConfig = cookiesConfig
            self.headersConfig = headersConfig
            self.name = name
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyCookieBehavior(rawValue: rawValue) ?? OriginRequestPolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyCookiesConfig: Swift.Equatable {
        /// Determines whether cookies in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none  No cookies in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist  Only the cookies in viewer requests that are listed in the CookieNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all  All cookies in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept  All cookies in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the CookieNames type, which are not included.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init(
            cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allexcept
        case allviewer
        case allviewerandwhitelistcloudfront
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyHeaderBehavior] {
            return [
                .allexcept,
                .allviewer,
                .allviewerandwhitelistcloudfront,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allexcept: return "allExcept"
            case .allviewer: return "allViewer"
            case .allviewerandwhitelistcloudfront: return "allViewerAndWhitelistCloudFront"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyHeaderBehavior(rawValue: rawValue) ?? OriginRequestPolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none  No HTTP headers in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist  Only the HTTP headers that are listed in the Headers type are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewer  All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewerAndWhitelistCloudFront  All HTTP headers in viewer requests and the additional CloudFront headers that are listed in the Headers type are included in requests that CloudFront sends to the origin. The additional headers are added by CloudFront.
        ///
        /// * allExcept  All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the Headers type, which are not included.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init(
            headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension OriginRequestPolicyInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<OriginRequestPolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot delete the origin request policy because it is attached to one or more cache behaviors.
public struct OriginRequestPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginRequestPolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OriginRequestPolicyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension OriginRequestPolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for originrequestpolicysummary0 in items {
                try itemsContainer.encode(originrequestpolicysummary0, forKey: ClientRuntime.Key("OriginRequestPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginRequestPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginRequestPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginRequestPolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginRequestPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginRequestPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of origin request policies.
    public struct OriginRequestPolicyList: Swift.Equatable {
        /// Contains the origin request policies in the list.
        public var items: [CloudFrontClientTypes.OriginRequestPolicySummary]?
        /// The maximum number of origin request policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing origin request policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of origin request policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginRequestPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyQueryStringBehavior(rawValue: rawValue) ?? OriginRequestPolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none  No query strings in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist  Only the query strings in viewer requests that are listed in the QueryStringNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all  All query strings in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept  All query strings in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the QueryStringNames type, which are not included.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the OriginRequestPolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init(
            queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.OriginRequestPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicy = originRequestPolicy {
            try container.encode(originRequestPolicy, forKey: ClientRuntime.Key("OriginRequestPolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyType.self, forKey: .type)
        type = typeDecoded
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains an origin request policy.
    public struct OriginRequestPolicySummary: Swift.Equatable {
        /// The origin request policy.
        /// This member is required.
        public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
        /// The type of origin request policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.OriginRequestPolicyType?

        public init(
            originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil,
            type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
        )
        {
            self.originRequestPolicy = originRequestPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyType(rawValue: rawValue) ?? OriginRequestPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginShield: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case originShieldRegion = "OriginShieldRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let originShieldRegion = originShieldRegion {
            try container.encode(originShieldRegion, forKey: ClientRuntime.Key("OriginShieldRegion"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let originShieldRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originShieldRegion)
        originShieldRegion = originShieldRegionDecoded
    }
}

extension CloudFrontClientTypes.OriginShield: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
    public struct OriginShield: Swift.Equatable {
        /// A flag that specifies whether Origin Shield is enabled. When it's enabled, CloudFront routes all requests through Origin Shield, which can help protect your origin. When it's disabled, CloudFront might send requests directly to your origin from multiple edge locations or regional edge caches.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The Amazon Web Services Region for Origin Shield. Specify the Amazon Web Services Region that has the lowest latency to your origin. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2. When you enable CloudFront Origin Shield, you must specify the Amazon Web Services Region for Origin Shield. For the list of Amazon Web Services Regions that you can specify, and for help choosing the best Region for your origin, see [Choosing the Amazon Web Services Region for Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region) in the Amazon CloudFront Developer Guide.
        public var originShieldRegion: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            originShieldRegion: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.originShieldRegion = originShieldRegion
        }
    }

}

extension CloudFrontClientTypes.OriginSslProtocols: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for sslprotocol0 in items {
                try itemsContainer.encode(sslprotocol0, forKey: ClientRuntime.Key("SslProtocol"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct SslProtocol{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SslProtocol>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.SslProtocol].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.SslProtocol]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.SslProtocol]()
                    for enumContainer0 in itemsContainer {
                        itemsBuffer?.append(enumContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginSslProtocols: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin.
    public struct OriginSslProtocols: Swift.Equatable {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        /// This member is required.
        public var items: [CloudFrontClientTypes.SslProtocol]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.SslProtocol]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.Origins: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origin0 in items {
                try itemsContainer.encode(origin0, forKey: ClientRuntime.Key("Origin"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Origin{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Origin>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Origin].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Origin]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Origin]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Origins: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the origins for this distribution.
    public struct Origins: Swift.Equatable {
        /// A list of origins.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Origin]?
        /// The number of origins for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.Origin]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookiesConfig = "CookiesConfig"
        case enableAcceptEncodingBrotli = "EnableAcceptEncodingBrotli"
        case enableAcceptEncodingGzip = "EnableAcceptEncodingGzip"
        case headersConfig = "HeadersConfig"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let enableAcceptEncodingBrotli = enableAcceptEncodingBrotli {
            try container.encode(enableAcceptEncodingBrotli, forKey: ClientRuntime.Key("EnableAcceptEncodingBrotli"))
        }
        if let enableAcceptEncodingGzip = enableAcceptEncodingGzip {
            try container.encode(enableAcceptEncodingGzip, forKey: ClientRuntime.Key("EnableAcceptEncodingGzip"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAcceptEncodingGzipDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingGzip)
        enableAcceptEncodingGzip = enableAcceptEncodingGzipDecoded
        let enableAcceptEncodingBrotliDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingBrotli)
        enableAcceptEncodingBrotli = enableAcceptEncodingBrotliDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This object determines the values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer. The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find an object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct ParametersInCacheKeyAndForwardedToOrigin: Swift.Equatable {
        /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingGzip field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer's Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it's not included in the cache key and it's not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        public var enableAcceptEncodingBrotli: Swift.Bool?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingBrotli field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer's Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it's not included in the cache key and it's not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        /// This member is required.
        public var enableAcceptEncodingGzip: Swift.Bool?
        /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig?
        /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig?

        public init(
            cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig? = nil,
            enableAcceptEncodingBrotli: Swift.Bool? = nil,
            enableAcceptEncodingGzip: Swift.Bool? = nil,
            headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig? = nil,
            queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig? = nil
        )
        {
            self.cookiesConfig = cookiesConfig
            self.enableAcceptEncodingBrotli = enableAcceptEncodingBrotli
            self.enableAcceptEncodingGzip = enableAcceptEncodingGzip
            self.headersConfig = headersConfig
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes.Paths: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Path"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Path{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Path>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Paths: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
    public struct Paths: Swift.Equatable {
        /// A complex type that contains a list of the paths that you want to invalidate.
        public var items: [Swift.String]?
        /// The number of invalidation paths specified for the objects that you want to invalidate.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension PreconditionFailed {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PreconditionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The precondition in one or more of the request fields evaluated to false.
public struct PreconditionFailed: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailed" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PreconditionFailedBody: Swift.Equatable {
    let message: Swift.String?
}

extension PreconditionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum PriceClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case priceclass100
        case priceclass200
        case priceclassAll
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceClass] {
            return [
                .priceclass100,
                .priceclass200,
                .priceclassAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .priceclass100: return "PriceClass_100"
            case .priceclass200: return "PriceClass_200"
            case .priceclassAll: return "PriceClass_All"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PriceClass(rawValue: rawValue) ?? PriceClass.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.PublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case id = "Id"
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encodeTimestamp(createdTime, format: .dateTime, forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CloudFrontClientTypes.PublicKey: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKey: Swift.Equatable {
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
        )
        {
            self.createdTime = createdTime
            self.id = id
            self.publicKeyConfig = publicKeyConfig
        }
    }

}

extension PublicKeyAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PublicKeyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified public key already exists.
public struct PublicKeyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PublicKeyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PublicKeyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension PublicKeyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encodedKey = "EncodedKey"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyConfig: Swift.Equatable {
        /// A string included in the request to help make sure that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var encodedKey: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encodedKey: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encodedKey = encodedKey
            self.name = name
        }
    }

}

extension PublicKeyInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PublicKeyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified public key is in use.
public struct PublicKeyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PublicKeyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PublicKeyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension PublicKeyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for publickeysummary0 in items {
                try itemsContainer.encode(publickeysummary0, forKey: ClientRuntime.Key("PublicKeySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKeySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKeySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.PublicKeySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.PublicKeySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.PublicKeySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.PublicKeyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of public keys that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyList: Swift.Equatable {
        /// A list of public keys.
        public var items: [CloudFrontClientTypes.PublicKeySummary]?
        /// The maximum number of public keys you want in the response.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your public keys where you left off.
        public var nextMarker: Swift.String?
        /// The number of public keys in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.PublicKeySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.PublicKeySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case createdTime = "CreatedTime"
        case encodedKey = "EncodedKey"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let createdTime = createdTime {
            try container.encodeTimestamp(createdTime, format: .dateTime, forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a public key.
    public struct PublicKeySummary: Swift.Equatable {
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The public key.
        /// This member is required.
        public var encodedKey: Swift.String?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encodedKey: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.createdTime = createdTime
            self.encodedKey = encodedKey
            self.id = id
            self.name = name
        }
    }

}

extension PublishFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension PublishFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/publish"
    }
}

public struct PublishFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are publishing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are publishing.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct PublishFunctionInputBody: Swift.Equatable {
}

extension PublishFunctionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PublishFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
            self.functionSummary = output
        } else {
            self.functionSummary = nil
        }
    }
}

public struct PublishFunctionOutput: Swift.Equatable {
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.functionSummary = functionSummary
    }
}

struct PublishFunctionOutputBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension PublishFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

enum PublishFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFunctionExists": return try await NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.QueryArgProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
        case queryArg = "QueryArg"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
        if let queryArg = queryArg {
            try container.encode(queryArg, forKey: ClientRuntime.Key("QueryArg"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryArgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryArg)
        queryArg = queryArgDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfile: Swift.Equatable {
        /// ID of profile to use for field-level encryption query argument-profile mapping
        /// This member is required.
        public var profileId: Swift.String?
        /// Query argument for field-level encryption query argument-profile mapping.
        /// This member is required.
        public var queryArg: Swift.String?

        public init(
            profileId: Swift.String? = nil,
            queryArg: Swift.String? = nil
        )
        {
            self.profileId = profileId
            self.queryArg = queryArg
        }
    }

}

extension CloudFrontClientTypes.QueryArgProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forwardWhenQueryArgProfileIsUnknown = "ForwardWhenQueryArgProfileIsUnknown"
        case queryArgProfiles = "QueryArgProfiles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown {
            try container.encode(forwardWhenQueryArgProfileIsUnknown, forKey: ClientRuntime.Key("ForwardWhenQueryArgProfileIsUnknown"))
        }
        if let queryArgProfiles = queryArgProfiles {
            try container.encode(queryArgProfiles, forKey: ClientRuntime.Key("QueryArgProfiles"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenQueryArgProfileIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenQueryArgProfileIsUnknown)
        forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknownDecoded
        let queryArgProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfiles.self, forKey: .queryArgProfiles)
        queryArgProfiles = queryArgProfilesDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Configuration for query argument-profile mapping for field-level encryption.
    public struct QueryArgProfileConfig: Swift.Equatable {
        /// Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
        /// This member is required.
        public var forwardWhenQueryArgProfileIsUnknown: Swift.Bool?
        /// Profiles specified for query argument-profile mapping for field-level encryption.
        public var queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles?

        public init(
            forwardWhenQueryArgProfileIsUnknown: Swift.Bool? = nil,
            queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles? = nil
        )
        {
            self.forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown
            self.queryArgProfiles = queryArgProfiles
        }
    }

}

extension QueryArgProfileEmpty {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<QueryArgProfileEmptyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// No profile specified for the field-level encryption query argument.
public struct QueryArgProfileEmpty: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryArgProfileEmpty" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct QueryArgProfileEmptyBody: Swift.Equatable {
    let message: Swift.String?
}

extension QueryArgProfileEmptyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for queryargprofile0 in items {
                try itemsContainer.encode(queryargprofile0, forKey: ClientRuntime.Key("QueryArgProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct QueryArgProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.QueryArgProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.QueryArgProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.QueryArgProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.QueryArgProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfiles: Swift.Equatable {
        /// Number of items for query argument-profile mapping for field-level encryption.
        public var items: [CloudFrontClientTypes.QueryArgProfile]?
        /// Number of profiles for query argument-profile mapping for field-level encryption.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.QueryArgProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringCacheKeys: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringCacheKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use QueryStringsConfig in a cache policy. See CachePolicy. If you want to send query strings to the origin but not include them in the cache key, use QueryStringsConfig in an origin request policy. See OriginRequestPolicy. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for a cache behavior.
    public struct QueryStringCacheKeys: Swift.Equatable {
        /// A list that contains the query string parameters that you want CloudFront to use as a basis for caching for a cache behavior. If Quantity is 0, you can omit Items.
        public var items: [Swift.String]?
        /// The number of whitelisted query string parameters for a cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringNames: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of query string names.
    public struct QueryStringNames: Swift.Equatable {
        /// A list of query string names.
        public var items: [Swift.String]?
        /// The number of query string names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.RealtimeLogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension CloudFrontClientTypes.RealtimeLogConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A real-time log configuration.
    public struct RealtimeLogConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this real-time log configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data for this real-time log configuration.
        /// This member is required.
        public var endPoints: [CloudFrontClientTypes.EndPoint]?
        /// A list of fields that are included in each real-time log record. In an API response, the fields are provided in the same order in which they are sent to the Amazon Kinesis data stream. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var fields: [Swift.String]?
        /// The unique name of this real-time log configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. The sampling rate is an integer between 1 and 100, inclusive.
        /// This member is required.
        public var samplingRate: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
            fields: [Swift.String]? = nil,
            name: Swift.String? = nil,
            samplingRate: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.endPoints = endPoints
            self.fields = fields
            self.name = name
            self.samplingRate = samplingRate
        }
    }

}

extension RealtimeLogConfigAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use UpdateRealtimeLogConfig.
public struct RealtimeLogConfigAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RealtimeLogConfigAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension RealtimeLogConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.
public struct RealtimeLogConfigInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RealtimeLogConfigInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension RealtimeLogConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigOwnerMismatch {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigOwnerMismatchBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified real-time log configuration belongs to a different Amazon Web Services account.
public struct RealtimeLogConfigOwnerMismatch: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigOwnerMismatch" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RealtimeLogConfigOwnerMismatchBody: Swift.Equatable {
    let message: Swift.String?
}

extension RealtimeLogConfigOwnerMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for realtimelogconfig0 in items {
                try itemsContainer.encode(realtimelogconfig0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct member{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.RealtimeLogConfig].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.RealtimeLogConfig]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.RealtimeLogConfig]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of real-time log configurations.
    public struct RealtimeLogConfigs: Swift.Equatable {
        /// A flag that indicates whether there are more real-time log configurations than are contained in this list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the list of real-time log configurations.
        public var items: [CloudFrontClientTypes.RealtimeLogConfig]?
        /// This parameter indicates where this list of real-time log configurations begins. This list includes real-time log configurations that occur after the marker.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of real-time log configurations requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing real-time log configurations where you left off.
        public var nextMarker: Swift.String?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.RealtimeLogConfig]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
        }
    }

}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionStatus = "RealtimeMetricsSubscriptionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus {
            try container.encode(realtimeMetricsSubscriptionStatus, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionStatus"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus.self, forKey: .realtimeMetricsSubscriptionStatus)
        realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatusDecoded
    }
}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A subscription configuration for additional CloudWatch metrics.
    public struct RealtimeMetricsSubscriptionConfig: Swift.Equatable {
        /// A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
        /// This member is required.
        public var realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus?

        public init(
            realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus? = nil
        )
        {
            self.realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus
        }
    }

}

extension CloudFrontClientTypes {
    public enum RealtimeMetricsSubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RealtimeMetricsSubscriptionStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealtimeMetricsSubscriptionStatus(rawValue: rawValue) ?? RealtimeMetricsSubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ReferrerPolicyList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noReferrer
        case noReferrerWhenDowngrade
        case origin
        case originWhenCrossOrigin
        case sameOrigin
        case strictOrigin
        case strictOriginWhenCrossOrigin
        case unsafeUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferrerPolicyList] {
            return [
                .noReferrer,
                .noReferrerWhenDowngrade,
                .origin,
                .originWhenCrossOrigin,
                .sameOrigin,
                .strictOrigin,
                .strictOriginWhenCrossOrigin,
                .unsafeUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noReferrer: return "no-referrer"
            case .noReferrerWhenDowngrade: return "no-referrer-when-downgrade"
            case .origin: return "origin"
            case .originWhenCrossOrigin: return "origin-when-cross-origin"
            case .sameOrigin: return "same-origin"
            case .strictOrigin: return "strict-origin"
            case .strictOriginWhenCrossOrigin: return "strict-origin-when-cross-origin"
            case .unsafeUrl: return "unsafe-url"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferrerPolicyList(rawValue: rawValue) ?? ReferrerPolicyList.sdkUnknown(rawValue)
        }
    }
}

extension ResourceInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot delete this resource because it is in use.
public struct ResourceInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let responseHeadersPolicyConfig = responseHeadersPolicyConfig {
            try container.encode(responseHeadersPolicyConfig, forKey: ClientRuntime.Key("ResponseHeadersPolicyConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A response headers policy. A response headers policy contains information about a set of HTTP response headers. After you create a response headers policy, you can use its ID to attach it to one or more cache behaviors in a CloudFront distribution. When it's attached to a cache behavior, the response headers policy affects the HTTP headers that CloudFront includes in HTTP responses to requests that match the cache behavior. CloudFront adds or removes response headers according to the configuration of the response headers policy. For more information, see [Adding or removing HTTP headers in CloudFront responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/modifying-response-headers.html) in the Amazon CloudFront Developer Guide.
    public struct ResponseHeadersPolicy: Swift.Equatable {
        /// The identifier for the response headers policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the response headers policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A response headers policy configuration.
        /// This member is required.
        public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

        public init(
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Header"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Header{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Header>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowHeaders: Swift.Equatable {
        /// The list of HTTP header names. You can specify * to allow all headers.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of HTTP header names in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for responseheaderspolicyaccesscontrolallowmethodsvalues0 in items {
                try itemsContainer.encode(responseheaderspolicyaccesscontrolallowmethodsvalues0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]()
                    for enumContainer0 in itemsContainer {
                        itemsBuffer?.append(enumContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowMethods: Swift.Equatable {
        /// The list of HTTP methods. Valid values are:
        ///
        /// * GET
        ///
        /// * DELETE
        ///
        /// * HEAD
        ///
        /// * OPTIONS
        ///
        /// * PATCH
        ///
        /// * POST
        ///
        /// * PUT
        ///
        /// * ALL
        ///
        ///
        /// ALL is a special value that includes all of the listed HTTP methods.
        /// This member is required.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]?
        /// The number of HTTP methods in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum ResponseHeadersPolicyAccessControlAllowMethodsValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyAccessControlAllowMethodsValues] {
            return [
                .all,
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseHeadersPolicyAccessControlAllowMethodsValues(rawValue: rawValue) ?? ResponseHeadersPolicyAccessControlAllowMethodsValues.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Origin"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Origin{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Origin>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowOrigins: Swift.Equatable {
        /// The list of origins (domain names). You can specify * to allow all origins.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of origins in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Header"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Header{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Header>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlExposeHeaders: Swift.Equatable {
        /// The list of HTTP headers. You can specify * to expose all headers.
        public var items: [Swift.String]?
        /// The number of HTTP headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ResponseHeadersPolicyAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ResponseHeadersPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use UpdateResponseHeadersPolicy.
public struct ResponseHeadersPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResponseHeadersPolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResponseHeadersPolicyAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResponseHeadersPolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case corsConfig = "CorsConfig"
        case customHeadersConfig = "CustomHeadersConfig"
        case name = "Name"
        case removeHeadersConfig = "RemoveHeadersConfig"
        case securityHeadersConfig = "SecurityHeadersConfig"
        case serverTimingHeadersConfig = "ServerTimingHeadersConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let corsConfig = corsConfig {
            try container.encode(corsConfig, forKey: ClientRuntime.Key("CorsConfig"))
        }
        if let customHeadersConfig = customHeadersConfig {
            try container.encode(customHeadersConfig, forKey: ClientRuntime.Key("CustomHeadersConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let removeHeadersConfig = removeHeadersConfig {
            try container.encode(removeHeadersConfig, forKey: ClientRuntime.Key("RemoveHeadersConfig"))
        }
        if let securityHeadersConfig = securityHeadersConfig {
            try container.encode(securityHeadersConfig, forKey: ClientRuntime.Key("SecurityHeadersConfig"))
        }
        if let serverTimingHeadersConfig = serverTimingHeadersConfig {
            try container.encode(serverTimingHeadersConfig, forKey: ClientRuntime.Key("ServerTimingHeadersConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let corsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig.self, forKey: .corsConfig)
        corsConfig = corsConfigDecoded
        let securityHeadersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig.self, forKey: .securityHeadersConfig)
        securityHeadersConfig = securityHeadersConfigDecoded
        let serverTimingHeadersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig.self, forKey: .serverTimingHeadersConfig)
        serverTimingHeadersConfig = serverTimingHeadersConfigDecoded
        let customHeadersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig.self, forKey: .customHeadersConfig)
        customHeadersConfig = customHeadersConfigDecoded
        let removeHeadersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig.self, forKey: .removeHeadersConfig)
        removeHeadersConfig = removeHeadersConfigDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A response headers policy configuration. A response headers policy configuration contains metadata about the response headers policy, and configurations for sets of HTTP response headers.
    public struct ResponseHeadersPolicyConfig: Swift.Equatable {
        /// A comment to describe the response headers policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS).
        public var corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig?
        /// A configuration for a set of custom HTTP response headers.
        public var customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig?
        /// A name to identify the response headers policy. The name must be unique for response headers policies in this Amazon Web Services account.
        /// This member is required.
        public var name: Swift.String?
        /// A configuration for a set of HTTP headers to remove from the HTTP response.
        public var removeHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig?
        /// A configuration for a set of security-related HTTP response headers.
        public var securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig?
        /// A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront.
        public var serverTimingHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig?

        public init(
            comment: Swift.String? = nil,
            corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig? = nil,
            customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig? = nil,
            name: Swift.String? = nil,
            removeHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig? = nil,
            securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig? = nil,
            serverTimingHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig? = nil
        )
        {
            self.comment = comment
            self.corsConfig = corsConfig
            self.customHeadersConfig = customHeadersConfig
            self.name = name
            self.removeHeadersConfig = removeHeadersConfig
            self.securityHeadersConfig = securityHeadersConfig
            self.serverTimingHeadersConfig = serverTimingHeadersConfig
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSecurityPolicy = "ContentSecurityPolicy"
        case `override` = "Override"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentSecurityPolicy = contentSecurityPolicy {
            try container.encode(contentSecurityPolicy, forKey: ClientRuntime.Key("ContentSecurityPolicy"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let contentSecurityPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentSecurityPolicy)
        contentSecurityPolicy = contentSecurityPolicyDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentSecurityPolicy: Swift.Equatable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
        /// This member is required.
        public var contentSecurityPolicy: Swift.String?
        /// A Boolean that determines whether CloudFront overrides the Content-Security-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            contentSecurityPolicy: Swift.String? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.`override` = `override`
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `override` = "Override"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentTypeOptions: Swift.Equatable {
        /// A Boolean that determines whether CloudFront overrides the X-Content-Type-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            `override`: Swift.Bool? = nil
        )
        {
            self.`override` = `override`
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlAllowCredentials = "AccessControlAllowCredentials"
        case accessControlAllowHeaders = "AccessControlAllowHeaders"
        case accessControlAllowMethods = "AccessControlAllowMethods"
        case accessControlAllowOrigins = "AccessControlAllowOrigins"
        case accessControlExposeHeaders = "AccessControlExposeHeaders"
        case accessControlMaxAgeSec = "AccessControlMaxAgeSec"
        case originOverride = "OriginOverride"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlAllowCredentials = accessControlAllowCredentials {
            try container.encode(accessControlAllowCredentials, forKey: ClientRuntime.Key("AccessControlAllowCredentials"))
        }
        if let accessControlAllowHeaders = accessControlAllowHeaders {
            try container.encode(accessControlAllowHeaders, forKey: ClientRuntime.Key("AccessControlAllowHeaders"))
        }
        if let accessControlAllowMethods = accessControlAllowMethods {
            try container.encode(accessControlAllowMethods, forKey: ClientRuntime.Key("AccessControlAllowMethods"))
        }
        if let accessControlAllowOrigins = accessControlAllowOrigins {
            try container.encode(accessControlAllowOrigins, forKey: ClientRuntime.Key("AccessControlAllowOrigins"))
        }
        if let accessControlExposeHeaders = accessControlExposeHeaders {
            try container.encode(accessControlExposeHeaders, forKey: ClientRuntime.Key("AccessControlExposeHeaders"))
        }
        if let accessControlMaxAgeSec = accessControlMaxAgeSec {
            try container.encode(accessControlMaxAgeSec, forKey: ClientRuntime.Key("AccessControlMaxAgeSec"))
        }
        if let originOverride = originOverride {
            try container.encode(originOverride, forKey: ClientRuntime.Key("OriginOverride"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlAllowOriginsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins.self, forKey: .accessControlAllowOrigins)
        accessControlAllowOrigins = accessControlAllowOriginsDecoded
        let accessControlAllowHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders.self, forKey: .accessControlAllowHeaders)
        accessControlAllowHeaders = accessControlAllowHeadersDecoded
        let accessControlAllowMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods.self, forKey: .accessControlAllowMethods)
        accessControlAllowMethods = accessControlAllowMethodsDecoded
        let accessControlAllowCredentialsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessControlAllowCredentials)
        accessControlAllowCredentials = accessControlAllowCredentialsDecoded
        let accessControlExposeHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders.self, forKey: .accessControlExposeHeaders)
        accessControlExposeHeaders = accessControlExposeHeadersDecoded
        let accessControlMaxAgeSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .accessControlMaxAgeSec)
        accessControlMaxAgeSec = accessControlMaxAgeSecDecoded
        let originOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .originOverride)
        originOverride = originOverrideDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS). CloudFront adds these headers to HTTP responses that it sends for CORS requests that match a cache behavior associated with this response headers policy. For more information about CORS, see [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) in the MDN Web Docs.
    public struct ResponseHeadersPolicyCorsConfig: Swift.Equatable {
        /// A Boolean that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header. For more information about the Access-Control-Allow-Credentials HTTP response header, see [Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowCredentials: Swift.Bool?
        /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders?
        /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods?
        /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins?
        /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
        public var accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders?
        /// A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header. For more information about the Access-Control-Max-Age HTTP response header, see [Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age) in the MDN Web Docs.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront overrides HTTP response headers received from the origin with the ones specified in this response headers policy.
        /// This member is required.
        public var originOverride: Swift.Bool?

        public init(
            accessControlAllowCredentials: Swift.Bool? = nil,
            accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders? = nil,
            accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods? = nil,
            accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins? = nil,
            accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders? = nil,
            accessControlMaxAgeSec: Swift.Int? = nil,
            originOverride: Swift.Bool? = nil
        )
        {
            self.accessControlAllowCredentials = accessControlAllowCredentials
            self.accessControlAllowHeaders = accessControlAllowHeaders
            self.accessControlAllowMethods = accessControlAllowMethods
            self.accessControlAllowOrigins = accessControlAllowOrigins
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.originOverride = originOverride
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case header = "Header"
        case `override` = "Override"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let header = header {
            try container.encode(header, forKey: ClientRuntime.Key("Header"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .header)
        header = headerDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An HTTP response header name and its value. CloudFront includes this header in HTTP responses that it sends for requests that match a cache behavior that's associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeader: Swift.Equatable {
        /// The HTTP response header name.
        /// This member is required.
        public var header: Swift.String?
        /// A Boolean that determines whether CloudFront overrides a response header with the same name received from the origin with the header specified here.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value for the HTTP response header.
        /// This member is required.
        public var value: Swift.String?

        public init(
            header: Swift.String? = nil,
            `override`: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.header = header
            self.`override` = `override`
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for responseheaderspolicycustomheader0 in items {
                try itemsContainer.encode(responseheaderspolicycustomheader0, forKey: ClientRuntime.Key("ResponseHeadersPolicyCustomHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ResponseHeadersPolicyCustomHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResponseHeadersPolicyCustomHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP response header names and their values. CloudFront includes these headers in HTTP responses that it sends for requests that match a cache behavior that's associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeadersConfig: Swift.Equatable {
        /// The list of HTTP response headers and their values.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]?
        /// The number of HTTP response headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameOption = "FrameOption"
        case `override` = "Override"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let frameOption = frameOption {
            try container.encode(frameOption, forKey: ClientRuntime.Key("FrameOption"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let frameOptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FrameOptionsList.self, forKey: .frameOption)
        frameOption = frameOptionDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header's value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyFrameOptions: Swift.Equatable {
        /// The value of the X-Frame-Options HTTP response header. Valid values are DENY and SAMEORIGIN. For more information about these values, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        /// This member is required.
        public var frameOption: CloudFrontClientTypes.FrameOptionsList?
        /// A Boolean that determines whether CloudFront overrides the X-Frame-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            frameOption: CloudFrontClientTypes.FrameOptionsList? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.frameOption = frameOption
            self.`override` = `override`
        }
    }

}

extension ResponseHeadersPolicyInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ResponseHeadersPolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.
public struct ResponseHeadersPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResponseHeadersPolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResponseHeadersPolicyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResponseHeadersPolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for responseheaderspolicysummary0 in items {
                try itemsContainer.encode(responseheaderspolicysummary0, forKey: ClientRuntime.Key("ResponseHeadersPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ResponseHeadersPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResponseHeadersPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ResponseHeadersPolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ResponseHeadersPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ResponseHeadersPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of response headers policies.
    public struct ResponseHeadersPolicyList: Swift.Equatable {
        /// The response headers policies in the list.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]?
        /// The maximum number of response headers policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing response headers policies where you left off.
        public var nextMarker: Swift.String?
        /// The number of response headers policies returned.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `override` = "Override"
        case referrerPolicy = "ReferrerPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let referrerPolicy = referrerPolicy {
            try container.encode(referrerPolicy, forKey: ClientRuntime.Key("ReferrerPolicy"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let referrerPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ReferrerPolicyList.self, forKey: .referrerPolicy)
        referrerPolicy = referrerPolicyDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header's value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyReferrerPolicy: Swift.Equatable {
        /// A Boolean that determines whether CloudFront overrides the Referrer-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value of the Referrer-Policy HTTP response header. Valid values are:
        ///
        /// * no-referrer
        ///
        /// * no-referrer-when-downgrade
        ///
        /// * origin
        ///
        /// * origin-when-cross-origin
        ///
        /// * same-origin
        ///
        /// * strict-origin
        ///
        /// * strict-origin-when-cross-origin
        ///
        /// * unsafe-url
        ///
        ///
        /// For more information about these values, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        /// This member is required.
        public var referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList?

        public init(
            `override`: Swift.Bool? = nil,
            referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList? = nil
        )
        {
            self.`override` = `override`
            self.referrerPolicy = referrerPolicy
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case header = "Header"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let header = header {
            try container.encode(header, forKey: ClientRuntime.Key("Header"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .header)
        header = headerDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The name of an HTTP header that CloudFront removes from HTTP responses to requests that match the cache behavior that this response headers policy is attached to.
    public struct ResponseHeadersPolicyRemoveHeader: Swift.Equatable {
        /// The HTTP header name.
        /// This member is required.
        public var header: Swift.String?

        public init(
            header: Swift.String? = nil
        )
        {
            self.header = header
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for responseheaderspolicyremoveheader0 in items {
                try itemsContainer.encode(responseheaderspolicyremoveheader0, forKey: ClientRuntime.Key("ResponseHeadersPolicyRemoveHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ResponseHeadersPolicyRemoveHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResponseHeadersPolicyRemoveHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP header names that CloudFront removes from HTTP responses to requests that match the cache behavior that this response headers policy is attached to.
    public struct ResponseHeadersPolicyRemoveHeadersConfig: Swift.Equatable {
        /// The list of HTTP header names.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]?
        /// The number of HTTP header names in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSecurityPolicy = "ContentSecurityPolicy"
        case contentTypeOptions = "ContentTypeOptions"
        case frameOptions = "FrameOptions"
        case referrerPolicy = "ReferrerPolicy"
        case strictTransportSecurity = "StrictTransportSecurity"
        case xssProtection = "XSSProtection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentSecurityPolicy = contentSecurityPolicy {
            try container.encode(contentSecurityPolicy, forKey: ClientRuntime.Key("ContentSecurityPolicy"))
        }
        if let contentTypeOptions = contentTypeOptions {
            try container.encode(contentTypeOptions, forKey: ClientRuntime.Key("ContentTypeOptions"))
        }
        if let frameOptions = frameOptions {
            try container.encode(frameOptions, forKey: ClientRuntime.Key("FrameOptions"))
        }
        if let referrerPolicy = referrerPolicy {
            try container.encode(referrerPolicy, forKey: ClientRuntime.Key("ReferrerPolicy"))
        }
        if let strictTransportSecurity = strictTransportSecurity {
            try container.encode(strictTransportSecurity, forKey: ClientRuntime.Key("StrictTransportSecurity"))
        }
        if let xssProtection = xssProtection {
            try container.encode(xssProtection, forKey: ClientRuntime.Key("XSSProtection"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssProtectionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection.self, forKey: .xssProtection)
        xssProtection = xssProtectionDecoded
        let frameOptionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions.self, forKey: .frameOptions)
        frameOptions = frameOptionsDecoded
        let referrerPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy.self, forKey: .referrerPolicy)
        referrerPolicy = referrerPolicyDecoded
        let contentSecurityPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy.self, forKey: .contentSecurityPolicy)
        contentSecurityPolicy = contentSecurityPolicyDecoded
        let contentTypeOptionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions.self, forKey: .contentTypeOptions)
        contentTypeOptions = contentTypeOptionsDecoded
        let strictTransportSecurityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity.self, forKey: .strictTransportSecurity)
        strictTransportSecurity = strictTransportSecurityDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A configuration for a set of security-related HTTP response headers. CloudFront adds these headers to HTTP responses that it sends for requests that match a cache behavior associated with this response headers policy.
    public struct ResponseHeadersPolicySecurityHeadersConfig: Swift.Equatable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
        public var contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy?
        /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
        public var contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions?
        /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header's value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        public var frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions?
        /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header's value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        public var referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy?
        /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header's value. For more information about the Strict-Transport-Security HTTP response header, see [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
        public var strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity?
        /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header's value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var xssProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection?

        public init(
            contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy? = nil,
            contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions? = nil,
            frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions? = nil,
            referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy? = nil,
            strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity? = nil,
            xssProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.contentTypeOptions = contentTypeOptions
            self.frameOptions = frameOptions
            self.referrerPolicy = referrerPolicy
            self.strictTransportSecurity = strictTransportSecurity
            self.xssProtection = xssProtection
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront. CloudFront adds this header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy. You can use the Server-Timing header to view metrics that can help you gain insights about the behavior and performance of CloudFront. For example, you can see which cache layer served a cache hit, or the first byte latency from the origin when there was a cache miss. You can use the metrics in the Server-Timing header to troubleshoot issues or test the efficiency of your CloudFront configuration. For more information, see [Server-Timing header](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/understanding-response-headers-policies.html#server-timing-header) in the Amazon CloudFront Developer Guide.
    public struct ResponseHeadersPolicyServerTimingHeadersConfig: Swift.Equatable {
        /// A Boolean that determines whether CloudFront adds the Server-Timing header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A number 0100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to. When you set the sampling rate to 100, CloudFront adds the Server-Timing header to the HTTP response for every request that matches the cache behavior that this response headers policy is attached to. When you set it to 50, CloudFront adds the header to 50% of the responses for requests that match the cache behavior. You can set the sampling rate to any number 0100 with up to four decimal places.
        public var samplingRate: Swift.Double?

        public init(
            enabled: Swift.Bool? = nil,
            samplingRate: Swift.Double? = nil
        )
        {
            self.enabled = enabled
            self.samplingRate = samplingRate
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlMaxAgeSec = "AccessControlMaxAgeSec"
        case includeSubdomains = "IncludeSubdomains"
        case `override` = "Override"
        case preload = "Preload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlMaxAgeSec = accessControlMaxAgeSec {
            try container.encode(accessControlMaxAgeSec, forKey: ClientRuntime.Key("AccessControlMaxAgeSec"))
        }
        if let includeSubdomains = includeSubdomains {
            try container.encode(includeSubdomains, forKey: ClientRuntime.Key("IncludeSubdomains"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let preload = preload {
            try container.encode(preload, forKey: ClientRuntime.Key("Preload"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let includeSubdomainsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSubdomains)
        includeSubdomains = includeSubdomainsDecoded
        let preloadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preload)
        preload = preloadDecoded
        let accessControlMaxAgeSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .accessControlMaxAgeSec)
        accessControlMaxAgeSec = accessControlMaxAgeSecDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header's value. For more information about the Strict-Transport-Security HTTP response header, see [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
    public struct ResponseHeadersPolicyStrictTransportSecurity: Swift.Equatable {
        /// A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
        /// This member is required.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
        public var includeSubdomains: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the Strict-Transport-Security HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
        public var preload: Swift.Bool?

        public init(
            accessControlMaxAgeSec: Swift.Int? = nil,
            includeSubdomains: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            preload: Swift.Bool? = nil
        )
        {
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.includeSubdomains = includeSubdomains
            self.`override` = `override`
            self.preload = preload
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let responseHeadersPolicy = responseHeadersPolicy {
            try container.encode(responseHeadersPolicy, forKey: ClientRuntime.Key("ResponseHeadersPolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyType.self, forKey: .type)
        type = typeDecoded
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a response headers policy.
    public struct ResponseHeadersPolicySummary: Swift.Equatable {
        /// The response headers policy.
        /// This member is required.
        public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
        /// The type of response headers policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

        public init(
            responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil,
            type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
        )
        {
            self.responseHeadersPolicy = responseHeadersPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum ResponseHeadersPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseHeadersPolicyType(rawValue: rawValue) ?? ResponseHeadersPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modeBlock = "ModeBlock"
        case `override` = "Override"
        case protection = "Protection"
        case reportUri = "ReportUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let modeBlock = modeBlock {
            try container.encode(modeBlock, forKey: ClientRuntime.Key("ModeBlock"))
        }
        if let `override` = `override` {
            try container.encode(`override`, forKey: ClientRuntime.Key("Override"))
        }
        if let protection = protection {
            try container.encode(protection, forKey: ClientRuntime.Key("Protection"))
        }
        if let reportUri = reportUri {
            try container.encode(reportUri, forKey: ClientRuntime.Key("ReportUri"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .override)
        `override` = overrideDecoded
        let protectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .protection)
        protection = protectionDecoded
        let modeBlockDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .modeBlock)
        modeBlock = modeBlockDecoded
        let reportUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportUri)
        reportUri = reportUriDecoded
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header's value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
    public struct ResponseHeadersPolicyXSSProtection: Swift.Equatable {
        /// A Boolean that determines whether CloudFront includes the mode=block directive in the X-XSS-Protection header. For more information about this directive, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var modeBlock: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0. For more information about these settings, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        /// This member is required.
        public var protection: Swift.Bool?
        /// A reporting URI, which CloudFront uses as the value of the report directive in the X-XSS-Protection header. You cannot specify a ReportUri when ModeBlock is true. For more information about using a reporting URL, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var reportUri: Swift.String?

        public init(
            modeBlock: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            protection: Swift.Bool? = nil,
            reportUri: Swift.String? = nil
        )
        {
            self.modeBlock = modeBlock
            self.`override` = `override`
            self.protection = protection
            self.reportUri = reportUri
        }
    }

}

extension CloudFrontClientTypes.Restrictions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoRestriction = "GeoRestriction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let geoRestriction = geoRestriction {
            try container.encode(geoRestriction, forKey: ClientRuntime.Key("GeoRestriction"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoRestrictionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestriction.self, forKey: .geoRestriction)
        geoRestriction = geoRestrictionDecoded
    }
}

extension CloudFrontClientTypes.Restrictions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that identifies ways in which you want to restrict distribution of your content.
    public struct Restrictions: Swift.Equatable {
        /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
        /// This member is required.
        public var geoRestriction: CloudFrontClientTypes.GeoRestriction?

        public init(
            geoRestriction: CloudFrontClientTypes.GeoRestriction? = nil
        )
        {
            self.geoRestriction = geoRestriction
        }
    }

}

extension CloudFrontClientTypes.S3Origin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
    public struct S3Origin: Swift.Equatable {
        /// The DNS name of the Amazon S3 origin.
        /// This member is required.
        public var domainName: Swift.String?
        /// The CloudFront origin access identity to associate with the distribution. Use an origin access identity to configure the distribution so that end users can only access objects in an Amazon S3 bucket through CloudFront. If you want end users to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information, see [Using an Origin Access Identity to Restrict Access to Your Amazon S3 Content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes.S3OriginConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3OriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin or an S3 bucket that is configured as a website endpoint, use the CustomOriginConfig element instead.
    public struct S3OriginConfig: Swift.Equatable {
        /// The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that viewers can only access objects in an Amazon S3 bucket through CloudFront. The format of the value is: origin-access-identity/cloudfront/ID-of-origin-access-identity where  ID-of-origin-access-identity  is the value that CloudFront returned in the ID element when you created the origin access identity. If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information about the origin access identity, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init(
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes {
    public enum SSLSupportMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sniOnly
        case staticIp
        case vip
        case sdkUnknown(Swift.String)

        public static var allCases: [SSLSupportMethod] {
            return [
                .sniOnly,
                .staticIp,
                .vip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sniOnly: return "sni-only"
            case .staticIp: return "static-ip"
            case .vip: return "vip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSLSupportMethod(rawValue: rawValue) ?? SSLSupportMethod.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.SessionStickinessConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idleTTL = "IdleTTL"
        case maximumTTL = "MaximumTTL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let idleTTL = idleTTL {
            try container.encode(idleTTL, forKey: ClientRuntime.Key("IdleTTL"))
        }
        if let maximumTTL = maximumTTL {
            try container.encode(maximumTTL, forKey: ClientRuntime.Key("MaximumTTL"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idleTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleTTL)
        idleTTL = idleTTLDecoded
        let maximumTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumTTL)
        maximumTTL = maximumTTLDecoded
    }
}

extension CloudFrontClientTypes.SessionStickinessConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Session stickiness provides the ability to define multiple requests from a single viewer as a single session. This prevents the potentially inconsistent experience of sending some of a given user's requests to your staging distribution, while others are sent to your primary distribution. Define the session duration using TTL values.
    public struct SessionStickinessConfig: Swift.Equatable {
        /// The amount of time after which you want sessions to cease if no requests are received. Allowed values are 3003600 seconds (560 minutes). The value must be less than or equal to MaximumTTL.
        /// This member is required.
        public var idleTTL: Swift.Int?
        /// The maximum amount of time to consider requests from the viewer as being part of the same session. Allowed values are 3003600 seconds (560 minutes). The value must be less than or equal to IdleTTL.
        /// This member is required.
        public var maximumTTL: Swift.Int?

        public init(
            idleTTL: Swift.Int? = nil,
            maximumTTL: Swift.Int? = nil
        )
        {
            self.idleTTL = idleTTL
            self.maximumTTL = maximumTTL
        }
    }

}

extension CloudFrontClientTypes.Signer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountNumber = "AwsAccountNumber"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let awsAccountNumber = awsAccountNumber {
            try container.encode(awsAccountNumber, forKey: ClientRuntime.Key("AwsAccountNumber"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.Signer: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct Signer: Swift.Equatable {
        /// An Amazon Web Services account number that contains active CloudFront key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies. If the Amazon Web Services account that owns the key pairs is the same account that owns the CloudFront distribution, the value of this field is self.
        public var awsAccountNumber: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init(
            awsAccountNumber: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes {
    public enum SslProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv11
        case tlsv12
        case sdkUnknown(Swift.String)

        public static var allCases: [SslProtocol] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv11,
                .tlsv12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv11: return "TLSv1.1"
            case .tlsv12: return "TLSv1.2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SslProtocol(rawValue: rawValue) ?? SslProtocol.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.StagingDistributionDnsNames: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("DnsName"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DnsName{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DnsName>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StagingDistributionDnsNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The CloudFront domain name of the staging distribution.
    public struct StagingDistributionDnsNames: Swift.Equatable {
        /// The CloudFront domain name of the staging distribution.
        public var items: [Swift.String]?
        /// The number of CloudFront domain names in your staging distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension StagingDistributionInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<StagingDistributionInUseBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A continuous deployment policy for this staging distribution already exists.
public struct StagingDistributionInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StagingDistributionInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StagingDistributionInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension StagingDistributionInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StatusCodes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for integer0 in items {
                try itemsContainer.encode(integer0, forKey: ClientRuntime.Key("StatusCode"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StatusCode{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StatusCode>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.Int].self, forKey: .member)
                var itemsBuffer:[Swift.Int]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.Int]()
                    for integerContainer0 in itemsContainer {
                        itemsBuffer?.append(integerContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StatusCodes: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the status codes that you specify that, when returned by a primary origin, trigger CloudFront to failover to a second origin.
    public struct StatusCodes: Swift.Equatable {
        /// The items (status codes) for an origin group.
        /// This member is required.
        public var items: [Swift.Int]?
        /// The number of status codes.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.Int]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.StreamingDistribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case domainName = "DomainName"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to track and manage content delivery.
    public struct StreamingDistribution: Swift.Equatable {
        /// A complex type that lists the Amazon Web Services accounts, if any, that you included in the TrustedSigners complex type for this distribution. These are the accounts that you want to allow to create signed URLs for private content. The Signer complex type lists the Amazon Web Services account number of the trusted signer or self if the signer is the Amazon Web Services account that created the distribution. The Signer element also includes the IDs of any active CloudFront key pairs that are associated with the trusted signer's Amazon Web Services account. If no KeyPairId element appears for a Signer, that signer can't create signed URLs. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// The domain name that corresponds to the streaming distribution, for example, s5c39gqb8ow64r.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The identifier for the RTMP distribution. For example: EGTXBD79EXAMPLE.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the distribution was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The current status of the RTMP distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// The current configuration information for the RTMP distribution.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

        public init(
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            arn: Swift.String? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil,
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
        )
        {
            self.activeTrustedSigners = activeTrustedSigners
            self.arn = arn
            self.domainName = domainName
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.streamingDistributionConfig = streamingDistributionConfig
        }
    }

}

extension StreamingDistributionAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<StreamingDistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The caller reference you attempted to create the streaming distribution with is associated with another distribution
public struct StreamingDistributionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamingDistributionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StreamingDistributionAlreadyExistsBody: Swift.Equatable {
    let message: Swift.String?
}

extension StreamingDistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case enabled = "Enabled"
        case logging = "Logging"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingLoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The RTMP distribution's configuration information.
    public struct StreamingDistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the StreamingDistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// Any comments you want to include about the streaming distribution.
        /// This member is required.
        public var comment: Swift.String?
        /// Whether the streaming distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the streaming distribution.
        public var logging: CloudFrontClientTypes.StreamingLoggingConfig?
        /// A complex type that contains information about price class for this streaming distribution.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// A complex type that specifies any Amazon Web Services accounts that you want to permit to create signed URLs for private content. If you want the distribution to use signed URLs, include this element; if you want the distribution to use public URLs, remove this element. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.StreamingLoggingConfig? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.callerReference = callerReference
            self.comment = comment
            self.enabled = enabled
            self.logging = logging
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution Configuration and a list of tags to be associated with the streaming distribution.
    public struct StreamingDistributionConfigWithTags: Swift.Equatable {
        /// A streaming distribution Configuration.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init(
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.streamingDistributionConfig = streamingDistributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for streamingdistributionsummary0 in items {
                try itemsContainer.encode(streamingdistributionsummary0, forKey: ClientRuntime.Key("StreamingDistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StreamingDistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StreamingDistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.StreamingDistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.StreamingDistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.StreamingDistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StreamingDistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution list.
    public struct StreamingDistributionList: Swift.Equatable {
        /// A flag that indicates whether more streaming distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one StreamingDistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.StreamingDistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your RTMP distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of streaming distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.StreamingDistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension StreamingDistributionNotDisabled {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<StreamingDistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct StreamingDistributionNotDisabled: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamingDistributionNotDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StreamingDistributionNotDisabledBody: Swift.Equatable {
    let message: Swift.String?
}

extension StreamingDistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case aliases = "Aliases"
        case comment = "Comment"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case status = "Status"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information for a CloudFront streaming distribution.
    public struct StreamingDistributionSummary: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The ARN (Amazon Resource Name) for the streaming distribution. For example: arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// The domain name corresponding to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept end user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The identifier for the distribution, for example, EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// Indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that specifies the Amazon Web Services accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items.If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            arn: Swift.String? = nil,
            comment: Swift.String? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            status: Swift.String? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.arn = arn
            self.comment = comment
            self.domainName = domainName
            self.enabled = enabled
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.status = status
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingLoggingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let `prefix` = `prefix` {
            try container.encode(`prefix`, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension CloudFrontClientTypes.StreamingLoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for this streaming distribution.
    public struct StreamingLoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a streaming distribution or if you want to disable logging for an existing streaming distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket and Prefix, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension CloudFrontClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudFrontClientTypes.Tag: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains Tag key and Tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains Tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional Tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.TagKeys: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tagkey0 in items {
                try itemsContainer.encode(tagkey0, forKey: ClientRuntime.Key("Key"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Key{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Key>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TagKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct TagKeys: Swift.Equatable {
        /// A complex type that contains Tag key elements.
        public var items: [Swift.String]?

        public init(
            items: [Swift.String]? = nil
        )
        {
            self.items = items
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<TagResourceOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let tags = input.operationInput.tags {
                let xmlEncoder = encoder as! XMLEncoder
                let tagsData = try xmlEncoder.encode(tags, withRootKey: "Tags")
                let tagsBody = ClientRuntime.HttpBody.data(tagsData)
                input.builder.withBody(tagsBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let tagsData = "{}".data(using: .utf8)!
                    let tagsBody = ClientRuntime.HttpBody.data(tagsData)
                    input.builder.withBody(tagsBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension TagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "Operation", value: "Tag"))
            guard let resource = resource else {
                let message = "Creating a URL Query Item failed. resource is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            items.append(resourceQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to add tags to a CloudFront resource.
public struct TagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init(
        resource: Swift.String? = nil,
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: CloudFrontClientTypes.Tags?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTagging": return try await InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.Tags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tag0 in items {
                try itemsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag"))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Tag{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Tag].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Tag]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Tag]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Tags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct Tags: Swift.Equatable {
        /// A complex type that contains Tag elements.
        public var items: [CloudFrontClientTypes.Tag]?

        public init(
            items: [CloudFrontClientTypes.Tag]? = nil
        )
        {
            self.items = items
        }
    }

}

extension TestFunctionFailed {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TestFunctionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The CloudFront function failed.
public struct TestFunctionFailed: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TestFunctionFailed" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TestFunctionFailedBody: Swift.Equatable {
    let message: Swift.String?
}

extension TestFunctionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TestFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionInput(ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)), eventObject: \"CONTENT_REDACTED\")"}
}

extension TestFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TestFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventObject = eventObject {
            try container.encode(eventObject, forKey: ClientRuntime.Key("EventObject"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }
}

extension TestFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension TestFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/test"
    }
}

public struct TestFunctionInput: Swift.Equatable {
    /// The event object to test the function with. For more information about the structure of the event object, see [Testing functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var eventObject: ClientRuntime.Data?
    /// The current version (ETag value) of the function that you are testing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are testing.
    /// This member is required.
    public var name: Swift.String?
    /// The stage of the function that you are testing, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        eventObject: ClientRuntime.Data? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.eventObject = eventObject
        self.ifMatch = ifMatch
        self.name = name
        self.stage = stage
    }
}

struct TestFunctionInputBody: Swift.Equatable {
    let stage: CloudFrontClientTypes.FunctionStage?
    let eventObject: ClientRuntime.Data?
}

extension TestFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        if containerValues.contains(.eventObject) {
            do {
                let eventObjectDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .eventObject)
                eventObject = eventObjectDecoded
            } catch {
                eventObject = "".data(using: .utf8)
            }
        } else {
            eventObject = nil
        }
    }
}

extension TestFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.TestResult = try responseDecoder.decode(responseBody: data)
            self.testResult = output
        } else {
            self.testResult = nil
        }
    }
}

public struct TestFunctionOutput: Swift.Equatable {
    /// An object that represents the result of running the function with the provided event object.
    public var testResult: CloudFrontClientTypes.TestResult?

    public init(
        testResult: CloudFrontClientTypes.TestResult? = nil
    )
    {
        self.testResult = testResult
    }
}

struct TestFunctionOutputBody: Swift.Equatable {
    let testResult: CloudFrontClientTypes.TestResult?
}

extension TestFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testResult = "TestResult"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testResultDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
    }
}

enum TestFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFunctionExists": return try await NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TestFunctionFailed": return try await TestFunctionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.TestResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeUtilization = "ComputeUtilization"
        case functionErrorMessage = "FunctionErrorMessage"
        case functionExecutionLogs = "FunctionExecutionLogs"
        case functionOutput = "FunctionOutput"
        case functionSummary = "FunctionSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let computeUtilization = computeUtilization {
            try container.encode(computeUtilization, forKey: ClientRuntime.Key("ComputeUtilization"))
        }
        if let functionErrorMessage = functionErrorMessage {
            try container.encode(functionErrorMessage, forKey: ClientRuntime.Key("FunctionErrorMessage"))
        }
        if let functionExecutionLogs = functionExecutionLogs {
            var functionExecutionLogsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FunctionExecutionLogs"))
            for string0 in functionExecutionLogs {
                try functionExecutionLogsContainer.encode(string0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let functionOutput = functionOutput {
            try container.encode(functionOutput, forKey: ClientRuntime.Key("FunctionOutput"))
        }
        if let functionSummary = functionSummary {
            try container.encode(functionSummary, forKey: ClientRuntime.Key("FunctionSummary"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
        let computeUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computeUtilization)
        computeUtilization = computeUtilizationDecoded
        if containerValues.contains(.functionExecutionLogs) {
            struct KeyVal0{struct member{}}
            let functionExecutionLogsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .functionExecutionLogs)
            if let functionExecutionLogsWrappedContainer = functionExecutionLogsWrappedContainer {
                let functionExecutionLogsContainer = try functionExecutionLogsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var functionExecutionLogsBuffer:[Swift.String]? = nil
                if let functionExecutionLogsContainer = functionExecutionLogsContainer {
                    functionExecutionLogsBuffer = [Swift.String]()
                    for stringContainer0 in functionExecutionLogsContainer {
                        functionExecutionLogsBuffer?.append(stringContainer0)
                    }
                }
                functionExecutionLogs = functionExecutionLogsBuffer
            } else {
                functionExecutionLogs = []
            }
        } else {
            functionExecutionLogs = nil
        }
        let functionErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionErrorMessage)
        functionErrorMessage = functionErrorMessageDecoded
        let functionOutputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionOutput)
        functionOutput = functionOutputDecoded
    }
}

extension CloudFrontClientTypes.TestResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestResult(computeUtilization: \(Swift.String(describing: computeUtilization)), functionSummary: \(Swift.String(describing: functionSummary)), functionErrorMessage: \"CONTENT_REDACTED\", functionExecutionLogs: \"CONTENT_REDACTED\", functionOutput: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes.TestResult: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains the result of testing a CloudFront function with TestFunction.
    public struct TestResult: Swift.Equatable {
        /// The amount of time that the function took to run as a percentage of the maximum allowed time. For example, a compute utilization of 35 means that the function completed in 35% of the maximum allowed time.
        public var computeUtilization: Swift.String?
        /// If the result of testing the function was an error, this field contains the error message.
        public var functionErrorMessage: Swift.String?
        /// Contains the log lines that the function wrote (if any) when running the test.
        public var functionExecutionLogs: [Swift.String]?
        /// The event object returned by the function. For more information about the structure of the event object, see [Event object structure](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html) in the Amazon CloudFront Developer Guide.
        public var functionOutput: Swift.String?
        /// Contains configuration information and metadata about the CloudFront function that was tested.
        public var functionSummary: CloudFrontClientTypes.FunctionSummary?

        public init(
            computeUtilization: Swift.String? = nil,
            functionErrorMessage: Swift.String? = nil,
            functionExecutionLogs: [Swift.String]? = nil,
            functionOutput: Swift.String? = nil,
            functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
        )
        {
            self.computeUtilization = computeUtilization
            self.functionErrorMessage = functionErrorMessage
            self.functionExecutionLogs = functionExecutionLogs
            self.functionOutput = functionOutput
            self.functionSummary = functionSummary
        }
    }

}

extension TooLongCSPInResponseHeadersPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooLongCSPInResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The length of the Content-Security-Policy header value in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooLongCSPInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooLongCSPInResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooLongCSPInResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooLongCSPInResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCacheBehaviors {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCacheBehaviorsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot create more cache behaviors for the distribution.
public struct TooManyCacheBehaviors: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCacheBehaviors" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCacheBehaviorsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCacheBehaviorsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCachePolicies {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCachePoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCachePolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCachePolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCachePoliciesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCachePoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCertificates {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCertificatesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot create anymore custom SSL/TLS certificates.
public struct TooManyCertificates: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCertificates" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCertificatesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCertificatesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCloudFrontOriginAccessIdentities {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCloudFrontOriginAccessIdentitiesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin access identities allowed.
public struct TooManyCloudFrontOriginAccessIdentities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCloudFrontOriginAccessIdentities" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyContinuousDeploymentPolicies {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyContinuousDeploymentPoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of continuous deployment policies for this Amazon Web Services account.
public struct TooManyContinuousDeploymentPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyContinuousDeploymentPolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyContinuousDeploymentPoliciesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyContinuousDeploymentPoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookieNamesInWhiteList {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookieNamesInWhiteListBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains more cookie names in the whitelist than are allowed per cache behavior.
public struct TooManyCookieNamesInWhiteList: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookieNamesInWhiteList" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCookieNamesInWhiteListBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCookieNamesInWhiteListBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInCachePolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookiesInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of cookies in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookiesInCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCookiesInCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCookiesInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInOriginRequestPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookiesInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of cookies in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookiesInOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCookiesInOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCookiesInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCustomHeadersInResponseHeadersPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCustomHeadersInResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of custom headers in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCustomHeadersInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCustomHeadersInResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyCustomHeadersInResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyCustomHeadersInResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionCNAMEs {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyDistributionCNAMEs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionCNAMEs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionCNAMEsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributions {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of distributions allowed.
public struct TooManyDistributions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributions" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsAssociatedToCachePolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of distributions have been associated with the specified cache policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsAssociatedToCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of distributions have been associated with the specified configuration for field-level encryption.
public struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToKeyGroup {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of distributions that reference this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToKeyGroup: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToKeyGroup" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsAssociatedToKeyGroupBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToOriginAccessControl {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToOriginAccessControlBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of distributions have been associated with the specified origin access control. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsAssociatedToOriginAccessControlBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToOriginAccessControlBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of distributions have been associated with the specified origin request policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToResponseHeadersPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of distributions have been associated with the specified response headers policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsAssociatedToResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsAssociatedToResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyDistributionsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithFunctionAssociations {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsWithFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithFunctionAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsWithFunctionAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsWithFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithLambdaAssociations {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithLambdaAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.
public struct TooManyDistributionsWithLambdaAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithLambdaAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsWithLambdaAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsWithLambdaAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithSingleFunctionARN {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithSingleFunctionARNBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of distributions have been associated with the specified Lambda@Edge function.
public struct TooManyDistributionsWithSingleFunctionARN: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithSingleFunctionARN" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyDistributionsWithSingleFunctionARNBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyDistributionsWithSingleFunctionARNBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionConfigs {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of configurations for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionConfigs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionConfigs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFieldLevelEncryptionConfigsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionContentTypeProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of content type profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionContentTypeProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionContentTypeProfiles" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionEncryptionEntitiesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of encryption entities for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionEncryptionEntities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionEncryptionEntities" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionFieldPatternsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of field patterns for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionFieldPatterns: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionFieldPatterns" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionProfiles {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionProfiles" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFieldLevelEncryptionProfilesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionQueryArgProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of query arg profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionQueryArgProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionQueryArgProfiles" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctionAssociations {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of CloudFront function associations for this distribution. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFunctionAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFunctionAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctions {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFunctionsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFunctions" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyFunctionsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyFunctionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInCachePolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of headers in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyHeadersInCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyHeadersInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInForwardedValues {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInForwardedValuesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains too many headers in forwarded values.
public struct TooManyHeadersInForwardedValues: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInForwardedValues" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyHeadersInForwardedValuesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyHeadersInForwardedValuesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInOriginRequestPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of headers in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyHeadersInOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyHeadersInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyInvalidationsInProgress {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyInvalidationsInProgressBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.
public struct TooManyInvalidationsInProgress: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyInvalidationsInProgress" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyInvalidationsInProgressBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyInvalidationsInProgressBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyKeyGroups {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyKeyGroupsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroups: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyKeyGroups" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyKeyGroupsAssociatedToDistribution {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyKeyGroupsAssociatedToDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroupsAssociatedToDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyKeyGroupsAssociatedToDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyKeyGroupsAssociatedToDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyKeyGroupsAssociatedToDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyKeyGroupsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyKeyGroupsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyLambdaFunctionAssociations {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyLambdaFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains more Lambda@Edge function associations than are allowed per distribution.
public struct TooManyLambdaFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyLambdaFunctionAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyLambdaFunctionAssociationsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyLambdaFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginAccessControls {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginAccessControlsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of origin access controls in your Amazon Web Services account exceeds the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginAccessControls: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginAccessControls" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyOriginAccessControlsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginAccessControlsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginCustomHeaders {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginCustomHeadersBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains too many origin custom headers.
public struct TooManyOriginCustomHeaders: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginCustomHeaders" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyOriginCustomHeadersBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginCustomHeadersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginGroupsPerDistribution {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginGroupsPerDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin groups allowed.
public struct TooManyOriginGroupsPerDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginGroupsPerDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyOriginGroupsPerDistributionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginGroupsPerDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginRequestPolicies {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginRequestPoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginRequestPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginRequestPolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyOriginRequestPoliciesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginRequestPoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOrigins {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You cannot create more origins for the distribution.
public struct TooManyOrigins: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOrigins" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyOriginsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyOriginsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeys {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyPublicKeysBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.
public struct TooManyPublicKeys: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPublicKeys" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyPublicKeysBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyPublicKeysBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeysInKeyGroup {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyPublicKeysInKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of public keys in this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyPublicKeysInKeyGroup: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPublicKeysInKeyGroup" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyPublicKeysInKeyGroupBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyPublicKeysInKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringParameters {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains too many query string parameters.
public struct TooManyQueryStringParameters: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringParameters" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyQueryStringParametersBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInCachePolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringsInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of query strings in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringsInCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyQueryStringsInCachePolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyQueryStringsInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInOriginRequestPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringsInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of query strings in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringsInOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyQueryStringsInOriginRequestPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyQueryStringsInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRealtimeLogConfigs {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyRealtimeLogConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRealtimeLogConfigs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRealtimeLogConfigs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRealtimeLogConfigsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRealtimeLogConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRemoveHeadersInResponseHeadersPolicy {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyRemoveHeadersInResponseHeadersPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of headers in RemoveHeadersConfig in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRemoveHeadersInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRemoveHeadersInResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRemoveHeadersInResponseHeadersPolicyBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRemoveHeadersInResponseHeadersPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyResponseHeadersPolicies {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyResponseHeadersPoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of response headers policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyResponseHeadersPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyResponseHeadersPolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyResponseHeadersPoliciesBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyResponseHeadersPoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributionCNAMEs {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyStreamingDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyStreamingDistributionCNAMEs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyStreamingDistributionCNAMEs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyStreamingDistributionCNAMEsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyStreamingDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributions {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyStreamingDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of streaming distributions allowed.
public struct TooManyStreamingDistributions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyStreamingDistributions" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyStreamingDistributionsBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyStreamingDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTrustedSigners {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyTrustedSignersBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request contains more trusted signers than are allowed per distribution.
public struct TooManyTrustedSigners: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTrustedSigners" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTrustedSignersBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTrustedSignersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrafficConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case singleHeaderConfig = "SingleHeaderConfig"
        case singleWeightConfig = "SingleWeightConfig"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let singleHeaderConfig = singleHeaderConfig {
            try container.encode(singleHeaderConfig, forKey: ClientRuntime.Key("SingleHeaderConfig"))
        }
        if let singleWeightConfig = singleWeightConfig {
            try container.encode(singleWeightConfig, forKey: ClientRuntime.Key("SingleWeightConfig"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let singleWeightConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig.self, forKey: .singleWeightConfig)
        singleWeightConfig = singleWeightConfigDecoded
        let singleHeaderConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig.self, forKey: .singleHeaderConfig)
        singleHeaderConfig = singleHeaderConfigDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CloudFrontClientTypes.TrafficConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The traffic configuration of your continuous deployment.
    public struct TrafficConfig: Swift.Equatable {
        /// Determines which HTTP requests are sent to the staging distribution.
        public var singleHeaderConfig: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig?
        /// Contains the percentage of traffic to send to the staging distribution.
        public var singleWeightConfig: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig?
        /// The type of traffic configuration.
        /// This member is required.
        public var type: CloudFrontClientTypes.ContinuousDeploymentPolicyType?

        public init(
            singleHeaderConfig: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig? = nil,
            singleWeightConfig: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig? = nil,
            type: CloudFrontClientTypes.ContinuousDeploymentPolicyType? = nil
        )
        {
            self.singleHeaderConfig = singleHeaderConfig
            self.singleWeightConfig = singleWeightConfig
            self.type = type
        }
    }

}

extension TrustedKeyGroupDoesNotExist {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TrustedKeyGroupDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified key group does not exist.
public struct TrustedKeyGroupDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrustedKeyGroupDoesNotExist" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TrustedKeyGroupDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrustedKeyGroupDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups in the list have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups identifiers.
        public var items: [Swift.String]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension TrustedSignerDoesNotExist {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TrustedSignerDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of your trusted signers don't exist.
public struct TrustedSignerDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrustedSignerDoesNotExist" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TrustedSignerDoesNotExistBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrustedSignerDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedSigners: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("AwsAccountNumber"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct AwsAccountNumber{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AwsAccountNumber>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedSigners: Swift.Equatable {
        /// This field is true if any of the Amazon Web Services accounts in the list are configured as trusted signers. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services account identifiers.
        public var items: [Swift.String]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension UnsupportedOperation {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<UnsupportedOperationBody> = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.error.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This operation is not supported in this region.
public struct UnsupportedOperation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedOperationBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UntagResourceOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let tagKeys = input.operationInput.tagKeys {
                let xmlEncoder = encoder as! XMLEncoder
                let tagKeysData = try xmlEncoder.encode(tagKeys, withRootKey: "TagKeys")
                let tagKeysBody = ClientRuntime.HttpBody.data(tagKeysData)
                input.builder.withBody(tagKeysBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let tagKeysData = "{}".data(using: .utf8)!
                    let tagKeysBody = ClientRuntime.HttpBody.data(tagKeysData)
                    input.builder.withBody(tagKeysBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UntagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagKeys = tagKeys {
            try container.encode(tagKeys, forKey: ClientRuntime.Key("TagKeys"))
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "Operation", value: "Untag"))
            guard let resource = resource else {
                let message = "Creating a URL Query Item failed. resource is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            items.append(resourceQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to remove tags from a CloudFront resource.
public struct UntagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag key elements.
    /// This member is required.
    public var tagKeys: CloudFrontClientTypes.TagKeys?

    public init(
        resource: Swift.String? = nil,
        tagKeys: CloudFrontClientTypes.TagKeys? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: CloudFrontClientTypes.TagKeys?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TagKeys.self, forKey: .tagKeys)
        tagKeys = tagKeysDecoded
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTagging": return try await InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateCachePolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let cachePolicyConfigData = try xmlEncoder.encode(cachePolicyConfig, withRootKey: "CachePolicyConfig")
                let cachePolicyConfigBody = ClientRuntime.HttpBody.data(cachePolicyConfigData)
                input.builder.withBody(cachePolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let cachePolicyConfigData = "{}".data(using: .utf8)!
                    let cachePolicyConfigBody = ClientRuntime.HttpBody.data(cachePolicyConfigData)
                    input.builder.withBody(cachePolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCachePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

extension UpdateCachePolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateCachePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The unique identifier for the cache policy that you are updating. The identifier is returned in a cache behavior's CachePolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are updating. The version is returned in the cache policy's ETag field in the response to GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCachePolicyInputBody: Swift.Equatable {
    let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension UpdateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension UpdateCachePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
            self.cachePolicy = output
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct UpdateCachePolicyOutput: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct UpdateCachePolicyOutputBody: Swift.Equatable {
    let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension UpdateCachePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

enum UpdateCachePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CachePolicyAlreadyExists": return try await CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookiesInCachePolicy": return try await TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInCachePolicy": return try await TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringsInCachePolicy": return try await TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let cloudFrontOriginAccessIdentityConfigData = try xmlEncoder.encode(cloudFrontOriginAccessIdentityConfig, withRootKey: "CloudFrontOriginAccessIdentityConfig")
                let cloudFrontOriginAccessIdentityConfigBody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigData)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let cloudFrontOriginAccessIdentityConfigData = "{}".data(using: .utf8)!
                    let cloudFrontOriginAccessIdentityConfigBody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigData)
                    input.builder.withBody(cloudFrontOriginAccessIdentityConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update an origin access identity.
public struct UpdateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's configuration information.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The identity's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the identity's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
            self.cloudFrontOriginAccessIdentity = output
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateCloudFrontOriginAccessIdentityOutput: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct UpdateCloudFrontOriginAccessIdentityOutputBody: Swift.Equatable {
    let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension UpdateCloudFrontOriginAccessIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

enum UpdateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateContinuousDeploymentPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContinuousDeploymentPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContinuousDeploymentPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateContinuousDeploymentPolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let continuousDeploymentPolicyConfig = input.operationInput.continuousDeploymentPolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let continuousDeploymentPolicyConfigData = try xmlEncoder.encode(continuousDeploymentPolicyConfig, withRootKey: "ContinuousDeploymentPolicyConfig")
                let continuousDeploymentPolicyConfigBody = ClientRuntime.HttpBody.data(continuousDeploymentPolicyConfigData)
                input.builder.withBody(continuousDeploymentPolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let continuousDeploymentPolicyConfigData = "{}".data(using: .utf8)!
                    let continuousDeploymentPolicyConfigBody = ClientRuntime.HttpBody.data(continuousDeploymentPolicyConfigData)
                    input.builder.withBody(continuousDeploymentPolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContinuousDeploymentPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContinuousDeploymentPolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateContinuousDeploymentPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateContinuousDeploymentPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicyConfig = "ContinuousDeploymentPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig {
            try container.encode(continuousDeploymentPolicyConfig, forKey: ClientRuntime.Key("ContinuousDeploymentPolicyConfig"))
        }
    }
}

extension UpdateContinuousDeploymentPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateContinuousDeploymentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateContinuousDeploymentPolicyInput: Swift.Equatable {
    /// The continuous deployment policy configuration.
    /// This member is required.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
    /// The identifier of the continuous deployment policy that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the continuous deployment policy that you are updating.
    public var ifMatch: Swift.String?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateContinuousDeploymentPolicyInputBody: Swift.Equatable {
    let continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
}

extension UpdateContinuousDeploymentPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicyConfig = "ContinuousDeploymentPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.self, forKey: .continuousDeploymentPolicyConfig)
        continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfigDecoded
    }
}

extension UpdateContinuousDeploymentPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ContinuousDeploymentPolicy = try responseDecoder.decode(responseBody: data)
            self.continuousDeploymentPolicy = output
        } else {
            self.continuousDeploymentPolicy = nil
        }
    }
}

public struct UpdateContinuousDeploymentPolicyOutput: Swift.Equatable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
    }
}

struct UpdateContinuousDeploymentPolicyOutputBody: Swift.Equatable {
    let continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
}

extension UpdateContinuousDeploymentPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuousDeploymentPolicy = "ContinuousDeploymentPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let continuousDeploymentPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContinuousDeploymentPolicy.self, forKey: .continuousDeploymentPolicy)
        continuousDeploymentPolicy = continuousDeploymentPolicyDecoded
    }
}

enum UpdateContinuousDeploymentPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "StagingDistributionInUse": return try await StagingDistributionInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateDistributionOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let distributionConfig = input.operationInput.distributionConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let distributionConfigData = try xmlEncoder.encode(distributionConfig, withRootKey: "DistributionConfig")
                let distributionConfigBody = ClientRuntime.HttpBody.data(distributionConfigData)
                input.builder.withBody(distributionConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let distributionConfigData = "{}".data(using: .utf8)!
                    let distributionConfigBody = ClientRuntime.HttpBody.data(distributionConfigData)
                    input.builder.withBody(distributionConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

extension UpdateDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update a distribution.
public struct UpdateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateDistributionInputBody: Swift.Equatable {
    let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension UpdateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension UpdateDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
            self.distribution = output
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateDistributionOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct UpdateDistributionOutputBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension UpdateDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

enum UpdateDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalOriginAccessConfiguration": return try await IllegalOriginAccessConfiguration(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDomainNameForOriginAccessControl": return try await InvalidDomainNameForOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidErrorCode": return try await InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidForwardCookies": return try await InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLocationCode": return try await InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRelativePath": return try await InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidResponseCode": return try await InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTTLOrder": return try await InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidViewerCertificate": return try await InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidWebACLId": return try await InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOrigin": return try await NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "StagingDistributionInUse": return try await StagingDistributionInUse(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCertificates": return try await TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOrigins": return try await TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateDistributionWithStagingConfigInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionWithStagingConfigInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let stagingDistributionId = stagingDistributionId {
                let stagingDistributionIdQueryItem = ClientRuntime.URLQueryItem(name: "StagingDistributionId".urlPercentEncoding(), value: Swift.String(stagingDistributionId).urlPercentEncoding())
                items.append(stagingDistributionIdQueryItem)
            }
            return items
        }
    }
}

extension UpdateDistributionWithStagingConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/promote-staging-config"
    }
}

public struct UpdateDistributionWithStagingConfigInput: Swift.Equatable {
    /// The identifier of the primary distribution to which you are copying a staging distribution's configuration.
    /// This member is required.
    public var id: Swift.String?
    /// The current versions (ETag values) of both primary and staging distributions. Provide these in the following format: ,
    public var ifMatch: Swift.String?
    /// The identifier of the staging distribution whose configuration you are copying to the primary distribution.
    public var stagingDistributionId: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        stagingDistributionId: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.stagingDistributionId = stagingDistributionId
    }
}

struct UpdateDistributionWithStagingConfigInputBody: Swift.Equatable {
}

extension UpdateDistributionWithStagingConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UpdateDistributionWithStagingConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
            self.distribution = output
        } else {
            self.distribution = nil
        }
    }
}

public struct UpdateDistributionWithStagingConfigOutput: Swift.Equatable {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the primary distribution (after it's updated).
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct UpdateDistributionWithStagingConfigOutputBody: Swift.Equatable {
    let distribution: CloudFrontClientTypes.Distribution?
}

extension UpdateDistributionWithStagingConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

enum UpdateDistributionWithStagingConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidErrorCode": return try await InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidForwardCookies": return try await InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidLocationCode": return try await InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRelativePath": return try await InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidResponseCode": return try await InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidTTLOrder": return try await InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidViewerCertificate": return try await InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidWebACLId": return try await InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchCachePolicy": return try await NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchDistribution": return try await NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOrigin": return try await NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCertificates": return try await TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyOrigins": return try await TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let fieldLevelEncryptionConfigData = try xmlEncoder.encode(fieldLevelEncryptionConfig, withRootKey: "FieldLevelEncryptionConfig")
                let fieldLevelEncryptionConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigData)
                input.builder.withBody(fieldLevelEncryptionConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let fieldLevelEncryptionConfigData = "{}".data(using: .utf8)!
                    let fieldLevelEncryptionConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigData)
                    input.builder.withBody(fieldLevelEncryptionConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request to update a field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
    /// The ID of the configuration you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension UpdateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryption = output
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigOutput: Swift.Equatable {
    /// The value of the ETag header that you received when updating the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the results of updating the configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct UpdateFieldLevelEncryptionConfigOutputBody: Swift.Equatable {
    let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension UpdateFieldLevelEncryptionConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

enum UpdateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "QueryArgProfileEmpty": return try await QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionContentTypeProfiles": return try await TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionQueryArgProfiles": return try await TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let fieldLevelEncryptionProfileConfigData = try xmlEncoder.encode(fieldLevelEncryptionProfileConfig, withRootKey: "FieldLevelEncryptionProfileConfig")
                let fieldLevelEncryptionProfileConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigData)
                input.builder.withBody(fieldLevelEncryptionProfileConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let fieldLevelEncryptionProfileConfigData = "{}".data(using: .utf8)!
                    let fieldLevelEncryptionProfileConfigBody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigData)
                    input.builder.withBody(fieldLevelEncryptionProfileConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request to update a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
    /// The ID of the field-level encryption profile request.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension UpdateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
            self.fieldLevelEncryptionProfile = output
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileOutput: Swift.Equatable {
    /// The result of the field-level encryption profile request.
    public var eTag: Swift.String?
    /// Return the results of updating the profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct UpdateFieldLevelEncryptionProfileOutputBody: Swift.Equatable {
    let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension UpdateFieldLevelEncryptionProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

enum UpdateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "FieldLevelEncryptionProfileAlreadyExists": return try await FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "FieldLevelEncryptionProfileSizeExceeded": return try await FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchPublicKey": return try await NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionEncryptionEntities": return try await TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyFieldLevelEncryptionFieldPatterns": return try await TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionInput(functionConfig: \(Swift.String(describing: functionConfig)), ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), functionCode: \"CONTENT_REDACTED\")"}
}

extension UpdateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFunctionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
    }
}

extension UpdateFunctionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFunctionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// The current version (ETag value) of the function that you are updating, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are updating.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct UpdateFunctionInputBody: Swift.Equatable {
    let functionConfig: CloudFrontClientTypes.FunctionConfig?
    let functionCode: ClientRuntime.Data?
}

extension UpdateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension UpdateFunctionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETtag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
            self.functionSummary = output
        } else {
            self.functionSummary = nil
        }
    }
}

public struct UpdateFunctionOutput: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct UpdateFunctionOutputBody: Swift.Equatable {
    let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension UpdateFunctionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

enum UpdateFunctionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "FunctionSizeLimitExceeded": return try await FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchFunctionExists": return try await NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "UnsupportedOperation": return try await UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateKeyGroupOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let keyGroupConfig = input.operationInput.keyGroupConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let keyGroupConfigData = try xmlEncoder.encode(keyGroupConfig, withRootKey: "KeyGroupConfig")
                let keyGroupConfigBody = ClientRuntime.HttpBody.data(keyGroupConfigData)
                input.builder.withBody(keyGroupConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let keyGroupConfigData = "{}".data(using: .utf8)!
                    let keyGroupConfigBody = ClientRuntime.HttpBody.data(keyGroupConfigData)
                    input.builder.withBody(keyGroupConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateKeyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

extension UpdateKeyGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct UpdateKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are updating. The version is the key group's ETag value.
    public var ifMatch: Swift.String?
    /// The key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.keyGroupConfig = keyGroupConfig
    }
}

struct UpdateKeyGroupInputBody: Swift.Equatable {
    let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension UpdateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension UpdateKeyGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
            self.keyGroup = output
        } else {
            self.keyGroup = nil
        }
    }
}

public struct UpdateKeyGroupOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just updated.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct UpdateKeyGroupOutputBody: Swift.Equatable {
    let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension UpdateKeyGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

enum UpdateKeyGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "KeyGroupAlreadyExists": return try await KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResource": return try await NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyPublicKeysInKeyGroup": return try await TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateOriginAccessControlInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginAccessControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginAccessControlInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateOriginAccessControlOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let originAccessControlConfig = input.operationInput.originAccessControlConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let originAccessControlConfigData = try xmlEncoder.encode(originAccessControlConfig, withRootKey: "OriginAccessControlConfig")
                let originAccessControlConfigBody = ClientRuntime.HttpBody.data(originAccessControlConfigData)
                input.builder.withBody(originAccessControlConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let originAccessControlConfigData = "{}".data(using: .utf8)!
                    let originAccessControlConfigBody = ClientRuntime.HttpBody.data(originAccessControlConfigData)
                    input.builder.withBody(originAccessControlConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginAccessControlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginAccessControlOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateOriginAccessControlInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateOriginAccessControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControlConfig = "OriginAccessControlConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originAccessControlConfig = originAccessControlConfig {
            try container.encode(originAccessControlConfig, forKey: ClientRuntime.Key("OriginAccessControlConfig"))
        }
    }
}

extension UpdateOriginAccessControlInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateOriginAccessControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateOriginAccessControlInput: Swift.Equatable {
    /// The unique identifier of the origin access control that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the origin access control that you are updating.
    public var ifMatch: Swift.String?
    /// An origin access control.
    /// This member is required.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originAccessControlConfig = originAccessControlConfig
    }
}

struct UpdateOriginAccessControlInputBody: Swift.Equatable {
    let originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?
}

extension UpdateOriginAccessControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControlConfig = "OriginAccessControlConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessControlConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControlConfig.self, forKey: .originAccessControlConfig)
        originAccessControlConfig = originAccessControlConfigDecoded
    }
}

extension UpdateOriginAccessControlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginAccessControl = try responseDecoder.decode(responseBody: data)
            self.originAccessControl = output
        } else {
            self.originAccessControl = nil
        }
    }
}

public struct UpdateOriginAccessControlOutput: Swift.Equatable {
    /// The new version of the origin access control after it has been updated.
    public var eTag: Swift.String?
    /// The origin access control after it has been updated.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControl = originAccessControl
    }
}

struct UpdateOriginAccessControlOutputBody: Swift.Equatable {
    let originAccessControl: CloudFrontClientTypes.OriginAccessControl?
}

extension UpdateOriginAccessControlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessControl = "OriginAccessControl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessControlDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginAccessControl.self, forKey: .originAccessControl)
        originAccessControl = originAccessControlDecoded
    }
}

enum UpdateOriginAccessControlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "OriginAccessControlAlreadyExists": return try await OriginAccessControlAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let originRequestPolicyConfigData = try xmlEncoder.encode(originRequestPolicyConfig, withRootKey: "OriginRequestPolicyConfig")
                let originRequestPolicyConfigBody = ClientRuntime.HttpBody.data(originRequestPolicyConfigData)
                input.builder.withBody(originRequestPolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let originRequestPolicyConfigData = "{}".data(using: .utf8)!
                    let originRequestPolicyConfigBody = ClientRuntime.HttpBody.data(originRequestPolicyConfigData)
                    input.builder.withBody(originRequestPolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateOriginRequestPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are updating. The identifier is returned in a cache behavior's OriginRequestPolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are updating. The version is returned in the origin request policy's ETag field in the response to GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct UpdateOriginRequestPolicyInputBody: Swift.Equatable {
    let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension UpdateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension UpdateOriginRequestPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
            self.originRequestPolicy = output
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct UpdateOriginRequestPolicyOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct UpdateOriginRequestPolicyOutputBody: Swift.Equatable {
    let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension UpdateOriginRequestPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

enum UpdateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "OriginRequestPolicyAlreadyExists": return try await OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCookiesInOriginRequestPolicy": return try await TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyHeadersInOriginRequestPolicy": return try await TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyQueryStringsInOriginRequestPolicy": return try await TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdatePublicKeyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let publicKeyConfig = input.operationInput.publicKeyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let publicKeyConfigData = try xmlEncoder.encode(publicKeyConfig, withRootKey: "PublicKeyConfig")
                let publicKeyConfigBody = ClientRuntime.HttpBody.data(publicKeyConfigData)
                input.builder.withBody(publicKeyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let publicKeyConfigData = "{}".data(using: .utf8)!
                    let publicKeyConfigBody = ClientRuntime.HttpBody.data(publicKeyConfigData)
                    input.builder.withBody(publicKeyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdatePublicKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

extension UpdatePublicKeyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdatePublicKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdatePublicKeyInput: Swift.Equatable {
    /// The identifier of the public key that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// A public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.publicKeyConfig = publicKeyConfig
    }
}

struct UpdatePublicKeyInputBody: Swift.Equatable {
    let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension UpdatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension UpdatePublicKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
            self.publicKey = output
        } else {
            self.publicKey = nil
        }
    }
}

public struct UpdatePublicKeyOutput: Swift.Equatable {
    /// The identifier of the current version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct UpdatePublicKeyOutputBody: Swift.Equatable {
    let publicKey: CloudFrontClientTypes.PublicKey?
}

extension UpdatePublicKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

enum UpdatePublicKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CannotChangeImmutablePublicKeyFields": return try await CannotChangeImmutablePublicKeyFields(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchPublicKey": return try await NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension UpdateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateRealtimeLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

extension UpdateRealtimeLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct UpdateRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this real-time log configuration.
    public var arn: Swift.String?
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    public var fields: [Swift.String]?
    /// The name for this real-time log configuration.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    public var samplingRate: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct UpdateRealtimeLogConfigInputBody: Swift.Equatable {
    let endPoints: [CloudFrontClientTypes.EndPoint]?
    let fields: [Swift.String]?
    let name: Swift.String?
    let arn: Swift.String?
    let samplingRate: Swift.Int?
}

extension UpdateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension UpdateRealtimeLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRealtimeLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct UpdateRealtimeLogConfigOutput: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct UpdateRealtimeLogConfigOutputBody: Swift.Equatable {
    let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension UpdateRealtimeLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

enum UpdateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateResponseHeadersPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResponseHeadersPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResponseHeadersPolicyInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateResponseHeadersPolicyOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let responseHeadersPolicyConfig = input.operationInput.responseHeadersPolicyConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let responseHeadersPolicyConfigData = try xmlEncoder.encode(responseHeadersPolicyConfig, withRootKey: "ResponseHeadersPolicyConfig")
                let responseHeadersPolicyConfigBody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigData)
                input.builder.withBody(responseHeadersPolicyConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let responseHeadersPolicyConfigData = "{}".data(using: .utf8)!
                    let responseHeadersPolicyConfigBody = ClientRuntime.HttpBody.data(responseHeadersPolicyConfigData)
                    input.builder.withBody(responseHeadersPolicyConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResponseHeadersPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResponseHeadersPolicyOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateResponseHeadersPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateResponseHeadersPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let responseHeadersPolicyConfig = responseHeadersPolicyConfig {
            try container.encode(responseHeadersPolicyConfig, forKey: ClientRuntime.Key("ResponseHeadersPolicyConfig"))
        }
    }
}

extension UpdateResponseHeadersPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateResponseHeadersPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are updating. The version is returned in the cache policy's ETag field in the response to GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?
    /// A response headers policy configuration.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

struct UpdateResponseHeadersPolicyInputBody: Swift.Equatable {
    let responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?
}

extension UpdateResponseHeadersPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicyConfig = "ResponseHeadersPolicyConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicyConfig.self, forKey: .responseHeadersPolicyConfig)
        responseHeadersPolicyConfig = responseHeadersPolicyConfigDecoded
    }
}

extension UpdateResponseHeadersPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.ResponseHeadersPolicy = try responseDecoder.decode(responseBody: data)
            self.responseHeadersPolicy = output
        } else {
            self.responseHeadersPolicy = nil
        }
    }
}

public struct UpdateResponseHeadersPolicyOutput: Swift.Equatable {
    /// The current version of the response headers policy.
    public var eTag: Swift.String?
    /// A response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

struct UpdateResponseHeadersPolicyOutputBody: Swift.Equatable {
    let responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
}

extension UpdateResponseHeadersPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseHeadersPolicy = "ResponseHeadersPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseHeadersPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ResponseHeadersPolicy.self, forKey: .responseHeadersPolicy)
        responseHeadersPolicy = responseHeadersPolicyDecoded
    }
}

enum UpdateResponseHeadersPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "ResponseHeadersPolicyAlreadyExists": return try await ResponseHeadersPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooLongCSPInResponseHeadersPolicy": return try await TooLongCSPInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyCustomHeadersInResponseHeadersPolicy": return try await TooManyCustomHeadersInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyRemoveHeadersInResponseHeadersPolicy": return try await TooManyRemoveHeadersInResponseHeadersPolicy(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

public struct UpdateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateStreamingDistributionOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
                let xmlEncoder = encoder as! XMLEncoder
                let streamingDistributionConfigData = try xmlEncoder.encode(streamingDistributionConfig, withRootKey: "StreamingDistributionConfig")
                let streamingDistributionConfigBody = ClientRuntime.HttpBody.data(streamingDistributionConfigData)
                input.builder.withBody(streamingDistributionConfigBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let streamingDistributionConfigData = "{}".data(using: .utf8)!
                    let streamingDistributionConfigBody = ClientRuntime.HttpBody.data(streamingDistributionConfigData)
                    input.builder.withBody(streamingDistributionConfigBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateStreamingDistributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

extension UpdateStreamingDistributionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateStreamingDistributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update a streaming distribution.
public struct UpdateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the streaming distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct UpdateStreamingDistributionInputBody: Swift.Equatable {
    let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension UpdateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension UpdateStreamingDistributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
            self.streamingDistribution = output
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateStreamingDistributionOutput: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct UpdateStreamingDistributionOutputBody: Swift.Equatable {
    let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension UpdateStreamingDistributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

enum UpdateStreamingDistributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restXMLError = try await AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        switch restXMLError.errorCode {
            case "AccessDenied": return try await AccessDenied(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "IllegalUpdate": return try await IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InconsistentQuantities": return try await InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidArgument": return try await InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "MissingBody": return try await MissingBody(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "PreconditionFailed": return try await PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyStreamingDistributionCNAMEs": return try await TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TooManyTrustedSigners": return try await TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: restXMLError.message, requestID: restXMLError.requestId)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestId, typeName: restXMLError.errorCode)
        }
    }
}

extension CloudFrontClientTypes.ViewerCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "ACMCertificateArn"
        case certificate = "Certificate"
        case certificateSource = "CertificateSource"
        case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
        case iamCertificateId = "IAMCertificateId"
        case minimumProtocolVersion = "MinimumProtocolVersion"
        case sslSupportMethod = "SSLSupportMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let acmCertificateArn = acmCertificateArn {
            try container.encode(acmCertificateArn, forKey: ClientRuntime.Key("ACMCertificateArn"))
        }
        if let certificate = certificate {
            try container.encode(certificate, forKey: ClientRuntime.Key("Certificate"))
        }
        if let certificateSource = certificateSource {
            try container.encode(certificateSource, forKey: ClientRuntime.Key("CertificateSource"))
        }
        if let cloudFrontDefaultCertificate = cloudFrontDefaultCertificate {
            try container.encode(cloudFrontDefaultCertificate, forKey: ClientRuntime.Key("CloudFrontDefaultCertificate"))
        }
        if let iamCertificateId = iamCertificateId {
            try container.encode(iamCertificateId, forKey: ClientRuntime.Key("IAMCertificateId"))
        }
        if let minimumProtocolVersion = minimumProtocolVersion {
            try container.encode(minimumProtocolVersion, forKey: ClientRuntime.Key("MinimumProtocolVersion"))
        }
        if let sslSupportMethod = sslSupportMethod {
            try container.encode(sslSupportMethod, forKey: ClientRuntime.Key("SSLSupportMethod"))
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontDefaultCertificateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudFrontDefaultCertificate)
        cloudFrontDefaultCertificate = cloudFrontDefaultCertificateDecoded
        let iamCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamCertificateId)
        iamCertificateId = iamCertificateIdDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
        let sslSupportMethodDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.SSLSupportMethod.self, forKey: .sslSupportMethod)
        sslSupportMethod = sslSupportMethodDecoded
        let minimumProtocolVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MinimumProtocolVersion.self, forKey: .minimumProtocolVersion)
        minimumProtocolVersion = minimumProtocolVersionDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateSourceDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CertificateSource.self, forKey: .certificateSource)
        certificateSource = certificateSourceDecoded
    }
}

extension CloudFrontClientTypes.ViewerCertificate: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers. If the distribution doesn't use Aliases (also known as alternate domain names or CNAMEs)that is, if the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.netset CloudFrontDefaultCertificate to true and leave all other fields empty. If the distribution uses Aliases (alternate domain names or CNAMEs), use the fields in this type to specify the following settings:
    ///
    /// * Which viewers the distribution accepts HTTPS connections from: only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication) (recommended), or all viewers including those that don't support SNI.
    ///
    /// * To accept HTTPS connections from only viewers that support SNI, set SSLSupportMethod to sni-only. This is recommended. Most browsers and clients support SNI.
    ///
    /// * To accept HTTPS connections from all viewers, including those that don't support SNI, set SSLSupportMethod to vip. This is not recommended, and results in additional monthly charges from CloudFront.
    ///
    ///
    ///
    ///
    /// * The minimum SSL/TLS protocol version that the distribution can use to communicate with viewers. To specify a minimum version, choose a value for MinimumProtocolVersion. For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) in the Amazon CloudFront Developer Guide.
    ///
    /// * The location of the SSL/TLS certificate, [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended) or [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html). You specify the location by setting a value in one of the following fields (not both):
    ///
    /// * ACMCertificateArn
    ///
    /// * IAMCertificateId
    ///
    ///
    ///
    ///
    ///
    /// All distributions support HTTPS connections from viewers. To require viewers to use HTTPS only, or to redirect them from HTTP to HTTPS, use ViewerProtocolPolicy in the CacheBehavior or DefaultCacheBehavior. To specify how CloudFront should use SSL/TLS to communicate with your custom origin, use CustomOriginConfig. For more information, see [Using HTTPS with CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html) and [ Using Alternate Domain Names and HTTPS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html) in the Amazon CloudFront Developer Guide.
    public struct ViewerCertificate: Swift.Equatable {
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html), provide the Amazon Resource Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US East (N. Virginia) Region (us-east-1). If you specify an ACM certificate ARN, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var acmCertificateArn: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificate: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificateSource: CloudFrontClientTypes.CertificateSource?
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, set this field to true. If the distribution uses Aliases (alternate domain names or CNAMEs), set this field to false and specify values for the following fields:
        ///
        /// * ACMCertificateArn or IAMCertificateId (specify a value for one, not both)
        ///
        /// * MinimumProtocolVersion
        ///
        /// * SSLSupportMethod
        public var cloudFrontDefaultCertificate: Swift.Bool?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html), provide the ID of the IAM certificate. If you specify an IAM certificate ID, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var iamCertificateId: Swift.String?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify the security policy that you want CloudFront to use for HTTPS connections with viewers. The security policy determines two settings:
        ///
        /// * The minimum SSL/TLS protocol that CloudFront can use to communicate with viewers.
        ///
        /// * The ciphers that CloudFront can use to encrypt the content that it returns to viewers.
        ///
        ///
        /// For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) and [Supported Protocols and Ciphers Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers) in the Amazon CloudFront Developer Guide. On the CloudFront console, this setting is called Security Policy. When you're using SNI only (you set SSLSupportMethod to sni-only), you must specify TLSv1 or higher. If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net (you set CloudFrontDefaultCertificate to true), CloudFront automatically sets the security policy to TLSv1 regardless of the value that you set here.
        public var minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify which viewers the distribution accepts HTTPS connections from.
        ///
        /// * sni-only  The distribution accepts HTTPS connections from only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication). This is recommended. Most browsers and clients support SNI.
        ///
        /// * vip  The distribution accepts HTTPS connections from all viewers including those that don't support SNI. This is not recommended, and results in additional monthly charges from CloudFront.
        ///
        /// * static-ip - Do not specify this value unless your distribution has been enabled for this feature by the CloudFront team. If you have a use case that requires static IP addresses for a distribution, contact CloudFront through the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home).
        ///
        ///
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, don't set a value for this field.
        public var sslSupportMethod: CloudFrontClientTypes.SSLSupportMethod?

        public init(
            acmCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: CloudFrontClientTypes.CertificateSource? = nil,
            cloudFrontDefaultCertificate: Swift.Bool? = nil,
            iamCertificateId: Swift.String? = nil,
            minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion? = nil,
            sslSupportMethod: CloudFrontClientTypes.SSLSupportMethod? = nil
        )
        {
            self.acmCertificateArn = acmCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iamCertificateId = iamCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sslSupportMethod = sslSupportMethod
        }
    }

}

extension CloudFrontClientTypes {
    public enum ViewerProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowAll
        case httpsOnly
        case redirectToHttps
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewerProtocolPolicy] {
            return [
                .allowAll,
                .httpsOnly,
                .redirectToHttps,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "allow-all"
            case .httpsOnly: return "https-only"
            case .redirectToHttps: return "redirect-to-https"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViewerProtocolPolicy(rawValue: rawValue) ?? ViewerProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}
