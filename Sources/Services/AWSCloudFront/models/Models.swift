// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyReadWrite
import SmithyXML

extension AccessDenied {

    static var readingClosure: SmithyReadWrite.ReadingClosure<AccessDenied, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = AccessDenied()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension AccessDenied {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = AccessDenied()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Access denied.
public struct AccessDenied: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups {

    static func writingClosure(_ value: CloudFrontClientTypes.ActiveTrustedKeyGroups?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Enabled"].write(value.enabled)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.KGKeyPairIds.writingClosure(_:to:), memberNodeInfo: "KeyGroup", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ActiveTrustedKeyGroups, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ActiveTrustedKeyGroups()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KGKeyPairIds.readingClosure, memberNodeInfo: "KeyGroup", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups, and the public keys in each key group, that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups, including the identifiers of the public keys in each key group that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.KGKeyPairIds]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.KGKeyPairIds]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ActiveTrustedSigners {

    static func writingClosure(_ value: CloudFrontClientTypes.ActiveTrustedSigners?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Enabled"].write(value.enabled)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.Signer.writingClosure(_:to:), memberNodeInfo: "Signer", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ActiveTrustedSigners, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ActiveTrustedSigners()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Signer.readingClosure, memberNodeInfo: "Signer", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedSigners: Swift.Equatable {
        /// This field is true if any of the Amazon Web Services accounts in the list are configured as trusted signers. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services accounts and the identifiers of active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.Signer]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.Signer]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AliasICPRecordal {

    static func writingClosure(_ value: CloudFrontClientTypes.AliasICPRecordal?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CNAME"].write(value.cname)
        try writer["ICPRecordalStatus"].write(value.icpRecordalStatus)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.AliasICPRecordal, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.AliasICPRecordal()
            value.cname = try reader["CNAME"].readIfPresent()
            value.icpRecordalStatus = try reader["ICPRecordalStatus"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure it yourself. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
    public struct AliasICPRecordal: Swift.Equatable {
        /// A domain name associated with a distribution.
        public var cname: Swift.String?
        /// The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to APPROVED for all CNAMEs (aliases) in regions outside of China. The status values returned are the following:
        ///
        /// * APPROVED indicates that the associated CNAME has a valid ICP recordal number. Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.
        ///
        /// * SUSPENDED indicates that the associated CNAME does not have a valid ICP recordal number.
        ///
        /// * PENDING indicates that CloudFront can't determine the ICP recordal status of the CNAME associated with the distribution because there was an error in trying to determine the status. You can try again to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.
        public var icpRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus?

        public init(
            cname: Swift.String? = nil,
            icpRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus? = nil
        )
        {
            self.cname = cname
            self.icpRecordalStatus = icpRecordalStatus
        }
    }

}

extension CloudFrontClientTypes.Aliases {

    static func writingClosure(_ value: CloudFrontClientTypes.Aliases?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "CNAME", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Aliases, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Aliases()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "CNAME", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
    public struct Aliases: Swift.Equatable {
        /// A complex type that contains the CNAME aliases, if any, that you want to associate with this distribution.
        public var items: [Swift.String]?
        /// The number of CNAME aliases, if any, that you want to associate with this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AllowedMethods {

    static func writingClosure(_ value: CloudFrontClientTypes.AllowedMethods?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CachedMethods"].write(value.cachedMethods, writingClosure: CloudFrontClientTypes.CachedMethods.writingClosure(_:to:))
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.Method.writingClosure(_:to:), memberNodeInfo: "Method", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.AllowedMethods, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.AllowedMethods()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Method.readingClosure, memberNodeInfo: "Method", isFlattened: false)
            value.cachedMethods = try reader["CachedMethods"].readIfPresent(readingClosure: CloudFrontClientTypes.CachedMethods.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
    ///
    /// * CloudFront forwards only GET and HEAD requests.
    ///
    /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
    ///
    /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
    ///
    ///
    /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
    public struct AllowedMethods: Swift.Equatable {
        /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
        ///
        /// * CloudFront caches responses to GET and HEAD requests.
        ///
        /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
        ///
        ///
        /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        public var cachedMethods: CloudFrontClientTypes.CachedMethods?
        /// A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD, and OPTIONS requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            cachedMethods: CloudFrontClientTypes.CachedMethods? = nil,
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.cachedMethods = cachedMethods
            self.items = items
            self.quantity = quantity
        }
    }

}

extension AssociateAliasInput {

    static func queryItemProvider(_ value: AssociateAliasInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let alias = value.alias else {
            let message = "Creating a URL Query Item failed. alias is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let aliasQueryItem = ClientRuntime.SDKURLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
        items.append(aliasQueryItem)
        return items
    }
}

extension AssociateAliasInput {

    static func urlPathProvider(_ value: AssociateAliasInput) -> Swift.String? {
        guard let targetDistributionId = value.targetDistributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(targetDistributionId.urlPercentEncoding())/associate-alias"
    }
}

public struct AssociateAliasInput: Swift.Equatable {
    /// The alias (also known as a CNAME) to add to the target distribution.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the distribution that you're associating the alias with.
    /// This member is required.
    public var targetDistributionId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        targetDistributionId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.targetDistributionId = targetDistributionId
    }
}

extension AssociateAliasOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AssociateAliasOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AssociateAliasOutput()
        }
    }
}

public struct AssociateAliasOutput: Swift.Equatable {

    public init() { }
}

enum AssociateAliasOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension BatchTooLarge {

    static var readingClosure: SmithyReadWrite.ReadingClosure<BatchTooLarge, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = BatchTooLarge()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension BatchTooLarge {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = BatchTooLarge()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Invalidation batch specified is too large.
public struct BatchTooLarge: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchTooLarge" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CNAMEAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<CNAMEAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CNAMEAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension CNAMEAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CNAMEAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The CNAME specified is already defined for CloudFront.
public struct CNAMEAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CNAMEAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.CacheBehavior {

    static func writingClosure(_ value: CloudFrontClientTypes.CacheBehavior?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AllowedMethods"].write(value.allowedMethods, writingClosure: CloudFrontClientTypes.AllowedMethods.writingClosure(_:to:))
        try writer["CachePolicyId"].write(value.cachePolicyId)
        try writer["Compress"].write(value.compress)
        try writer["DefaultTTL"].write(value.defaultTTL)
        try writer["FieldLevelEncryptionId"].write(value.fieldLevelEncryptionId)
        try writer["ForwardedValues"].write(value.forwardedValues, writingClosure: CloudFrontClientTypes.ForwardedValues.writingClosure(_:to:))
        try writer["FunctionAssociations"].write(value.functionAssociations, writingClosure: CloudFrontClientTypes.FunctionAssociations.writingClosure(_:to:))
        try writer["LambdaFunctionAssociations"].write(value.lambdaFunctionAssociations, writingClosure: CloudFrontClientTypes.LambdaFunctionAssociations.writingClosure(_:to:))
        try writer["MaxTTL"].write(value.maxTTL)
        try writer["MinTTL"].write(value.minTTL)
        try writer["OriginRequestPolicyId"].write(value.originRequestPolicyId)
        try writer["PathPattern"].write(value.pathPattern)
        try writer["RealtimeLogConfigArn"].write(value.realtimeLogConfigArn)
        try writer["ResponseHeadersPolicyId"].write(value.responseHeadersPolicyId)
        try writer["SmoothStreaming"].write(value.smoothStreaming)
        try writer["TargetOriginId"].write(value.targetOriginId)
        try writer["TrustedKeyGroups"].write(value.trustedKeyGroups, writingClosure: CloudFrontClientTypes.TrustedKeyGroups.writingClosure(_:to:))
        try writer["TrustedSigners"].write(value.trustedSigners, writingClosure: CloudFrontClientTypes.TrustedSigners.writingClosure(_:to:))
        try writer["ViewerProtocolPolicy"].write(value.viewerProtocolPolicy)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CacheBehavior, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CacheBehavior()
            value.pathPattern = try reader["PathPattern"].readIfPresent()
            value.targetOriginId = try reader["TargetOriginId"].readIfPresent()
            value.trustedSigners = try reader["TrustedSigners"].readIfPresent(readingClosure: CloudFrontClientTypes.TrustedSigners.readingClosure)
            value.trustedKeyGroups = try reader["TrustedKeyGroups"].readIfPresent(readingClosure: CloudFrontClientTypes.TrustedKeyGroups.readingClosure)
            value.viewerProtocolPolicy = try reader["ViewerProtocolPolicy"].readIfPresent()
            value.allowedMethods = try reader["AllowedMethods"].readIfPresent(readingClosure: CloudFrontClientTypes.AllowedMethods.readingClosure)
            value.smoothStreaming = try reader["SmoothStreaming"].readIfPresent()
            value.compress = try reader["Compress"].readIfPresent()
            value.lambdaFunctionAssociations = try reader["LambdaFunctionAssociations"].readIfPresent(readingClosure: CloudFrontClientTypes.LambdaFunctionAssociations.readingClosure)
            value.functionAssociations = try reader["FunctionAssociations"].readIfPresent(readingClosure: CloudFrontClientTypes.FunctionAssociations.readingClosure)
            value.fieldLevelEncryptionId = try reader["FieldLevelEncryptionId"].readIfPresent()
            value.realtimeLogConfigArn = try reader["RealtimeLogConfigArn"].readIfPresent()
            value.cachePolicyId = try reader["CachePolicyId"].readIfPresent()
            value.originRequestPolicyId = try reader["OriginRequestPolicyId"].readIfPresent()
            value.responseHeadersPolicyId = try reader["ResponseHeadersPolicyId"].readIfPresent()
            value.forwardedValues = try reader["ForwardedValues"].readIfPresent(readingClosure: CloudFrontClientTypes.ForwardedValues.readingClosure)
            value.minTTL = try reader["MinTTL"].readIfPresent()
            value.defaultTTL = try reader["DefaultTTL"].readIfPresent()
            value.maxTTL = try reader["MaxTTL"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes how CloudFront processes requests. You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to serve objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin is never used. For the current quota (formerly known as limit) on the number of cache behaviors that you can add to a distribution, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) in the Amazon CloudFront Developer Guide. If you don't want to specify any cache behaviors, include only an empty CacheBehaviors element. Don't include an empty CacheBehavior element because this is invalid. To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty CacheBehaviors element. To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution. For more information about cache behaviors, see [Cache Behavior Settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior) in the Amazon CloudFront Developer Guide.
    public struct CacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to this cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for this cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [ Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to this cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The pattern (for example, images/*.jpg) that specifies which requests to apply the behavior to. When CloudFront receives a viewer request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. You can optionally include a slash (/) at the beginning of the path pattern. For example, /images/*.jpg. CloudFront behavior is the same with or without the leading /. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior. For more information, see [Path Pattern](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var pathPattern: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they match this cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in the trusted signer's Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init(
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            pathPattern: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.pathPattern = pathPattern
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension CloudFrontClientTypes.CacheBehaviors {

    static func writingClosure(_ value: CloudFrontClientTypes.CacheBehaviors?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.CacheBehavior.writingClosure(_:to:), memberNodeInfo: "CacheBehavior", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CacheBehaviors, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CacheBehaviors()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CacheBehavior.readingClosure, memberNodeInfo: "CacheBehavior", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more CacheBehavior elements.
    public struct CacheBehaviors: Swift.Equatable {
        /// Optional: A complex type that contains cache behaviors for this distribution. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.CacheBehavior]?
        /// The number of cache behaviors for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CacheBehavior]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CachePolicy {

    static func writingClosure(_ value: CloudFrontClientTypes.CachePolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CachePolicyConfig"].write(value.cachePolicyConfig, writingClosure: CloudFrontClientTypes.CachePolicyConfig.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachePolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachePolicy()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.cachePolicyConfig = try reader["CachePolicyConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicyConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A cache policy. When it's attached to a cache behavior, the cache policy determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find a valid object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicy: Swift.Equatable {
        /// The cache policy configuration.
        /// This member is required.
        public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
        /// The unique identifier for the cache policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the cache policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.cachePolicyConfig = cachePolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CachePolicyAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<CachePolicyAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CachePolicyAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension CachePolicyAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CachePolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use UpdateCachePolicy.
public struct CachePolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CachePolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.CachePolicyConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.CachePolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["DefaultTTL"].write(value.defaultTTL)
        try writer["MaxTTL"].write(value.maxTTL)
        try writer["MinTTL"].write(value.minTTL)
        try writer["Name"].write(value.name)
        try writer["ParametersInCacheKeyAndForwardedToOrigin"].write(value.parametersInCacheKeyAndForwardedToOrigin, writingClosure: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachePolicyConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachePolicyConfig()
            value.comment = try reader["Comment"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.defaultTTL = try reader["DefaultTTL"].readIfPresent()
            value.maxTTL = try reader["MaxTTL"].readIfPresent()
            value.minTTL = try reader["MinTTL"].readIfPresent()
            value.parametersInCacheKeyAndForwardedToOrigin = try reader["ParametersInCacheKeyAndForwardedToOrigin"].readIfPresent(readingClosure: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A cache policy configuration. This configuration determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find a valid object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicyConfig: Swift.Equatable {
        /// A comment to describe the cache policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value as the object's time to live (TTL) only when the origin does not send Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 86400 seconds (one day). If the value of MinTTL is more than 86400 seconds, then the default value for this field is the same as the value of MinTTL.
        public var defaultTTL: Swift.Int?
        /// The maximum amount of time, in seconds, that objects stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value only when the origin sends Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 31536000 seconds (one year). If the value of MinTTL or DefaultTTL is more than 31536000 seconds, then the default value for this field is the same as the value of DefaultTTL.
        public var maxTTL: Swift.Int?
        /// The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var minTTL: Swift.Int?
        /// A unique name to identify the cache policy.
        /// This member is required.
        public var name: Swift.String?
        /// The HTTP headers, cookies, and URL query strings to include in the cache key. The values included in the cache key are also included in requests that CloudFront sends to the origin.
        public var parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?

        public init(
            comment: Swift.String? = nil,
            defaultTTL: Swift.Int? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            name: Swift.String? = nil,
            parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin? = nil
        )
        {
            self.comment = comment
            self.defaultTTL = defaultTTL
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.name = name
            self.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyCookieBehavior(rawValue: rawValue) ?? CachePolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.CachePolicyCookiesConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CookieBehavior"].write(value.cookieBehavior)
        try writer["Cookies"].write(value.cookies, writingClosure: CloudFrontClientTypes.CookieNames.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachePolicyCookiesConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachePolicyCookiesConfig()
            value.cookieBehavior = try reader["CookieBehavior"].readIfPresent()
            value.cookies = try reader["Cookies"].readIfPresent(readingClosure: CloudFrontClientTypes.CookieNames.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyCookiesConfig: Swift.Equatable {
        /// Determines whether any cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No cookies in viewer requests are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – Only the cookies in viewer requests that are listed in the CookieNames type are included in the cache key and in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin, except for those that are listed in the CookieNames type, which are not included.
        ///
        /// * all – All cookies in viewer requests are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init(
            cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyHeaderBehavior] {
            return [
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyHeaderBehavior(rawValue: rawValue) ?? CachePolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.CachePolicyHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["HeaderBehavior"].write(value.headerBehavior)
        try writer["Headers"].write(value.headers, writingClosure: CloudFrontClientTypes.Headers.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachePolicyHeadersConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachePolicyHeadersConfig()
            value.headerBehavior = try reader["HeaderBehavior"].readIfPresent()
            value.headers = try reader["Headers"].readIfPresent(readingClosure: CloudFrontClientTypes.Headers.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No HTTP headers are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – Only the HTTP headers that are listed in the Headers type are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init(
            headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension CachePolicyInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<CachePolicyInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CachePolicyInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension CachePolicyInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CachePolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Cannot delete the cache policy because it is attached to one or more cache behaviors.
public struct CachePolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CachePolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.CachePolicyList {

    static func writingClosure(_ value: CloudFrontClientTypes.CachePolicyList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.CachePolicySummary.writingClosure(_:to:), memberNodeInfo: "CachePolicySummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachePolicyList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachePolicyList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CachePolicySummary.readingClosure, memberNodeInfo: "CachePolicySummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of cache policies.
    public struct CachePolicyList: Swift.Equatable {
        /// Contains the cache policies in the list.
        public var items: [CloudFrontClientTypes.CachePolicySummary]?
        /// The maximum number of cache policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing cache policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of cache policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CachePolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyQueryStringBehavior(rawValue: rawValue) ?? CachePolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.CachePolicyQueryStringsConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["QueryStringBehavior"].write(value.queryStringBehavior)
        try writer["QueryStrings"].write(value.queryStrings, writingClosure: CloudFrontClientTypes.QueryStringNames.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachePolicyQueryStringsConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachePolicyQueryStringsConfig()
            value.queryStringBehavior = try reader["QueryStringBehavior"].readIfPresent()
            value.queryStrings = try reader["QueryStrings"].readIfPresent(readingClosure: CloudFrontClientTypes.QueryStringNames.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and in requests that CloudFront sends to the origin.
    public struct CachePolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No query strings in viewer requests are included in the cache key or in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – Only the query strings in viewer requests that are listed in the QueryStringNames type are included in the cache key and in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin, except those that are listed in the QueryStringNames type, which are not included.
        ///
        /// * all – All query strings in viewer requests are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in the cache key and in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the CachePolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init(
            queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.CachePolicySummary {

    static func writingClosure(_ value: CloudFrontClientTypes.CachePolicySummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CachePolicy"].write(value.cachePolicy, writingClosure: CloudFrontClientTypes.CachePolicy.writingClosure(_:to:))
        try writer["Type"].write(value.type)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachePolicySummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachePolicySummary()
            value.type = try reader["Type"].readIfPresent()
            value.cachePolicy = try reader["CachePolicy"].readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicy.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains a cache policy.
    public struct CachePolicySummary: Swift.Equatable {
        /// The cache policy.
        /// This member is required.
        public var cachePolicy: CloudFrontClientTypes.CachePolicy?
        /// The type of cache policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.CachePolicyType?

        public init(
            cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
            type: CloudFrontClientTypes.CachePolicyType? = nil
        )
        {
            self.cachePolicy = cachePolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyType(rawValue: rawValue) ?? CachePolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachedMethods {

    static func writingClosure(_ value: CloudFrontClientTypes.CachedMethods?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.Method.writingClosure(_:to:), memberNodeInfo: "Method", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CachedMethods, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CachedMethods()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Method.readingClosure, memberNodeInfo: "Method", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
    ///
    /// * CloudFront caches responses to GET and HEAD requests.
    ///
    /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
    ///
    ///
    /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
    public struct CachedMethods: Swift.Equatable {
        /// A complex type that contains the HTTP methods that you want CloudFront to cache responses to.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods for which you want CloudFront to cache responses. Valid values are 2 (for caching responses to GET and HEAD requests) and 3 (for caching responses to GET, HEAD, and OPTIONS requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CannotChangeImmutablePublicKeyFields {

    static var readingClosure: SmithyReadWrite.ReadingClosure<CannotChangeImmutablePublicKeyFields, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CannotChangeImmutablePublicKeyFields()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension CannotChangeImmutablePublicKeyFields {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CannotChangeImmutablePublicKeyFields()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You can't change the value of a public key.
public struct CannotChangeImmutablePublicKeyFields: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotChangeImmutablePublicKeyFields" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CannotDeleteEntityWhileInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<CannotDeleteEntityWhileInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CannotDeleteEntityWhileInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension CannotDeleteEntityWhileInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CannotDeleteEntityWhileInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Key Value Store entity cannot be deleted while it is in use.
public struct CannotDeleteEntityWhileInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotDeleteEntityWhileInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {
    public enum CertificateSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acm
        case cloudfront
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateSource] {
            return [
                .acm,
                .cloudfront,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acm: return "acm"
            case .cloudfront: return "cloudfront"
            case .iam: return "iam"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateSource(rawValue: rawValue) ?? CertificateSource.sdkUnknown(rawValue)
        }
    }
}

public enum CloudFrontClientTypes {}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity {

    static func writingClosure(_ value: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CloudFrontOriginAccessIdentityConfig"].write(value.cloudFrontOriginAccessIdentityConfig, writingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["S3CanonicalUserId"].write(value.s3CanonicalUserId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CloudFrontOriginAccessIdentity, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentity()
            value.id = try reader["Id"].readIfPresent()
            value.s3CanonicalUserId = try reader["S3CanonicalUserId"].readIfPresent()
            value.cloudFrontOriginAccessIdentityConfig = try reader["CloudFrontOriginAccessIdentityConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentity: Swift.Equatable {
        /// The current configuration information for the identity.
        public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
        /// The ID for the origin access identity, for example, E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, used when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init(
            cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontOriginAccessIdentityAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontOriginAccessIdentityAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontOriginAccessIdentityAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontOriginAccessIdentityAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CloudFrontOriginAccessIdentityAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
public struct CloudFrontOriginAccessIdentityAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudFrontOriginAccessIdentityAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig()
            value.callerReference = try reader["CallerReference"].readIfPresent()
            value.comment = try reader["Comment"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Origin access identity configuration. Send a GET request to the /CloudFront API version/CloudFront/identity ID/config resource.
    public struct CloudFrontOriginAccessIdentityConfig: Swift.Equatable {
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the CloudFrontOriginAccessIdentityConfig object), a new origin access identity is created. If the CallerReference is a value already sent in a previous identity request, and the content of the CloudFrontOriginAccessIdentityConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create an identity, but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the origin access identity. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
        }
    }

}

extension CloudFrontOriginAccessIdentityInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontOriginAccessIdentityInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontOriginAccessIdentityInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontOriginAccessIdentityInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CloudFrontOriginAccessIdentityInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Origin Access Identity specified is already in use.
public struct CloudFrontOriginAccessIdentityInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudFrontOriginAccessIdentityInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList {

    static func writingClosure(_ value: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsTruncated"].write(value.isTruncated)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary.writingClosure(_:to:), memberNodeInfo: "CloudFrontOriginAccessIdentitySummary", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CloudFrontOriginAccessIdentityList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentityList()
            value.marker = try reader["Marker"].readIfPresent()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.isTruncated = try reader["IsTruncated"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary.readingClosure, memberNodeInfo: "CloudFrontOriginAccessIdentitySummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Lists the origin access identities for CloudFront.Send a GET request to the /CloudFront API version/origin-access-identity/cloudfront resource. The response includes a CloudFrontOriginAccessIdentityList element with zero or more CloudFrontOriginAccessIdentitySummary child elements. By default, your entire list of origin access identities is returned in one single page. If the list is long, you can paginate it using the MaxItems and Marker parameters.
    public struct CloudFrontOriginAccessIdentityList: Swift.Equatable {
        /// A flag that indicates whether more origin access identities remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more items in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one CloudFrontOriginAccessIdentitySummary element for each origin access identity that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]?
        /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access identities you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your origin access identities where they left off.
        public var nextMarker: Swift.String?
        /// The number of CloudFront origin access identities that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary {

    static func writingClosure(_ value: CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["Id"].write(value.id)
        try writer["S3CanonicalUserId"].write(value.s3CanonicalUserId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary()
            value.id = try reader["Id"].readIfPresent()
            value.s3CanonicalUserId = try reader["S3CanonicalUserId"].readIfPresent()
            value.comment = try reader["Comment"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Summary of the information about a CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentitySummary: Swift.Equatable {
        /// The comment for this origin access identity, as originally specified when created.
        /// This member is required.
        public var comment: Swift.String?
        /// The ID for the origin access identity. For example: E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init(
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.comment = comment
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAlias {

    static func writingClosure(_ value: CloudFrontClientTypes.ConflictingAlias?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccountId"].write(value.accountId)
        try writer["Alias"].write(value.alias)
        try writer["DistributionId"].write(value.distributionId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ConflictingAlias, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ConflictingAlias()
            value.alias = try reader["Alias"].readIfPresent()
            value.distributionId = try reader["DistributionId"].readIfPresent()
            value.accountId = try reader["AccountId"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An alias (also called a CNAME) and the CloudFront distribution and Amazon Web Services account ID that it's associated with. The distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don't own.
    public struct ConflictingAlias: Swift.Equatable {
        /// The (partially hidden) ID of the Amazon Web Services account that owns the distribution that's associated with the alias.
        public var accountId: Swift.String?
        /// An alias (also called a CNAME).
        public var alias: Swift.String?
        /// The (partially hidden) ID of the CloudFront distribution associated with the alias.
        public var distributionId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            alias: Swift.String? = nil,
            distributionId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.alias = alias
            self.distributionId = distributionId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAliasesList {

    static func writingClosure(_ value: CloudFrontClientTypes.ConflictingAliasesList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ConflictingAlias.writingClosure(_:to:), memberNodeInfo: "ConflictingAlias", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ConflictingAliasesList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ConflictingAliasesList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ConflictingAlias.readingClosure, memberNodeInfo: "ConflictingAlias", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of aliases (also called CNAMEs) and the CloudFront distributions and Amazon Web Services accounts that they are associated with. In the list, the distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don't own.
    public struct ConflictingAliasesList: Swift.Equatable {
        /// Contains the conflicting aliases in the list.
        public var items: [CloudFrontClientTypes.ConflictingAlias]?
        /// The maximum number of conflicting aliases requested.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing conflicting aliases where you left off.
        public var nextMarker: Swift.String?
        /// The number of conflicting aliases returned in the response.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ConflictingAlias]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfile {

    static func writingClosure(_ value: CloudFrontClientTypes.ContentTypeProfile?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContentType"].write(value.contentType)
        try writer["Format"].write(value.format)
        try writer["ProfileId"].write(value.profileId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContentTypeProfile, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContentTypeProfile()
            value.format = try reader["Format"].readIfPresent()
            value.profileId = try reader["ProfileId"].readIfPresent()
            value.contentType = try reader["ContentType"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A field-level encryption content type profile.
    public struct ContentTypeProfile: Swift.Equatable {
        /// The content type for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var contentType: Swift.String?
        /// The format for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var format: CloudFrontClientTypes.Format?
        /// The profile ID for a field-level encryption content type-profile mapping.
        public var profileId: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            format: CloudFrontClientTypes.Format? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.format = format
            self.profileId = profileId
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfileConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ContentTypeProfileConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContentTypeProfiles"].write(value.contentTypeProfiles, writingClosure: CloudFrontClientTypes.ContentTypeProfiles.writingClosure(_:to:))
        try writer["ForwardWhenContentTypeIsUnknown"].write(value.forwardWhenContentTypeIsUnknown)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContentTypeProfileConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContentTypeProfileConfig()
            value.forwardWhenContentTypeIsUnknown = try reader["ForwardWhenContentTypeIsUnknown"].readIfPresent()
            value.contentTypeProfiles = try reader["ContentTypeProfiles"].readIfPresent(readingClosure: CloudFrontClientTypes.ContentTypeProfiles.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The configuration for a field-level encryption content type-profile mapping.
    public struct ContentTypeProfileConfig: Swift.Equatable {
        /// The configuration for a field-level encryption content type-profile.
        public var contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles?
        /// The setting in a field-level encryption content type-profile mapping that specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
        /// This member is required.
        public var forwardWhenContentTypeIsUnknown: Swift.Bool?

        public init(
            contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles? = nil,
            forwardWhenContentTypeIsUnknown: Swift.Bool? = nil
        )
        {
            self.contentTypeProfiles = contentTypeProfiles
            self.forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfiles {

    static func writingClosure(_ value: CloudFrontClientTypes.ContentTypeProfiles?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ContentTypeProfile.writingClosure(_:to:), memberNodeInfo: "ContentTypeProfile", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContentTypeProfiles, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContentTypeProfiles()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ContentTypeProfile.readingClosure, memberNodeInfo: "ContentTypeProfile", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Field-level encryption content type-profile.
    public struct ContentTypeProfiles: Swift.Equatable {
        /// Items in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.ContentTypeProfile]?
        /// The number of field-level encryption content type-profile mappings.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ContentTypeProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContinuousDeploymentPolicy {

    static func writingClosure(_ value: CloudFrontClientTypes.ContinuousDeploymentPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContinuousDeploymentPolicyConfig"].write(value.continuousDeploymentPolicyConfig, writingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContinuousDeploymentPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContinuousDeploymentPolicy()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.continuousDeploymentPolicyConfig = try reader["ContinuousDeploymentPolicyConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A continuous deployment policy.
    public struct ContinuousDeploymentPolicy: Swift.Equatable {
        /// Contains the configuration for a continuous deployment policy.
        /// This member is required.
        public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
        /// The identifier of the continuous deployment policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the continuous deployment policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension ContinuousDeploymentPolicyAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<ContinuousDeploymentPolicyAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ContinuousDeploymentPolicyAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension ContinuousDeploymentPolicyAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ContinuousDeploymentPolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A continuous deployment policy with this configuration already exists.
public struct ContinuousDeploymentPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContinuousDeploymentPolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Enabled"].write(value.enabled)
        try writer["StagingDistributionDnsNames"].write(value.stagingDistributionDnsNames, writingClosure: CloudFrontClientTypes.StagingDistributionDnsNames.writingClosure(_:to:))
        try writer["TrafficConfig"].write(value.trafficConfig, writingClosure: CloudFrontClientTypes.TrafficConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContinuousDeploymentPolicyConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContinuousDeploymentPolicyConfig()
            value.stagingDistributionDnsNames = try reader["StagingDistributionDnsNames"].readIfPresent(readingClosure: CloudFrontClientTypes.StagingDistributionDnsNames.readingClosure)
            value.enabled = try reader["Enabled"].readIfPresent()
            value.trafficConfig = try reader["TrafficConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.TrafficConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains the configuration for a continuous deployment policy.
    public struct ContinuousDeploymentPolicyConfig: Swift.Equatable {
        /// A Boolean that indicates whether this continuous deployment policy is enabled (in effect). When this value is true, this policy is enabled and in effect. When this value is false, this policy is not enabled and has no effect.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The CloudFront domain name of the staging distribution. For example: d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var stagingDistributionDnsNames: CloudFrontClientTypes.StagingDistributionDnsNames?
        /// Contains the parameters for routing production traffic from your primary to staging distributions.
        public var trafficConfig: CloudFrontClientTypes.TrafficConfig?

        public init(
            enabled: Swift.Bool? = nil,
            stagingDistributionDnsNames: CloudFrontClientTypes.StagingDistributionDnsNames? = nil,
            trafficConfig: CloudFrontClientTypes.TrafficConfig? = nil
        )
        {
            self.enabled = enabled
            self.stagingDistributionDnsNames = stagingDistributionDnsNames
            self.trafficConfig = trafficConfig
        }
    }

}

extension ContinuousDeploymentPolicyInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<ContinuousDeploymentPolicyInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ContinuousDeploymentPolicyInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension ContinuousDeploymentPolicyInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ContinuousDeploymentPolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You cannot delete a continuous deployment policy that is associated with a primary distribution.
public struct ContinuousDeploymentPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ContinuousDeploymentPolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentPolicyList {

    static func writingClosure(_ value: CloudFrontClientTypes.ContinuousDeploymentPolicyList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicySummary.writingClosure(_:to:), memberNodeInfo: "ContinuousDeploymentPolicySummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContinuousDeploymentPolicyList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContinuousDeploymentPolicyList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicySummary.readingClosure, memberNodeInfo: "ContinuousDeploymentPolicySummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of continuous deployment policies.
    public struct ContinuousDeploymentPolicyList: Swift.Equatable {
        /// A list of continuous deployment policy items.
        public var items: [CloudFrontClientTypes.ContinuousDeploymentPolicySummary]?
        /// The maximum number of continuous deployment policies that were specified in your request.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Indicates the next page of continuous deployment policies. To get the next page of the list, use this value in the Marker field of your request.
        public var nextMarker: Swift.String?
        /// The total number of continuous deployment policies in your Amazon Web Services account, regardless of the MaxItems value.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ContinuousDeploymentPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContinuousDeploymentPolicySummary {

    static func writingClosure(_ value: CloudFrontClientTypes.ContinuousDeploymentPolicySummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContinuousDeploymentPolicy"].write(value.continuousDeploymentPolicy, writingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicy.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContinuousDeploymentPolicySummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContinuousDeploymentPolicySummary()
            value.continuousDeploymentPolicy = try reader["ContinuousDeploymentPolicy"].readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicy.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information about your continuous deployment policies.
    public struct ContinuousDeploymentPolicySummary: Swift.Equatable {
        /// The continuous deployment policy.
        /// This member is required.
        public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?

        public init(
            continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil
        )
        {
            self.continuousDeploymentPolicy = continuousDeploymentPolicy
        }
    }

}

extension CloudFrontClientTypes {
    public enum ContinuousDeploymentPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case singleheader
        case singleweight
        case sdkUnknown(Swift.String)

        public static var allCases: [ContinuousDeploymentPolicyType] {
            return [
                .singleheader,
                .singleweight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singleheader: return "SingleHeader"
            case .singleweight: return "SingleWeight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContinuousDeploymentPolicyType(rawValue: rawValue) ?? ContinuousDeploymentPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Header"].write(value.header)
        try writer["Value"].write(value.value)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig()
            value.header = try reader["Header"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// This configuration determines which HTTP requests are sent to the staging distribution. If the HTTP request contains a header and value that matches what you specify here, the request is sent to the staging distribution. Otherwise the request is sent to the primary distribution.
    public struct ContinuousDeploymentSingleHeaderConfig: Swift.Equatable {
        /// The request header name that you want CloudFront to send to your staging distribution. The header must contain the prefix aws-cf-cd-.
        /// This member is required.
        public var header: Swift.String?
        /// The request header value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            header: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.header = header
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["SessionStickinessConfig"].write(value.sessionStickinessConfig, writingClosure: CloudFrontClientTypes.SessionStickinessConfig.writingClosure(_:to:))
        try writer["Weight"].write(value.weight)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig()
            value.weight = try reader["Weight"].readIfPresent()
            value.sessionStickinessConfig = try reader["SessionStickinessConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.SessionStickinessConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains the percentage of traffic to send to a staging distribution.
    public struct ContinuousDeploymentSingleWeightConfig: Swift.Equatable {
        /// Session stickiness provides the ability to define multiple requests from a single viewer as a single session. This prevents the potentially inconsistent experience of sending some of a given user's requests to your staging distribution, while others are sent to your primary distribution. Define the session duration using TTL values.
        public var sessionStickinessConfig: CloudFrontClientTypes.SessionStickinessConfig?
        /// The percentage of traffic to send to a staging distribution, expressed as a decimal number between 0 and .15.
        /// This member is required.
        public var weight: Swift.Float?

        public init(
            sessionStickinessConfig: CloudFrontClientTypes.SessionStickinessConfig? = nil,
            weight: Swift.Float? = nil
        )
        {
            self.sessionStickinessConfig = sessionStickinessConfig
            self.weight = weight
        }
    }

}

extension CloudFrontClientTypes.CookieNames {

    static func writingClosure(_ value: CloudFrontClientTypes.CookieNames?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CookieNames, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CookieNames()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Name", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of cookie names.
    public struct CookieNames: Swift.Equatable {
        /// A list of cookie names.
        public var items: [Swift.String]?
        /// The number of cookie names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookiePreference {

    static func writingClosure(_ value: CloudFrontClientTypes.CookiePreference?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Forward"].write(value.forward)
        try writer["WhitelistedNames"].write(value.whitelistedNames, writingClosure: CloudFrontClientTypes.CookieNames.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CookiePreference, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CookiePreference()
            value.forward = try reader["Forward"].readIfPresent()
            value.whitelistedNames = try reader["WhitelistedNames"].readIfPresent(readingClosure: CloudFrontClientTypes.CookieNames.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use CookiesConfig in a cache policy. See CachePolicy. If you want to send cookies to the origin but not include them in the cache key, use CookiesConfig in an origin request policy. See OriginRequestPolicy. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [Caching Content Based on Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
    public struct CookiePreference: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Specifies which cookies to forward to the origin for this cache behavior: all, none, or the list of cookies specified in the WhitelistedNames complex type. Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an Amazon S3 origin, specify none for the Forward element.
        /// This member is required.
        public var forward: CloudFrontClientTypes.ItemSelection?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Required if you specify whitelist for the value of Forward. A complex type that specifies how many different cookies you want CloudFront to forward to the origin for this cache behavior and, if you want to forward selected cookies, the names of those cookies. If you specify all or none for the value of Forward, omit WhitelistedNames. If you change the value of Forward from whitelist to all or none and you don't delete the WhitelistedNames element and its child elements, CloudFront deletes them automatically. For the current limit on the number of cookie names that you can whitelist for each cache behavior, see [ CloudFront Limits](https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront) in the Amazon Web Services General Reference.
        public var whitelistedNames: CloudFrontClientTypes.CookieNames?

        public init(
            forward: CloudFrontClientTypes.ItemSelection? = nil,
            whitelistedNames: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.forward = forward
            self.whitelistedNames = whitelistedNames
        }
    }

}

extension CopyDistributionInput {
    static func writingClosure(_ value: CopyDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Enabled"].write(value.enabled)
    }
}

extension CopyDistributionInput {

    static func headerProvider(_ value: CopyDistributionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let staging = value.staging {
            items.add(Header(name: "Staging", value: Swift.String(staging)))
        }
        return items
    }
}

extension CopyDistributionInput {

    static func urlPathProvider(_ value: CopyDistributionInput) -> Swift.String? {
        guard let primaryDistributionId = value.primaryDistributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(primaryDistributionId.urlPercentEncoding())/copy"
    }
}

public struct CopyDistributionInput: Swift.Equatable {
    /// A value that uniquely identifies a request to create a resource. This helps to prevent CloudFront from creating a duplicate resource if you accidentally resubmit an identical request.
    /// This member is required.
    public var callerReference: Swift.String?
    /// A Boolean flag to specify the state of the staging distribution when it's created. When you set this value to True, the staging distribution is enabled. When you set this value to False, the staging distribution is disabled. If you omit this field, the default value is True.
    public var enabled: Swift.Bool?
    /// The version identifier of the primary distribution whose configuration you are copying. This is the ETag value returned in the response to GetDistribution and GetDistributionConfig.
    public var ifMatch: Swift.String?
    /// The identifier of the primary distribution whose configuration you are copying. To get a distribution ID, use ListDistributions.
    /// This member is required.
    public var primaryDistributionId: Swift.String?
    /// The type of distribution that your primary distribution will be copied to. The only valid value is True, indicating that you are copying to a staging distribution.
    public var staging: Swift.Bool?

    public init(
        callerReference: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ifMatch: Swift.String? = nil,
        primaryDistributionId: Swift.String? = nil,
        staging: Swift.Bool? = nil
    )
    {
        self.callerReference = callerReference
        self.enabled = enabled
        self.ifMatch = ifMatch
        self.primaryDistributionId = primaryDistributionId
        self.staging = staging
    }
}

extension CopyDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CopyDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CopyDistributionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.distribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Distribution.readingClosure)
            return value
        }
    }
}

public struct CopyDistributionOutput: Swift.Equatable {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The version identifier for the current version of the staging distribution.
    public var eTag: Swift.String?
    /// The URL of the staging distribution.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

enum CopyDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "DistributionAlreadyExists": return try await DistributionAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidErrorCode": return try await InvalidErrorCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidForwardCookies": return try await InvalidForwardCookies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLocationCode": return try await InvalidLocationCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOrigin": return try await InvalidOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidProtocolSettings": return try await InvalidProtocolSettings.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRelativePath": return try await InvalidRelativePath.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidResponseCode": return try await InvalidResponseCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTTLOrder": return try await InvalidTTLOrder.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidViewerCertificate": return try await InvalidViewerCertificate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidWebACLId": return try await InvalidWebACLId.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOrigin": return try await NoSuchOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCertificates": return try await TooManyCertificates.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributions": return try await TooManyDistributions.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOrigins": return try await TooManyOrigins.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateCachePolicyInput {
    static func writingClosure(_ value: CreateCachePolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CachePolicyConfig"].write(value.cachePolicyConfig, writingClosure: CloudFrontClientTypes.CachePolicyConfig.writingClosure(_:to:))
    }
}

extension CreateCachePolicyInput {

    static func urlPathProvider(_ value: CreateCachePolicyInput) -> Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

public struct CreateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
    }
}

extension CreateCachePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateCachePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateCachePolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.cachePolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicy.readingClosure)
            return value
        }
    }
}

public struct CreateCachePolicyOutput: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the cache policy just created.
    public var location: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
        self.location = location
    }
}

enum CreateCachePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CachePolicyAlreadyExists": return try await CachePolicyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCachePolicies": return try await TooManyCachePolicies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookiesInCachePolicy": return try await TooManyCookiesInCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInCachePolicy": return try await TooManyHeadersInCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringsInCachePolicy": return try await TooManyQueryStringsInCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateCloudFrontOriginAccessIdentityInput {
    static func writingClosure(_ value: CreateCloudFrontOriginAccessIdentityInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CloudFrontOriginAccessIdentityConfig"].write(value.cloudFrontOriginAccessIdentityConfig, writingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.writingClosure(_:to:))
    }
}

extension CreateCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: CreateCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

/// The request to create a new origin access identity (OAI). An origin access identity is a special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or just some of your Amazon S3 content. For more information, see [ Restricting Access to Amazon S3 Content by Using an Origin Access Identity](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
public struct CreateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The current configuration information for the identity.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
    }
}

extension CreateCloudFrontOriginAccessIdentityOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateCloudFrontOriginAccessIdentityOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateCloudFrontOriginAccessIdentityOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.cloudFrontOriginAccessIdentity = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentity.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateCloudFrontOriginAccessIdentityOutput: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new origin access identity just created.
    public var location: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
        self.location = location
    }
}

enum CreateCloudFrontOriginAccessIdentityOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "CloudFrontOriginAccessIdentityAlreadyExists": return try await CloudFrontOriginAccessIdentityAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCloudFrontOriginAccessIdentities": return try await TooManyCloudFrontOriginAccessIdentities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateContinuousDeploymentPolicyInput {
    static func writingClosure(_ value: CreateContinuousDeploymentPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContinuousDeploymentPolicyConfig"].write(value.continuousDeploymentPolicyConfig, writingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.writingClosure(_:to:))
    }
}

extension CreateContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: CreateContinuousDeploymentPolicyInput) -> Swift.String? {
        return "/2020-05-31/continuous-deployment-policy"
    }
}

public struct CreateContinuousDeploymentPolicyInput: Swift.Equatable {
    /// Contains the configuration for a continuous deployment policy.
    /// This member is required.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
    }
}

extension CreateContinuousDeploymentPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateContinuousDeploymentPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateContinuousDeploymentPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.continuousDeploymentPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicy.readingClosure)
            return value
        }
    }
}

public struct CreateContinuousDeploymentPolicyOutput: Swift.Equatable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?
    /// The location of the continuous deployment policy.
    public var location: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
        self.location = location
    }
}

enum CreateContinuousDeploymentPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ContinuousDeploymentPolicyAlreadyExists": return try await ContinuousDeploymentPolicyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "StagingDistributionInUse": return try await StagingDistributionInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyContinuousDeploymentPolicies": return try await TooManyContinuousDeploymentPolicies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateDistributionInput {
    static func writingClosure(_ value: CreateDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DistributionConfig"].write(value.distributionConfig, writingClosure: CloudFrontClientTypes.DistributionConfig.writingClosure(_:to:))
    }
}

extension CreateDistributionInput {

    static func urlPathProvider(_ value: CreateDistributionInput) -> Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to create a new distribution.
public struct CreateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil
    )
    {
        self.distributionConfig = distributionConfig
    }
}

extension CreateDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateDistributionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.distribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Distribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

enum CreateDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "DistributionAlreadyExists": return try await DistributionAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalOriginAccessConfiguration": return try await IllegalOriginAccessConfiguration.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDomainNameForOriginAccessControl": return try await InvalidDomainNameForOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidErrorCode": return try await InvalidErrorCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidForwardCookies": return try await InvalidForwardCookies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLocationCode": return try await InvalidLocationCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOrigin": return try await InvalidOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidProtocolSettings": return try await InvalidProtocolSettings.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRelativePath": return try await InvalidRelativePath.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidResponseCode": return try await InvalidResponseCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTTLOrder": return try await InvalidTTLOrder.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidViewerCertificate": return try await InvalidViewerCertificate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidWebACLId": return try await InvalidWebACLId.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOrigin": return try await NoSuchOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCertificates": return try await TooManyCertificates.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributions": return try await TooManyDistributions.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOrigins": return try await TooManyOrigins.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateDistributionWithTagsInput {
    static func writingClosure(_ value: CreateDistributionWithTagsInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DistributionConfigWithTags"].write(value.distributionConfigWithTags, writingClosure: CloudFrontClientTypes.DistributionConfigWithTags.writingClosure(_:to:))
    }
}

extension CreateDistributionWithTagsInput {

    static func queryItemProvider(_ value: CreateDistributionWithTagsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "WithTags", value: nil))
        return items
    }
}

extension CreateDistributionWithTagsInput {

    static func urlPathProvider(_ value: CreateDistributionWithTagsInput) -> Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to create a new distribution with tags.
public struct CreateDistributionWithTagsInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?

    public init(
        distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags? = nil
    )
    {
        self.distributionConfigWithTags = distributionConfigWithTags
    }
}

extension CreateDistributionWithTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateDistributionWithTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateDistributionWithTagsOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.distribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Distribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionWithTagsOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

enum CreateDistributionWithTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "DistributionAlreadyExists": return try await DistributionAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalOriginAccessConfiguration": return try await IllegalOriginAccessConfiguration.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDomainNameForOriginAccessControl": return try await InvalidDomainNameForOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidErrorCode": return try await InvalidErrorCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidForwardCookies": return try await InvalidForwardCookies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLocationCode": return try await InvalidLocationCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOrigin": return try await InvalidOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidProtocolSettings": return try await InvalidProtocolSettings.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRelativePath": return try await InvalidRelativePath.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidResponseCode": return try await InvalidResponseCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTagging": return try await InvalidTagging.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTTLOrder": return try await InvalidTTLOrder.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidViewerCertificate": return try await InvalidViewerCertificate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidWebACLId": return try await InvalidWebACLId.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOrigin": return try await NoSuchOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCertificates": return try await TooManyCertificates.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributions": return try await TooManyDistributions.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOrigins": return try await TooManyOrigins.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateFieldLevelEncryptionConfigInput {
    static func writingClosure(_ value: CreateFieldLevelEncryptionConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FieldLevelEncryptionConfig"].write(value.fieldLevelEncryptionConfig, writingClosure: CloudFrontClientTypes.FieldLevelEncryptionConfig.writingClosure(_:to:))
    }
}

extension CreateFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: CreateFieldLevelEncryptionConfigInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

public struct CreateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The request to create a new field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init(
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

extension CreateFieldLevelEncryptionConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateFieldLevelEncryptionConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateFieldLevelEncryptionConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.fieldLevelEncryption = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryption.readingClosure)
            return value
        }
    }
}

public struct CreateFieldLevelEncryptionConfigOutput: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
    /// The fully qualified URI of the new configuration resource just created.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
        self.location = location
    }
}

enum CreateFieldLevelEncryptionConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "FieldLevelEncryptionConfigAlreadyExists": return try await FieldLevelEncryptionConfigAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "QueryArgProfileEmpty": return try await QueryArgProfileEmpty.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionConfigs": return try await TooManyFieldLevelEncryptionConfigs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionContentTypeProfiles": return try await TooManyFieldLevelEncryptionContentTypeProfiles.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionQueryArgProfiles": return try await TooManyFieldLevelEncryptionQueryArgProfiles.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateFieldLevelEncryptionProfileInput {
    static func writingClosure(_ value: CreateFieldLevelEncryptionProfileInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FieldLevelEncryptionProfileConfig"].write(value.fieldLevelEncryptionProfileConfig, writingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.writingClosure(_:to:))
    }
}

extension CreateFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: CreateFieldLevelEncryptionProfileInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

public struct CreateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// The request to create a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init(
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

extension CreateFieldLevelEncryptionProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateFieldLevelEncryptionProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateFieldLevelEncryptionProfileOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.fieldLevelEncryptionProfile = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfile.readingClosure)
            return value
        }
    }
}

public struct CreateFieldLevelEncryptionProfileOutput: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
    /// The fully qualified URI of the new profile resource just created.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
        self.location = location
    }
}

enum CreateFieldLevelEncryptionProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "FieldLevelEncryptionProfileAlreadyExists": return try await FieldLevelEncryptionProfileAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "FieldLevelEncryptionProfileSizeExceeded": return try await FieldLevelEncryptionProfileSizeExceeded.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchPublicKey": return try await NoSuchPublicKey.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionEncryptionEntities": return try await TooManyFieldLevelEncryptionEncryptionEntities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionFieldPatterns": return try await TooManyFieldLevelEncryptionFieldPatterns.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionProfiles": return try await TooManyFieldLevelEncryptionProfiles.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionInput(functionConfig: \(Swift.String(describing: functionConfig)), name: \(Swift.String(describing: name)), functionCode: \"CONTENT_REDACTED\")"}
}

extension CreateFunctionInput {
    static func writingClosure(_ value: CreateFunctionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FunctionCode"].write(value.functionCode)
        try writer["FunctionConfig"].write(value.functionConfig, writingClosure: CloudFrontClientTypes.FunctionConfig.writingClosure(_:to:))
        try writer["Name"].write(value.name)
    }
}

extension CreateFunctionInput {

    static func urlPathProvider(_ value: CreateFunctionInput) -> Swift.String? {
        return "/2020-05-31/function"
    }
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function, including an optional comment and the function's runtime.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// A name to identify the function.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.name = name
    }
}

extension CreateFunctionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateFunctionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateFunctionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.functionSummary = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FunctionSummary.readingClosure)
            return value
        }
    }
}

public struct CreateFunctionOutput: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?
    /// The URL of the CloudFront function. Use the URL to manage the function with the CloudFront API.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
        self.location = location
    }
}

enum CreateFunctionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "FunctionAlreadyExists": return try await FunctionAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "FunctionSizeLimitExceeded": return try await FunctionSizeLimitExceeded.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFunctions": return try await TooManyFunctions.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateInvalidationInput {
    static func writingClosure(_ value: CreateInvalidationInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["InvalidationBatch"].write(value.invalidationBatch, writingClosure: CloudFrontClientTypes.InvalidationBatch.writingClosure(_:to:))
    }
}

extension CreateInvalidationInput {

    static func urlPathProvider(_ value: CreateInvalidationInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

/// The request to create an invalidation.
public struct CreateInvalidationInput: Swift.Equatable {
    /// The distribution's id.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The batch information for the invalidation.
    /// This member is required.
    public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?

    public init(
        distributionId: Swift.String? = nil,
        invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil
    )
    {
        self.distributionId = distributionId
        self.invalidationBatch = invalidationBatch
    }
}

extension CreateInvalidationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateInvalidationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateInvalidationOutput()
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.invalidation = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Invalidation.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateInvalidationOutput: Swift.Equatable {
    /// The invalidation's information.
    public var invalidation: CloudFrontClientTypes.Invalidation?
    /// The fully qualified URI of the distribution and invalidation batch request, including the Invalidation ID.
    public var location: Swift.String?

    public init(
        invalidation: CloudFrontClientTypes.Invalidation? = nil,
        location: Swift.String? = nil
    )
    {
        self.invalidation = invalidation
        self.location = location
    }
}

enum CreateInvalidationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "BatchTooLarge": return try await BatchTooLarge.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyInvalidationsInProgress": return try await TooManyInvalidationsInProgress.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateKeyGroupInput {
    static func writingClosure(_ value: CreateKeyGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KeyGroupConfig"].write(value.keyGroupConfig, writingClosure: CloudFrontClientTypes.KeyGroupConfig.writingClosure(_:to:))
    }
}

extension CreateKeyGroupInput {

    static func urlPathProvider(_ value: CreateKeyGroupInput) -> Swift.String? {
        return "/2020-05-31/key-group"
    }
}

public struct CreateKeyGroupInput: Swift.Equatable {
    /// A key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.keyGroupConfig = keyGroupConfig
    }
}

extension CreateKeyGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateKeyGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateKeyGroupOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.keyGroup = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyGroup.readingClosure)
            return value
        }
    }
}

public struct CreateKeyGroupOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just created.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?
    /// The URL of the key group.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
        self.location = location
    }
}

enum CreateKeyGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "KeyGroupAlreadyExists": return try await KeyGroupAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyKeyGroups": return try await TooManyKeyGroups.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyPublicKeysInKeyGroup": return try await TooManyPublicKeysInKeyGroup.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateKeyValueStoreInput {
    static func writingClosure(_ value: CreateKeyValueStoreInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["ImportSource"].write(value.importSource, writingClosure: CloudFrontClientTypes.ImportSource.writingClosure(_:to:))
        try writer["Name"].write(value.name)
    }
}

extension CreateKeyValueStoreInput {

    static func urlPathProvider(_ value: CreateKeyValueStoreInput) -> Swift.String? {
        return "/2020-05-31/key-value-store"
    }
}

public struct CreateKeyValueStoreInput: Swift.Equatable {
    /// The comment of the Key Value Store.
    public var comment: Swift.String?
    /// The S3 bucket that provides the source for the import. The source must be in a valid JSON format.
    public var importSource: CloudFrontClientTypes.ImportSource?
    /// The name of the Key Value Store. The maximum length of the name is 32 characters.
    /// This member is required.
    public var name: Swift.String?

    public init(
        comment: Swift.String? = nil,
        importSource: CloudFrontClientTypes.ImportSource? = nil,
        name: Swift.String? = nil
    )
    {
        self.comment = comment
        self.importSource = importSource
        self.name = name
    }
}

extension CreateKeyValueStoreOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateKeyValueStoreOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateKeyValueStoreOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.keyValueStore = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyValueStore.readingClosure)
            return value
        }
    }
}

public struct CreateKeyValueStoreOutput: Swift.Equatable {
    /// The ETag in the resulting Key Value Store.
    public var eTag: Swift.String?
    /// The resulting Key Value Store.
    public var keyValueStore: CloudFrontClientTypes.KeyValueStore?
    /// The location of the resulting Key Value Store.
    public var location: Swift.String?

    public init(
        eTag: Swift.String? = nil,
        keyValueStore: CloudFrontClientTypes.KeyValueStore? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyValueStore = keyValueStore
        self.location = location
    }
}

enum CreateKeyValueStoreOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "EntityAlreadyExists": return try await EntityAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "EntityLimitExceeded": return try await EntityLimitExceeded.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "EntitySizeLimitExceeded": return try await EntitySizeLimitExceeded.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateMonitoringSubscriptionInput {
    static func writingClosure(_ value: CreateMonitoringSubscriptionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["MonitoringSubscription"].write(value.monitoringSubscription, writingClosure: CloudFrontClientTypes.MonitoringSubscription.writingClosure(_:to:))
    }
}

extension CreateMonitoringSubscriptionInput {

    static func urlPathProvider(_ value: CreateMonitoringSubscriptionInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct CreateMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are enabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    /// This member is required.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        distributionId: Swift.String? = nil,
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.distributionId = distributionId
        self.monitoringSubscription = monitoringSubscription
    }
}

extension CreateMonitoringSubscriptionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateMonitoringSubscriptionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateMonitoringSubscriptionOutput()
            value.monitoringSubscription = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.MonitoringSubscription.readingClosure)
            return value
        }
    }
}

public struct CreateMonitoringSubscriptionOutput: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

enum CreateMonitoringSubscriptionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MonitoringSubscriptionAlreadyExists": return try await MonitoringSubscriptionAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateOriginAccessControlInput {
    static func writingClosure(_ value: CreateOriginAccessControlInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["OriginAccessControlConfig"].write(value.originAccessControlConfig, writingClosure: CloudFrontClientTypes.OriginAccessControlConfig.writingClosure(_:to:))
    }
}

extension CreateOriginAccessControlInput {

    static func urlPathProvider(_ value: CreateOriginAccessControlInput) -> Swift.String? {
        return "/2020-05-31/origin-access-control"
    }
}

public struct CreateOriginAccessControlInput: Swift.Equatable {
    /// Contains the origin access control.
    /// This member is required.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.originAccessControlConfig = originAccessControlConfig
    }
}

extension CreateOriginAccessControlOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateOriginAccessControlOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateOriginAccessControlOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.originAccessControl = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginAccessControl.readingClosure)
            return value
        }
    }
}

public struct CreateOriginAccessControlOutput: Swift.Equatable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// The URL of the origin access control.
    public var location: Swift.String?
    /// Contains an origin access control.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originAccessControl = originAccessControl
    }
}

enum CreateOriginAccessControlOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "OriginAccessControlAlreadyExists": return try await OriginAccessControlAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginAccessControls": return try await TooManyOriginAccessControls.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateOriginRequestPolicyInput {
    static func writingClosure(_ value: CreateOriginRequestPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["OriginRequestPolicyConfig"].write(value.originRequestPolicyConfig, writingClosure: CloudFrontClientTypes.OriginRequestPolicyConfig.writingClosure(_:to:))
    }
}

extension CreateOriginRequestPolicyInput {

    static func urlPathProvider(_ value: CreateOriginRequestPolicyInput) -> Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

public struct CreateOriginRequestPolicyInput: Swift.Equatable {
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

extension CreateOriginRequestPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateOriginRequestPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateOriginRequestPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.originRequestPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicy.readingClosure)
            return value
        }
    }
}

public struct CreateOriginRequestPolicyOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the origin request policy just created.
    public var location: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originRequestPolicy = originRequestPolicy
    }
}

enum CreateOriginRequestPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "OriginRequestPolicyAlreadyExists": return try await OriginRequestPolicyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookiesInOriginRequestPolicy": return try await TooManyCookiesInOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInOriginRequestPolicy": return try await TooManyHeadersInOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginRequestPolicies": return try await TooManyOriginRequestPolicies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringsInOriginRequestPolicy": return try await TooManyQueryStringsInOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreatePublicKeyInput {
    static func writingClosure(_ value: CreatePublicKeyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["PublicKeyConfig"].write(value.publicKeyConfig, writingClosure: CloudFrontClientTypes.PublicKeyConfig.writingClosure(_:to:))
    }
}

extension CreatePublicKeyInput {

    static func urlPathProvider(_ value: CreatePublicKeyInput) -> Swift.String? {
        return "/2020-05-31/public-key"
    }
}

public struct CreatePublicKeyInput: Swift.Equatable {
    /// A CloudFront public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.publicKeyConfig = publicKeyConfig
    }
}

extension CreatePublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreatePublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreatePublicKeyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.publicKey = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.PublicKey.readingClosure)
            return value
        }
    }
}

public struct CreatePublicKeyOutput: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The URL of the public key.
    public var location: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.publicKey = publicKey
    }
}

enum CreatePublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PublicKeyAlreadyExists": return try await PublicKeyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyPublicKeys": return try await TooManyPublicKeys.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateRealtimeLogConfigInput {
    static func writingClosure(_ value: CreateRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["EndPoints"].writeList(value.endPoints, memberWritingClosure: CloudFrontClientTypes.EndPoint.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Fields"].writeList(value.fields, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Field", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["SamplingRate"].write(value.samplingRate)
    }
}

extension CreateRealtimeLogConfigInput {

    static func urlPathProvider(_ value: CreateRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct CreateRealtimeLogConfigInput: Swift.Equatable {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    /// This member is required.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var fields: [Swift.String]?
    /// A unique name to identify this real-time log configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    /// This member is required.
    public var samplingRate: Swift.Int?

    public init(
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

extension CreateRealtimeLogConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateRealtimeLogConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateRealtimeLogConfigOutput()
            value.realtimeLogConfig = try reader["RealtimeLogConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.RealtimeLogConfig.readingClosure)
            return value
        }
    }
}

public struct CreateRealtimeLogConfigOutput: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

enum CreateRealtimeLogConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "RealtimeLogConfigAlreadyExists": return try await RealtimeLogConfigAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRealtimeLogConfigs": return try await TooManyRealtimeLogConfigs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateResponseHeadersPolicyInput {
    static func writingClosure(_ value: CreateResponseHeadersPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ResponseHeadersPolicyConfig"].write(value.responseHeadersPolicyConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyConfig.writingClosure(_:to:))
    }
}

extension CreateResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: CreateResponseHeadersPolicyInput) -> Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

public struct CreateResponseHeadersPolicyInput: Swift.Equatable {
    /// Contains metadata about the response headers policy, and a set of configurations that specify the HTTP headers.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

extension CreateResponseHeadersPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateResponseHeadersPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateResponseHeadersPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.responseHeadersPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicy.readingClosure)
            return value
        }
    }
}

public struct CreateResponseHeadersPolicyOutput: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// The URL of the response headers policy.
    public var location: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

enum CreateResponseHeadersPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ResponseHeadersPolicyAlreadyExists": return try await ResponseHeadersPolicyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooLongCSPInResponseHeadersPolicy": return try await TooLongCSPInResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCustomHeadersInResponseHeadersPolicy": return try await TooManyCustomHeadersInResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRemoveHeadersInResponseHeadersPolicy": return try await TooManyRemoveHeadersInResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyResponseHeadersPolicies": return try await TooManyResponseHeadersPolicies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateStreamingDistributionInput {
    static func writingClosure(_ value: CreateStreamingDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StreamingDistributionConfig"].write(value.streamingDistributionConfig, writingClosure: CloudFrontClientTypes.StreamingDistributionConfig.writingClosure(_:to:))
    }
}

extension CreateStreamingDistributionInput {

    static func urlPathProvider(_ value: CreateStreamingDistributionInput) -> Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to create a new streaming distribution.
public struct CreateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

extension CreateStreamingDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateStreamingDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateStreamingDistributionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.streamingDistribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionOutput: Swift.Equatable {
    /// The current version of the streaming distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

enum CreateStreamingDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOrigin": return try await InvalidOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "StreamingDistributionAlreadyExists": return try await StreamingDistributionAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyStreamingDistributionCNAMEs": return try await TooManyStreamingDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyStreamingDistributions": return try await TooManyStreamingDistributions.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CreateStreamingDistributionWithTagsInput {
    static func writingClosure(_ value: CreateStreamingDistributionWithTagsInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StreamingDistributionConfigWithTags"].write(value.streamingDistributionConfigWithTags, writingClosure: CloudFrontClientTypes.StreamingDistributionConfigWithTags.writingClosure(_:to:))
    }
}

extension CreateStreamingDistributionWithTagsInput {

    static func queryItemProvider(_ value: CreateStreamingDistributionWithTagsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "WithTags", value: nil))
        return items
    }
}

extension CreateStreamingDistributionWithTagsInput {

    static func urlPathProvider(_ value: CreateStreamingDistributionWithTagsInput) -> Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to create a new streaming distribution with tags.
public struct CreateStreamingDistributionWithTagsInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?

    public init(
        streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags? = nil
    )
    {
        self.streamingDistributionConfigWithTags = streamingDistributionConfigWithTags
    }
}

extension CreateStreamingDistributionWithTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateStreamingDistributionWithTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = CreateStreamingDistributionWithTagsOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
                value.location = locationHeaderValue
            }
            value.streamingDistribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionWithTagsOutput: Swift.Equatable {
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

enum CreateStreamingDistributionWithTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOrigin": return try await InvalidOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTagging": return try await InvalidTagging.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "StreamingDistributionAlreadyExists": return try await StreamingDistributionAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyStreamingDistributionCNAMEs": return try await TooManyStreamingDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyStreamingDistributions": return try await TooManyStreamingDistributions.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.CustomErrorResponse {

    static func writingClosure(_ value: CloudFrontClientTypes.CustomErrorResponse?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ErrorCachingMinTTL"].write(value.errorCachingMinTTL)
        try writer["ErrorCode"].write(value.errorCode)
        try writer["ResponseCode"].write(value.responseCode)
        try writer["ResponsePagePath"].write(value.responsePagePath)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CustomErrorResponse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CustomErrorResponse()
            value.errorCode = try reader["ErrorCode"].readIfPresent()
            value.responsePagePath = try reader["ResponsePagePath"].readIfPresent()
            value.responseCode = try reader["ResponseCode"].readIfPresent()
            value.errorCachingMinTTL = try reader["ErrorCachingMinTTL"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponse: Swift.Equatable {
        /// The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status code specified in ErrorCode. When this time period has elapsed, CloudFront queries your origin to see whether the problem that caused the error has been resolved and the requested object is now available. For more information, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var errorCachingMinTTL: Swift.Int?
        /// The HTTP status code for which you want to specify a custom error page and/or a caching duration.
        /// This member is required.
        public var errorCode: Swift.Int?
        /// The HTTP status code that you want CloudFront to return to the viewer along with the custom error page. There are a variety of reasons that you might want CloudFront to return a status code different from the status code that your origin returned to CloudFront, for example:
        ///
        /// * Some Internet devices (some firewalls and corporate proxies, for example) intercept HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you substitute 200, the response typically won't be intercepted.
        ///
        /// * If you don't care about distinguishing among different client errors or server errors, you can specify 400 or 500 as the ResponseCode for all 4xx or 5xx errors.
        ///
        /// * You might want to return a 200 status code (OK) and static website so your customers don't know that your website is down.
        ///
        ///
        /// If you specify a value for ResponseCode, you must also specify a value for ResponsePagePath.
        public var responseCode: Swift.String?
        /// The path to the custom error page that you want CloudFront to return to a viewer when your origin returns the HTTP status code specified by ErrorCode, for example, /4xx-errors/403-forbidden.html. If you want to store your objects and your custom error pages in different locations, your distribution must include a cache behavior for which the following is true:
        ///
        /// * The value of PathPattern matches the path to your custom error messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3 bucket in a directory named /4xx-errors. Your distribution must include a cache behavior for which the path pattern routes requests for your custom error pages to that location, for example, /4xx-errors/*.
        ///
        /// * The value of TargetOriginId specifies the value of the ID element for the origin that contains your custom error pages.
        ///
        ///
        /// If you specify a value for ResponsePagePath, you must also specify a value for ResponseCode. We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the files that you want to return to viewers because the origin server is unavailable.
        public var responsePagePath: Swift.String?

        public init(
            errorCachingMinTTL: Swift.Int? = nil,
            errorCode: Swift.Int? = nil,
            responseCode: Swift.String? = nil,
            responsePagePath: Swift.String? = nil
        )
        {
            self.errorCachingMinTTL = errorCachingMinTTL
            self.errorCode = errorCode
            self.responseCode = responseCode
            self.responsePagePath = responsePagePath
        }
    }

}

extension CloudFrontClientTypes.CustomErrorResponses {

    static func writingClosure(_ value: CloudFrontClientTypes.CustomErrorResponses?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.CustomErrorResponse.writingClosure(_:to:), memberNodeInfo: "CustomErrorResponse", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CustomErrorResponses, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CustomErrorResponses()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.CustomErrorResponse.readingClosure, memberNodeInfo: "CustomErrorResponse", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponses: Swift.Equatable {
        /// A complex type that contains a CustomErrorResponse element for each HTTP status code for which you want to specify a custom error page and/or a caching duration.
        public var items: [CloudFrontClientTypes.CustomErrorResponse]?
        /// The number of HTTP status codes for which you want to specify a custom error page and/or a caching duration. If Quantity is 0, you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.CustomErrorResponse]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomHeaders {

    static func writingClosure(_ value: CloudFrontClientTypes.CustomHeaders?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginCustomHeader.writingClosure(_:to:), memberNodeInfo: "OriginCustomHeader", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CustomHeaders, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CustomHeaders()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginCustomHeader.readingClosure, memberNodeInfo: "OriginCustomHeader", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains the list of Custom Headers for each origin.
    public struct CustomHeaders: Swift.Equatable {
        /// Optional: A list that contains one OriginCustomHeader element for each custom header that you want CloudFront to forward to the origin. If Quantity is 0, omit Items.
        public var items: [CloudFrontClientTypes.OriginCustomHeader]?
        /// The number of custom headers, if any, for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomOriginConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.CustomOriginConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["HTTPPort"].write(value.httpPort)
        try writer["HTTPSPort"].write(value.httpsPort)
        try writer["OriginKeepaliveTimeout"].write(value.originKeepaliveTimeout)
        try writer["OriginProtocolPolicy"].write(value.originProtocolPolicy)
        try writer["OriginReadTimeout"].write(value.originReadTimeout)
        try writer["OriginSslProtocols"].write(value.originSslProtocols, writingClosure: CloudFrontClientTypes.OriginSslProtocols.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.CustomOriginConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.CustomOriginConfig()
            value.httpPort = try reader["HTTPPort"].readIfPresent()
            value.httpsPort = try reader["HTTPSPort"].readIfPresent()
            value.originProtocolPolicy = try reader["OriginProtocolPolicy"].readIfPresent()
            value.originSslProtocols = try reader["OriginSslProtocols"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginSslProtocols.readingClosure)
            value.originReadTimeout = try reader["OriginReadTimeout"].readIfPresent()
            value.originKeepaliveTimeout = try reader["OriginKeepaliveTimeout"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) is a custom origin.
    public struct CustomOriginConfig: Swift.Equatable {
        /// The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin listens on.
        /// This member is required.
        public var httpPort: Swift.Int?
        /// The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the origin listens on.
        /// This member is required.
        public var httpsPort: Swift.Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 5 seconds. For more information, see [Origin Keep-alive Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout) in the Amazon CloudFront Developer Guide.
        public var originKeepaliveTimeout: Swift.Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values are:
        ///
        /// * http-only – CloudFront always uses HTTP to connect to the origin.
        ///
        /// * match-viewer – CloudFront connects to the origin using the same protocol that the viewer used to connect to CloudFront.
        ///
        /// * https-only – CloudFront always uses HTTPS to connect to the origin.
        /// This member is required.
        public var originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the origin response timeout. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 30 seconds. For more information, see [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout) in the Amazon CloudFront Developer Guide.
        public var originReadTimeout: Swift.Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. Valid values include SSLv3, TLSv1, TLSv1.1, and TLSv1.2. For more information, see [Minimum Origin SSL Protocol](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols) in the Amazon CloudFront Developer Guide.
        public var originSslProtocols: CloudFrontClientTypes.OriginSslProtocols?

        public init(
            httpPort: Swift.Int? = nil,
            httpsPort: Swift.Int? = nil,
            originKeepaliveTimeout: Swift.Int? = nil,
            originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy? = nil,
            originReadTimeout: Swift.Int? = nil,
            originSslProtocols: CloudFrontClientTypes.OriginSslProtocols? = nil
        )
        {
            self.httpPort = httpPort
            self.httpsPort = httpsPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }

}

extension CloudFrontClientTypes.DefaultCacheBehavior {

    static func writingClosure(_ value: CloudFrontClientTypes.DefaultCacheBehavior?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AllowedMethods"].write(value.allowedMethods, writingClosure: CloudFrontClientTypes.AllowedMethods.writingClosure(_:to:))
        try writer["CachePolicyId"].write(value.cachePolicyId)
        try writer["Compress"].write(value.compress)
        try writer["DefaultTTL"].write(value.defaultTTL)
        try writer["FieldLevelEncryptionId"].write(value.fieldLevelEncryptionId)
        try writer["ForwardedValues"].write(value.forwardedValues, writingClosure: CloudFrontClientTypes.ForwardedValues.writingClosure(_:to:))
        try writer["FunctionAssociations"].write(value.functionAssociations, writingClosure: CloudFrontClientTypes.FunctionAssociations.writingClosure(_:to:))
        try writer["LambdaFunctionAssociations"].write(value.lambdaFunctionAssociations, writingClosure: CloudFrontClientTypes.LambdaFunctionAssociations.writingClosure(_:to:))
        try writer["MaxTTL"].write(value.maxTTL)
        try writer["MinTTL"].write(value.minTTL)
        try writer["OriginRequestPolicyId"].write(value.originRequestPolicyId)
        try writer["RealtimeLogConfigArn"].write(value.realtimeLogConfigArn)
        try writer["ResponseHeadersPolicyId"].write(value.responseHeadersPolicyId)
        try writer["SmoothStreaming"].write(value.smoothStreaming)
        try writer["TargetOriginId"].write(value.targetOriginId)
        try writer["TrustedKeyGroups"].write(value.trustedKeyGroups, writingClosure: CloudFrontClientTypes.TrustedKeyGroups.writingClosure(_:to:))
        try writer["TrustedSigners"].write(value.trustedSigners, writingClosure: CloudFrontClientTypes.TrustedSigners.writingClosure(_:to:))
        try writer["ViewerProtocolPolicy"].write(value.viewerProtocolPolicy)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.DefaultCacheBehavior, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.DefaultCacheBehavior()
            value.targetOriginId = try reader["TargetOriginId"].readIfPresent()
            value.trustedSigners = try reader["TrustedSigners"].readIfPresent(readingClosure: CloudFrontClientTypes.TrustedSigners.readingClosure)
            value.trustedKeyGroups = try reader["TrustedKeyGroups"].readIfPresent(readingClosure: CloudFrontClientTypes.TrustedKeyGroups.readingClosure)
            value.viewerProtocolPolicy = try reader["ViewerProtocolPolicy"].readIfPresent()
            value.allowedMethods = try reader["AllowedMethods"].readIfPresent(readingClosure: CloudFrontClientTypes.AllowedMethods.readingClosure)
            value.smoothStreaming = try reader["SmoothStreaming"].readIfPresent()
            value.compress = try reader["Compress"].readIfPresent()
            value.lambdaFunctionAssociations = try reader["LambdaFunctionAssociations"].readIfPresent(readingClosure: CloudFrontClientTypes.LambdaFunctionAssociations.readingClosure)
            value.functionAssociations = try reader["FunctionAssociations"].readIfPresent(readingClosure: CloudFrontClientTypes.FunctionAssociations.readingClosure)
            value.fieldLevelEncryptionId = try reader["FieldLevelEncryptionId"].readIfPresent()
            value.realtimeLogConfigArn = try reader["RealtimeLogConfigArn"].readIfPresent()
            value.cachePolicyId = try reader["CachePolicyId"].readIfPresent()
            value.originRequestPolicyId = try reader["OriginRequestPolicyId"].readIfPresent()
            value.responseHeadersPolicyId = try reader["ResponseHeadersPolicyId"].readIfPresent()
            value.forwardedValues = try reader["ForwardedValues"].readIfPresent(readingClosure: CloudFrontClientTypes.ForwardedValues.readingClosure)
            value.minTTL = try reader["MinTTL"].readIfPresent()
            value.defaultTTL = try reader["DefaultTTL"].readIfPresent()
            value.maxTTL = try reader["MaxTTL"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if request URLs don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
    public struct DefaultCacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to the default cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for the default cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to the default cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// The identifier for a response headers policy.
        public var responseHeadersPolicyId: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they use the default cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of Amazon Web Services account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in a trusted signer's Amazon Web Services account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init(
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            responseHeadersPolicyId: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.responseHeadersPolicyId = responseHeadersPolicyId
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension DeleteCachePolicyInput {

    static func headerProvider(_ value: DeleteCachePolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteCachePolicyInput {

    static func urlPathProvider(_ value: DeleteCachePolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy that you are deleting. To get the identifier, you can use ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are deleting. The version is the cache policy's ETag value, which you can get using ListCachePolicies, GetCachePolicy, or GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteCachePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteCachePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteCachePolicyOutput()
        }
    }
}

public struct DeleteCachePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCachePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CachePolicyInUse": return try await CachePolicyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalDelete": return try await IllegalDelete.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput {

    static func headerProvider(_ value: DeleteCloudFrontOriginAccessIdentityInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: DeleteCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

/// Deletes a origin access identity.
public struct DeleteCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The origin access identity's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header you received from a previous GET or PUT request. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteCloudFrontOriginAccessIdentityOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteCloudFrontOriginAccessIdentityOutput()
        }
    }
}

public struct DeleteCloudFrontOriginAccessIdentityOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCloudFrontOriginAccessIdentityOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CloudFrontOriginAccessIdentityInUse": return try await CloudFrontOriginAccessIdentityInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteContinuousDeploymentPolicyInput {

    static func headerProvider(_ value: DeleteContinuousDeploymentPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: DeleteContinuousDeploymentPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteContinuousDeploymentPolicyInput: Swift.Equatable {
    /// The identifier of the continuous deployment policy that you are deleting.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the continuous deployment policy that you are deleting.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteContinuousDeploymentPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteContinuousDeploymentPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteContinuousDeploymentPolicyOutput()
        }
    }
}

public struct DeleteContinuousDeploymentPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContinuousDeploymentPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteDistributionInput {

    static func headerProvider(_ value: DeleteDistributionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteDistributionInput {

    static func urlPathProvider(_ value: DeleteDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

/// This action deletes a web distribution. To delete a web distribution using the CloudFront API, perform the following steps. To delete a web distribution using the CloudFront API:
///
/// * Disable the web distribution
///
/// * Submit a GET Distribution Config request to get the current configuration and the Etag header for the distribution.
///
/// * Update the XML document that was returned in the response to your GET Distribution Config request to change the value of Enabled to false.
///
/// * Submit a PUT Distribution Config request to update the configuration for your distribution. In the request body, include the XML document that you updated in Step 3. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 2.
///
/// * Review the response to the PUT Distribution Config request to confirm that the distribution was successfully disabled.
///
/// * Submit a GET Distribution request to confirm that your changes have propagated. When propagation is complete, the value of Status is Deployed.
///
/// * Submit a DELETE Distribution request. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 6.
///
/// * Review the response to your DELETE Distribution request to confirm that the distribution was successfully deleted.
///
///
/// For information about deleting a distribution using the CloudFront console, see [Deleting a Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html) in the Amazon CloudFront Developer Guide.
public struct DeleteDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteDistributionOutput()
        }
    }
}

public struct DeleteDistributionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "DistributionNotDisabled": return try await DistributionNotDisabled.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteFieldLevelEncryptionConfigInput {

    static func headerProvider(_ value: DeleteFieldLevelEncryptionConfigInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: DeleteFieldLevelEncryptionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The ID of the configuration you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteFieldLevelEncryptionConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteFieldLevelEncryptionConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteFieldLevelEncryptionConfigOutput()
        }
    }
}

public struct DeleteFieldLevelEncryptionConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFieldLevelEncryptionConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "FieldLevelEncryptionConfigInUse": return try await FieldLevelEncryptionConfigInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteFieldLevelEncryptionProfileInput {

    static func headerProvider(_ value: DeleteFieldLevelEncryptionProfileInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: DeleteFieldLevelEncryptionProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request the ID of the profile you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteFieldLevelEncryptionProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteFieldLevelEncryptionProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteFieldLevelEncryptionProfileOutput()
        }
    }
}

public struct DeleteFieldLevelEncryptionProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFieldLevelEncryptionProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "FieldLevelEncryptionProfileInUse": return try await FieldLevelEncryptionProfileInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteFunctionInput {

    static func headerProvider(_ value: DeleteFunctionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteFunctionInput {

    static func urlPathProvider(_ value: DeleteFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are deleting, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are deleting.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

extension DeleteFunctionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteFunctionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteFunctionOutput()
        }
    }
}

public struct DeleteFunctionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "FunctionInUse": return try await FunctionInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFunctionExists": return try await NoSuchFunctionExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteKeyGroupInput {

    static func headerProvider(_ value: DeleteKeyGroupInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteKeyGroupInput {

    static func urlPathProvider(_ value: DeleteKeyGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct DeleteKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are deleting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are deleting. The version is the key group's ETag value. To get the ETag, use GetKeyGroup or GetKeyGroupConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteKeyGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteKeyGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteKeyGroupOutput()
        }
    }
}

public struct DeleteKeyGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKeyGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ResourceInUse": return try await ResourceInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteKeyValueStoreInput {

    static func headerProvider(_ value: DeleteKeyValueStoreInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteKeyValueStoreInput {

    static func urlPathProvider(_ value: DeleteKeyValueStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/key-value-store/\(name.urlPercentEncoding())"
    }
}

public struct DeleteKeyValueStoreInput: Swift.Equatable {
    /// The Key Value Store to delete, if a match occurs.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the Key Value Store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

extension DeleteKeyValueStoreOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteKeyValueStoreOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteKeyValueStoreOutput()
        }
    }
}

public struct DeleteKeyValueStoreOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKeyValueStoreOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CannotDeleteEntityWhileInUse": return try await CannotDeleteEntityWhileInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "EntityNotFound": return try await EntityNotFound.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteMonitoringSubscriptionInput {

    static func urlPathProvider(_ value: DeleteMonitoringSubscriptionInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct DeleteMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are disabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init(
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

extension DeleteMonitoringSubscriptionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteMonitoringSubscriptionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteMonitoringSubscriptionOutput()
        }
    }
}

public struct DeleteMonitoringSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMonitoringSubscriptionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchMonitoringSubscription": return try await NoSuchMonitoringSubscription.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteOriginAccessControlInput {

    static func headerProvider(_ value: DeleteOriginAccessControlInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteOriginAccessControlInput {

    static func urlPathProvider(_ value: DeleteOriginAccessControlInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())"
    }
}

public struct DeleteOriginAccessControlInput: Swift.Equatable {
    /// The unique identifier of the origin access control that you are deleting.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the origin access control that you are deleting.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteOriginAccessControlOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteOriginAccessControlOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteOriginAccessControlOutput()
        }
    }
}

public struct DeleteOriginAccessControlOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOriginAccessControlOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "OriginAccessControlInUse": return try await OriginAccessControlInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteOriginRequestPolicyInput {

    static func headerProvider(_ value: DeleteOriginRequestPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteOriginRequestPolicyInput {

    static func urlPathProvider(_ value: DeleteOriginRequestPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are deleting. To get the identifier, you can use ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are deleting. The version is the origin request policy's ETag value, which you can get using ListOriginRequestPolicies, GetOriginRequestPolicy, or GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteOriginRequestPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteOriginRequestPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteOriginRequestPolicyOutput()
        }
    }
}

public struct DeleteOriginRequestPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOriginRequestPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalDelete": return try await IllegalDelete.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "OriginRequestPolicyInUse": return try await OriginRequestPolicyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeletePublicKeyInput {

    static func headerProvider(_ value: DeletePublicKeyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeletePublicKeyInput {

    static func urlPathProvider(_ value: DeletePublicKeyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

public struct DeletePublicKeyInput: Swift.Equatable {
    /// The ID of the public key you want to remove from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeletePublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeletePublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeletePublicKeyOutput()
        }
    }
}

public struct DeletePublicKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeletePublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchPublicKey": return try await NoSuchPublicKey.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PublicKeyInUse": return try await PublicKeyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteRealtimeLogConfigInput {
    static func writingClosure(_ value: DeleteRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["Name"].write(value.name)
    }
}

extension DeleteRealtimeLogConfigInput {

    static func urlPathProvider(_ value: DeleteRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/delete-realtime-log-config"
    }
}

public struct DeleteRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to delete.
    public var arn: Swift.String?
    /// The name of the real-time log configuration to delete.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension DeleteRealtimeLogConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteRealtimeLogConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteRealtimeLogConfigOutput()
        }
    }
}

public struct DeleteRealtimeLogConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRealtimeLogConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "RealtimeLogConfigInUse": return try await RealtimeLogConfigInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteResponseHeadersPolicyInput {

    static func headerProvider(_ value: DeleteResponseHeadersPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: DeleteResponseHeadersPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct DeleteResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy that you are deleting. To get the identifier, you can use ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are deleting. The version is the response headers policy's ETag value, which you can get using ListResponseHeadersPolicies, GetResponseHeadersPolicy, or GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteResponseHeadersPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteResponseHeadersPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteResponseHeadersPolicyOutput()
        }
    }
}

public struct DeleteResponseHeadersPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResponseHeadersPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalDelete": return try await IllegalDelete.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ResponseHeadersPolicyInUse": return try await ResponseHeadersPolicyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DeleteStreamingDistributionInput {

    static func headerProvider(_ value: DeleteStreamingDistributionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteStreamingDistributionInput {

    static func urlPathProvider(_ value: DeleteStreamingDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to delete a streaming distribution.
public struct DeleteStreamingDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the streaming distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension DeleteStreamingDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteStreamingDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteStreamingDistributionOutput()
        }
    }
}

public struct DeleteStreamingDistributionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStreamingDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "StreamingDistributionNotDisabled": return try await StreamingDistributionNotDisabled.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DescribeFunctionInput {

    static func queryItemProvider(_ value: DescribeFunctionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let stage = value.stage {
            let stageQueryItem = ClientRuntime.SDKURLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        return items
    }
}

extension DescribeFunctionInput {

    static func urlPathProvider(_ value: DescribeFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/describe"
    }
}

public struct DescribeFunctionInput: Swift.Equatable {
    /// The name of the function that you are getting information about.
    /// This member is required.
    public var name: Swift.String?
    /// The function's stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

extension DescribeFunctionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeFunctionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = DescribeFunctionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.functionSummary = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FunctionSummary.readingClosure)
            return value
        }
    }
}

public struct DescribeFunctionOutput: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

enum DescribeFunctionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "NoSuchFunctionExists": return try await NoSuchFunctionExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension DescribeKeyValueStoreInput {

    static func urlPathProvider(_ value: DescribeKeyValueStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/key-value-store/\(name.urlPercentEncoding())"
    }
}

public struct DescribeKeyValueStoreInput: Swift.Equatable {
    /// The name of the Key Value Store.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension DescribeKeyValueStoreOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeKeyValueStoreOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = DescribeKeyValueStoreOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.keyValueStore = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyValueStore.readingClosure)
            return value
        }
    }
}

public struct DescribeKeyValueStoreOutput: Swift.Equatable {
    /// The ETag of the resulting Key Value Store.
    public var eTag: Swift.String?
    /// The resulting Key Value Store.
    public var keyValueStore: CloudFrontClientTypes.KeyValueStore?

    public init(
        eTag: Swift.String? = nil,
        keyValueStore: CloudFrontClientTypes.KeyValueStore? = nil
    )
    {
        self.eTag = eTag
        self.keyValueStore = keyValueStore
    }
}

enum DescribeKeyValueStoreOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "EntityNotFound": return try await EntityNotFound.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.Distribution {

    static func writingClosure(_ value: CloudFrontClientTypes.Distribution?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["ActiveTrustedKeyGroups"].write(value.activeTrustedKeyGroups, writingClosure: CloudFrontClientTypes.ActiveTrustedKeyGroups.writingClosure(_:to:))
        try writer["ActiveTrustedSigners"].write(value.activeTrustedSigners, writingClosure: CloudFrontClientTypes.ActiveTrustedSigners.writingClosure(_:to:))
        try writer["AliasICPRecordals"].writeList(value.aliasICPRecordals, memberWritingClosure: CloudFrontClientTypes.AliasICPRecordal.writingClosure(_:to:), memberNodeInfo: "AliasICPRecordal", isFlattened: false)
        try writer["DistributionConfig"].write(value.distributionConfig, writingClosure: CloudFrontClientTypes.DistributionConfig.writingClosure(_:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Id"].write(value.id)
        try writer["InProgressInvalidationBatches"].write(value.inProgressInvalidationBatches)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Distribution, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Distribution()
            value.id = try reader["Id"].readIfPresent()
            value.arn = try reader["ARN"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.inProgressInvalidationBatches = try reader["InProgressInvalidationBatches"].readIfPresent()
            value.domainName = try reader["DomainName"].readIfPresent()
            value.activeTrustedSigners = try reader["ActiveTrustedSigners"].readIfPresent(readingClosure: CloudFrontClientTypes.ActiveTrustedSigners.readingClosure)
            value.activeTrustedKeyGroups = try reader["ActiveTrustedKeyGroups"].readIfPresent(readingClosure: CloudFrontClientTypes.ActiveTrustedKeyGroups.readingClosure)
            value.distributionConfig = try reader["DistributionConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.DistributionConfig.readingClosure)
            value.aliasICPRecordals = try reader["AliasICPRecordals"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.AliasICPRecordal.readingClosure, memberNodeInfo: "AliasICPRecordal", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public struct Distribution: Swift.Equatable {
        /// This field contains a list of key groups and the public keys in each key group that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. This field contains a list of Amazon Web Services account IDs and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// The distribution's Amazon Resource Name (ARN).
        /// This member is required.
        public var arn: Swift.String?
        /// The distribution's configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// The distribution's CloudFront domain name. For example: d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The distribution's identifier. For example: E1U5RQF7T870K0.
        /// This member is required.
        public var id: Swift.String?
        /// The number of invalidation batches currently in progress.
        /// This member is required.
        public var inProgressInvalidationBatches: Swift.Int?
        /// The date and time when the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The distribution's status. When the status is Deployed, the distribution's information is fully propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?

        public init(
            activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            arn: Swift.String? = nil,
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            inProgressInvalidationBatches: Swift.Int? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.activeTrustedKeyGroups = activeTrustedKeyGroups
            self.activeTrustedSigners = activeTrustedSigners
            self.aliasICPRecordals = aliasICPRecordals
            self.arn = arn
            self.distributionConfig = distributionConfig
            self.domainName = domainName
            self.id = id
            self.inProgressInvalidationBatches = inProgressInvalidationBatches
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

extension DistributionAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<DistributionAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = DistributionAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension DistributionAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DistributionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The caller reference you attempted to create the distribution with is associated with another distribution.
public struct DistributionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DistributionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.DistributionConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.DistributionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Aliases"].write(value.aliases, writingClosure: CloudFrontClientTypes.Aliases.writingClosure(_:to:))
        try writer["CacheBehaviors"].write(value.cacheBehaviors, writingClosure: CloudFrontClientTypes.CacheBehaviors.writingClosure(_:to:))
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["ContinuousDeploymentPolicyId"].write(value.continuousDeploymentPolicyId)
        try writer["CustomErrorResponses"].write(value.customErrorResponses, writingClosure: CloudFrontClientTypes.CustomErrorResponses.writingClosure(_:to:))
        try writer["DefaultCacheBehavior"].write(value.defaultCacheBehavior, writingClosure: CloudFrontClientTypes.DefaultCacheBehavior.writingClosure(_:to:))
        try writer["DefaultRootObject"].write(value.defaultRootObject)
        try writer["Enabled"].write(value.enabled)
        try writer["HttpVersion"].write(value.httpVersion)
        try writer["IsIPV6Enabled"].write(value.isIPV6Enabled)
        try writer["Logging"].write(value.logging, writingClosure: CloudFrontClientTypes.LoggingConfig.writingClosure(_:to:))
        try writer["OriginGroups"].write(value.originGroups, writingClosure: CloudFrontClientTypes.OriginGroups.writingClosure(_:to:))
        try writer["Origins"].write(value.origins, writingClosure: CloudFrontClientTypes.Origins.writingClosure(_:to:))
        try writer["PriceClass"].write(value.priceClass)
        try writer["Restrictions"].write(value.restrictions, writingClosure: CloudFrontClientTypes.Restrictions.writingClosure(_:to:))
        try writer["Staging"].write(value.staging)
        try writer["ViewerCertificate"].write(value.viewerCertificate, writingClosure: CloudFrontClientTypes.ViewerCertificate.writingClosure(_:to:))
        try writer["WebACLId"].write(value.webACLId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.DistributionConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.DistributionConfig()
            value.callerReference = try reader["CallerReference"].readIfPresent()
            value.aliases = try reader["Aliases"].readIfPresent(readingClosure: CloudFrontClientTypes.Aliases.readingClosure)
            value.defaultRootObject = try reader["DefaultRootObject"].readIfPresent()
            value.origins = try reader["Origins"].readIfPresent(readingClosure: CloudFrontClientTypes.Origins.readingClosure)
            value.originGroups = try reader["OriginGroups"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginGroups.readingClosure)
            value.defaultCacheBehavior = try reader["DefaultCacheBehavior"].readIfPresent(readingClosure: CloudFrontClientTypes.DefaultCacheBehavior.readingClosure)
            value.cacheBehaviors = try reader["CacheBehaviors"].readIfPresent(readingClosure: CloudFrontClientTypes.CacheBehaviors.readingClosure)
            value.customErrorResponses = try reader["CustomErrorResponses"].readIfPresent(readingClosure: CloudFrontClientTypes.CustomErrorResponses.readingClosure)
            value.comment = try reader["Comment"].readIfPresent()
            value.logging = try reader["Logging"].readIfPresent(readingClosure: CloudFrontClientTypes.LoggingConfig.readingClosure)
            value.priceClass = try reader["PriceClass"].readIfPresent()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.viewerCertificate = try reader["ViewerCertificate"].readIfPresent(readingClosure: CloudFrontClientTypes.ViewerCertificate.readingClosure)
            value.restrictions = try reader["Restrictions"].readIfPresent(readingClosure: CloudFrontClientTypes.Restrictions.readingClosure)
            value.webACLId = try reader["WebACLId"].readIfPresent()
            value.httpVersion = try reader["HttpVersion"].readIfPresent()
            value.isIPV6Enabled = try reader["IsIPV6Enabled"].readIfPresent()
            value.continuousDeploymentPolicyId = try reader["ContinuousDeploymentPolicyId"].readIfPresent()
            value.staging = try reader["Staging"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfig(aliases: \(Swift.String(describing: aliases)), cacheBehaviors: \(Swift.String(describing: cacheBehaviors)), callerReference: \(Swift.String(describing: callerReference)), continuousDeploymentPolicyId: \(Swift.String(describing: continuousDeploymentPolicyId)), customErrorResponses: \(Swift.String(describing: customErrorResponses)), defaultCacheBehavior: \(Swift.String(describing: defaultCacheBehavior)), defaultRootObject: \(Swift.String(describing: defaultRootObject)), enabled: \(Swift.String(describing: enabled)), httpVersion: \(Swift.String(describing: httpVersion)), isIPV6Enabled: \(Swift.String(describing: isIPV6Enabled)), logging: \(Swift.String(describing: logging)), originGroups: \(Swift.String(describing: originGroups)), origins: \(Swift.String(describing: origins)), priceClass: \(Swift.String(describing: priceClass)), restrictions: \(Swift.String(describing: restrictions)), staging: \(Swift.String(describing: staging)), viewerCertificate: \(Swift.String(describing: viewerCertificate)), webACLId: \(Swift.String(describing: webACLId)), comment: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes {
    /// A distribution configuration.
    public struct DistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A complex type that contains zero or more CacheBehavior elements.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the DistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the distribution. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?
        /// The identifier of a continuous deployment policy. For more information, see CreateContinuousDeploymentPolicy.
        public var continuousDeploymentPolicyId: Swift.String?
        /// A complex type that controls the following:
        ///
        /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
        ///
        /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
        ///
        ///
        /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution (https://www.example.com) instead of an object in your distribution (https://www.example.com/product-description.html). Specifying a default root object avoids exposing the contents of your distribution. Specify only the object name, for example, index.html. Don't add a / before the object name. If you don't want to specify a default root object when you create a distribution, include an empty DefaultRootObject element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty DefaultRootObject element. To replace the default root object, update the distribution configuration and specify the new object. For more information about the default root object, see [Creating a Default Root Object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html) in the Amazon CloudFront Developer Guide.
        public var defaultRootObject: Swift.String?
        /// From this field, you can enable or disable the selected distribution.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// (Optional) Specify the maximum HTTP version(s) that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 automatically use an earlier HTTP version. For viewers and CloudFront to use HTTP/2, viewers must support TLSv1.2 or later, and must support Server Name Indication (SNI). For viewers and CloudFront to use HTTP/3, viewers must support TLSv1.3 and Server Name Indication (SNI). CloudFront supports HTTP/3 connection migration to allow the viewer to switch networks without losing connection. For more information about connection migration, see [Connection Migration](https://www.rfc-editor.org/rfc/rfc9000.html#name-connection-migration) at RFC 9000. For more information about supported TLSv1.3 ciphers, see [Supported protocols and ciphers between viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html).
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your distribution, specify true. If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. In general, you should enable IPv6 if you have users on IPv6 networks who want to access your content. However, if you're using signed URLs or signed cookies to restrict access to your content, and if you're using a custom policy that includes the IpAddress parameter to restrict the IP addresses that can access your content, don't enable IPv6. If you want to restrict access to some content by IP address and not restrict access to other content (or restrict access but not by IP address), you can create two distributions. For more information, see [Creating a Signed URL Using a Custom Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html) in the Amazon CloudFront Developer Guide. If you're using an Route 53 Amazon Web Services Integration alias resource record set to route traffic to your CloudFront distribution, you need to create a second alias resource record set when both of the following are true:
        ///
        /// * You enable IPv6 for the distribution
        ///
        /// * You're using alternate domain names in the URLs for your objects
        ///
        ///
        /// For more information, see [Routing Traffic to an Amazon CloudFront Web Distribution by Using Your Domain Name](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html) in the Route 53 Amazon Web Services Integration Developer Guide. If you created a CNAME resource record set, either with Route 53 Amazon Web Services Integration or with another DNS service, you don't need to make any changes. A CNAME record will route traffic to your distribution regardless of the IP address format of the viewer request.
        public var isIPV6Enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the distribution. For more information about logging, see [Access Logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html) in the Amazon CloudFront Developer Guide.
        public var logging: CloudFrontClientTypes.LoggingConfig?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Viewers who are in or near regions that are excluded from your specified price class may encounter slower performance. For more information about price classes, see [Choosing the Price Class for a CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html) in the Amazon CloudFront Developer Guide. For information about CloudFront pricing, including how price classes (such as Price Class 100) map to CloudFront regions, see [Amazon CloudFront Pricing](http://aws.amazon.com/cloudfront/pricing/).
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// A Boolean that indicates whether this is a staging distribution. When this value is true, this is a staging distribution. When this value is false, this is not a staging distribution.
        public var staging: Swift.Bool?
        /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a. WAF is a web application firewall that lets you monitor the HTTP and HTTPS requests that are forwarded to CloudFront, and lets you control access to your content. Based on conditions that you specify, such as the IP addresses that requests originate from or the values of query strings, CloudFront responds to requests either with the requested content or with an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page when a request is blocked. For more information about WAF, see the [WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html).
        public var webACLId: Swift.String?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            continuousDeploymentPolicyId: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.LoggingConfig? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            staging: Swift.Bool? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.callerReference = callerReference
            self.comment = comment
            self.continuousDeploymentPolicyId = continuousDeploymentPolicyId
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.isIPV6Enabled = isIPV6Enabled
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.staging = staging
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.DistributionConfigWithTags {

    static func writingClosure(_ value: CloudFrontClientTypes.DistributionConfigWithTags?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DistributionConfig"].write(value.distributionConfig, writingClosure: CloudFrontClientTypes.DistributionConfig.writingClosure(_:to:))
        try writer["Tags"].write(value.tags, writingClosure: CloudFrontClientTypes.Tags.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.DistributionConfigWithTags, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.DistributionConfigWithTags()
            value.distributionConfig = try reader["DistributionConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.DistributionConfig.readingClosure)
            value.tags = try reader["Tags"].readIfPresent(readingClosure: CloudFrontClientTypes.Tags.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A distribution Configuration and a list of tags to be associated with the distribution.
    public struct DistributionConfigWithTags: Swift.Equatable {
        /// A distribution configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init(
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.distributionConfig = distributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.DistributionIdList {

    static func writingClosure(_ value: CloudFrontClientTypes.DistributionIdList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsTruncated"].write(value.isTruncated)
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "DistributionId", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.DistributionIdList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.DistributionIdList()
            value.marker = try reader["Marker"].readIfPresent()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.isTruncated = try reader["IsTruncated"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "DistributionId", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of distribution IDs.
    public struct DistributionIdList: Swift.Equatable {
        /// A flag that indicates whether more distribution IDs remain to be listed. If your results were truncated, you can make a subsequent request using the Marker request field to retrieve more distribution IDs in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the distribution IDs in the list.
        public var items: [Swift.String]?
        /// The value provided in the Marker request field.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of distribution IDs requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Contains the value that you should use in the Marker field of a subsequent request to continue listing distribution IDs where you left off.
        public var nextMarker: Swift.String?
        /// The total number of distribution IDs returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.DistributionList {

    static func writingClosure(_ value: CloudFrontClientTypes.DistributionList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsTruncated"].write(value.isTruncated)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.DistributionSummary.writingClosure(_:to:), memberNodeInfo: "DistributionSummary", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.DistributionList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.DistributionList()
            value.marker = try reader["Marker"].readIfPresent()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.isTruncated = try reader["IsTruncated"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.DistributionSummary.readingClosure, memberNodeInfo: "DistributionSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A distribution list.
    public struct DistributionList: Swift.Equatable {
        /// A flag that indicates whether more distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one DistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.DistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.DistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension DistributionNotDisabled {

    static var readingClosure: SmithyReadWrite.ReadingClosure<DistributionNotDisabled, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = DistributionNotDisabled()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension DistributionNotDisabled {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DistributionNotDisabled()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct DistributionNotDisabled: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DistributionNotDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.DistributionSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.DistributionSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["AliasICPRecordals"].writeList(value.aliasICPRecordals, memberWritingClosure: CloudFrontClientTypes.AliasICPRecordal.writingClosure(_:to:), memberNodeInfo: "AliasICPRecordal", isFlattened: false)
        try writer["Aliases"].write(value.aliases, writingClosure: CloudFrontClientTypes.Aliases.writingClosure(_:to:))
        try writer["CacheBehaviors"].write(value.cacheBehaviors, writingClosure: CloudFrontClientTypes.CacheBehaviors.writingClosure(_:to:))
        try writer["Comment"].write(value.comment)
        try writer["CustomErrorResponses"].write(value.customErrorResponses, writingClosure: CloudFrontClientTypes.CustomErrorResponses.writingClosure(_:to:))
        try writer["DefaultCacheBehavior"].write(value.defaultCacheBehavior, writingClosure: CloudFrontClientTypes.DefaultCacheBehavior.writingClosure(_:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Enabled"].write(value.enabled)
        try writer["HttpVersion"].write(value.httpVersion)
        try writer["Id"].write(value.id)
        try writer["IsIPV6Enabled"].write(value.isIPV6Enabled)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["OriginGroups"].write(value.originGroups, writingClosure: CloudFrontClientTypes.OriginGroups.writingClosure(_:to:))
        try writer["Origins"].write(value.origins, writingClosure: CloudFrontClientTypes.Origins.writingClosure(_:to:))
        try writer["PriceClass"].write(value.priceClass)
        try writer["Restrictions"].write(value.restrictions, writingClosure: CloudFrontClientTypes.Restrictions.writingClosure(_:to:))
        try writer["Staging"].write(value.staging)
        try writer["Status"].write(value.status)
        try writer["ViewerCertificate"].write(value.viewerCertificate, writingClosure: CloudFrontClientTypes.ViewerCertificate.writingClosure(_:to:))
        try writer["WebACLId"].write(value.webACLId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.DistributionSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.DistributionSummary()
            value.id = try reader["Id"].readIfPresent()
            value.arn = try reader["ARN"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.domainName = try reader["DomainName"].readIfPresent()
            value.aliases = try reader["Aliases"].readIfPresent(readingClosure: CloudFrontClientTypes.Aliases.readingClosure)
            value.origins = try reader["Origins"].readIfPresent(readingClosure: CloudFrontClientTypes.Origins.readingClosure)
            value.originGroups = try reader["OriginGroups"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginGroups.readingClosure)
            value.defaultCacheBehavior = try reader["DefaultCacheBehavior"].readIfPresent(readingClosure: CloudFrontClientTypes.DefaultCacheBehavior.readingClosure)
            value.cacheBehaviors = try reader["CacheBehaviors"].readIfPresent(readingClosure: CloudFrontClientTypes.CacheBehaviors.readingClosure)
            value.customErrorResponses = try reader["CustomErrorResponses"].readIfPresent(readingClosure: CloudFrontClientTypes.CustomErrorResponses.readingClosure)
            value.comment = try reader["Comment"].readIfPresent()
            value.priceClass = try reader["PriceClass"].readIfPresent()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.viewerCertificate = try reader["ViewerCertificate"].readIfPresent(readingClosure: CloudFrontClientTypes.ViewerCertificate.readingClosure)
            value.restrictions = try reader["Restrictions"].readIfPresent(readingClosure: CloudFrontClientTypes.Restrictions.readingClosure)
            value.webACLId = try reader["WebACLId"].readIfPresent()
            value.httpVersion = try reader["HttpVersion"].readIfPresent()
            value.isIPV6Enabled = try reader["IsIPV6Enabled"].readIfPresent()
            value.aliasICPRecordals = try reader["AliasICPRecordals"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.AliasICPRecordal.readingClosure, memberNodeInfo: "AliasICPRecordal", isFlattened: false)
            value.staging = try reader["Staging"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information about a CloudFront distribution.
    public struct DistributionSummary: Swift.Equatable {
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains zero or more CacheBehavior elements.
        /// This member is required.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// A complex type that contains zero or more CustomErrorResponses elements.
        /// This member is required.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The domain name that corresponds to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 will automatically use an earlier version.
        /// This member is required.
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// The identifier for the distribution. For example: EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your distribution.
        /// This member is required.
        public var isIPV6Enabled: Swift.Bool?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        /// This member is required.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// Whether the primary distribution has a staging distribution enabled.
        /// This member is required.
        public var staging: Swift.Bool?
        /// The current status of the distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers.
        /// This member is required.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// The Web ACL Id (if any) associated with the distribution.
        /// This member is required.
        public var webACLId: Swift.String?

        public init(
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            arn: Swift.String? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            id: Swift.String? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            staging: Swift.Bool? = nil,
            status: Swift.String? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliasICPRecordals = aliasICPRecordals
            self.aliases = aliases
            self.arn = arn
            self.cacheBehaviors = cacheBehaviors
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.domainName = domainName
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.id = id
            self.isIPV6Enabled = isIPV6Enabled
            self.lastModifiedTime = lastModifiedTime
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.staging = staging
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntities {

    static func writingClosure(_ value: CloudFrontClientTypes.EncryptionEntities?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.EncryptionEntity.writingClosure(_:to:), memberNodeInfo: "EncryptionEntity", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.EncryptionEntities, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.EncryptionEntities()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.EncryptionEntity.readingClosure, memberNodeInfo: "EncryptionEntity", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes all of the encryption entities.
    public struct EncryptionEntities: Swift.Equatable {
        /// An array of field patterns in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.EncryptionEntity]?
        /// Number of field pattern items in a field-level encryption content type-profile mapping.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.EncryptionEntity]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntity {

    static func writingClosure(_ value: CloudFrontClientTypes.EncryptionEntity?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FieldPatterns"].write(value.fieldPatterns, writingClosure: CloudFrontClientTypes.FieldPatterns.writingClosure(_:to:))
        try writer["ProviderId"].write(value.providerId)
        try writer["PublicKeyId"].write(value.publicKeyId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.EncryptionEntity, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.EncryptionEntity()
            value.publicKeyId = try reader["PublicKeyId"].readIfPresent()
            value.providerId = try reader["ProviderId"].readIfPresent()
            value.fieldPatterns = try reader["FieldPatterns"].readIfPresent(readingClosure: CloudFrontClientTypes.FieldPatterns.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications.
    public struct EncryptionEntity: Swift.Equatable {
        /// Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have both ABC* and AB*. Note that field patterns are case-sensitive.
        /// This member is required.
        public var fieldPatterns: CloudFrontClientTypes.FieldPatterns?
        /// The provider associated with the public key being used for encryption. This value must also be provided with the private key for applications to be able to decrypt data.
        /// This member is required.
        public var providerId: Swift.String?
        /// The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match the patterns.
        /// This member is required.
        public var publicKeyId: Swift.String?

        public init(
            fieldPatterns: CloudFrontClientTypes.FieldPatterns? = nil,
            providerId: Swift.String? = nil,
            publicKeyId: Swift.String? = nil
        )
        {
            self.fieldPatterns = fieldPatterns
            self.providerId = providerId
            self.publicKeyId = publicKeyId
        }
    }

}

extension CloudFrontClientTypes.EndPoint {

    static func writingClosure(_ value: CloudFrontClientTypes.EndPoint?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KinesisStreamConfig"].write(value.kinesisStreamConfig, writingClosure: CloudFrontClientTypes.KinesisStreamConfig.writingClosure(_:to:))
        try writer["StreamType"].write(value.streamType)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.EndPoint, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.EndPoint()
            value.streamType = try reader["StreamType"].readIfPresent()
            value.kinesisStreamConfig = try reader["KinesisStreamConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.KinesisStreamConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data in a real-time log configuration.
    public struct EndPoint: Swift.Equatable {
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
        public var kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig?
        /// The type of data stream where you are sending real-time log data. The only valid value is Kinesis.
        /// This member is required.
        public var streamType: Swift.String?

        public init(
            kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig? = nil,
            streamType: Swift.String? = nil
        )
        {
            self.kinesisStreamConfig = kinesisStreamConfig
            self.streamType = streamType
        }
    }

}

extension EntityAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<EntityAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = EntityAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension EntityAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EntityAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Key Value Store entity already exists. You must provide a unique Key Value Store entity.
public struct EntityAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension EntityLimitExceeded {

    static var readingClosure: SmithyReadWrite.ReadingClosure<EntityLimitExceeded, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = EntityLimitExceeded()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension EntityLimitExceeded {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EntityLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Key Value Store entity limit has been exceeded.
public struct EntityLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension EntityNotFound {

    static var readingClosure: SmithyReadWrite.ReadingClosure<EntityNotFound, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = EntityNotFound()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension EntityNotFound {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EntityNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Key Value Store entity was not found.
public struct EntityNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension EntitySizeLimitExceeded {

    static var readingClosure: SmithyReadWrite.ReadingClosure<EntitySizeLimitExceeded, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = EntitySizeLimitExceeded()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension EntitySizeLimitExceeded {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EntitySizeLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Key Value Store entity size limit was exceeded.
public struct EntitySizeLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntitySizeLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case originRequest
        case originResponse
        case viewerRequest
        case viewerResponse
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .originRequest,
                .originResponse,
                .viewerRequest,
                .viewerResponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .originRequest: return "origin-request"
            case .originResponse: return "origin-response"
            case .viewerRequest: return "viewer-request"
            case .viewerResponse: return "viewer-response"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryption?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FieldLevelEncryptionConfig"].write(value.fieldLevelEncryptionConfig, writingClosure: CloudFrontClientTypes.FieldLevelEncryptionConfig.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryption, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryption()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.fieldLevelEncryptionConfig = try reader["FieldLevelEncryptionConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations and other options specified for field-level encryption.
    public struct FieldLevelEncryption: Swift.Equatable {
        /// A complex data type that includes the profile configurations specified for field-level encryption.
        /// This member is required.
        public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
        /// The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption configuration was changed.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryptionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["ContentTypeProfileConfig"].write(value.contentTypeProfileConfig, writingClosure: CloudFrontClientTypes.ContentTypeProfileConfig.writingClosure(_:to:))
        try writer["QueryArgProfileConfig"].write(value.queryArgProfileConfig, writingClosure: CloudFrontClientTypes.QueryArgProfileConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryptionConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryptionConfig()
            value.callerReference = try reader["CallerReference"].readIfPresent()
            value.comment = try reader["Comment"].readIfPresent()
            value.queryArgProfileConfig = try reader["QueryArgProfileConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.QueryArgProfileConfig.readingClosure)
            value.contentTypeProfileConfig = try reader["ContentTypeProfileConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ContentTypeProfileConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations specified for field-level encryption.
    public struct FieldLevelEncryptionConfig: Swift.Equatable {
        /// A unique number that ensures the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment about the configuration. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default in a request if a query argument doesn't specify a profile to use.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a query argument in a request.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension FieldLevelEncryptionConfigAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FieldLevelEncryptionConfigAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FieldLevelEncryptionConfigAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FieldLevelEncryptionConfigAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FieldLevelEncryptionConfigAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified configuration for field-level encryption already exists.
public struct FieldLevelEncryptionConfigAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionConfigAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FieldLevelEncryptionConfigInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FieldLevelEncryptionConfigInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FieldLevelEncryptionConfigInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FieldLevelEncryptionConfigInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FieldLevelEncryptionConfigInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified configuration for field-level encryption is in use.
public struct FieldLevelEncryptionConfigInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionConfigInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryptionList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.FieldLevelEncryptionSummary.writingClosure(_:to:), memberNodeInfo: "FieldLevelEncryptionSummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryptionList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryptionList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FieldLevelEncryptionSummary.readingClosure, memberNodeInfo: "FieldLevelEncryptionSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encryption configurations.
    public struct FieldLevelEncryptionList: Swift.Equatable {
        /// An array of field-level encryption items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]?
        /// The maximum number of elements you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your configurations where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryptionProfile?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FieldLevelEncryptionProfileConfig"].write(value.fieldLevelEncryptionProfileConfig, writingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryptionProfile, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryptionProfile()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.fieldLevelEncryptionProfileConfig = try reader["FieldLevelEncryptionProfileConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for field-level encryption profiles.
    public struct FieldLevelEncryptionProfile: Swift.Equatable {
        /// A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.
        /// This member is required.
        public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
        /// The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption profile was updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension FieldLevelEncryptionProfileAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FieldLevelEncryptionProfileAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FieldLevelEncryptionProfileAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FieldLevelEncryptionProfileAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FieldLevelEncryptionProfileAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified profile for field-level encryption already exists.
public struct FieldLevelEncryptionProfileAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["EncryptionEntities"].write(value.encryptionEntities, writingClosure: CloudFrontClientTypes.EncryptionEntities.writingClosure(_:to:))
        try writer["Name"].write(value.name)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryptionProfileConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryptionProfileConfig()
            value.name = try reader["Name"].readIfPresent()
            value.callerReference = try reader["CallerReference"].readIfPresent()
            value.comment = try reader["Comment"].readIfPresent()
            value.encryptionEntities = try reader["EncryptionEntities"].readIfPresent(readingClosure: CloudFrontClientTypes.EncryptionEntities.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type of profiles for the field-level encryption.
    public struct FieldLevelEncryptionProfileConfig: Swift.Equatable {
        /// A unique number that ensures that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment for the field-level encryption profile. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// Profile name for the field-level encryption profile.
        /// This member is required.
        public var name: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.name = name
        }
    }

}

extension FieldLevelEncryptionProfileInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FieldLevelEncryptionProfileInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FieldLevelEncryptionProfileInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FieldLevelEncryptionProfileInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FieldLevelEncryptionProfileInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified profile for field-level encryption is in use.
public struct FieldLevelEncryptionProfileInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryptionProfileList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileSummary.writingClosure(_:to:), memberNodeInfo: "FieldLevelEncryptionProfileSummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryptionProfileList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryptionProfileList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileSummary.readingClosure, memberNodeInfo: "FieldLevelEncryptionProfileSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encryption profiles.
    public struct FieldLevelEncryptionProfileList: Swift.Equatable {
        /// The field-level encryption profile items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]?
        /// The maximum number of field-level encryption profiles you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your profiles where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption profiles.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension FieldLevelEncryptionProfileSizeExceeded {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FieldLevelEncryptionProfileSizeExceeded, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FieldLevelEncryptionProfileSizeExceeded()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FieldLevelEncryptionProfileSizeExceeded {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FieldLevelEncryptionProfileSizeExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum size of a profile for field-level encryption was exceeded.
public struct FieldLevelEncryptionProfileSizeExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FieldLevelEncryptionProfileSizeExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryptionProfileSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["EncryptionEntities"].write(value.encryptionEntities, writingClosure: CloudFrontClientTypes.EncryptionEntities.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["Name"].write(value.name)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryptionProfileSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryptionProfileSummary()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.name = try reader["Name"].readIfPresent()
            value.encryptionEntities = try reader["EncryptionEntities"].readIfPresent(readingClosure: CloudFrontClientTypes.EncryptionEntities.readingClosure)
            value.comment = try reader["Comment"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The field-level encryption profile summary.
    public struct FieldLevelEncryptionProfileSummary: Swift.Equatable {
        /// An optional comment for the field-level encryption profile summary. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// ID for the field-level encryption profile summary.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the field-level encryption profile summary was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Name for the field-level encryption profile summary.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldLevelEncryptionSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["ContentTypeProfileConfig"].write(value.contentTypeProfileConfig, writingClosure: CloudFrontClientTypes.ContentTypeProfileConfig.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["QueryArgProfileConfig"].write(value.queryArgProfileConfig, writingClosure: CloudFrontClientTypes.QueryArgProfileConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldLevelEncryptionSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldLevelEncryptionSummary()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.comment = try reader["Comment"].readIfPresent()
            value.queryArgProfileConfig = try reader["QueryArgProfileConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.QueryArgProfileConfig.readingClosure)
            value.contentTypeProfileConfig = try reader["ContentTypeProfileConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ContentTypeProfileConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A summary of a field-level encryption item.
    public struct FieldLevelEncryptionSummary: Swift.Equatable {
        /// An optional comment about the field-level encryption item. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A summary of a content type-profile mapping.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// The unique ID of a field-level encryption item.
        /// This member is required.
        public var id: Swift.String?
        /// The last time that the summary of field-level encryption items was modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A summary of a query argument-profile mapping.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init(
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension CloudFrontClientTypes.FieldPatterns {

    static func writingClosure(_ value: CloudFrontClientTypes.FieldPatterns?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "FieldPattern", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FieldPatterns, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FieldPatterns()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "FieldPattern", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the field patterns to match for field-level encryption.
    public struct FieldPatterns: Swift.Equatable {
        /// An array of the field-level encryption field patterns.
        public var items: [Swift.String]?
        /// The number of field-level encryption field patterns.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case urlencoded
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .urlencoded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .urlencoded: return "URLEncoded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ForwardedValues {

    static func writingClosure(_ value: CloudFrontClientTypes.ForwardedValues?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Cookies"].write(value.cookies, writingClosure: CloudFrontClientTypes.CookiePreference.writingClosure(_:to:))
        try writer["Headers"].write(value.headers, writingClosure: CloudFrontClientTypes.Headers.writingClosure(_:to:))
        try writer["QueryString"].write(value.queryString)
        try writer["QueryStringCacheKeys"].write(value.queryStringCacheKeys, writingClosure: CloudFrontClientTypes.QueryStringCacheKeys.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ForwardedValues, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ForwardedValues()
            value.queryString = try reader["QueryString"].readIfPresent()
            value.cookies = try reader["Cookies"].readIfPresent(readingClosure: CloudFrontClientTypes.CookiePreference.readingClosure)
            value.headers = try reader["Headers"].readIfPresent(readingClosure: CloudFrontClientTypes.Headers.readingClosure)
            value.queryStringCacheKeys = try reader["QueryStringCacheKeys"].readIfPresent(readingClosure: CloudFrontClientTypes.QueryStringCacheKeys.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
    public struct ForwardedValues: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var cookies: CloudFrontClientTypes.CookiePreference?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include headers in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send headers to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies the Headers, if any, that you want CloudFront to forward to the origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches separate versions of a specified object that is based on the header values in viewer requests. For more information, see [ Caching Content Based on Request Headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html) in the Amazon CloudFront Developer Guide.
        public var headers: CloudFrontClientTypes.Headers?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior and cache based on the query string parameters. CloudFront behavior depends on the value of QueryString and on the values that you specify for QueryStringCacheKeys, if any: If you specify true for QueryString and you don't specify any values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin and caches based on all query string parameters. Depending on how many query string parameters and values you have, this can adversely affect performance because CloudFront must forward more requests to the origin. If you specify true for QueryString and you specify one or more values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin, but it only caches based on the query string parameters that you specify. If you specify false for QueryString, CloudFront doesn't forward any query string parameters to the origin, and doesn't cache based on query string parameters. For more information, see [Configuring CloudFront to Cache Based on Query String Parameters](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var queryString: Swift.Bool?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for this cache behavior.
        public var queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys?

        public init(
            cookies: CloudFrontClientTypes.CookiePreference? = nil,
            headers: CloudFrontClientTypes.Headers? = nil,
            queryString: Swift.Bool? = nil,
            queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys? = nil
        )
        {
            self.cookies = cookies
            self.headers = headers
            self.queryString = queryString
            self.queryStringCacheKeys = queryStringCacheKeys
        }
    }

}

extension CloudFrontClientTypes {
    public enum FrameOptionsList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deny
        case sameorigin
        case sdkUnknown(Swift.String)

        public static var allCases: [FrameOptionsList] {
            return [
                .deny,
                .sameorigin,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case .sameorigin: return "SAMEORIGIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrameOptionsList(rawValue: rawValue) ?? FrameOptionsList.sdkUnknown(rawValue)
        }
    }
}

extension FunctionAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FunctionAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FunctionAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FunctionAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FunctionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A function with the same name already exists in this Amazon Web Services account. To create a function, you must provide a unique name. To update an existing function, use UpdateFunction.
public struct FunctionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.FunctionAssociation {

    static func writingClosure(_ value: CloudFrontClientTypes.FunctionAssociation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["EventType"].write(value.eventType)
        try writer["FunctionARN"].write(value.functionARN)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FunctionAssociation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FunctionAssociation()
            value.functionARN = try reader["FunctionARN"].readIfPresent()
            value.eventType = try reader["EventType"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront function that is associated with a cache behavior in a CloudFront distribution.
    public struct FunctionAssociation: Swift.Equatable {
        /// The event type of the function, either viewer-request or viewer-response. You cannot use origin-facing event types (origin-request and origin-response) with a CloudFront function.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// The Amazon Resource Name (ARN) of the function.
        /// This member is required.
        public var functionARN: Swift.String?

        public init(
            eventType: CloudFrontClientTypes.EventType? = nil,
            functionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.functionARN = functionARN
        }
    }

}

extension CloudFrontClientTypes.FunctionAssociations {

    static func writingClosure(_ value: CloudFrontClientTypes.FunctionAssociations?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.FunctionAssociation.writingClosure(_:to:), memberNodeInfo: "FunctionAssociation", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FunctionAssociations, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FunctionAssociations()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FunctionAssociation.readingClosure, memberNodeInfo: "FunctionAssociation", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
    public struct FunctionAssociations: Swift.Equatable {
        /// The CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var items: [CloudFrontClientTypes.FunctionAssociation]?
        /// The number of CloudFront functions in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.FunctionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["KeyValueStoreAssociations"].write(value.keyValueStoreAssociations, writingClosure: CloudFrontClientTypes.KeyValueStoreAssociations.writingClosure(_:to:))
        try writer["Runtime"].write(value.runtime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FunctionConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FunctionConfig()
            value.comment = try reader["Comment"].readIfPresent()
            value.runtime = try reader["Runtime"].readIfPresent()
            value.keyValueStoreAssociations = try reader["KeyValueStoreAssociations"].readIfPresent(readingClosure: CloudFrontClientTypes.KeyValueStoreAssociations.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information about a CloudFront function.
    public struct FunctionConfig: Swift.Equatable {
        /// A comment to describe the function.
        /// This member is required.
        public var comment: Swift.String?
        /// The configuration for the Key Value Store associations.
        public var keyValueStoreAssociations: CloudFrontClientTypes.KeyValueStoreAssociations?
        /// The function's runtime environment version.
        /// This member is required.
        public var runtime: CloudFrontClientTypes.FunctionRuntime?

        public init(
            comment: Swift.String? = nil,
            keyValueStoreAssociations: CloudFrontClientTypes.KeyValueStoreAssociations? = nil,
            runtime: CloudFrontClientTypes.FunctionRuntime? = nil
        )
        {
            self.comment = comment
            self.keyValueStoreAssociations = keyValueStoreAssociations
            self.runtime = runtime
        }
    }

}

extension FunctionInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FunctionInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FunctionInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FunctionInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FunctionInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Cannot delete the function because it's attached to one or more cache behaviors.
public struct FunctionInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.FunctionList {

    static func writingClosure(_ value: CloudFrontClientTypes.FunctionList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.FunctionSummary.writingClosure(_:to:), memberNodeInfo: "FunctionSummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FunctionList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FunctionList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.FunctionSummary.readingClosure, memberNodeInfo: "FunctionSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions.
    public struct FunctionList: Swift.Equatable {
        /// Contains the functions in the list.
        public var items: [CloudFrontClientTypes.FunctionSummary]?
        /// The maximum number of functions requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing functions where you left off.
        public var nextMarker: Swift.String?
        /// The number of functions returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.FunctionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionMetadata {

    static func writingClosure(_ value: CloudFrontClientTypes.FunctionMetadata?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreatedTime"].writeTimestamp(value.createdTime, format: .dateTime)
        try writer["FunctionARN"].write(value.functionARN)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["Stage"].write(value.stage)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FunctionMetadata, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FunctionMetadata()
            value.functionARN = try reader["FunctionARN"].readIfPresent()
            value.stage = try reader["Stage"].readIfPresent()
            value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .dateTime)
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains metadata about a CloudFront function.
    public struct FunctionMetadata: Swift.Equatable {
        /// The date and time when the function was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the function.
        /// This member is required.
        public var functionARN: Swift.String?
        /// The date and time when the function was most recently updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The stage that the function is in, either DEVELOPMENT or LIVE. When a function is in the DEVELOPMENT stage, you can test the function with TestFunction, and update it with UpdateFunction. When a function is in the LIVE stage, you can attach the function to a distribution's cache behavior, using the function's ARN.
        public var stage: CloudFrontClientTypes.FunctionStage?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            functionARN: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            stage: CloudFrontClientTypes.FunctionStage? = nil
        )
        {
            self.createdTime = createdTime
            self.functionARN = functionARN
            self.lastModifiedTime = lastModifiedTime
            self.stage = stage
        }
    }

}

extension CloudFrontClientTypes {
    public enum FunctionRuntime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudfrontJs10
        case cloudfrontJs20
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionRuntime] {
            return [
                .cloudfrontJs10,
                .cloudfrontJs20,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontJs10: return "cloudfront-js-1.0"
            case .cloudfrontJs20: return "cloudfront-js-2.0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionRuntime(rawValue: rawValue) ?? FunctionRuntime.sdkUnknown(rawValue)
        }
    }
}

extension FunctionSizeLimitExceeded {

    static var readingClosure: SmithyReadWrite.ReadingClosure<FunctionSizeLimitExceeded, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = FunctionSizeLimitExceeded()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension FunctionSizeLimitExceeded {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FunctionSizeLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The function is too large. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct FunctionSizeLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FunctionSizeLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {
    public enum FunctionStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionStage] {
            return [
                .development,
                .live,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionStage(rawValue: rawValue) ?? FunctionStage.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FunctionSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.FunctionSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FunctionConfig"].write(value.functionConfig, writingClosure: CloudFrontClientTypes.FunctionConfig.writingClosure(_:to:))
        try writer["FunctionMetadata"].write(value.functionMetadata, writingClosure: CloudFrontClientTypes.FunctionMetadata.writingClosure(_:to:))
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.FunctionSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.FunctionSummary()
            value.name = try reader["Name"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.functionConfig = try reader["FunctionConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.FunctionConfig.readingClosure)
            value.functionMetadata = try reader["FunctionMetadata"].readIfPresent(readingClosure: CloudFrontClientTypes.FunctionMetadata.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information and metadata about a CloudFront function.
    public struct FunctionSummary: Swift.Equatable {
        /// Contains configuration information about a CloudFront function.
        /// This member is required.
        public var functionConfig: CloudFrontClientTypes.FunctionConfig?
        /// Contains metadata about a CloudFront function.
        /// This member is required.
        public var functionMetadata: CloudFrontClientTypes.FunctionMetadata?
        /// The name of the CloudFront function.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the CloudFront function.
        public var status: Swift.String?

        public init(
            functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
            functionMetadata: CloudFrontClientTypes.FunctionMetadata? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.functionConfig = functionConfig
            self.functionMetadata = functionMetadata
            self.name = name
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.GeoRestriction {

    static func writingClosure(_ value: CloudFrontClientTypes.GeoRestriction?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Location", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
        try writer["RestrictionType"].write(value.restrictionType)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.GeoRestriction, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.GeoRestriction()
            value.restrictionType = try reader["RestrictionType"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Location", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
    public struct GeoRestriction: Swift.Equatable {
        /// A complex type that contains a Location element for each country in which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). The Location element is a two-letter, uppercase country code for a country that you want to include in your blacklist or whitelist. Include one Location element for each country. CloudFront and MaxMind both use ISO 3166 country codes. For the current list of countries and the corresponding codes, see ISO 3166-1-alpha-2 code on the International Organization for Standardization website. You can also refer to the country list on the CloudFront console, which includes both country names and codes.
        public var items: [Swift.String]?
        /// When geo restriction is enabled, this is the number of countries in your whitelist or blacklist. Otherwise, when it is not enabled, Quantity is 0, and you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?
        /// The method that you want to use to restrict distribution of your content by country:
        ///
        /// * none: No geo restriction is enabled, meaning access to content is not restricted by client geo location.
        ///
        /// * blacklist: The Location elements specify the countries in which you don't want CloudFront to distribute your content.
        ///
        /// * whitelist: The Location elements specify the countries in which you want CloudFront to distribute your content.
        /// This member is required.
        public var restrictionType: CloudFrontClientTypes.GeoRestrictionType?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil,
            restrictionType: CloudFrontClientTypes.GeoRestrictionType? = nil
        )
        {
            self.items = items
            self.quantity = quantity
            self.restrictionType = restrictionType
        }
    }

}

extension CloudFrontClientTypes {
    public enum GeoRestrictionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blacklist
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoRestrictionType] {
            return [
                .blacklist,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blacklist: return "blacklist"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoRestrictionType(rawValue: rawValue) ?? GeoRestrictionType.sdkUnknown(rawValue)
        }
    }
}

extension GetCachePolicyConfigInput {

    static func urlPathProvider(_ value: GetCachePolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetCachePolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetCachePolicyConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetCachePolicyConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetCachePolicyConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.cachePolicyConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicyConfig.readingClosure)
            return value
        }
    }
}

public struct GetCachePolicyConfigOutput: Swift.Equatable {
    /// The cache policy configuration.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.eTag = eTag
    }
}

enum GetCachePolicyConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetCachePolicyInput {

    static func urlPathProvider(_ value: GetCachePolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetCachePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetCachePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetCachePolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.cachePolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicy.readingClosure)
            return value
        }
    }
}

public struct GetCachePolicyOutput: Swift.Equatable {
    /// The cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

enum GetCachePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetCloudFrontOriginAccessIdentityConfigInput {

    static func urlPathProvider(_ value: GetCloudFrontOriginAccessIdentityConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

/// The origin access identity's configuration information. For more information, see [CloudFrontOriginAccessIdentityConfig](https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html).
public struct GetCloudFrontOriginAccessIdentityConfigInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetCloudFrontOriginAccessIdentityConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetCloudFrontOriginAccessIdentityConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.cloudFrontOriginAccessIdentityConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityConfigOutput: Swift.Equatable {
    /// The origin access identity's configuration information.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.eTag = eTag
    }
}

enum GetCloudFrontOriginAccessIdentityConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: GetCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
    }
}

/// The request to get an origin access identity's information.
public struct GetCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetCloudFrontOriginAccessIdentityOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetCloudFrontOriginAccessIdentityOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetCloudFrontOriginAccessIdentityOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.cloudFrontOriginAccessIdentity = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentity.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityOutput: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

enum GetCloudFrontOriginAccessIdentityOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetContinuousDeploymentPolicyConfigInput {

    static func urlPathProvider(_ value: GetContinuousDeploymentPolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetContinuousDeploymentPolicyConfigInput: Swift.Equatable {
    /// The identifier of the continuous deployment policy whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetContinuousDeploymentPolicyConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetContinuousDeploymentPolicyConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetContinuousDeploymentPolicyConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.continuousDeploymentPolicyConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.readingClosure)
            return value
        }
    }
}

public struct GetContinuousDeploymentPolicyConfigOutput: Swift.Equatable {
    /// Contains the configuration for a continuous deployment policy.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
        self.eTag = eTag
    }
}

enum GetContinuousDeploymentPolicyConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: GetContinuousDeploymentPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetContinuousDeploymentPolicyInput: Swift.Equatable {
    /// The identifier of the continuous deployment policy that you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetContinuousDeploymentPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetContinuousDeploymentPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetContinuousDeploymentPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.continuousDeploymentPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicy.readingClosure)
            return value
        }
    }
}

public struct GetContinuousDeploymentPolicyOutput: Swift.Equatable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
    }
}

enum GetContinuousDeploymentPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetDistributionConfigInput {

    static func urlPathProvider(_ value: GetDistributionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to get a distribution configuration.
public struct GetDistributionConfigInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetDistributionConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetDistributionConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetDistributionConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.distributionConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionConfig.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionConfigOutput: Swift.Equatable {
    /// The distribution's configuration information.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.eTag = eTag
    }
}

enum GetDistributionConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetDistributionInput {

    static func urlPathProvider(_ value: GetDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to get a distribution's information.
public struct GetDistributionInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetDistributionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.distribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Distribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

enum GetDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

public struct GetFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetFieldLevelEncryptionConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetFieldLevelEncryptionConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetFieldLevelEncryptionConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.fieldLevelEncryptionConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionConfig.readingClosure)
            return value
        }
    }
}

public struct GetFieldLevelEncryptionConfigOutput: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

enum GetFieldLevelEncryptionConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetFieldLevelEncryptionInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
    }
}

public struct GetFieldLevelEncryptionInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetFieldLevelEncryptionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetFieldLevelEncryptionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetFieldLevelEncryptionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.fieldLevelEncryption = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryption.readingClosure)
            return value
        }
    }
}

public struct GetFieldLevelEncryptionOutput: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

enum GetFieldLevelEncryptionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetFieldLevelEncryptionProfileConfigInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionProfileConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

public struct GetFieldLevelEncryptionProfileConfigInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetFieldLevelEncryptionProfileConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetFieldLevelEncryptionProfileConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetFieldLevelEncryptionProfileConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.fieldLevelEncryptionProfileConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.readingClosure)
            return value
        }
    }
}

public struct GetFieldLevelEncryptionProfileConfigOutput: Swift.Equatable {
    /// The current version of the field-level encryption profile configuration result. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile configuration information.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

enum GetFieldLevelEncryptionProfileConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: GetFieldLevelEncryptionProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
    }
}

public struct GetFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetFieldLevelEncryptionProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetFieldLevelEncryptionProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetFieldLevelEncryptionProfileOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.fieldLevelEncryptionProfile = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfile.readingClosure)
            return value
        }
    }
}

public struct GetFieldLevelEncryptionProfileOutput: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile information.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

enum GetFieldLevelEncryptionProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetFunctionInput {

    static func queryItemProvider(_ value: GetFunctionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let stage = value.stage {
            let stageQueryItem = ClientRuntime.SDKURLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        return items
    }
}

extension GetFunctionInput {

    static func urlPathProvider(_ value: GetFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct GetFunctionInput: Swift.Equatable {
    /// The name of the function whose code you are getting.
    /// This member is required.
    public var name: Swift.String?
    /// The function's stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

extension GetFunctionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionOutput(contentType: \(Swift.String(describing: contentType)), eTag: \(Swift.String(describing: eTag)), functionCode: \"CONTENT_REDACTED\")"}
}

extension GetFunctionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetFunctionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetFunctionOutput()
            if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
                value.contentType = contentTypeHeaderValue
            }
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            switch httpResponse.body {
            case .data(let data):
                value.functionCode = data
            case .stream(let stream):
                value.functionCode = try stream.readToEnd()
            case .noStream:
                value.functionCode = nil
            }
            return value
        }
    }
}

public struct GetFunctionOutput: Swift.Equatable {
    /// The content type (media type) of the response.
    public var contentType: Swift.String?
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// The function code of a CloudFront function.
    public var functionCode: ClientRuntime.Data?

    public init(
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        functionCode: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.functionCode = functionCode
    }
}

enum GetFunctionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "NoSuchFunctionExists": return try await NoSuchFunctionExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetInvalidationInput {

    static func urlPathProvider(_ value: GetInvalidationInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation/\(id.urlPercentEncoding())"
    }
}

/// The request to get an invalidation's information.
public struct GetInvalidationInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The identifier for the invalidation request, for example, IDFDVBD632BHDS5.
    /// This member is required.
    public var id: Swift.String?

    public init(
        distributionId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
        self.id = id
    }
}

extension GetInvalidationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetInvalidationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetInvalidationOutput()
            value.invalidation = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Invalidation.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct GetInvalidationOutput: Swift.Equatable {
    /// The invalidation's information. For more information, see [Invalidation Complex Type](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html).
    public var invalidation: CloudFrontClientTypes.Invalidation?

    public init(
        invalidation: CloudFrontClientTypes.Invalidation? = nil
    )
    {
        self.invalidation = invalidation
    }
}

enum GetInvalidationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchInvalidation": return try await NoSuchInvalidation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetKeyGroupConfigInput {

    static func urlPathProvider(_ value: GetKeyGroupConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())/config"
    }
}

public struct GetKeyGroupConfigInput: Swift.Equatable {
    /// The identifier of the key group whose configuration you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetKeyGroupConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetKeyGroupConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetKeyGroupConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.keyGroupConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyGroupConfig.readingClosure)
            return value
        }
    }
}

public struct GetKeyGroupConfigOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group configuration.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        eTag: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.eTag = eTag
        self.keyGroupConfig = keyGroupConfig
    }
}

enum GetKeyGroupConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetKeyGroupInput {

    static func urlPathProvider(_ value: GetKeyGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct GetKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetKeyGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetKeyGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetKeyGroupOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.keyGroup = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyGroup.readingClosure)
            return value
        }
    }
}

public struct GetKeyGroupOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

enum GetKeyGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetMonitoringSubscriptionInput {

    static func urlPathProvider(_ value: GetMonitoringSubscriptionInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
    }
}

public struct GetMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are getting metrics information for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init(
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

extension GetMonitoringSubscriptionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetMonitoringSubscriptionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetMonitoringSubscriptionOutput()
            value.monitoringSubscription = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.MonitoringSubscription.readingClosure)
            return value
        }
    }
}

public struct GetMonitoringSubscriptionOutput: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init(
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

enum GetMonitoringSubscriptionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchMonitoringSubscription": return try await NoSuchMonitoringSubscription.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetOriginAccessControlConfigInput {

    static func urlPathProvider(_ value: GetOriginAccessControlConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())/config"
    }
}

public struct GetOriginAccessControlConfigInput: Swift.Equatable {
    /// The unique identifier of the origin access control.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetOriginAccessControlConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetOriginAccessControlConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetOriginAccessControlConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.originAccessControlConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginAccessControlConfig.readingClosure)
            return value
        }
    }
}

public struct GetOriginAccessControlConfigOutput: Swift.Equatable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// Contains an origin access control configuration.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        eTag: Swift.String? = nil,
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControlConfig = originAccessControlConfig
    }
}

enum GetOriginAccessControlConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetOriginAccessControlInput {

    static func urlPathProvider(_ value: GetOriginAccessControlInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())"
    }
}

public struct GetOriginAccessControlInput: Swift.Equatable {
    /// The unique identifier of the origin access control.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetOriginAccessControlOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetOriginAccessControlOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetOriginAccessControlOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.originAccessControl = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginAccessControl.readingClosure)
            return value
        }
    }
}

public struct GetOriginAccessControlOutput: Swift.Equatable {
    /// The version identifier for the current version of the origin access control.
    public var eTag: Swift.String?
    /// Contains an origin access control, including its unique identifier.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControl = originAccessControl
    }
}

enum GetOriginAccessControlOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetOriginRequestPolicyConfigInput {

    static func urlPathProvider(_ value: GetOriginRequestPolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetOriginRequestPolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetOriginRequestPolicyConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetOriginRequestPolicyConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetOriginRequestPolicyConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.originRequestPolicyConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicyConfig.readingClosure)
            return value
        }
    }
}

public struct GetOriginRequestPolicyConfigOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy configuration.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

enum GetOriginRequestPolicyConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetOriginRequestPolicyInput {

    static func urlPathProvider(_ value: GetOriginRequestPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetOriginRequestPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetOriginRequestPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetOriginRequestPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.originRequestPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicy.readingClosure)
            return value
        }
    }
}

public struct GetOriginRequestPolicyOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

enum GetOriginRequestPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetPublicKeyConfigInput {

    static func urlPathProvider(_ value: GetPublicKeyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

public struct GetPublicKeyConfigInput: Swift.Equatable {
    /// The identifier of the public key whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetPublicKeyConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetPublicKeyConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetPublicKeyConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.publicKeyConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.PublicKeyConfig.readingClosure)
            return value
        }
    }
}

public struct GetPublicKeyConfigOutput: Swift.Equatable {
    /// The identifier for this version of the public key configuration.
    public var eTag: Swift.String?
    /// A public key configuration.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        eTag: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.eTag = eTag
        self.publicKeyConfig = publicKeyConfig
    }
}

enum GetPublicKeyConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchPublicKey": return try await NoSuchPublicKey.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetPublicKeyInput {

    static func urlPathProvider(_ value: GetPublicKeyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())"
    }
}

public struct GetPublicKeyInput: Swift.Equatable {
    /// The identifier of the public key you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetPublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetPublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetPublicKeyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.publicKey = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.PublicKey.readingClosure)
            return value
        }
    }
}

public struct GetPublicKeyOutput: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

enum GetPublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchPublicKey": return try await NoSuchPublicKey.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetRealtimeLogConfigInput {
    static func writingClosure(_ value: GetRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["Name"].write(value.name)
    }
}

extension GetRealtimeLogConfigInput {

    static func urlPathProvider(_ value: GetRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/get-realtime-log-config"
    }
}

public struct GetRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to get.
    public var arn: Swift.String?
    /// The name of the real-time log configuration to get.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension GetRealtimeLogConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetRealtimeLogConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetRealtimeLogConfigOutput()
            value.realtimeLogConfig = try reader["RealtimeLogConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.RealtimeLogConfig.readingClosure)
            return value
        }
    }
}

public struct GetRealtimeLogConfigOutput: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

enum GetRealtimeLogConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetResponseHeadersPolicyConfigInput {

    static func urlPathProvider(_ value: GetResponseHeadersPolicyConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())/config"
    }
}

public struct GetResponseHeadersPolicyConfigInput: Swift.Equatable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetResponseHeadersPolicyConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetResponseHeadersPolicyConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetResponseHeadersPolicyConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.responseHeadersPolicyConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyConfig.readingClosure)
            return value
        }
    }
}

public struct GetResponseHeadersPolicyConfigOutput: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

enum GetResponseHeadersPolicyConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: GetResponseHeadersPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct GetResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy. If the response headers policy is attached to a distribution's cache behavior, you can get the policy's identifier using ListDistributions or GetDistribution. If the response headers policy is not attached to a cache behavior, you can get the identifier using ListResponseHeadersPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetResponseHeadersPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetResponseHeadersPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetResponseHeadersPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.responseHeadersPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicy.readingClosure)
            return value
        }
    }
}

public struct GetResponseHeadersPolicyOutput: Swift.Equatable {
    /// The version identifier for the current version of the response headers policy.
    public var eTag: Swift.String?
    /// Contains a response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

enum GetResponseHeadersPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetStreamingDistributionConfigInput {

    static func urlPathProvider(_ value: GetStreamingDistributionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

/// To request to get a streaming distribution configuration.
public struct GetStreamingDistributionConfigInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetStreamingDistributionConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetStreamingDistributionConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetStreamingDistributionConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.streamingDistributionConfig = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistributionConfig.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionConfigOutput: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's configuration information.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        eTag: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

enum GetStreamingDistributionConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension GetStreamingDistributionInput {

    static func urlPathProvider(_ value: GetStreamingDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
    }
}

/// The request to get a streaming distribution's information.
public struct GetStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension GetStreamingDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetStreamingDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = GetStreamingDistributionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.streamingDistribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionOutput: Swift.Equatable {
    /// The current version of the streaming distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

enum GetStreamingDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.Headers {

    static func writingClosure(_ value: CloudFrontClientTypes.Headers?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Headers, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Headers()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Name", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of HTTP header names.
    public struct Headers: Swift.Equatable {
        /// A list of HTTP header names.
        public var items: [Swift.String]?
        /// The number of header names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum HttpVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http11
        case http2
        case http2and3
        case http3
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpVersion] {
            return [
                .http11,
                .http2,
                .http2and3,
                .http3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http11: return "http1.1"
            case .http2: return "http2"
            case .http2and3: return "http2and3"
            case .http3: return "http3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpVersion(rawValue: rawValue) ?? HttpVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ICPRecordalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [ICPRecordalStatus] {
            return [
                .approved,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICPRecordalStatus(rawValue: rawValue) ?? ICPRecordalStatus.sdkUnknown(rawValue)
        }
    }
}

extension IllegalDelete {

    static var readingClosure: SmithyReadWrite.ReadingClosure<IllegalDelete, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IllegalDelete()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension IllegalDelete {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = IllegalDelete()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You cannot delete a managed policy.
public struct IllegalDelete: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalDelete" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {

    static var readingClosure: SmithyReadWrite.ReadingClosure<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified configuration for field-level encryption can't be associated with the specified cache behavior.
public struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IllegalOriginAccessConfiguration {

    static var readingClosure: SmithyReadWrite.ReadingClosure<IllegalOriginAccessConfiguration, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IllegalOriginAccessConfiguration()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension IllegalOriginAccessConfiguration {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = IllegalOriginAccessConfiguration()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An origin cannot contain both an origin access control (OAC) and an origin access identity (OAI).
public struct IllegalOriginAccessConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalOriginAccessConfiguration" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IllegalUpdate {

    static var readingClosure: SmithyReadWrite.ReadingClosure<IllegalUpdate, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = IllegalUpdate()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension IllegalUpdate {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = IllegalUpdate()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The update contains modifications that are not allowed.
public struct IllegalUpdate: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalUpdate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.ImportSource {

    static func writingClosure(_ value: CloudFrontClientTypes.ImportSource?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["SourceARN"].write(value.sourceARN)
        try writer["SourceType"].write(value.sourceType)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ImportSource, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ImportSource()
            value.sourceType = try reader["SourceType"].readIfPresent()
            value.sourceARN = try reader["SourceARN"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The import source for the Key Value Store.
    public struct ImportSource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the import source for the Key Value Store.
        /// This member is required.
        public var sourceARN: Swift.String?
        /// The source type of the import source for the Key Value Store.
        /// This member is required.
        public var sourceType: CloudFrontClientTypes.ImportSourceType?

        public init(
            sourceARN: Swift.String? = nil,
            sourceType: CloudFrontClientTypes.ImportSourceType? = nil
        )
        {
            self.sourceARN = sourceARN
            self.sourceType = sourceType
        }
    }

}

extension CloudFrontClientTypes {
    public enum ImportSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportSourceType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportSourceType(rawValue: rawValue) ?? ImportSourceType.sdkUnknown(rawValue)
        }
    }
}

extension InconsistentQuantities {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InconsistentQuantities, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InconsistentQuantities()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InconsistentQuantities {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InconsistentQuantities()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The value of Quantity and the size of Items don't match.
public struct InconsistentQuantities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InconsistentQuantities" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidArgument {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidArgument, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidArgument()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidArgument {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidArgument()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An argument is invalid.
public struct InvalidArgument: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgument" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidDefaultRootObject {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidDefaultRootObject, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidDefaultRootObject()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidDefaultRootObject {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidDefaultRootObject()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The default root object file name is too big or contains an invalid character.
public struct InvalidDefaultRootObject: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDefaultRootObject" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidDomainNameForOriginAccessControl {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidDomainNameForOriginAccessControl, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidDomainNameForOriginAccessControl()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidDomainNameForOriginAccessControl {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidDomainNameForOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An origin access control is associated with an origin whose domain name is not supported.
public struct InvalidDomainNameForOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDomainNameForOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidErrorCode {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidErrorCode, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidErrorCode()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidErrorCode {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidErrorCode()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An invalid error code was specified.
public struct InvalidErrorCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidErrorCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidForwardCookies {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidForwardCookies, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidForwardCookies()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidForwardCookies {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidForwardCookies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.
public struct InvalidForwardCookies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidForwardCookies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidFunctionAssociation {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidFunctionAssociation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidFunctionAssociation()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidFunctionAssociation {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidFunctionAssociation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A CloudFront function association is invalid.
public struct InvalidFunctionAssociation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFunctionAssociation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidGeoRestrictionParameter {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidGeoRestrictionParameter, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidGeoRestrictionParameter()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidGeoRestrictionParameter {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidGeoRestrictionParameter()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified geo restriction parameter is not valid.
public struct InvalidGeoRestrictionParameter: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidGeoRestrictionParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidHeadersForS3Origin {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidHeadersForS3Origin, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidHeadersForS3Origin()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidHeadersForS3Origin {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidHeadersForS3Origin()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The headers specified are not valid for an Amazon S3 origin.
public struct InvalidHeadersForS3Origin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidHeadersForS3Origin" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidIfMatchVersion {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidIfMatchVersion, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidIfMatchVersion()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidIfMatchVersion {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidIfMatchVersion()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The If-Match version is missing or not valid.
public struct InvalidIfMatchVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidIfMatchVersion" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidLambdaFunctionAssociation {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidLambdaFunctionAssociation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidLambdaFunctionAssociation()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidLambdaFunctionAssociation {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidLambdaFunctionAssociation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified Lambda@Edge function association is invalid.
public struct InvalidLambdaFunctionAssociation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLambdaFunctionAssociation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidLocationCode {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidLocationCode, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidLocationCode()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidLocationCode {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidLocationCode()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The location code specified is not valid.
public struct InvalidLocationCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLocationCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidMinimumProtocolVersion {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidMinimumProtocolVersion, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidMinimumProtocolVersion()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidMinimumProtocolVersion {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidMinimumProtocolVersion()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The minimum protocol version specified is not valid.
public struct InvalidMinimumProtocolVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMinimumProtocolVersion" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidOrigin {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidOrigin, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidOrigin()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidOrigin {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidOrigin()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.
public struct InvalidOrigin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOrigin" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidOriginAccessControl {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidOriginAccessControl, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidOriginAccessControl()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidOriginAccessControl {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The origin access control is not valid.
public struct InvalidOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidOriginAccessIdentity {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidOriginAccessIdentity, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidOriginAccessIdentity()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidOriginAccessIdentity {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidOriginAccessIdentity()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The origin access identity is not valid or doesn't exist.
public struct InvalidOriginAccessIdentity: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginAccessIdentity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidOriginKeepaliveTimeout {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidOriginKeepaliveTimeout, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidOriginKeepaliveTimeout()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidOriginKeepaliveTimeout {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidOriginKeepaliveTimeout()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The keep alive timeout specified for the origin is not valid.
public struct InvalidOriginKeepaliveTimeout: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginKeepaliveTimeout" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidOriginReadTimeout {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidOriginReadTimeout, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidOriginReadTimeout()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidOriginReadTimeout {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidOriginReadTimeout()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The read timeout specified for the origin is not valid.
public struct InvalidOriginReadTimeout: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOriginReadTimeout" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidProtocolSettings {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidProtocolSettings, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidProtocolSettings()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidProtocolSettings {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidProtocolSettings()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).
public struct InvalidProtocolSettings: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidProtocolSettings" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidQueryStringParameters {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidQueryStringParameters, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidQueryStringParameters()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidQueryStringParameters {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidQueryStringParameters()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The query string parameters specified are not valid.
public struct InvalidQueryStringParameters: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryStringParameters" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRelativePath {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidRelativePath, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidRelativePath()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidRelativePath {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidRelativePath()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The relative path is too big, is not URL-encoded, or does not begin with a slash (/).
public struct InvalidRelativePath: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRelativePath" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRequiredProtocol {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidRequiredProtocol, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidRequiredProtocol()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidRequiredProtocol {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidRequiredProtocol()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration.
public struct InvalidRequiredProtocol: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequiredProtocol" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidResponseCode {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidResponseCode, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidResponseCode()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidResponseCode {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidResponseCode()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A response code is not valid.
public struct InvalidResponseCode: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResponseCode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidTTLOrder {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidTTLOrder, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidTTLOrder()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidTTLOrder {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidTTLOrder()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The TTL order specified is not valid.
public struct InvalidTTLOrder: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTTLOrder" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidTagging {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidTagging, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidTagging()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidTagging {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidTagging()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The tagging specified is not valid.
public struct InvalidTagging: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagging" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidViewerCertificate {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidViewerCertificate, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidViewerCertificate()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidViewerCertificate {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidViewerCertificate()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A viewer certificate specified is not valid.
public struct InvalidViewerCertificate: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidViewerCertificate" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidWebACLId {

    static var readingClosure: SmithyReadWrite.ReadingClosure<InvalidWebACLId, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = InvalidWebACLId()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension InvalidWebACLId {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidWebACLId()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a.
public struct InvalidWebACLId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidWebACLId" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.Invalidation {

    static func writingClosure(_ value: CloudFrontClientTypes.Invalidation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["Id"].write(value.id)
        try writer["InvalidationBatch"].write(value.invalidationBatch, writingClosure: CloudFrontClientTypes.InvalidationBatch.writingClosure(_:to:))
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Invalidation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Invalidation()
            value.id = try reader["Id"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
            value.invalidationBatch = try reader["InvalidationBatch"].readIfPresent(readingClosure: CloudFrontClientTypes.InvalidationBatch.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An invalidation.
    public struct Invalidation: Swift.Equatable {
        /// The date and time the invalidation request was first made.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier for the invalidation request. For example: IDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The current invalidation information for the batch request.
        /// This member is required.
        public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
        /// The status of the invalidation request. When the invalidation batch is finished, the status is Completed.
        /// This member is required.
        public var status: Swift.String?

        public init(
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.invalidationBatch = invalidationBatch
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.InvalidationBatch {

    static func writingClosure(_ value: CloudFrontClientTypes.InvalidationBatch?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Paths"].write(value.paths, writingClosure: CloudFrontClientTypes.Paths.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.InvalidationBatch, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.InvalidationBatch()
            value.paths = try reader["Paths"].readIfPresent(readingClosure: CloudFrontClientTypes.Paths.readingClosure)
            value.callerReference = try reader["CallerReference"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An invalidation batch.
    public struct InvalidationBatch: Swift.Equatable {
        /// A value that you specify to uniquely identify an invalidation request. CloudFront uses the value to prevent you from accidentally resubmitting an identical request. Whenever you create a new invalidation request, you must specify a new value for CallerReference and change other values in the request as applicable. One way to ensure that the value of CallerReference is unique is to use a timestamp, for example, 20120301090000. If you make a second invalidation request with the same value for CallerReference, and if the rest of the request is the same, CloudFront doesn't create a new invalidation request. Instead, CloudFront returns information about the invalidation request that you previously created with the same CallerReference. If CallerReference is a value you already sent in a previous invalidation batch request but the content of any Path is different from the original request, CloudFront returns an InvalidationBatchAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var paths: CloudFrontClientTypes.Paths?

        public init(
            callerReference: Swift.String? = nil,
            paths: CloudFrontClientTypes.Paths? = nil
        )
        {
            self.callerReference = callerReference
            self.paths = paths
        }
    }

}

extension CloudFrontClientTypes.InvalidationList {

    static func writingClosure(_ value: CloudFrontClientTypes.InvalidationList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsTruncated"].write(value.isTruncated)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.InvalidationSummary.writingClosure(_:to:), memberNodeInfo: "InvalidationSummary", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.InvalidationList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.InvalidationList()
            value.marker = try reader["Marker"].readIfPresent()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.isTruncated = try reader["IsTruncated"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.InvalidationSummary.readingClosure, memberNodeInfo: "InvalidationSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The InvalidationList complex type describes the list of invalidation objects. For more information about invalidation, see [Invalidating Objects (Web Distributions Only)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html) in the Amazon CloudFront Developer Guide.
    public struct InvalidationList: Swift.Equatable {
        /// A flag that indicates whether more invalidation batch requests remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more invalidation batches in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one InvalidationSummary element for each invalidation batch created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.InvalidationSummary]?
        /// The value that you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value that you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value that you can use for the Marker request parameter to continue listing your invalidation batches where they left off.
        public var nextMarker: Swift.String?
        /// The number of invalidation batches that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.InvalidationSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.InvalidationSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.InvalidationSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: .dateTime)
        try writer["Id"].write(value.id)
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.InvalidationSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.InvalidationSummary()
            value.id = try reader["Id"].readIfPresent()
            value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .dateTime)
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A summary of an invalidation request.
    public struct InvalidationSummary: Swift.Equatable {
        /// The time that an invalidation request was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID for an invalidation request.
        /// This member is required.
        public var id: Swift.String?
        /// The status of an invalidation request.
        /// This member is required.
        public var status: Swift.String?

        public init(
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.status = status
        }
    }

}

extension CloudFrontClientTypes {
    public enum ItemSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemSelection] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemSelection(rawValue: rawValue) ?? ItemSelection.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.KGKeyPairIds {

    static func writingClosure(_ value: CloudFrontClientTypes.KGKeyPairIds?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KeyGroupId"].write(value.keyGroupId)
        try writer["KeyPairIds"].write(value.keyPairIds, writingClosure: CloudFrontClientTypes.KeyPairIds.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KGKeyPairIds, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KGKeyPairIds()
            value.keyGroupId = try reader["KeyGroupId"].readIfPresent()
            value.keyPairIds = try reader["KeyPairIds"].readIfPresent(readingClosure: CloudFrontClientTypes.KeyPairIds.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of identifiers for the public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct KGKeyPairIds: Swift.Equatable {
        /// The identifier of the key group that contains the public keys.
        public var keyGroupId: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init(
            keyGroupId: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.keyGroupId = keyGroupId
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes.KeyGroup {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyGroup?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Id"].write(value.id)
        try writer["KeyGroupConfig"].write(value.keyGroupConfig, writingClosure: CloudFrontClientTypes.KeyGroupConfig.writingClosure(_:to:))
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyGroup, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyGroup()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.keyGroupConfig = try reader["KeyGroupConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.KeyGroupConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A key group. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroup: Swift.Equatable {
        /// The identifier for the key group.
        /// This member is required.
        public var id: Swift.String?
        /// The key group configuration.
        /// This member is required.
        public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
        /// The date and time when the key group was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init(
            id: Swift.String? = nil,
            keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.id = id
            self.keyGroupConfig = keyGroupConfig
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension KeyGroupAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<KeyGroupAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = KeyGroupAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension KeyGroupAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KeyGroupAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A key group with this name already exists. You must provide a unique name. To modify an existing key group, use UpdateKeyGroup.
public struct KeyGroupAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KeyGroupAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.KeyGroupConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyGroupConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "PublicKey", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyGroupConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyGroupConfig()
            value.name = try reader["Name"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "PublicKey", isFlattened: false)
            value.comment = try reader["Comment"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A key group configuration. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroupConfig: Swift.Equatable {
        /// A comment to describe the key group. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A list of the identifiers of the public keys in the key group.
        /// This member is required.
        public var items: [Swift.String]?
        /// A name to identify the key group.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            items: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.items = items
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.KeyGroupList {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyGroupList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.KeyGroupSummary.writingClosure(_:to:), memberNodeInfo: "KeyGroupSummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyGroupList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyGroupList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KeyGroupSummary.readingClosure, memberNodeInfo: "KeyGroupSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups.
    public struct KeyGroupList: Swift.Equatable {
        /// A list of key groups.
        public var items: [CloudFrontClientTypes.KeyGroupSummary]?
        /// The maximum number of key groups requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing key groups.
        public var nextMarker: Swift.String?
        /// The number of key groups returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.KeyGroupSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KeyGroupSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyGroupSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KeyGroup"].write(value.keyGroup, writingClosure: CloudFrontClientTypes.KeyGroup.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyGroupSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyGroupSummary()
            value.keyGroup = try reader["KeyGroup"].readIfPresent(readingClosure: CloudFrontClientTypes.KeyGroup.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a key group.
    public struct KeyGroupSummary: Swift.Equatable {
        /// A key group.
        /// This member is required.
        public var keyGroup: CloudFrontClientTypes.KeyGroup?

        public init(
            keyGroup: CloudFrontClientTypes.KeyGroup? = nil
        )
        {
            self.keyGroup = keyGroup
        }
    }

}

extension CloudFrontClientTypes.KeyPairIds {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyPairIds?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "KeyPairId", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyPairIds, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyPairIds()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "KeyPairId", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront key pair identifiers.
    public struct KeyPairIds: Swift.Equatable {
        /// A list of CloudFront key pair identifiers.
        public var items: [Swift.String]?
        /// The number of key pair identifiers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KeyValueStore {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyValueStore?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["Comment"].write(value.comment)
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyValueStore, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyValueStore()
            value.name = try reader["Name"].readIfPresent()
            value.id = try reader["Id"].readIfPresent()
            value.comment = try reader["Comment"].readIfPresent()
            value.arn = try reader["ARN"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The Key Value Store. Use this to separate data from function code, allowing you to update data without having to publish a new version of a function. The Key Value Store holds keys and their corresponding values.
    public struct KeyValueStore: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Key Value Store.
        /// This member is required.
        public var arn: Swift.String?
        /// A comment for the Key Value Store.
        /// This member is required.
        public var comment: Swift.String?
        /// The unique Id for the Key Value Store.
        /// This member is required.
        public var id: Swift.String?
        /// The last-modified time of the Key Value Store.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the Key Value Store.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the Key Value Store.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.comment = comment
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.KeyValueStoreAssociation {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyValueStoreAssociation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KeyValueStoreARN"].write(value.keyValueStoreARN)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyValueStoreAssociation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyValueStoreAssociation()
            value.keyValueStoreARN = try reader["KeyValueStoreARN"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The Key Value Store association.
    public struct KeyValueStoreAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Key Value Store association.
        /// This member is required.
        public var keyValueStoreARN: Swift.String?

        public init(
            keyValueStoreARN: Swift.String? = nil
        )
        {
            self.keyValueStoreARN = keyValueStoreARN
        }
    }

}

extension CloudFrontClientTypes.KeyValueStoreAssociations {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyValueStoreAssociations?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.KeyValueStoreAssociation.writingClosure(_:to:), memberNodeInfo: "KeyValueStoreAssociation", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyValueStoreAssociations, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyValueStoreAssociations()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KeyValueStoreAssociation.readingClosure, memberNodeInfo: "KeyValueStoreAssociation", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The Key Value Store associations.
    public struct KeyValueStoreAssociations: Swift.Equatable {
        /// The items of the Key Value Store association.
        public var items: [CloudFrontClientTypes.KeyValueStoreAssociation]?
        /// The quantity of Key Value Store associations.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.KeyValueStoreAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KeyValueStoreList {

    static func writingClosure(_ value: CloudFrontClientTypes.KeyValueStoreList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.KeyValueStore.writingClosure(_:to:), memberNodeInfo: "KeyValueStore", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KeyValueStoreList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KeyValueStoreList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.KeyValueStore.readingClosure, memberNodeInfo: "KeyValueStore", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The Key Value Store list.
    public struct KeyValueStoreList: Swift.Equatable {
        /// The items of the Key Value Store list.
        public var items: [CloudFrontClientTypes.KeyValueStore]?
        /// The maximum number of items in the Key Value Store list.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// The next marker associated with the Key Value Store list.
        public var nextMarker: Swift.String?
        /// The quantity of the Key Value Store list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.KeyValueStore]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KinesisStreamConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.KinesisStreamConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["RoleARN"].write(value.roleARN)
        try writer["StreamARN"].write(value.streamARN)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.KinesisStreamConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.KinesisStreamConfig()
            value.roleARN = try reader["RoleARN"].readIfPresent()
            value.streamARN = try reader["StreamARN"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public struct KinesisStreamConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that CloudFront can use to send real-time log data to your Kinesis data stream. For more information the IAM role, see [Real-time log configuration IAM role](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var roleARN: Swift.String?
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time log data.
        /// This member is required.
        public var streamARN: Swift.String?

        public init(
            roleARN: Swift.String? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.roleARN = roleARN
            self.streamARN = streamARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociation {

    static func writingClosure(_ value: CloudFrontClientTypes.LambdaFunctionAssociation?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["EventType"].write(value.eventType)
        try writer["IncludeBody"].write(value.includeBody)
        try writer["LambdaFunctionARN"].write(value.lambdaFunctionARN)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.LambdaFunctionAssociation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.LambdaFunctionAssociation()
            value.lambdaFunctionARN = try reader["LambdaFunctionARN"].readIfPresent()
            value.eventType = try reader["EventType"].readIfPresent()
            value.includeBody = try reader["IncludeBody"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains a Lambda@Edge function association.
    public struct LambdaFunctionAssociation: Swift.Equatable {
        /// Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:
        ///
        /// * viewer-request: The function executes when CloudFront receives a request from a viewer and before it checks to see whether the requested object is in the edge cache.
        ///
        /// * origin-request: The function executes only when CloudFront sends a request to your origin. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * origin-response: The function executes after CloudFront receives a response from the origin and before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * viewer-response: The function executes before CloudFront returns the requested object to the viewer. The function executes regardless of whether the object was already in the edge cache. If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// A flag that allows a Lambda@Edge function to have read access to the body content. For more information, see [Accessing the Request Body by Choosing the Include Body Option](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html) in the Amazon CloudFront Developer Guide.
        public var includeBody: Swift.Bool?
        /// The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias or $LATEST.
        /// This member is required.
        public var lambdaFunctionARN: Swift.String?

        public init(
            eventType: CloudFrontClientTypes.EventType? = nil,
            includeBody: Swift.Bool? = nil,
            lambdaFunctionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.includeBody = includeBody
            self.lambdaFunctionARN = lambdaFunctionARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociations {

    static func writingClosure(_ value: CloudFrontClientTypes.LambdaFunctionAssociations?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.LambdaFunctionAssociation.writingClosure(_:to:), memberNodeInfo: "LambdaFunctionAssociation", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.LambdaFunctionAssociations, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.LambdaFunctionAssociations()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.LambdaFunctionAssociation.readingClosure, memberNodeInfo: "LambdaFunctionAssociation", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that specifies a list of Lambda@Edge functions associations for a cache behavior. If you want to invoke one or more Lambda@Edge functions triggered by requests that match the PathPattern of the cache behavior, specify the applicable values for Quantity and Items. Note that there can be up to 4 LambdaFunctionAssociation items in this list (one for each possible value of EventType) and each EventType can be associated with only one function. If you don't want to invoke any Lambda@Edge functions for the requests that match PathPattern, specify 0 for Quantity and omit Items.
    public struct LambdaFunctionAssociations: Swift.Equatable {
        /// Optional: A complex type that contains LambdaFunctionAssociation items for this cache behavior. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.LambdaFunctionAssociation]?
        /// The number of Lambda@Edge function associations for this cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.LambdaFunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ListCachePoliciesInput {

    static func queryItemProvider(_ value: ListCachePoliciesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCachePoliciesInput {

    static func urlPathProvider(_ value: ListCachePoliciesInput) -> Swift.String? {
        return "/2020-05-31/cache-policy"
    }
}

public struct ListCachePoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of cache policies. The response includes cache policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of cache policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of cache policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.CachePolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.CachePolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

extension ListCachePoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListCachePoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListCachePoliciesOutput()
            value.cachePolicyList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicyList.readingClosure)
            return value
        }
    }
}

public struct ListCachePoliciesOutput: Swift.Equatable {
    /// A list of cache policies.
    public var cachePolicyList: CloudFrontClientTypes.CachePolicyList?

    public init(
        cachePolicyList: CloudFrontClientTypes.CachePolicyList? = nil
    )
    {
        self.cachePolicyList = cachePolicyList
    }
}

enum ListCachePoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput {

    static func queryItemProvider(_ value: ListCloudFrontOriginAccessIdentitiesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput {

    static func urlPathProvider(_ value: ListCloudFrontOriginAccessIdentitiesInput) -> Swift.String? {
        return "/2020-05-31/origin-access-identity/cloudfront"
    }
}

/// The request to list origin access identities.
public struct ListCloudFrontOriginAccessIdentitiesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
    public var marker: Swift.String?
    /// The maximum number of origin access identities you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListCloudFrontOriginAccessIdentitiesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListCloudFrontOriginAccessIdentitiesOutput()
            value.cloudFrontOriginAccessIdentityList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct ListCloudFrontOriginAccessIdentitiesOutput: Swift.Equatable {
    /// The CloudFrontOriginAccessIdentityList type.
    public var cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?

    public init(
        cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityList
    }
}

enum ListCloudFrontOriginAccessIdentitiesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListConflictingAliasesInput {

    static func queryItemProvider(_ value: ListConflictingAliasesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let alias = value.alias else {
            let message = "Creating a URL Query Item failed. alias is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let aliasQueryItem = ClientRuntime.SDKURLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
        items.append(aliasQueryItem)
        guard let distributionId = value.distributionId else {
            let message = "Creating a URL Query Item failed. distributionId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let distributionIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "DistributionId".urlPercentEncoding(), value: Swift.String(distributionId).urlPercentEncoding())
        items.append(distributionIdQueryItem)
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListConflictingAliasesInput {

    static func urlPathProvider(_ value: ListConflictingAliasesInput) -> Swift.String? {
        return "/2020-05-31/conflicting-alias"
    }
}

public struct ListConflictingAliasesInput: Swift.Equatable {
    /// The alias (also called a CNAME) to search for conflicting aliases.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of conflicting aliases that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        alias: Swift.String? = nil,
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListConflictingAliasesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListConflictingAliasesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListConflictingAliasesOutput()
            value.conflictingAliasesList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ConflictingAliasesList.readingClosure)
            return value
        }
    }
}

public struct ListConflictingAliasesOutput: Swift.Equatable {
    /// A list of conflicting aliases.
    public var conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?

    public init(
        conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList? = nil
    )
    {
        self.conflictingAliasesList = conflictingAliasesList
    }
}

enum ListConflictingAliasesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListContinuousDeploymentPoliciesInput {

    static func queryItemProvider(_ value: ListContinuousDeploymentPoliciesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListContinuousDeploymentPoliciesInput {

    static func urlPathProvider(_ value: ListContinuousDeploymentPoliciesInput) -> Swift.String? {
        return "/2020-05-31/continuous-deployment-policy"
    }
}

public struct ListContinuousDeploymentPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of continuous deployment policies. The response includes policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of continuous deployment policies that you want returned in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListContinuousDeploymentPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListContinuousDeploymentPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListContinuousDeploymentPoliciesOutput()
            value.continuousDeploymentPolicyList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicyList.readingClosure)
            return value
        }
    }
}

public struct ListContinuousDeploymentPoliciesOutput: Swift.Equatable {
    /// A list of continuous deployment policies.
    public var continuousDeploymentPolicyList: CloudFrontClientTypes.ContinuousDeploymentPolicyList?

    public init(
        continuousDeploymentPolicyList: CloudFrontClientTypes.ContinuousDeploymentPolicyList? = nil
    )
    {
        self.continuousDeploymentPolicyList = continuousDeploymentPolicyList
    }
}

enum ListContinuousDeploymentPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListDistributionsByCachePolicyIdInput {

    static func queryItemProvider(_ value: ListDistributionsByCachePolicyIdInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByCachePolicyIdInput {

    static func urlPathProvider(_ value: ListDistributionsByCachePolicyIdInput) -> Swift.String? {
        guard let cachePolicyId = value.cachePolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByCachePolicyId/\(cachePolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByCachePolicyIdInput: Swift.Equatable {
    /// The ID of the cache policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var cachePolicyId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        cachePolicyId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.cachePolicyId = cachePolicyId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListDistributionsByCachePolicyIdOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDistributionsByCachePolicyIdOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListDistributionsByCachePolicyIdOutput()
            value.distributionIdList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionIdList.readingClosure)
            return value
        }
    }
}

public struct ListDistributionsByCachePolicyIdOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

enum ListDistributionsByCachePolicyIdOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListDistributionsByKeyGroupInput {

    static func queryItemProvider(_ value: ListDistributionsByKeyGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByKeyGroupInput {

    static func urlPathProvider(_ value: ListDistributionsByKeyGroupInput) -> Swift.String? {
        guard let keyGroupId = value.keyGroupId else {
            return nil
        }
        return "/2020-05-31/distributionsByKeyGroupId/\(keyGroupId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByKeyGroupInput: Swift.Equatable {
    /// The ID of the key group whose associated distribution IDs you are listing.
    /// This member is required.
    public var keyGroupId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        keyGroupId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListDistributionsByKeyGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDistributionsByKeyGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListDistributionsByKeyGroupOutput()
            value.distributionIdList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionIdList.readingClosure)
            return value
        }
    }
}

public struct ListDistributionsByKeyGroupOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

enum ListDistributionsByKeyGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput {

    static func queryItemProvider(_ value: ListDistributionsByOriginRequestPolicyIdInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput {

    static func urlPathProvider(_ value: ListDistributionsByOriginRequestPolicyIdInput) -> Swift.String? {
        guard let originRequestPolicyId = value.originRequestPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByOriginRequestPolicyId/\(originRequestPolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByOriginRequestPolicyIdInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?
    /// The ID of the origin request policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var originRequestPolicyId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        originRequestPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.originRequestPolicyId = originRequestPolicyId
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDistributionsByOriginRequestPolicyIdOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListDistributionsByOriginRequestPolicyIdOutput()
            value.distributionIdList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionIdList.readingClosure)
            return value
        }
    }
}

public struct ListDistributionsByOriginRequestPolicyIdOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

enum ListDistributionsByOriginRequestPolicyIdOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListDistributionsByRealtimeLogConfigInput {
    static func writingClosure(_ value: ListDistributionsByRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["RealtimeLogConfigArn"].write(value.realtimeLogConfigArn)
        try writer["RealtimeLogConfigName"].write(value.realtimeLogConfigName)
    }
}

extension ListDistributionsByRealtimeLogConfigInput {

    static func urlPathProvider(_ value: ListDistributionsByRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/distributionsByRealtimeLogConfig"
    }
}

public struct ListDistributionsByRealtimeLogConfigInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distributions. The response includes distributions in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distributions that you want in the response.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigArn: Swift.String?
    /// The name of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        realtimeLogConfigArn: Swift.String? = nil,
        realtimeLogConfigName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.realtimeLogConfigName = realtimeLogConfigName
    }
}

extension ListDistributionsByRealtimeLogConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDistributionsByRealtimeLogConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListDistributionsByRealtimeLogConfigOutput()
            value.distributionList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionList.readingClosure)
            return value
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigOutput: Swift.Equatable {
    /// A distribution list.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

enum ListDistributionsByRealtimeLogConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput {

    static func queryItemProvider(_ value: ListDistributionsByResponseHeadersPolicyIdInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByResponseHeadersPolicyIdInput {

    static func urlPathProvider(_ value: ListDistributionsByResponseHeadersPolicyIdInput) -> Swift.String? {
        guard let responseHeadersPolicyId = value.responseHeadersPolicyId else {
            return nil
        }
        return "/2020-05-31/distributionsByResponseHeadersPolicyId/\(responseHeadersPolicyId.urlPercentEncoding())"
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want to get in the response.
    public var maxItems: Swift.Int?
    /// The ID of the response headers policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var responseHeadersPolicyId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        responseHeadersPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.responseHeadersPolicyId = responseHeadersPolicyId
    }
}

extension ListDistributionsByResponseHeadersPolicyIdOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDistributionsByResponseHeadersPolicyIdOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListDistributionsByResponseHeadersPolicyIdOutput()
            value.distributionIdList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionIdList.readingClosure)
            return value
        }
    }
}

public struct ListDistributionsByResponseHeadersPolicyIdOutput: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init(
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

enum ListDistributionsByResponseHeadersPolicyIdOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListDistributionsByWebACLIdInput {

    static func queryItemProvider(_ value: ListDistributionsByWebACLIdInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsByWebACLIdInput {

    static func urlPathProvider(_ value: ListDistributionsByWebACLIdInput) -> Swift.String? {
        guard let webACLId = value.webACLId else {
            return nil
        }
        return "/2020-05-31/distributionsByWebACLId/\(webACLId.urlPercentEncoding())"
    }
}

/// The request to list distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdInput: Swift.Equatable {
    /// Use Marker and MaxItems to control pagination of results. If you have more than MaxItems distributions that satisfy the request, the response includes a NextMarker element. To get the next page of results, submit another request. For the value of Marker, specify the value of NextMarker from the last response. (For the first request, omit Marker.)
    public var marker: Swift.String?
    /// The maximum number of distributions that you want CloudFront to return in the response body. The maximum and default values are both 100.
    public var maxItems: Swift.Int?
    /// The ID of the WAF web ACL that you want to list the associated distributions. If you specify "null" for the ID, the request returns a list of the distributions that aren't associated with a web ACL.
    /// This member is required.
    public var webACLId: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        webACLId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.webACLId = webACLId
    }
}

extension ListDistributionsByWebACLIdOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDistributionsByWebACLIdOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListDistributionsByWebACLIdOutput()
            value.distributionList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionList.readingClosure)
            return value
        }
    }
}

/// The response to a request to list the distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdOutput: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

enum ListDistributionsByWebACLIdOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidWebACLId": return try await InvalidWebACLId.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListDistributionsInput {

    static func queryItemProvider(_ value: ListDistributionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListDistributionsInput {

    static func urlPathProvider(_ value: ListDistributionsInput) -> Swift.String? {
        return "/2020-05-31/distribution"
    }
}

/// The request to list your distributions.
public struct ListDistributionsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page).
    public var marker: Swift.String?
    /// The maximum number of distributions you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListDistributionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDistributionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListDistributionsOutput()
            value.distributionList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.DistributionList.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct ListDistributionsOutput: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init(
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

enum ListDistributionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListFieldLevelEncryptionConfigsInput {

    static func queryItemProvider(_ value: ListFieldLevelEncryptionConfigsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFieldLevelEncryptionConfigsInput {

    static func urlPathProvider(_ value: ListFieldLevelEncryptionConfigsInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption"
    }
}

public struct ListFieldLevelEncryptionConfigsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last configuration on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption configurations you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListFieldLevelEncryptionConfigsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListFieldLevelEncryptionConfigsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListFieldLevelEncryptionConfigsOutput()
            value.fieldLevelEncryptionList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionList.readingClosure)
            return value
        }
    }
}

public struct ListFieldLevelEncryptionConfigsOutput: Swift.Equatable {
    /// Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.
    public var fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?

    public init(
        fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList? = nil
    )
    {
        self.fieldLevelEncryptionList = fieldLevelEncryptionList
    }
}

enum ListFieldLevelEncryptionConfigsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListFieldLevelEncryptionProfilesInput {

    static func queryItemProvider(_ value: ListFieldLevelEncryptionProfilesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFieldLevelEncryptionProfilesInput {

    static func urlPathProvider(_ value: ListFieldLevelEncryptionProfilesInput) -> Swift.String? {
        return "/2020-05-31/field-level-encryption-profile"
    }
}

public struct ListFieldLevelEncryptionProfilesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last profile on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption profiles you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListFieldLevelEncryptionProfilesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListFieldLevelEncryptionProfilesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListFieldLevelEncryptionProfilesOutput()
            value.fieldLevelEncryptionProfileList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileList.readingClosure)
            return value
        }
    }
}

public struct ListFieldLevelEncryptionProfilesOutput: Swift.Equatable {
    /// Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.
    public var fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?

    public init(
        fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList? = nil
    )
    {
        self.fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileList
    }
}

enum ListFieldLevelEncryptionProfilesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListFunctionsInput {

    static func queryItemProvider(_ value: ListFunctionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let stage = value.stage {
            let stageQueryItem = ClientRuntime.SDKURLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            items.append(stageQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListFunctionsInput {

    static func urlPathProvider(_ value: ListFunctionsInput) -> Swift.String? {
        return "/2020-05-31/function"
    }
}

public struct ListFunctionsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of functions. The response includes functions in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of functions that you want in the response.
    public var maxItems: Swift.Int?
    /// An optional filter to return only the functions that are in the specified stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.stage = stage
    }
}

extension ListFunctionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListFunctionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListFunctionsOutput()
            value.functionList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FunctionList.readingClosure)
            return value
        }
    }
}

public struct ListFunctionsOutput: Swift.Equatable {
    /// A list of CloudFront functions.
    public var functionList: CloudFrontClientTypes.FunctionList?

    public init(
        functionList: CloudFrontClientTypes.FunctionList? = nil
    )
    {
        self.functionList = functionList
    }
}

enum ListFunctionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListInvalidationsInput {

    static func queryItemProvider(_ value: ListInvalidationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListInvalidationsInput {

    static func urlPathProvider(_ value: ListInvalidationsInput) -> Swift.String? {
        guard let distributionId = value.distributionId else {
            return nil
        }
        return "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
    }
}

/// The request to list invalidations.
public struct ListInvalidationsInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this parameter when paginating results to indicate where to begin in your list of invalidation batches. Because the results are returned in decreasing order from most recent to oldest, the most recent results are on the first page, the second page will contain earlier results, and so on. To get the next page of results, set Marker to the value of the NextMarker from the current page's response. This value is the same as the ID of the last invalidation batch on that page.
    public var marker: Swift.String?
    /// The maximum number of invalidation batches that you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListInvalidationsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListInvalidationsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListInvalidationsOutput()
            value.invalidationList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.InvalidationList.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct ListInvalidationsOutput: Swift.Equatable {
    /// Information about invalidation batches.
    public var invalidationList: CloudFrontClientTypes.InvalidationList?

    public init(
        invalidationList: CloudFrontClientTypes.InvalidationList? = nil
    )
    {
        self.invalidationList = invalidationList
    }
}

enum ListInvalidationsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListKeyGroupsInput {

    static func queryItemProvider(_ value: ListKeyGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListKeyGroupsInput {

    static func urlPathProvider(_ value: ListKeyGroupsInput) -> Swift.String? {
        return "/2020-05-31/key-group"
    }
}

public struct ListKeyGroupsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of key groups. The response includes key groups in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of key groups that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListKeyGroupsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListKeyGroupsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListKeyGroupsOutput()
            value.keyGroupList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyGroupList.readingClosure)
            return value
        }
    }
}

public struct ListKeyGroupsOutput: Swift.Equatable {
    /// A list of key groups.
    public var keyGroupList: CloudFrontClientTypes.KeyGroupList?

    public init(
        keyGroupList: CloudFrontClientTypes.KeyGroupList? = nil
    )
    {
        self.keyGroupList = keyGroupList
    }
}

enum ListKeyGroupsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListKeyValueStoresInput {

    static func queryItemProvider(_ value: ListKeyValueStoresInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListKeyValueStoresInput {

    static func urlPathProvider(_ value: ListKeyValueStoresInput) -> Swift.String? {
        return "/2020-05-31/key-value-store"
    }
}

public struct ListKeyValueStoresInput: Swift.Equatable {
    /// The marker associated with the Key Value Stores list.
    public var marker: Swift.String?
    /// The maximum number of items in the Key Value Stores list.
    public var maxItems: Swift.Int?
    /// The status of the request for the Key Value Stores list.
    public var status: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        status: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.status = status
    }
}

extension ListKeyValueStoresOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListKeyValueStoresOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListKeyValueStoresOutput()
            value.keyValueStoreList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyValueStoreList.readingClosure)
            return value
        }
    }
}

public struct ListKeyValueStoresOutput: Swift.Equatable {
    /// The resulting Key Value Stores list.
    public var keyValueStoreList: CloudFrontClientTypes.KeyValueStoreList?

    public init(
        keyValueStoreList: CloudFrontClientTypes.KeyValueStoreList? = nil
    )
    {
        self.keyValueStoreList = keyValueStoreList
    }
}

enum ListKeyValueStoresOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListOriginAccessControlsInput {

    static func queryItemProvider(_ value: ListOriginAccessControlsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListOriginAccessControlsInput {

    static func urlPathProvider(_ value: ListOriginAccessControlsInput) -> Swift.String? {
        return "/2020-05-31/origin-access-control"
    }
}

public struct ListOriginAccessControlsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of origin access controls. The response includes the items in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of origin access controls that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListOriginAccessControlsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListOriginAccessControlsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListOriginAccessControlsOutput()
            value.originAccessControlList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginAccessControlList.readingClosure)
            return value
        }
    }
}

public struct ListOriginAccessControlsOutput: Swift.Equatable {
    /// A list of origin access controls.
    public var originAccessControlList: CloudFrontClientTypes.OriginAccessControlList?

    public init(
        originAccessControlList: CloudFrontClientTypes.OriginAccessControlList? = nil
    )
    {
        self.originAccessControlList = originAccessControlList
    }
}

enum ListOriginAccessControlsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListOriginRequestPoliciesInput {

    static func queryItemProvider(_ value: ListOriginRequestPoliciesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListOriginRequestPoliciesInput {

    static func urlPathProvider(_ value: ListOriginRequestPoliciesInput) -> Swift.String? {
        return "/2020-05-31/origin-request-policy"
    }
}

public struct ListOriginRequestPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of origin request policies. The response includes origin request policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of origin request policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of origin request policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.OriginRequestPolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

extension ListOriginRequestPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListOriginRequestPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListOriginRequestPoliciesOutput()
            value.originRequestPolicyList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicyList.readingClosure)
            return value
        }
    }
}

public struct ListOriginRequestPoliciesOutput: Swift.Equatable {
    /// A list of origin request policies.
    public var originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?

    public init(
        originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList? = nil
    )
    {
        self.originRequestPolicyList = originRequestPolicyList
    }
}

enum ListOriginRequestPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListPublicKeysInput {

    static func queryItemProvider(_ value: ListPublicKeysInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListPublicKeysInput {

    static func urlPathProvider(_ value: ListPublicKeysInput) -> Swift.String? {
        return "/2020-05-31/public-key"
    }
}

public struct ListPublicKeysInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last public key on that page).
    public var marker: Swift.String?
    /// The maximum number of public keys you want in the response body.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListPublicKeysOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListPublicKeysOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListPublicKeysOutput()
            value.publicKeyList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.PublicKeyList.readingClosure)
            return value
        }
    }
}

public struct ListPublicKeysOutput: Swift.Equatable {
    /// Returns a list of all public keys that have been added to CloudFront for this account.
    public var publicKeyList: CloudFrontClientTypes.PublicKeyList?

    public init(
        publicKeyList: CloudFrontClientTypes.PublicKeyList? = nil
    )
    {
        self.publicKeyList = publicKeyList
    }
}

enum ListPublicKeysOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListRealtimeLogConfigsInput {

    static func queryItemProvider(_ value: ListRealtimeLogConfigsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension ListRealtimeLogConfigsInput {

    static func urlPathProvider(_ value: ListRealtimeLogConfigsInput) -> Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct ListRealtimeLogConfigsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of real-time log configurations. The response includes real-time log configurations in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of real-time log configurations that you want in the response.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListRealtimeLogConfigsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListRealtimeLogConfigsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListRealtimeLogConfigsOutput()
            value.realtimeLogConfigs = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.RealtimeLogConfigs.readingClosure)
            return value
        }
    }
}

public struct ListRealtimeLogConfigsOutput: Swift.Equatable {
    /// A list of real-time log configurations.
    public var realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?

    public init(
        realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs? = nil
    )
    {
        self.realtimeLogConfigs = realtimeLogConfigs
    }
}

enum ListRealtimeLogConfigsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListResponseHeadersPoliciesInput {

    static func queryItemProvider(_ value: ListResponseHeadersPoliciesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListResponseHeadersPoliciesInput {

    static func urlPathProvider(_ value: ListResponseHeadersPoliciesInput) -> Swift.String? {
        return "/2020-05-31/response-headers-policy"
    }
}

public struct ListResponseHeadersPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of response headers policies. The response includes response headers policies in the list that occur after the marker. To get the next page of the list, set this field's value to the value of NextMarker from the current page's response.
    public var marker: Swift.String?
    /// The maximum number of response headers policies that you want to get in the response.
    public var maxItems: Swift.Int?
    /// A filter to get only the specified kind of response headers policies. Valid values are:
    ///
    /// * managed – Gets only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Gets only the custom policies created in your Amazon Web Services account.
    public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

extension ListResponseHeadersPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListResponseHeadersPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListResponseHeadersPoliciesOutput()
            value.responseHeadersPolicyList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyList.readingClosure)
            return value
        }
    }
}

public struct ListResponseHeadersPoliciesOutput: Swift.Equatable {
    /// A list of response headers policies.
    public var responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList?

    public init(
        responseHeadersPolicyList: CloudFrontClientTypes.ResponseHeadersPolicyList? = nil
    )
    {
        self.responseHeadersPolicyList = responseHeadersPolicyList
    }
}

enum ListResponseHeadersPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListStreamingDistributionsInput {

    static func queryItemProvider(_ value: ListStreamingDistributionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = ClientRuntime.SDKURLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListStreamingDistributionsInput {

    static func urlPathProvider(_ value: ListStreamingDistributionsInput) -> Swift.String? {
        return "/2020-05-31/streaming-distribution"
    }
}

/// The request to list your streaming distributions.
public struct ListStreamingDistributionsInput: Swift.Equatable {
    /// The value that you provided for the Marker request parameter.
    public var marker: Swift.String?
    /// The value that you provided for the MaxItems request parameter.
    public var maxItems: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

extension ListStreamingDistributionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListStreamingDistributionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListStreamingDistributionsOutput()
            value.streamingDistributionList = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistributionList.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct ListStreamingDistributionsOutput: Swift.Equatable {
    /// The StreamingDistributionList type.
    public var streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?

    public init(
        streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList? = nil
    )
    {
        self.streamingDistributionList = streamingDistributionList
    }
}

enum ListStreamingDistributionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let resource = value.resource else {
            let message = "Creating a URL Query Item failed. resource is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceQueryItem = ClientRuntime.SDKURLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
        items.append(resourceQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to list tags for a CloudFront resource.
public struct ListTagsForResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?

    public init(
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

extension ListTagsForResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListTagsForResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = ListTagsForResourceOutput()
            value.tags = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Tags.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init(
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTagging": return try await InvalidTagging.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.LoggingConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.LoggingConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["Enabled"].write(value.enabled)
        try writer["IncludeCookies"].write(value.includeCookies)
        try writer["Prefix"].write(value.`prefix`)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.LoggingConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.LoggingConfig()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.includeCookies = try reader["IncludeCookies"].readIfPresent()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for the distribution.
    public struct LoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a distribution or if you want to disable logging for an existing distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket, prefix, and IncludeCookies, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs, specify true for IncludeCookies. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you don't want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify false for IncludeCookies.
        /// This member is required.
        public var includeCookies: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            includeCookies: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.`prefix` = `prefix`
        }
    }

}

extension CloudFrontClientTypes {
    public enum Method: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [Method] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Method(rawValue: rawValue) ?? Method.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum MinimumProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv112016
        case tlsv12016
        case tlsv122018
        case tlsv122019
        case tlsv122021
        case sdkUnknown(Swift.String)

        public static var allCases: [MinimumProtocolVersion] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv112016,
                .tlsv12016,
                .tlsv122018,
                .tlsv122019,
                .tlsv122021,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv112016: return "TLSv1.1_2016"
            case .tlsv12016: return "TLSv1_2016"
            case .tlsv122018: return "TLSv1.2_2018"
            case .tlsv122019: return "TLSv1.2_2019"
            case .tlsv122021: return "TLSv1.2_2021"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MinimumProtocolVersion(rawValue: rawValue) ?? MinimumProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension MissingBody {

    static var readingClosure: SmithyReadWrite.ReadingClosure<MissingBody, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = MissingBody()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension MissingBody {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = MissingBody()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// This operation requires a body. Ensure that the body is present and the Content-Type header is set.
public struct MissingBody: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingBody" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.MonitoringSubscription {

    static func writingClosure(_ value: CloudFrontClientTypes.MonitoringSubscription?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["RealtimeMetricsSubscriptionConfig"].write(value.realtimeMetricsSubscriptionConfig, writingClosure: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.MonitoringSubscription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.MonitoringSubscription()
            value.realtimeMetricsSubscriptionConfig = try reader["RealtimeMetricsSubscriptionConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public struct MonitoringSubscription: Swift.Equatable {
        /// A subscription configuration for additional CloudWatch metrics.
        public var realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?

        public init(
            realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig? = nil
        )
        {
            self.realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig
        }
    }

}

extension MonitoringSubscriptionAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<MonitoringSubscriptionAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = MonitoringSubscriptionAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension MonitoringSubscriptionAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = MonitoringSubscriptionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A monitoring subscription already exists for the specified distribution.
public struct MonitoringSubscriptionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MonitoringSubscriptionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchCachePolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchCachePolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchCachePolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchCachePolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The cache policy does not exist.
public struct NoSuchCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchCloudFrontOriginAccessIdentity {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchCloudFrontOriginAccessIdentity, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchCloudFrontOriginAccessIdentity()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchCloudFrontOriginAccessIdentity {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchCloudFrontOriginAccessIdentity()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified origin access identity does not exist.
public struct NoSuchCloudFrontOriginAccessIdentity: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchCloudFrontOriginAccessIdentity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchContinuousDeploymentPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchContinuousDeploymentPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchContinuousDeploymentPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchContinuousDeploymentPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchContinuousDeploymentPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The continuous deployment policy doesn't exist.
public struct NoSuchContinuousDeploymentPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchContinuousDeploymentPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchDistribution {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchDistribution, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchDistribution()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchDistribution {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified distribution does not exist.
public struct NoSuchDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchFieldLevelEncryptionConfig {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchFieldLevelEncryptionConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchFieldLevelEncryptionConfig()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchFieldLevelEncryptionConfig {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchFieldLevelEncryptionConfig()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified configuration for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFieldLevelEncryptionConfig" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchFieldLevelEncryptionProfile {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchFieldLevelEncryptionProfile, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchFieldLevelEncryptionProfile()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchFieldLevelEncryptionProfile {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchFieldLevelEncryptionProfile()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified profile for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionProfile: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFieldLevelEncryptionProfile" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchFunctionExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchFunctionExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchFunctionExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchFunctionExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchFunctionExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The function does not exist.
public struct NoSuchFunctionExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchFunctionExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchInvalidation {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchInvalidation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchInvalidation()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchInvalidation {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchInvalidation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified invalidation does not exist.
public struct NoSuchInvalidation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchInvalidation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchMonitoringSubscription {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchMonitoringSubscription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchMonitoringSubscription()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchMonitoringSubscription {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchMonitoringSubscription()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A monitoring subscription does not exist for the specified distribution.
public struct NoSuchMonitoringSubscription: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchMonitoringSubscription" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchOrigin {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchOrigin, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchOrigin()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchOrigin {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchOrigin()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// No origin exists with the specified Origin Id.
public struct NoSuchOrigin: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOrigin" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchOriginAccessControl {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchOriginAccessControl, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchOriginAccessControl()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchOriginAccessControl {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The origin access control does not exist.
public struct NoSuchOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchOriginRequestPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchOriginRequestPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchOriginRequestPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchOriginRequestPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The origin request policy does not exist.
public struct NoSuchOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchPublicKey {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchPublicKey, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchPublicKey()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchPublicKey {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchPublicKey()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified public key doesn't exist.
public struct NoSuchPublicKey: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchPublicKey" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchRealtimeLogConfig {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchRealtimeLogConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchRealtimeLogConfig()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchRealtimeLogConfig {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchRealtimeLogConfig()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The real-time log configuration does not exist.
public struct NoSuchRealtimeLogConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchRealtimeLogConfig" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchResource {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchResource, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchResource()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchResource {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchResource()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A resource that was specified is not valid.
public struct NoSuchResource: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResource" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchResponseHeadersPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchResponseHeadersPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchResponseHeadersPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchResponseHeadersPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The response headers policy does not exist.
public struct NoSuchResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NoSuchStreamingDistribution {

    static var readingClosure: SmithyReadWrite.ReadingClosure<NoSuchStreamingDistribution, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = NoSuchStreamingDistribution()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension NoSuchStreamingDistribution {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NoSuchStreamingDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified streaming distribution does not exist.
public struct NoSuchStreamingDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchStreamingDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.Origin {

    static func writingClosure(_ value: CloudFrontClientTypes.Origin?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ConnectionAttempts"].write(value.connectionAttempts)
        try writer["ConnectionTimeout"].write(value.connectionTimeout)
        try writer["CustomHeaders"].write(value.customHeaders, writingClosure: CloudFrontClientTypes.CustomHeaders.writingClosure(_:to:))
        try writer["CustomOriginConfig"].write(value.customOriginConfig, writingClosure: CloudFrontClientTypes.CustomOriginConfig.writingClosure(_:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Id"].write(value.id)
        try writer["OriginAccessControlId"].write(value.originAccessControlId)
        try writer["OriginPath"].write(value.originPath)
        try writer["OriginShield"].write(value.originShield, writingClosure: CloudFrontClientTypes.OriginShield.writingClosure(_:to:))
        try writer["S3OriginConfig"].write(value.s3OriginConfig, writingClosure: CloudFrontClientTypes.S3OriginConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Origin, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Origin()
            value.id = try reader["Id"].readIfPresent()
            value.domainName = try reader["DomainName"].readIfPresent()
            value.originPath = try reader["OriginPath"].readIfPresent()
            value.customHeaders = try reader["CustomHeaders"].readIfPresent(readingClosure: CloudFrontClientTypes.CustomHeaders.readingClosure)
            value.s3OriginConfig = try reader["S3OriginConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.S3OriginConfig.readingClosure)
            value.customOriginConfig = try reader["CustomOriginConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.CustomOriginConfig.readingClosure)
            value.connectionAttempts = try reader["ConnectionAttempts"].readIfPresent()
            value.connectionTimeout = try reader["ConnectionTimeout"].readIfPresent()
            value.originShield = try reader["OriginShield"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginShield.readingClosure)
            value.originAccessControlId = try reader["OriginAccessControlId"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An origin. An origin is the location where content is stored, and from which CloudFront gets content to serve to viewers. To specify an origin:
    ///
    /// * Use S3OriginConfig to specify an Amazon S3 bucket that is not configured with static website hosting.
    ///
    /// * Use CustomOriginConfig to specify all other kinds of origins, including:
    ///
    /// * An Amazon S3 bucket that is configured with static website hosting
    ///
    /// * An Elastic Load Balancing load balancer
    ///
    /// * An Elemental MediaPackage endpoint
    ///
    /// * An Elemental MediaStore container
    ///
    /// * Any other HTTP server, running on an Amazon EC2 instance or any other kind of host
    ///
    ///
    ///
    ///
    ///
    /// For the current maximum number of origins that you can specify per distribution, see [General Quotas on Web Distributions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions) in the Amazon CloudFront Developer Guide (quotas were formerly referred to as limits).
    public struct Origin: Swift.Equatable {
        /// The number of times that CloudFront attempts to connect to the origin. The minimum number is 1, the maximum is 3, and the default (if you don't specify otherwise) is 3. For a custom origin (including an Amazon S3 bucket that's configured with static website hosting), this value also specifies the number of times that CloudFront attempts to get a response from the origin, in the case of an [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout). For more information, see [Origin Connection Attempts](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts) in the Amazon CloudFront Developer Guide.
        public var connectionAttempts: Swift.Int?
        /// The number of seconds that CloudFront waits when trying to establish a connection to the origin. The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you don't specify otherwise) is 10 seconds. For more information, see [Origin Connection Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout) in the Amazon CloudFront Developer Guide.
        public var connectionTimeout: Swift.Int?
        /// A list of HTTP header names and values that CloudFront adds to the requests that it sends to the origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html) in the Amazon CloudFront Developer Guide.
        public var customHeaders: CloudFrontClientTypes.CustomHeaders?
        /// Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public var customOriginConfig: CloudFrontClientTypes.CustomOriginConfig?
        /// The domain name for the origin. For more information, see [Origin Domain Name](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the origin. This value must be unique within the distribution. Use this value to specify the TargetOriginId in a CacheBehavior or DefaultCacheBehavior.
        /// This member is required.
        public var id: Swift.String?
        /// The unique identifier of an origin access control for this origin. For more information, see [Restricting access to an Amazon S3 origin](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        public var originAccessControlId: Swift.String?
        /// An optional path that CloudFront appends to the origin domain name when CloudFront requests content from the origin. For more information, see [Origin Path](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath) in the Amazon CloudFront Developer Guide.
        public var originPath: Swift.String?
        /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
        public var originShield: CloudFrontClientTypes.OriginShield?
        /// Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static website hosting. To specify any other type of origin, including an Amazon S3 bucket that is configured with static website hosting, use the CustomOriginConfig type instead.
        public var s3OriginConfig: CloudFrontClientTypes.S3OriginConfig?

        public init(
            connectionAttempts: Swift.Int? = nil,
            connectionTimeout: Swift.Int? = nil,
            customHeaders: CloudFrontClientTypes.CustomHeaders? = nil,
            customOriginConfig: CloudFrontClientTypes.CustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originAccessControlId: Swift.String? = nil,
            originPath: Swift.String? = nil,
            originShield: CloudFrontClientTypes.OriginShield? = nil,
            s3OriginConfig: CloudFrontClientTypes.S3OriginConfig? = nil
        )
        {
            self.connectionAttempts = connectionAttempts
            self.connectionTimeout = connectionTimeout
            self.customHeaders = customHeaders
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originAccessControlId = originAccessControlId
            self.originPath = originPath
            self.originShield = originShield
            self.s3OriginConfig = s3OriginConfig
        }
    }

}

extension CloudFrontClientTypes.OriginAccessControl {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginAccessControl?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Id"].write(value.id)
        try writer["OriginAccessControlConfig"].write(value.originAccessControlConfig, writingClosure: CloudFrontClientTypes.OriginAccessControlConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginAccessControl, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginAccessControl()
            value.id = try reader["Id"].readIfPresent()
            value.originAccessControlConfig = try reader["OriginAccessControlConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginAccessControlConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront origin access control, including its unique identifier.
    public struct OriginAccessControl: Swift.Equatable {
        /// The unique identifier of the origin access control.
        /// This member is required.
        public var id: Swift.String?
        /// The origin access control.
        public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

        public init(
            id: Swift.String? = nil,
            originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
        )
        {
            self.id = id
            self.originAccessControlConfig = originAccessControlConfig
        }
    }

}

extension OriginAccessControlAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<OriginAccessControlAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = OriginAccessControlAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension OriginAccessControlAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = OriginAccessControlAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An origin access control with the specified parameters already exists.
public struct OriginAccessControlAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginAccessControlAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.OriginAccessControlConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginAccessControlConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["OriginAccessControlOriginType"].write(value.originAccessControlOriginType)
        try writer["SigningBehavior"].write(value.signingBehavior)
        try writer["SigningProtocol"].write(value.signingProtocol)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginAccessControlConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginAccessControlConfig()
            value.name = try reader["Name"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            value.signingProtocol = try reader["SigningProtocol"].readIfPresent()
            value.signingBehavior = try reader["SigningBehavior"].readIfPresent()
            value.originAccessControlOriginType = try reader["OriginAccessControlOriginType"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront origin access control configuration.
    public struct OriginAccessControlConfig: Swift.Equatable {
        /// A description of the origin access control.
        public var description: Swift.String?
        /// A name to identify the origin access control.
        /// This member is required.
        public var name: Swift.String?
        /// The type of origin that this origin access control is for.
        /// This member is required.
        public var originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes?
        /// Specifies which requests CloudFront signs (adds authentication information to). Specify always for the most common use case. For more information, see [origin access control advanced settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html#oac-advanced-settings) in the Amazon CloudFront Developer Guide. This field can have one of the following values:
        ///
        /// * always – CloudFront signs all origin requests, overwriting the Authorization header from the viewer request if one exists.
        ///
        /// * never – CloudFront doesn't sign any origin requests. This value turns off origin access control for all origins in all distributions that use this origin access control.
        ///
        /// * no-override – If the viewer request doesn't contain the Authorization header, then CloudFront signs the origin request. If the viewer request contains the Authorization header, then CloudFront doesn't sign the origin request and instead passes along the Authorization header from the viewer request. WARNING: To pass along the Authorization header from the viewer request, you must add the Authorization header to a [cache policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html) for all cache behaviors that use origins associated with this origin access control.
        /// This member is required.
        public var signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors?
        /// The signing protocol of the origin access control, which determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
        /// This member is required.
        public var signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes? = nil,
            signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors? = nil,
            signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols? = nil
        )
        {
            self.description = description
            self.name = name
            self.originAccessControlOriginType = originAccessControlOriginType
            self.signingBehavior = signingBehavior
            self.signingProtocol = signingProtocol
        }
    }

}

extension OriginAccessControlInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<OriginAccessControlInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = OriginAccessControlInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension OriginAccessControlInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = OriginAccessControlInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Cannot delete the origin access control because it's in use by one or more distributions.
public struct OriginAccessControlInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginAccessControlInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.OriginAccessControlList {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginAccessControlList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsTruncated"].write(value.isTruncated)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginAccessControlSummary.writingClosure(_:to:), memberNodeInfo: "OriginAccessControlSummary", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginAccessControlList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginAccessControlList()
            value.marker = try reader["Marker"].readIfPresent()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.isTruncated = try reader["IsTruncated"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginAccessControlSummary.readingClosure, memberNodeInfo: "OriginAccessControlSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront origin access controls.
    public struct OriginAccessControlList: Swift.Equatable {
        /// If there are more items in the list than are in this response, this value is true.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the origin access controls in the list.
        public var items: [CloudFrontClientTypes.OriginAccessControlSummary]?
        /// The value of the Marker field that was provided in the request.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access controls requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value to use in the Marker field of another request to continue listing origin access controls.
        public var nextMarker: Swift.String?
        /// The number of origin access controls returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.OriginAccessControlSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginAccessControlOriginTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mediastore
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlOriginTypes] {
            return [
                .mediastore,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mediastore: return "mediastore"
            case .s3: return "s3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginAccessControlOriginTypes(rawValue: rawValue) ?? OriginAccessControlOriginTypes.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum OriginAccessControlSigningBehaviors: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case never
        case noOverride
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlSigningBehaviors] {
            return [
                .always,
                .never,
                .noOverride,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "always"
            case .never: return "never"
            case .noOverride: return "no-override"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginAccessControlSigningBehaviors(rawValue: rawValue) ?? OriginAccessControlSigningBehaviors.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum OriginAccessControlSigningProtocols: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sigv4
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginAccessControlSigningProtocols] {
            return [
                .sigv4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sigv4: return "sigv4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginAccessControlSigningProtocols(rawValue: rawValue) ?? OriginAccessControlSigningProtocols.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginAccessControlSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginAccessControlSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["OriginAccessControlOriginType"].write(value.originAccessControlOriginType)
        try writer["SigningBehavior"].write(value.signingBehavior)
        try writer["SigningProtocol"].write(value.signingProtocol)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginAccessControlSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginAccessControlSummary()
            value.id = try reader["Id"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.signingProtocol = try reader["SigningProtocol"].readIfPresent()
            value.signingBehavior = try reader["SigningBehavior"].readIfPresent()
            value.originAccessControlOriginType = try reader["OriginAccessControlOriginType"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront origin access control.
    public struct OriginAccessControlSummary: Swift.Equatable {
        /// A description of the origin access control.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the origin access control.
        /// This member is required.
        public var id: Swift.String?
        /// A unique name that identifies the origin access control.
        /// This member is required.
        public var name: Swift.String?
        /// The type of origin that this origin access control is for.
        /// This member is required.
        public var originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes?
        /// A value that specifies which requests CloudFront signs (adds authentication information to). This field can have one of the following values:
        ///
        /// * never – CloudFront doesn't sign any origin requests.
        ///
        /// * always – CloudFront signs all origin requests, overwriting the Authorization header from the viewer request if necessary.
        ///
        /// * no-override – If the viewer request doesn't contain the Authorization header, CloudFront signs the origin request. If the viewer request contains the Authorization header, CloudFront doesn't sign the origin request, but instead passes along the Authorization header that it received in the viewer request.
        /// This member is required.
        public var signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors?
        /// The signing protocol of the origin access control. The signing protocol determines how CloudFront signs (authenticates) requests. The only valid value is sigv4.
        /// This member is required.
        public var signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            originAccessControlOriginType: CloudFrontClientTypes.OriginAccessControlOriginTypes? = nil,
            signingBehavior: CloudFrontClientTypes.OriginAccessControlSigningBehaviors? = nil,
            signingProtocol: CloudFrontClientTypes.OriginAccessControlSigningProtocols? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.originAccessControlOriginType = originAccessControlOriginType
            self.signingBehavior = signingBehavior
            self.signingProtocol = signingProtocol
        }
    }

}

extension CloudFrontClientTypes.OriginCustomHeader {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginCustomHeader?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["HeaderName"].write(value.headerName)
        try writer["HeaderValue"].write(value.headerValue)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginCustomHeader, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginCustomHeader()
            value.headerName = try reader["HeaderName"].readIfPresent()
            value.headerValue = try reader["HeaderValue"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginCustomHeader(headerName: \(Swift.String(describing: headerName)), headerValue: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes {
    /// A complex type that contains HeaderName and HeaderValue elements, if any, for this distribution.
    public struct OriginCustomHeader: Swift.Equatable {
        /// The name of a header that you want CloudFront to send to your origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var headerName: Swift.String?
        /// The value for the header that you specified in the HeaderName field.
        /// This member is required.
        public var headerValue: Swift.String?

        public init(
            headerName: Swift.String? = nil,
            headerValue: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.headerValue = headerValue
        }
    }

}

extension CloudFrontClientTypes.OriginGroup {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginGroup?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FailoverCriteria"].write(value.failoverCriteria, writingClosure: CloudFrontClientTypes.OriginGroupFailoverCriteria.writingClosure(_:to:))
        try writer["Id"].write(value.id)
        try writer["Members"].write(value.members, writingClosure: CloudFrontClientTypes.OriginGroupMembers.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginGroup, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginGroup()
            value.id = try reader["Id"].readIfPresent()
            value.failoverCriteria = try reader["FailoverCriteria"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginGroupFailoverCriteria.readingClosure)
            value.members = try reader["Members"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginGroupMembers.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify. You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specify the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin under the failover conditions that you've chosen.
    public struct OriginGroup: Swift.Equatable {
        /// A complex type that contains information about the failover criteria for an origin group.
        /// This member is required.
        public var failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria?
        /// The origin group's ID.
        /// This member is required.
        public var id: Swift.String?
        /// A complex type that contains information about the origins in an origin group.
        /// This member is required.
        public var members: CloudFrontClientTypes.OriginGroupMembers?

        public init(
            failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria? = nil,
            id: Swift.String? = nil,
            members: CloudFrontClientTypes.OriginGroupMembers? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
            self.id = id
            self.members = members
        }
    }

}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginGroupFailoverCriteria?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StatusCodes"].write(value.statusCodes, writingClosure: CloudFrontClientTypes.StatusCodes.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginGroupFailoverCriteria, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginGroupFailoverCriteria()
            value.statusCodes = try reader["StatusCodes"].readIfPresent(readingClosure: CloudFrontClientTypes.StatusCodes.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes information about the failover criteria for an origin group, including the status codes for which CloudFront will failover from the primary origin to the second origin.
    public struct OriginGroupFailoverCriteria: Swift.Equatable {
        /// The status codes that, when returned from the primary origin, will trigger CloudFront to failover to the second origin.
        /// This member is required.
        public var statusCodes: CloudFrontClientTypes.StatusCodes?

        public init(
            statusCodes: CloudFrontClientTypes.StatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMember {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginGroupMember?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["OriginId"].write(value.originId)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginGroupMember, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginGroupMember()
            value.originId = try reader["OriginId"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An origin in an origin group.
    public struct OriginGroupMember: Swift.Equatable {
        /// The ID for an origin in an origin group.
        /// This member is required.
        public var originId: Swift.String?

        public init(
            originId: Swift.String? = nil
        )
        {
            self.originId = originId
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMembers {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginGroupMembers?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginGroupMember.writingClosure(_:to:), memberNodeInfo: "OriginGroupMember", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginGroupMembers, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginGroupMembers()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginGroupMember.readingClosure, memberNodeInfo: "OriginGroupMember", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origins included in an origin group.
    public struct OriginGroupMembers: Swift.Equatable {
        /// Items (origins) in an origin group.
        /// This member is required.
        public var items: [CloudFrontClientTypes.OriginGroupMember]?
        /// The number of origins in an origin group.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginGroupMember]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.OriginGroups {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginGroups?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginGroup.writingClosure(_:to:), memberNodeInfo: "OriginGroup", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginGroups, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginGroups()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginGroup.readingClosure, memberNodeInfo: "OriginGroup", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origin groups specified for a distribution.
    public struct OriginGroups: Swift.Equatable {
        /// The items (origin groups) in a distribution.
        public var items: [CloudFrontClientTypes.OriginGroup]?
        /// The number of origin groups.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginGroup]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpOnly
        case httpsOnly
        case matchViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginProtocolPolicy] {
            return [
                .httpOnly,
                .httpsOnly,
                .matchViewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpOnly: return "http-only"
            case .httpsOnly: return "https-only"
            case .matchViewer: return "match-viewer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginProtocolPolicy(rawValue: rawValue) ?? OriginProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginRequestPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["OriginRequestPolicyConfig"].write(value.originRequestPolicyConfig, writingClosure: CloudFrontClientTypes.OriginRequestPolicyConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginRequestPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginRequestPolicy()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.originRequestPolicyConfig = try reader["OriginRequestPolicyConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicyConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy. When it's attached to a cache behavior, the origin request policy determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can't find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicy: Swift.Equatable {
        /// The unique identifier for the origin request policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the origin request policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The origin request policy configuration.
        /// This member is required.
        public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

        public init(
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.originRequestPolicyConfig = originRequestPolicyConfig
        }
    }

}

extension OriginRequestPolicyAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<OriginRequestPolicyAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = OriginRequestPolicyAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension OriginRequestPolicyAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = OriginRequestPolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use UpdateOriginRequestPolicy.
public struct OriginRequestPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginRequestPolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginRequestPolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["CookiesConfig"].write(value.cookiesConfig, writingClosure: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.writingClosure(_:to:))
        try writer["HeadersConfig"].write(value.headersConfig, writingClosure: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.writingClosure(_:to:))
        try writer["Name"].write(value.name)
        try writer["QueryStringsConfig"].write(value.queryStringsConfig, writingClosure: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginRequestPolicyConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginRequestPolicyConfig()
            value.comment = try reader["Comment"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.headersConfig = try reader["HeadersConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.readingClosure)
            value.cookiesConfig = try reader["CookiesConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.readingClosure)
            value.queryStringsConfig = try reader["QueryStringsConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy configuration. This configuration determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can't find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicyConfig: Swift.Equatable {
        /// A comment to describe the origin request policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The cookies from viewer requests to include in origin requests.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?
        /// The HTTP headers to include in origin requests. These can include headers from viewer requests and additional headers added by CloudFront.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?
        /// A unique name to identify the origin request policy.
        /// This member is required.
        public var name: Swift.String?
        /// The URL query strings from viewer requests to include in origin requests.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?

        public init(
            comment: Swift.String? = nil,
            cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig? = nil,
            headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig? = nil,
            name: Swift.String? = nil,
            queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig? = nil
        )
        {
            self.comment = comment
            self.cookiesConfig = cookiesConfig
            self.headersConfig = headersConfig
            self.name = name
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyCookieBehavior(rawValue: rawValue) ?? OriginRequestPolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CookieBehavior"].write(value.cookieBehavior)
        try writer["Cookies"].write(value.cookies, writingClosure: CloudFrontClientTypes.CookieNames.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginRequestPolicyCookiesConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginRequestPolicyCookiesConfig()
            value.cookieBehavior = try reader["CookieBehavior"].readIfPresent()
            value.cookies = try reader["Cookies"].readIfPresent(readingClosure: CloudFrontClientTypes.CookieNames.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyCookiesConfig: Swift.Equatable {
        /// Determines whether cookies in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No cookies in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – Only the cookies in viewer requests that are listed in the CookieNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All cookies in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All cookies in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the CookieNames type, which are not included.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init(
            cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allexcept
        case allviewer
        case allviewerandwhitelistcloudfront
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyHeaderBehavior] {
            return [
                .allexcept,
                .allviewer,
                .allviewerandwhitelistcloudfront,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allexcept: return "allExcept"
            case .allviewer: return "allViewer"
            case .allviewerandwhitelistcloudfront: return "allViewerAndWhitelistCloudFront"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyHeaderBehavior(rawValue: rawValue) ?? OriginRequestPolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["HeaderBehavior"].write(value.headerBehavior)
        try writer["Headers"].write(value.headers, writingClosure: CloudFrontClientTypes.Headers.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginRequestPolicyHeadersConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginRequestPolicyHeadersConfig()
            value.headerBehavior = try reader["HeaderBehavior"].readIfPresent()
            value.headers = try reader["Headers"].readIfPresent(readingClosure: CloudFrontClientTypes.Headers.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No HTTP headers in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – Only the HTTP headers that are listed in the Headers type are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewer – All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewerAndWhitelistCloudFront – All HTTP headers in viewer requests and the additional CloudFront headers that are listed in the Headers type are included in requests that CloudFront sends to the origin. The additional headers are added by CloudFront.
        ///
        /// * allExcept – All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the Headers type, which are not included.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init(
            headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension OriginRequestPolicyInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<OriginRequestPolicyInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = OriginRequestPolicyInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension OriginRequestPolicyInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = OriginRequestPolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Cannot delete the origin request policy because it is attached to one or more cache behaviors.
public struct OriginRequestPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OriginRequestPolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginRequestPolicyList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.OriginRequestPolicySummary.writingClosure(_:to:), memberNodeInfo: "OriginRequestPolicySummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginRequestPolicyList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginRequestPolicyList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.OriginRequestPolicySummary.readingClosure, memberNodeInfo: "OriginRequestPolicySummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of origin request policies.
    public struct OriginRequestPolicyList: Swift.Equatable {
        /// Contains the origin request policies in the list.
        public var items: [CloudFrontClientTypes.OriginRequestPolicySummary]?
        /// The maximum number of origin request policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing origin request policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of origin request policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.OriginRequestPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyQueryStringBehavior(rawValue: rawValue) ?? OriginRequestPolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["QueryStringBehavior"].write(value.queryStringBehavior)
        try writer["QueryStrings"].write(value.queryStrings, writingClosure: CloudFrontClientTypes.QueryStringNames.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig()
            value.queryStringBehavior = try reader["QueryStringBehavior"].readIfPresent()
            value.queryStrings = try reader["QueryStrings"].readIfPresent(readingClosure: CloudFrontClientTypes.QueryStringNames.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – No query strings in viewer requests are included in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – Only the query strings in viewer requests that are listed in the QueryStringNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All query strings in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All query strings in viewer requests are included in requests that CloudFront sends to the origin, except for those listed in the QueryStringNames type, which are not included.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the OriginRequestPolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init(
            queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.OriginRequestPolicySummary {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginRequestPolicySummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["OriginRequestPolicy"].write(value.originRequestPolicy, writingClosure: CloudFrontClientTypes.OriginRequestPolicy.writingClosure(_:to:))
        try writer["Type"].write(value.type)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginRequestPolicySummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginRequestPolicySummary()
            value.type = try reader["Type"].readIfPresent()
            value.originRequestPolicy = try reader["OriginRequestPolicy"].readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicy.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains an origin request policy.
    public struct OriginRequestPolicySummary: Swift.Equatable {
        /// The origin request policy.
        /// This member is required.
        public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
        /// The type of origin request policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.OriginRequestPolicyType?

        public init(
            originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil,
            type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
        )
        {
            self.originRequestPolicy = originRequestPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyType(rawValue: rawValue) ?? OriginRequestPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginShield {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginShield?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Enabled"].write(value.enabled)
        try writer["OriginShieldRegion"].write(value.originShieldRegion)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginShield, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginShield()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.originShieldRegion = try reader["OriginShieldRegion"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
    public struct OriginShield: Swift.Equatable {
        /// A flag that specifies whether Origin Shield is enabled. When it's enabled, CloudFront routes all requests through Origin Shield, which can help protect your origin. When it's disabled, CloudFront might send requests directly to your origin from multiple edge locations or regional edge caches.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The Amazon Web Services Region for Origin Shield. Specify the Amazon Web Services Region that has the lowest latency to your origin. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2. When you enable CloudFront Origin Shield, you must specify the Amazon Web Services Region for Origin Shield. For the list of Amazon Web Services Regions that you can specify, and for help choosing the best Region for your origin, see [Choosing the Amazon Web Services Region for Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region) in the Amazon CloudFront Developer Guide.
        public var originShieldRegion: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            originShieldRegion: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.originShieldRegion = originShieldRegion
        }
    }

}

extension CloudFrontClientTypes.OriginSslProtocols {

    static func writingClosure(_ value: CloudFrontClientTypes.OriginSslProtocols?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.SslProtocol.writingClosure(_:to:), memberNodeInfo: "SslProtocol", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.OriginSslProtocols, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.OriginSslProtocols()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.SslProtocol.readingClosure, memberNodeInfo: "SslProtocol", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin.
    public struct OriginSslProtocols: Swift.Equatable {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        /// This member is required.
        public var items: [CloudFrontClientTypes.SslProtocol]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.SslProtocol]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.Origins {

    static func writingClosure(_ value: CloudFrontClientTypes.Origins?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.Origin.writingClosure(_:to:), memberNodeInfo: "Origin", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Origins, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Origins()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Origin.readingClosure, memberNodeInfo: "Origin", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the origins for this distribution.
    public struct Origins: Swift.Equatable {
        /// A list of origins.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Origin]?
        /// The number of origins for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.Origin]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin {

    static func writingClosure(_ value: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CookiesConfig"].write(value.cookiesConfig, writingClosure: CloudFrontClientTypes.CachePolicyCookiesConfig.writingClosure(_:to:))
        try writer["EnableAcceptEncodingBrotli"].write(value.enableAcceptEncodingBrotli)
        try writer["EnableAcceptEncodingGzip"].write(value.enableAcceptEncodingGzip)
        try writer["HeadersConfig"].write(value.headersConfig, writingClosure: CloudFrontClientTypes.CachePolicyHeadersConfig.writingClosure(_:to:))
        try writer["QueryStringsConfig"].write(value.queryStringsConfig, writingClosure: CloudFrontClientTypes.CachePolicyQueryStringsConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin()
            value.enableAcceptEncodingGzip = try reader["EnableAcceptEncodingGzip"].readIfPresent()
            value.enableAcceptEncodingBrotli = try reader["EnableAcceptEncodingBrotli"].readIfPresent()
            value.headersConfig = try reader["HeadersConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicyHeadersConfig.readingClosure)
            value.cookiesConfig = try reader["CookiesConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicyCookiesConfig.readingClosure)
            value.queryStringsConfig = try reader["QueryStringsConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicyQueryStringsConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// This object determines the values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer. The headers, cookies, and query strings that are included in the cache key are also included in requests that CloudFront sends to the origin. CloudFront sends a request when it can't find an object in its cache that matches the request's cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct ParametersInCacheKeyAndForwardedToOrigin: Swift.Equatable {
        /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingGzip field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer's Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it's not included in the cache key and it's not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        public var enableAcceptEncodingBrotli: Swift.Bool?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingBrotli field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer's Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it's not included in the cache key and it's not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        /// This member is required.
        public var enableAcceptEncodingGzip: Swift.Bool?
        /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig?
        /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig?

        public init(
            cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig? = nil,
            enableAcceptEncodingBrotli: Swift.Bool? = nil,
            enableAcceptEncodingGzip: Swift.Bool? = nil,
            headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig? = nil,
            queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig? = nil
        )
        {
            self.cookiesConfig = cookiesConfig
            self.enableAcceptEncodingBrotli = enableAcceptEncodingBrotli
            self.enableAcceptEncodingGzip = enableAcceptEncodingGzip
            self.headersConfig = headersConfig
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes.Paths {

    static func writingClosure(_ value: CloudFrontClientTypes.Paths?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Path", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Paths, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Paths()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Path", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
    public struct Paths: Swift.Equatable {
        /// A complex type that contains a list of the paths that you want to invalidate.
        public var items: [Swift.String]?
        /// The number of invalidation paths specified for the objects that you want to invalidate.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension PreconditionFailed {

    static var readingClosure: SmithyReadWrite.ReadingClosure<PreconditionFailed, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = PreconditionFailed()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension PreconditionFailed {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PreconditionFailed()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The precondition in one or more of the request fields evaluated to false.
public struct PreconditionFailed: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailed" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes {
    public enum PriceClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case priceclass100
        case priceclass200
        case priceclassAll
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceClass] {
            return [
                .priceclass100,
                .priceclass200,
                .priceclassAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .priceclass100: return "PriceClass_100"
            case .priceclass200: return "PriceClass_200"
            case .priceclassAll: return "PriceClass_All"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PriceClass(rawValue: rawValue) ?? PriceClass.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.PublicKey {

    static func writingClosure(_ value: CloudFrontClientTypes.PublicKey?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CreatedTime"].writeTimestamp(value.createdTime, format: .dateTime)
        try writer["Id"].write(value.id)
        try writer["PublicKeyConfig"].write(value.publicKeyConfig, writingClosure: CloudFrontClientTypes.PublicKeyConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.PublicKey, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.PublicKey()
            value.id = try reader["Id"].readIfPresent()
            value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .dateTime)
            value.publicKeyConfig = try reader["PublicKeyConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.PublicKeyConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKey: Swift.Equatable {
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
        )
        {
            self.createdTime = createdTime
            self.id = id
            self.publicKeyConfig = publicKeyConfig
        }
    }

}

extension PublicKeyAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<PublicKeyAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = PublicKeyAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension PublicKeyAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PublicKeyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified public key already exists.
public struct PublicKeyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PublicKeyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.PublicKeyConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.PublicKeyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["EncodedKey"].write(value.encodedKey)
        try writer["Name"].write(value.name)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.PublicKeyConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.PublicKeyConfig()
            value.callerReference = try reader["CallerReference"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.encodedKey = try reader["EncodedKey"].readIfPresent()
            value.comment = try reader["Comment"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyConfig: Swift.Equatable {
        /// A string included in the request to help make sure that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var encodedKey: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init(
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encodedKey: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encodedKey = encodedKey
            self.name = name
        }
    }

}

extension PublicKeyInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<PublicKeyInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = PublicKeyInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension PublicKeyInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PublicKeyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified public key is in use.
public struct PublicKeyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PublicKeyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.PublicKeyList {

    static func writingClosure(_ value: CloudFrontClientTypes.PublicKeyList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.PublicKeySummary.writingClosure(_:to:), memberNodeInfo: "PublicKeySummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.PublicKeyList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.PublicKeyList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.PublicKeySummary.readingClosure, memberNodeInfo: "PublicKeySummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of public keys that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyList: Swift.Equatable {
        /// A list of public keys.
        public var items: [CloudFrontClientTypes.PublicKeySummary]?
        /// The maximum number of public keys you want in the response.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your public keys where you left off.
        public var nextMarker: Swift.String?
        /// The number of public keys in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.PublicKeySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.PublicKeySummary {

    static func writingClosure(_ value: CloudFrontClientTypes.PublicKeySummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["CreatedTime"].writeTimestamp(value.createdTime, format: .dateTime)
        try writer["EncodedKey"].write(value.encodedKey)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.PublicKeySummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.PublicKeySummary()
            value.id = try reader["Id"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .dateTime)
            value.encodedKey = try reader["EncodedKey"].readIfPresent()
            value.comment = try reader["Comment"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a public key.
    public struct PublicKeySummary: Swift.Equatable {
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The public key.
        /// This member is required.
        public var encodedKey: Swift.String?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init(
            comment: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encodedKey: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.createdTime = createdTime
            self.encodedKey = encodedKey
            self.id = id
            self.name = name
        }
    }

}

extension PublishFunctionInput {

    static func headerProvider(_ value: PublishFunctionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension PublishFunctionInput {

    static func urlPathProvider(_ value: PublishFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/publish"
    }
}

public struct PublishFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are publishing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are publishing.
    /// This member is required.
    public var name: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

extension PublishFunctionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PublishFunctionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = PublishFunctionOutput()
            value.functionSummary = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FunctionSummary.readingClosure)
            return value
        }
    }
}

public struct PublishFunctionOutput: Swift.Equatable {
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.functionSummary = functionSummary
    }
}

enum PublishFunctionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFunctionExists": return try await NoSuchFunctionExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.QueryArgProfile {

    static func writingClosure(_ value: CloudFrontClientTypes.QueryArgProfile?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ProfileId"].write(value.profileId)
        try writer["QueryArg"].write(value.queryArg)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.QueryArgProfile, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.QueryArgProfile()
            value.queryArg = try reader["QueryArg"].readIfPresent()
            value.profileId = try reader["ProfileId"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfile: Swift.Equatable {
        /// ID of profile to use for field-level encryption query argument-profile mapping
        /// This member is required.
        public var profileId: Swift.String?
        /// Query argument for field-level encryption query argument-profile mapping.
        /// This member is required.
        public var queryArg: Swift.String?

        public init(
            profileId: Swift.String? = nil,
            queryArg: Swift.String? = nil
        )
        {
            self.profileId = profileId
            self.queryArg = queryArg
        }
    }

}

extension CloudFrontClientTypes.QueryArgProfileConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.QueryArgProfileConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ForwardWhenQueryArgProfileIsUnknown"].write(value.forwardWhenQueryArgProfileIsUnknown)
        try writer["QueryArgProfiles"].write(value.queryArgProfiles, writingClosure: CloudFrontClientTypes.QueryArgProfiles.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.QueryArgProfileConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.QueryArgProfileConfig()
            value.forwardWhenQueryArgProfileIsUnknown = try reader["ForwardWhenQueryArgProfileIsUnknown"].readIfPresent()
            value.queryArgProfiles = try reader["QueryArgProfiles"].readIfPresent(readingClosure: CloudFrontClientTypes.QueryArgProfiles.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Configuration for query argument-profile mapping for field-level encryption.
    public struct QueryArgProfileConfig: Swift.Equatable {
        /// Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
        /// This member is required.
        public var forwardWhenQueryArgProfileIsUnknown: Swift.Bool?
        /// Profiles specified for query argument-profile mapping for field-level encryption.
        public var queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles?

        public init(
            forwardWhenQueryArgProfileIsUnknown: Swift.Bool? = nil,
            queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles? = nil
        )
        {
            self.forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown
            self.queryArgProfiles = queryArgProfiles
        }
    }

}

extension QueryArgProfileEmpty {

    static var readingClosure: SmithyReadWrite.ReadingClosure<QueryArgProfileEmpty, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = QueryArgProfileEmpty()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension QueryArgProfileEmpty {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = QueryArgProfileEmpty()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// No profile specified for the field-level encryption query argument.
public struct QueryArgProfileEmpty: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryArgProfileEmpty" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.QueryArgProfiles {

    static func writingClosure(_ value: CloudFrontClientTypes.QueryArgProfiles?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.QueryArgProfile.writingClosure(_:to:), memberNodeInfo: "QueryArgProfile", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.QueryArgProfiles, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.QueryArgProfiles()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.QueryArgProfile.readingClosure, memberNodeInfo: "QueryArgProfile", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfiles: Swift.Equatable {
        /// Number of items for query argument-profile mapping for field-level encryption.
        public var items: [CloudFrontClientTypes.QueryArgProfile]?
        /// Number of profiles for query argument-profile mapping for field-level encryption.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.QueryArgProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringCacheKeys {

    static func writingClosure(_ value: CloudFrontClientTypes.QueryStringCacheKeys?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.QueryStringCacheKeys, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.QueryStringCacheKeys()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Name", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use QueryStringsConfig in a cache policy. See CachePolicy. If you want to send query strings to the origin but not include them in the cache key, use QueryStringsConfig in an origin request policy. See OriginRequestPolicy. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for a cache behavior.
    public struct QueryStringCacheKeys: Swift.Equatable {
        /// A list that contains the query string parameters that you want CloudFront to use as a basis for caching for a cache behavior. If Quantity is 0, you can omit Items.
        public var items: [Swift.String]?
        /// The number of whitelisted query string parameters for a cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringNames {

    static func writingClosure(_ value: CloudFrontClientTypes.QueryStringNames?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Name", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.QueryStringNames, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.QueryStringNames()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Name", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of query string names.
    public struct QueryStringNames: Swift.Equatable {
        /// A list of query string names.
        public var items: [Swift.String]?
        /// The number of query string names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.RealtimeLogConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.RealtimeLogConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["EndPoints"].writeList(value.endPoints, memberWritingClosure: CloudFrontClientTypes.EndPoint.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Fields"].writeList(value.fields, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Field", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["SamplingRate"].write(value.samplingRate)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.RealtimeLogConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.RealtimeLogConfig()
            value.arn = try reader["ARN"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.samplingRate = try reader["SamplingRate"].readIfPresent()
            value.endPoints = try reader["EndPoints"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.EndPoint.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Field", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A real-time log configuration.
    public struct RealtimeLogConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this real-time log configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data for this real-time log configuration.
        /// This member is required.
        public var endPoints: [CloudFrontClientTypes.EndPoint]?
        /// A list of fields that are included in each real-time log record. In an API response, the fields are provided in the same order in which they are sent to the Amazon Kinesis data stream. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var fields: [Swift.String]?
        /// The unique name of this real-time log configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. The sampling rate is an integer between 1 and 100, inclusive.
        /// This member is required.
        public var samplingRate: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
            fields: [Swift.String]? = nil,
            name: Swift.String? = nil,
            samplingRate: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.endPoints = endPoints
            self.fields = fields
            self.name = name
            self.samplingRate = samplingRate
        }
    }

}

extension RealtimeLogConfigAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<RealtimeLogConfigAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = RealtimeLogConfigAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension RealtimeLogConfigAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = RealtimeLogConfigAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use UpdateRealtimeLogConfig.
public struct RealtimeLogConfigAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RealtimeLogConfigInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<RealtimeLogConfigInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = RealtimeLogConfigInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension RealtimeLogConfigInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = RealtimeLogConfigInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.
public struct RealtimeLogConfigInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RealtimeLogConfigOwnerMismatch {

    static var readingClosure: SmithyReadWrite.ReadingClosure<RealtimeLogConfigOwnerMismatch, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = RealtimeLogConfigOwnerMismatch()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension RealtimeLogConfigOwnerMismatch {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = RealtimeLogConfigOwnerMismatch()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified real-time log configuration belongs to a different Amazon Web Services account.
public struct RealtimeLogConfigOwnerMismatch: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RealtimeLogConfigOwnerMismatch" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs {

    static func writingClosure(_ value: CloudFrontClientTypes.RealtimeLogConfigs?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsTruncated"].write(value.isTruncated)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.RealtimeLogConfig.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.RealtimeLogConfigs, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.RealtimeLogConfigs()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.RealtimeLogConfig.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.isTruncated = try reader["IsTruncated"].readIfPresent()
            value.marker = try reader["Marker"].readIfPresent()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of real-time log configurations.
    public struct RealtimeLogConfigs: Swift.Equatable {
        /// A flag that indicates whether there are more real-time log configurations than are contained in this list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the list of real-time log configurations.
        public var items: [CloudFrontClientTypes.RealtimeLogConfig]?
        /// This parameter indicates where this list of real-time log configurations begins. This list includes real-time log configurations that occur after the marker.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of real-time log configurations requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing real-time log configurations where you left off.
        public var nextMarker: Swift.String?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.RealtimeLogConfig]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
        }
    }

}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["RealtimeMetricsSubscriptionStatus"].write(value.realtimeMetricsSubscriptionStatus)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig()
            value.realtimeMetricsSubscriptionStatus = try reader["RealtimeMetricsSubscriptionStatus"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A subscription configuration for additional CloudWatch metrics.
    public struct RealtimeMetricsSubscriptionConfig: Swift.Equatable {
        /// A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
        /// This member is required.
        public var realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus?

        public init(
            realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus? = nil
        )
        {
            self.realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus
        }
    }

}

extension CloudFrontClientTypes {
    public enum RealtimeMetricsSubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RealtimeMetricsSubscriptionStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealtimeMetricsSubscriptionStatus(rawValue: rawValue) ?? RealtimeMetricsSubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ReferrerPolicyList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noReferrer
        case noReferrerWhenDowngrade
        case origin
        case originWhenCrossOrigin
        case sameOrigin
        case strictOrigin
        case strictOriginWhenCrossOrigin
        case unsafeUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferrerPolicyList] {
            return [
                .noReferrer,
                .noReferrerWhenDowngrade,
                .origin,
                .originWhenCrossOrigin,
                .sameOrigin,
                .strictOrigin,
                .strictOriginWhenCrossOrigin,
                .unsafeUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noReferrer: return "no-referrer"
            case .noReferrerWhenDowngrade: return "no-referrer-when-downgrade"
            case .origin: return "origin"
            case .originWhenCrossOrigin: return "origin-when-cross-origin"
            case .sameOrigin: return "same-origin"
            case .strictOrigin: return "strict-origin"
            case .strictOriginWhenCrossOrigin: return "strict-origin-when-cross-origin"
            case .unsafeUrl: return "unsafe-url"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferrerPolicyList(rawValue: rawValue) ?? ReferrerPolicyList.sdkUnknown(rawValue)
        }
    }
}

extension ResourceInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<ResourceInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ResourceInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension ResourceInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ResourceInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Cannot delete this resource because it is in use.
public struct ResourceInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicy {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["ResponseHeadersPolicyConfig"].write(value.responseHeadersPolicyConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicy()
            value.id = try reader["Id"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.responseHeadersPolicyConfig = try reader["ResponseHeadersPolicyConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A response headers policy. A response headers policy contains information about a set of HTTP response headers. After you create a response headers policy, you can use its ID to attach it to one or more cache behaviors in a CloudFront distribution. When it's attached to a cache behavior, the response headers policy affects the HTTP headers that CloudFront includes in HTTP responses to requests that match the cache behavior. CloudFront adds or removes response headers according to the configuration of the response headers policy. For more information, see [Adding or removing HTTP headers in CloudFront responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/modifying-response-headers.html) in the Amazon CloudFront Developer Guide.
    public struct ResponseHeadersPolicy: Swift.Equatable {
        /// The identifier for the response headers policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the response headers policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A response headers policy configuration.
        /// This member is required.
        public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

        public init(
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Header", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Header", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowHeaders: Swift.Equatable {
        /// The list of HTTP header names. You can specify * to allow all headers.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of HTTP header names in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues.writingClosure(_:to:), memberNodeInfo: "Method", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues.readingClosure, memberNodeInfo: "Method", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowMethods: Swift.Equatable {
        /// The list of HTTP methods. Valid values are:
        ///
        /// * GET
        ///
        /// * DELETE
        ///
        /// * HEAD
        ///
        /// * OPTIONS
        ///
        /// * PATCH
        ///
        /// * POST
        ///
        /// * PUT
        ///
        /// * ALL
        ///
        ///
        /// ALL is a special value that includes all of the listed HTTP methods.
        /// This member is required.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]?
        /// The number of HTTP methods in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethodsValues]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum ResponseHeadersPolicyAccessControlAllowMethodsValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyAccessControlAllowMethodsValues] {
            return [
                .all,
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseHeadersPolicyAccessControlAllowMethodsValues(rawValue: rawValue) ?? ResponseHeadersPolicyAccessControlAllowMethodsValues.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Origin", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Origin", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlAllowOrigins: Swift.Equatable {
        /// The list of origins (domain names). You can specify * to allow all origins.
        /// This member is required.
        public var items: [Swift.String]?
        /// The number of origins in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Header", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Header", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
    public struct ResponseHeadersPolicyAccessControlExposeHeaders: Swift.Equatable {
        /// The list of HTTP headers. You can specify * to expose all headers.
        public var items: [Swift.String]?
        /// The number of HTTP headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ResponseHeadersPolicyAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<ResponseHeadersPolicyAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ResponseHeadersPolicyAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension ResponseHeadersPolicyAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ResponseHeadersPolicyAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A response headers policy with this name already exists. You must provide a unique name. To modify an existing response headers policy, use UpdateResponseHeadersPolicy.
public struct ResponseHeadersPolicyAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResponseHeadersPolicyAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
        try writer["CorsConfig"].write(value.corsConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig.writingClosure(_:to:))
        try writer["CustomHeadersConfig"].write(value.customHeadersConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig.writingClosure(_:to:))
        try writer["Name"].write(value.name)
        try writer["RemoveHeadersConfig"].write(value.removeHeadersConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig.writingClosure(_:to:))
        try writer["SecurityHeadersConfig"].write(value.securityHeadersConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig.writingClosure(_:to:))
        try writer["ServerTimingHeadersConfig"].write(value.serverTimingHeadersConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyConfig()
            value.comment = try reader["Comment"].readIfPresent()
            value.name = try reader["Name"].readIfPresent()
            value.corsConfig = try reader["CorsConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig.readingClosure)
            value.securityHeadersConfig = try reader["SecurityHeadersConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig.readingClosure)
            value.serverTimingHeadersConfig = try reader["ServerTimingHeadersConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig.readingClosure)
            value.customHeadersConfig = try reader["CustomHeadersConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig.readingClosure)
            value.removeHeadersConfig = try reader["RemoveHeadersConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A response headers policy configuration. A response headers policy configuration contains metadata about the response headers policy, and configurations for sets of HTTP response headers.
    public struct ResponseHeadersPolicyConfig: Swift.Equatable {
        /// A comment to describe the response headers policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS).
        public var corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig?
        /// A configuration for a set of custom HTTP response headers.
        public var customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig?
        /// A name to identify the response headers policy. The name must be unique for response headers policies in this Amazon Web Services account.
        /// This member is required.
        public var name: Swift.String?
        /// A configuration for a set of HTTP headers to remove from the HTTP response.
        public var removeHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig?
        /// A configuration for a set of security-related HTTP response headers.
        public var securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig?
        /// A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront.
        public var serverTimingHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig?

        public init(
            comment: Swift.String? = nil,
            corsConfig: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig? = nil,
            customHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig? = nil,
            name: Swift.String? = nil,
            removeHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig? = nil,
            securityHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig? = nil,
            serverTimingHeadersConfig: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig? = nil
        )
        {
            self.comment = comment
            self.corsConfig = corsConfig
            self.customHeadersConfig = customHeadersConfig
            self.name = name
            self.removeHeadersConfig = removeHeadersConfig
            self.securityHeadersConfig = securityHeadersConfig
            self.serverTimingHeadersConfig = serverTimingHeadersConfig
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContentSecurityPolicy"].write(value.contentSecurityPolicy)
        try writer["Override"].write(value.`override`)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy()
            value.`override` = try reader["Override"].readIfPresent()
            value.contentSecurityPolicy = try reader["ContentSecurityPolicy"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentSecurityPolicy: Swift.Equatable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header.
        /// This member is required.
        public var contentSecurityPolicy: Swift.String?
        /// A Boolean that determines whether CloudFront overrides the Content-Security-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            contentSecurityPolicy: Swift.String? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.`override` = `override`
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Override"].write(value.`override`)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions()
            value.`override` = try reader["Override"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyContentTypeOptions: Swift.Equatable {
        /// A Boolean that determines whether CloudFront overrides the X-Content-Type-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            `override`: Swift.Bool? = nil
        )
        {
            self.`override` = `override`
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessControlAllowCredentials"].write(value.accessControlAllowCredentials)
        try writer["AccessControlAllowHeaders"].write(value.accessControlAllowHeaders, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders.writingClosure(_:to:))
        try writer["AccessControlAllowMethods"].write(value.accessControlAllowMethods, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods.writingClosure(_:to:))
        try writer["AccessControlAllowOrigins"].write(value.accessControlAllowOrigins, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins.writingClosure(_:to:))
        try writer["AccessControlExposeHeaders"].write(value.accessControlExposeHeaders, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders.writingClosure(_:to:))
        try writer["AccessControlMaxAgeSec"].write(value.accessControlMaxAgeSec)
        try writer["OriginOverride"].write(value.originOverride)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyCorsConfig()
            value.accessControlAllowOrigins = try reader["AccessControlAllowOrigins"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins.readingClosure)
            value.accessControlAllowHeaders = try reader["AccessControlAllowHeaders"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders.readingClosure)
            value.accessControlAllowMethods = try reader["AccessControlAllowMethods"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods.readingClosure)
            value.accessControlAllowCredentials = try reader["AccessControlAllowCredentials"].readIfPresent()
            value.accessControlExposeHeaders = try reader["AccessControlExposeHeaders"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders.readingClosure)
            value.accessControlMaxAgeSec = try reader["AccessControlMaxAgeSec"].readIfPresent()
            value.originOverride = try reader["OriginOverride"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A configuration for a set of HTTP response headers that are used for cross-origin resource sharing (CORS). CloudFront adds these headers to HTTP responses that it sends for CORS requests that match a cache behavior associated with this response headers policy. For more information about CORS, see [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) in the MDN Web Docs.
    public struct ResponseHeadersPolicyCorsConfig: Swift.Equatable {
        /// A Boolean that CloudFront uses as the value for the Access-Control-Allow-Credentials HTTP response header. For more information about the Access-Control-Allow-Credentials HTTP response header, see [Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowCredentials: Swift.Bool?
        /// A list of HTTP header names that CloudFront includes as values for the Access-Control-Allow-Headers HTTP response header. For more information about the Access-Control-Allow-Headers HTTP response header, see [Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders?
        /// A list of HTTP methods that CloudFront includes as values for the Access-Control-Allow-Methods HTTP response header. For more information about the Access-Control-Allow-Methods HTTP response header, see [Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods?
        /// A list of origins (domain names) that CloudFront can use as the value for the Access-Control-Allow-Origin HTTP response header. For more information about the Access-Control-Allow-Origin HTTP response header, see [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) in the MDN Web Docs.
        /// This member is required.
        public var accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins?
        /// A list of HTTP headers that CloudFront includes as values for the Access-Control-Expose-Headers HTTP response header. For more information about the Access-Control-Expose-Headers HTTP response header, see [Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) in the MDN Web Docs.
        public var accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders?
        /// A number that CloudFront uses as the value for the Access-Control-Max-Age HTTP response header. For more information about the Access-Control-Max-Age HTTP response header, see [Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age) in the MDN Web Docs.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront overrides HTTP response headers received from the origin with the ones specified in this response headers policy.
        /// This member is required.
        public var originOverride: Swift.Bool?

        public init(
            accessControlAllowCredentials: Swift.Bool? = nil,
            accessControlAllowHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowHeaders? = nil,
            accessControlAllowMethods: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowMethods? = nil,
            accessControlAllowOrigins: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlAllowOrigins? = nil,
            accessControlExposeHeaders: CloudFrontClientTypes.ResponseHeadersPolicyAccessControlExposeHeaders? = nil,
            accessControlMaxAgeSec: Swift.Int? = nil,
            originOverride: Swift.Bool? = nil
        )
        {
            self.accessControlAllowCredentials = accessControlAllowCredentials
            self.accessControlAllowHeaders = accessControlAllowHeaders
            self.accessControlAllowMethods = accessControlAllowMethods
            self.accessControlAllowOrigins = accessControlAllowOrigins
            self.accessControlExposeHeaders = accessControlExposeHeaders
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.originOverride = originOverride
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Header"].write(value.header)
        try writer["Override"].write(value.`override`)
        try writer["Value"].write(value.value)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader()
            value.header = try reader["Header"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            value.`override` = try reader["Override"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// An HTTP response header name and its value. CloudFront includes this header in HTTP responses that it sends for requests that match a cache behavior that's associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeader: Swift.Equatable {
        /// The HTTP response header name.
        /// This member is required.
        public var header: Swift.String?
        /// A Boolean that determines whether CloudFront overrides a response header with the same name received from the origin with the header specified here.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value for the HTTP response header.
        /// This member is required.
        public var value: Swift.String?

        public init(
            header: Swift.String? = nil,
            `override`: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.header = header
            self.`override` = `override`
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader.writingClosure(_:to:), memberNodeInfo: "ResponseHeadersPolicyCustomHeader", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyCustomHeadersConfig()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader.readingClosure, memberNodeInfo: "ResponseHeadersPolicyCustomHeader", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP response header names and their values. CloudFront includes these headers in HTTP responses that it sends for requests that match a cache behavior that's associated with this response headers policy.
    public struct ResponseHeadersPolicyCustomHeadersConfig: Swift.Equatable {
        /// The list of HTTP response headers and their values.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]?
        /// The number of HTTP response headers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FrameOption"].write(value.frameOption)
        try writer["Override"].write(value.`override`)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions()
            value.`override` = try reader["Override"].readIfPresent()
            value.frameOption = try reader["FrameOption"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header's value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
    public struct ResponseHeadersPolicyFrameOptions: Swift.Equatable {
        /// The value of the X-Frame-Options HTTP response header. Valid values are DENY and SAMEORIGIN. For more information about these values, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        /// This member is required.
        public var frameOption: CloudFrontClientTypes.FrameOptionsList?
        /// A Boolean that determines whether CloudFront overrides the X-Frame-Options HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?

        public init(
            frameOption: CloudFrontClientTypes.FrameOptionsList? = nil,
            `override`: Swift.Bool? = nil
        )
        {
            self.frameOption = frameOption
            self.`override` = `override`
        }
    }

}

extension ResponseHeadersPolicyInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<ResponseHeadersPolicyInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ResponseHeadersPolicyInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension ResponseHeadersPolicyInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ResponseHeadersPolicyInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Cannot delete the response headers policy because it is attached to one or more cache behaviors in a CloudFront distribution.
public struct ResponseHeadersPolicyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResponseHeadersPolicyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyList {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ResponseHeadersPolicySummary.writingClosure(_:to:), memberNodeInfo: "ResponseHeadersPolicySummary", isFlattened: false)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyList()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ResponseHeadersPolicySummary.readingClosure, memberNodeInfo: "ResponseHeadersPolicySummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of response headers policies.
    public struct ResponseHeadersPolicyList: Swift.Equatable {
        /// The response headers policies in the list.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]?
        /// The maximum number of response headers policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing response headers policies where you left off.
        public var nextMarker: Swift.String?
        /// The number of response headers policies returned.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Override"].write(value.`override`)
        try writer["ReferrerPolicy"].write(value.referrerPolicy)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy()
            value.`override` = try reader["Override"].readIfPresent()
            value.referrerPolicy = try reader["ReferrerPolicy"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header's value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
    public struct ResponseHeadersPolicyReferrerPolicy: Swift.Equatable {
        /// A Boolean that determines whether CloudFront overrides the Referrer-Policy HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// The value of the Referrer-Policy HTTP response header. Valid values are:
        ///
        /// * no-referrer
        ///
        /// * no-referrer-when-downgrade
        ///
        /// * origin
        ///
        /// * origin-when-cross-origin
        ///
        /// * same-origin
        ///
        /// * strict-origin
        ///
        /// * strict-origin-when-cross-origin
        ///
        /// * unsafe-url
        ///
        ///
        /// For more information about these values, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        /// This member is required.
        public var referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList?

        public init(
            `override`: Swift.Bool? = nil,
            referrerPolicy: CloudFrontClientTypes.ReferrerPolicyList? = nil
        )
        {
            self.`override` = `override`
            self.referrerPolicy = referrerPolicy
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Header"].write(value.header)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader()
            value.header = try reader["Header"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The name of an HTTP header that CloudFront removes from HTTP responses to requests that match the cache behavior that this response headers policy is attached to.
    public struct ResponseHeadersPolicyRemoveHeader: Swift.Equatable {
        /// The HTTP header name.
        /// This member is required.
        public var header: Swift.String?

        public init(
            header: Swift.String? = nil
        )
        {
            self.header = header
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader.writingClosure(_:to:), memberNodeInfo: "ResponseHeadersPolicyRemoveHeader", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeadersConfig()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader.readingClosure, memberNodeInfo: "ResponseHeadersPolicyRemoveHeader", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of HTTP header names that CloudFront removes from HTTP responses to requests that match the cache behavior that this response headers policy is attached to.
    public struct ResponseHeadersPolicyRemoveHeadersConfig: Swift.Equatable {
        /// The list of HTTP header names.
        public var items: [CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]?
        /// The number of HTTP header names in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [CloudFrontClientTypes.ResponseHeadersPolicyRemoveHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContentSecurityPolicy"].write(value.contentSecurityPolicy, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy.writingClosure(_:to:))
        try writer["ContentTypeOptions"].write(value.contentTypeOptions, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions.writingClosure(_:to:))
        try writer["FrameOptions"].write(value.frameOptions, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions.writingClosure(_:to:))
        try writer["ReferrerPolicy"].write(value.referrerPolicy, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy.writingClosure(_:to:))
        try writer["StrictTransportSecurity"].write(value.strictTransportSecurity, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity.writingClosure(_:to:))
        try writer["XSSProtection"].write(value.xssProtection, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicySecurityHeadersConfig()
            value.xssProtection = try reader["XSSProtection"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection.readingClosure)
            value.frameOptions = try reader["FrameOptions"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions.readingClosure)
            value.referrerPolicy = try reader["ReferrerPolicy"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy.readingClosure)
            value.contentSecurityPolicy = try reader["ContentSecurityPolicy"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy.readingClosure)
            value.contentTypeOptions = try reader["ContentTypeOptions"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions.readingClosure)
            value.strictTransportSecurity = try reader["StrictTransportSecurity"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A configuration for a set of security-related HTTP response headers. CloudFront adds these headers to HTTP responses that it sends for requests that match a cache behavior associated with this response headers policy.
    public struct ResponseHeadersPolicySecurityHeadersConfig: Swift.Equatable {
        /// The policy directives and their values that CloudFront includes as values for the Content-Security-Policy HTTP response header. For more information about the Content-Security-Policy HTTP response header, see [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) in the MDN Web Docs.
        public var contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy?
        /// Determines whether CloudFront includes the X-Content-Type-Options HTTP response header with its value set to nosniff. For more information about the X-Content-Type-Options HTTP response header, see [X-Content-Type-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options) in the MDN Web Docs.
        public var contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions?
        /// Determines whether CloudFront includes the X-Frame-Options HTTP response header and the header's value. For more information about the X-Frame-Options HTTP response header, see [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options) in the MDN Web Docs.
        public var frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions?
        /// Determines whether CloudFront includes the Referrer-Policy HTTP response header and the header's value. For more information about the Referrer-Policy HTTP response header, see [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) in the MDN Web Docs.
        public var referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy?
        /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header's value. For more information about the Strict-Transport-Security HTTP response header, see [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
        public var strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity?
        /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header's value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var xssProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection?

        public init(
            contentSecurityPolicy: CloudFrontClientTypes.ResponseHeadersPolicyContentSecurityPolicy? = nil,
            contentTypeOptions: CloudFrontClientTypes.ResponseHeadersPolicyContentTypeOptions? = nil,
            frameOptions: CloudFrontClientTypes.ResponseHeadersPolicyFrameOptions? = nil,
            referrerPolicy: CloudFrontClientTypes.ResponseHeadersPolicyReferrerPolicy? = nil,
            strictTransportSecurity: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity? = nil,
            xssProtection: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection? = nil
        )
        {
            self.contentSecurityPolicy = contentSecurityPolicy
            self.contentTypeOptions = contentTypeOptions
            self.frameOptions = frameOptions
            self.referrerPolicy = referrerPolicy
            self.strictTransportSecurity = strictTransportSecurity
            self.xssProtection = xssProtection
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Enabled"].write(value.enabled)
        try writer["SamplingRate"].write(value.samplingRate)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyServerTimingHeadersConfig()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.samplingRate = try reader["SamplingRate"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A configuration for enabling the Server-Timing header in HTTP responses sent from CloudFront. CloudFront adds this header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy. You can use the Server-Timing header to view metrics that can help you gain insights about the behavior and performance of CloudFront. For example, you can see which cache layer served a cache hit, or the first byte latency from the origin when there was a cache miss. You can use the metrics in the Server-Timing header to troubleshoot issues or test the efficiency of your CloudFront configuration. For more information, see [Server-Timing header](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/understanding-response-headers-policies.html#server-timing-header) in the Amazon CloudFront Developer Guide.
    public struct ResponseHeadersPolicyServerTimingHeadersConfig: Swift.Equatable {
        /// A Boolean that determines whether CloudFront adds the Server-Timing header to HTTP responses that it sends in response to requests that match a cache behavior that's associated with this response headers policy.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A number 0–100 (inclusive) that specifies the percentage of responses that you want CloudFront to add the Server-Timing header to. When you set the sampling rate to 100, CloudFront adds the Server-Timing header to the HTTP response for every request that matches the cache behavior that this response headers policy is attached to. When you set it to 50, CloudFront adds the header to 50% of the responses for requests that match the cache behavior. You can set the sampling rate to any number 0–100 with up to four decimal places.
        public var samplingRate: Swift.Double?

        public init(
            enabled: Swift.Bool? = nil,
            samplingRate: Swift.Double? = nil
        )
        {
            self.enabled = enabled
            self.samplingRate = samplingRate
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AccessControlMaxAgeSec"].write(value.accessControlMaxAgeSec)
        try writer["IncludeSubdomains"].write(value.includeSubdomains)
        try writer["Override"].write(value.`override`)
        try writer["Preload"].write(value.preload)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyStrictTransportSecurity()
            value.`override` = try reader["Override"].readIfPresent()
            value.includeSubdomains = try reader["IncludeSubdomains"].readIfPresent()
            value.preload = try reader["Preload"].readIfPresent()
            value.accessControlMaxAgeSec = try reader["AccessControlMaxAgeSec"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the Strict-Transport-Security HTTP response header and the header's value. For more information about the Strict-Transport-Security HTTP response header, see [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) in the MDN Web Docs.
    public struct ResponseHeadersPolicyStrictTransportSecurity: Swift.Equatable {
        /// A number that CloudFront uses as the value for the max-age directive in the Strict-Transport-Security HTTP response header.
        /// This member is required.
        public var accessControlMaxAgeSec: Swift.Int?
        /// A Boolean that determines whether CloudFront includes the includeSubDomains directive in the Strict-Transport-Security HTTP response header.
        public var includeSubdomains: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the Strict-Transport-Security HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines whether CloudFront includes the preload directive in the Strict-Transport-Security HTTP response header.
        public var preload: Swift.Bool?

        public init(
            accessControlMaxAgeSec: Swift.Int? = nil,
            includeSubdomains: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            preload: Swift.Bool? = nil
        )
        {
            self.accessControlMaxAgeSec = accessControlMaxAgeSec
            self.includeSubdomains = includeSubdomains
            self.`override` = `override`
            self.preload = preload
        }
    }

}

extension CloudFrontClientTypes.ResponseHeadersPolicySummary {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicySummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ResponseHeadersPolicy"].write(value.responseHeadersPolicy, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicy.writingClosure(_:to:))
        try writer["Type"].write(value.type)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicySummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicySummary()
            value.type = try reader["Type"].readIfPresent()
            value.responseHeadersPolicy = try reader["ResponseHeadersPolicy"].readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicy.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Contains a response headers policy.
    public struct ResponseHeadersPolicySummary: Swift.Equatable {
        /// The response headers policy.
        /// This member is required.
        public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?
        /// The type of response headers policy, either managed (created by Amazon Web Services) or custom (created in this Amazon Web Services account).
        /// This member is required.
        public var type: CloudFrontClientTypes.ResponseHeadersPolicyType?

        public init(
            responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil,
            type: CloudFrontClientTypes.ResponseHeadersPolicyType? = nil
        )
        {
            self.responseHeadersPolicy = responseHeadersPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum ResponseHeadersPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseHeadersPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseHeadersPolicyType(rawValue: rawValue) ?? ResponseHeadersPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection {

    static func writingClosure(_ value: CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ModeBlock"].write(value.modeBlock)
        try writer["Override"].write(value.`override`)
        try writer["Protection"].write(value.protection)
        try writer["ReportUri"].write(value.reportUri)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ResponseHeadersPolicyXSSProtection()
            value.`override` = try reader["Override"].readIfPresent()
            value.protection = try reader["Protection"].readIfPresent()
            value.modeBlock = try reader["ModeBlock"].readIfPresent()
            value.reportUri = try reader["ReportUri"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Determines whether CloudFront includes the X-XSS-Protection HTTP response header and the header's value. For more information about the X-XSS-Protection HTTP response header, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
    public struct ResponseHeadersPolicyXSSProtection: Swift.Equatable {
        /// A Boolean that determines whether CloudFront includes the mode=block directive in the X-XSS-Protection header. For more information about this directive, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var modeBlock: Swift.Bool?
        /// A Boolean that determines whether CloudFront overrides the X-XSS-Protection HTTP response header received from the origin with the one specified in this response headers policy.
        /// This member is required.
        public var `override`: Swift.Bool?
        /// A Boolean that determines the value of the X-XSS-Protection HTTP response header. When this setting is true, the value of the X-XSS-Protection header is 1. When this setting is false, the value of the X-XSS-Protection header is 0. For more information about these settings, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        /// This member is required.
        public var protection: Swift.Bool?
        /// A reporting URI, which CloudFront uses as the value of the report directive in the X-XSS-Protection header. You cannot specify a ReportUri when ModeBlock is true. For more information about using a reporting URL, see [X-XSS-Protection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection) in the MDN Web Docs.
        public var reportUri: Swift.String?

        public init(
            modeBlock: Swift.Bool? = nil,
            `override`: Swift.Bool? = nil,
            protection: Swift.Bool? = nil,
            reportUri: Swift.String? = nil
        )
        {
            self.modeBlock = modeBlock
            self.`override` = `override`
            self.protection = protection
            self.reportUri = reportUri
        }
    }

}

extension CloudFrontClientTypes.Restrictions {

    static func writingClosure(_ value: CloudFrontClientTypes.Restrictions?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["GeoRestriction"].write(value.geoRestriction, writingClosure: CloudFrontClientTypes.GeoRestriction.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Restrictions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Restrictions()
            value.geoRestriction = try reader["GeoRestriction"].readIfPresent(readingClosure: CloudFrontClientTypes.GeoRestriction.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that identifies ways in which you want to restrict distribution of your content.
    public struct Restrictions: Swift.Equatable {
        /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
        /// This member is required.
        public var geoRestriction: CloudFrontClientTypes.GeoRestriction?

        public init(
            geoRestriction: CloudFrontClientTypes.GeoRestriction? = nil
        )
        {
            self.geoRestriction = geoRestriction
        }
    }

}

extension CloudFrontClientTypes.S3Origin {

    static func writingClosure(_ value: CloudFrontClientTypes.S3Origin?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DomainName"].write(value.domainName)
        try writer["OriginAccessIdentity"].write(value.originAccessIdentity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.S3Origin, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.S3Origin()
            value.domainName = try reader["DomainName"].readIfPresent()
            value.originAccessIdentity = try reader["OriginAccessIdentity"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
    public struct S3Origin: Swift.Equatable {
        /// The DNS name of the Amazon S3 origin.
        /// This member is required.
        public var domainName: Swift.String?
        /// The CloudFront origin access identity to associate with the distribution. Use an origin access identity to configure the distribution so that end users can only access objects in an Amazon S3 bucket through CloudFront. If you want end users to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information, see [Using an Origin Access Identity to Restrict Access to Your Amazon S3 Content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes.S3OriginConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.S3OriginConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["OriginAccessIdentity"].write(value.originAccessIdentity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.S3OriginConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.S3OriginConfig()
            value.originAccessIdentity = try reader["OriginAccessIdentity"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin or an S3 bucket that is configured as a website endpoint, use the CustomOriginConfig element instead.
    public struct S3OriginConfig: Swift.Equatable {
        /// The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that viewers can only access objects in an Amazon S3 bucket through CloudFront. The format of the value is: origin-access-identity/cloudfront/ID-of-origin-access-identity where  ID-of-origin-access-identity  is the value that CloudFront returned in the ID element when you created the origin access identity. If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information about the origin access identity, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init(
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes {
    public enum SSLSupportMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sniOnly
        case staticIp
        case vip
        case sdkUnknown(Swift.String)

        public static var allCases: [SSLSupportMethod] {
            return [
                .sniOnly,
                .staticIp,
                .vip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sniOnly: return "sni-only"
            case .staticIp: return "static-ip"
            case .vip: return "vip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSLSupportMethod(rawValue: rawValue) ?? SSLSupportMethod.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.SessionStickinessConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.SessionStickinessConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IdleTTL"].write(value.idleTTL)
        try writer["MaximumTTL"].write(value.maximumTTL)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.SessionStickinessConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.SessionStickinessConfig()
            value.idleTTL = try reader["IdleTTL"].readIfPresent()
            value.maximumTTL = try reader["MaximumTTL"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// Session stickiness provides the ability to define multiple requests from a single viewer as a single session. This prevents the potentially inconsistent experience of sending some of a given user's requests to your staging distribution, while others are sent to your primary distribution. Define the session duration using TTL values.
    public struct SessionStickinessConfig: Swift.Equatable {
        /// The amount of time after which you want sessions to cease if no requests are received. Allowed values are 300–3600 seconds (5–60 minutes). The value must be less than or equal to MaximumTTL.
        /// This member is required.
        public var idleTTL: Swift.Int?
        /// The maximum amount of time to consider requests from the viewer as being part of the same session. Allowed values are 300–3600 seconds (5–60 minutes). The value must be less than or equal to IdleTTL.
        /// This member is required.
        public var maximumTTL: Swift.Int?

        public init(
            idleTTL: Swift.Int? = nil,
            maximumTTL: Swift.Int? = nil
        )
        {
            self.idleTTL = idleTTL
            self.maximumTTL = maximumTTL
        }
    }

}

extension CloudFrontClientTypes.Signer {

    static func writingClosure(_ value: CloudFrontClientTypes.Signer?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["AwsAccountNumber"].write(value.awsAccountNumber)
        try writer["KeyPairIds"].write(value.keyPairIds, writingClosure: CloudFrontClientTypes.KeyPairIds.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Signer, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Signer()
            value.awsAccountNumber = try reader["AwsAccountNumber"].readIfPresent()
            value.keyPairIds = try reader["KeyPairIds"].readIfPresent(readingClosure: CloudFrontClientTypes.KeyPairIds.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct Signer: Swift.Equatable {
        /// An Amazon Web Services account number that contains active CloudFront key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies. If the Amazon Web Services account that owns the key pairs is the same account that owns the CloudFront distribution, the value of this field is self.
        public var awsAccountNumber: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init(
            awsAccountNumber: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes {
    public enum SslProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv11
        case tlsv12
        case sdkUnknown(Swift.String)

        public static var allCases: [SslProtocol] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv11,
                .tlsv12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv11: return "TLSv1.1"
            case .tlsv12: return "TLSv1.2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SslProtocol(rawValue: rawValue) ?? SslProtocol.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.StagingDistributionDnsNames {

    static func writingClosure(_ value: CloudFrontClientTypes.StagingDistributionDnsNames?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "DnsName", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StagingDistributionDnsNames, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StagingDistributionDnsNames()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "DnsName", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The CloudFront domain name of the staging distribution.
    public struct StagingDistributionDnsNames: Swift.Equatable {
        /// The CloudFront domain name of the staging distribution.
        public var items: [Swift.String]?
        /// The number of CloudFront domain names in your staging distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension StagingDistributionInUse {

    static var readingClosure: SmithyReadWrite.ReadingClosure<StagingDistributionInUse, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = StagingDistributionInUse()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension StagingDistributionInUse {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = StagingDistributionInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A continuous deployment policy for this staging distribution already exists.
public struct StagingDistributionInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StagingDistributionInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.StatusCodes {

    static func writingClosure(_ value: CloudFrontClientTypes.StatusCodes?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.Int.writingClosure(_:to:), memberNodeInfo: "StatusCode", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StatusCodes, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StatusCodes()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.Int.readingClosure, memberNodeInfo: "StatusCode", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the status codes that you specify that, when returned by a primary origin, trigger CloudFront to failover to a second origin.
    public struct StatusCodes: Swift.Equatable {
        /// The items (status codes) for an origin group.
        /// This member is required.
        public var items: [Swift.Int]?
        /// The number of status codes.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.Int]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.StreamingDistribution {

    static func writingClosure(_ value: CloudFrontClientTypes.StreamingDistribution?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["ActiveTrustedSigners"].write(value.activeTrustedSigners, writingClosure: CloudFrontClientTypes.ActiveTrustedSigners.writingClosure(_:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["Status"].write(value.status)
        try writer["StreamingDistributionConfig"].write(value.streamingDistributionConfig, writingClosure: CloudFrontClientTypes.StreamingDistributionConfig.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StreamingDistribution, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StreamingDistribution()
            value.id = try reader["Id"].readIfPresent()
            value.arn = try reader["ARN"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.domainName = try reader["DomainName"].readIfPresent()
            value.activeTrustedSigners = try reader["ActiveTrustedSigners"].readIfPresent(readingClosure: CloudFrontClientTypes.ActiveTrustedSigners.readingClosure)
            value.streamingDistributionConfig = try reader["StreamingDistributionConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistributionConfig.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to track and manage content delivery.
    public struct StreamingDistribution: Swift.Equatable {
        /// A complex type that lists the Amazon Web Services accounts, if any, that you included in the TrustedSigners complex type for this distribution. These are the accounts that you want to allow to create signed URLs for private content. The Signer complex type lists the Amazon Web Services account number of the trusted signer or self if the signer is the Amazon Web Services account that created the distribution. The Signer element also includes the IDs of any active CloudFront key pairs that are associated with the trusted signer's Amazon Web Services account. If no KeyPairId element appears for a Signer, that signer can't create signed URLs. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// The domain name that corresponds to the streaming distribution, for example, s5c39gqb8ow64r.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The identifier for the RTMP distribution. For example: EGTXBD79EXAMPLE.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the distribution was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The current status of the RTMP distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// The current configuration information for the RTMP distribution.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

        public init(
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            arn: Swift.String? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil,
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
        )
        {
            self.activeTrustedSigners = activeTrustedSigners
            self.arn = arn
            self.domainName = domainName
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.streamingDistributionConfig = streamingDistributionConfig
        }
    }

}

extension StreamingDistributionAlreadyExists {

    static var readingClosure: SmithyReadWrite.ReadingClosure<StreamingDistributionAlreadyExists, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = StreamingDistributionAlreadyExists()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension StreamingDistributionAlreadyExists {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = StreamingDistributionAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The caller reference you attempted to create the streaming distribution with is associated with another distribution
public struct StreamingDistributionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamingDistributionAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.StreamingDistributionConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Aliases"].write(value.aliases, writingClosure: CloudFrontClientTypes.Aliases.writingClosure(_:to:))
        try writer["CallerReference"].write(value.callerReference)
        try writer["Comment"].write(value.comment)
        try writer["Enabled"].write(value.enabled)
        try writer["Logging"].write(value.logging, writingClosure: CloudFrontClientTypes.StreamingLoggingConfig.writingClosure(_:to:))
        try writer["PriceClass"].write(value.priceClass)
        try writer["S3Origin"].write(value.s3Origin, writingClosure: CloudFrontClientTypes.S3Origin.writingClosure(_:to:))
        try writer["TrustedSigners"].write(value.trustedSigners, writingClosure: CloudFrontClientTypes.TrustedSigners.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StreamingDistributionConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StreamingDistributionConfig()
            value.callerReference = try reader["CallerReference"].readIfPresent()
            value.s3Origin = try reader["S3Origin"].readIfPresent(readingClosure: CloudFrontClientTypes.S3Origin.readingClosure)
            value.aliases = try reader["Aliases"].readIfPresent(readingClosure: CloudFrontClientTypes.Aliases.readingClosure)
            value.comment = try reader["Comment"].readIfPresent()
            value.logging = try reader["Logging"].readIfPresent(readingClosure: CloudFrontClientTypes.StreamingLoggingConfig.readingClosure)
            value.trustedSigners = try reader["TrustedSigners"].readIfPresent(readingClosure: CloudFrontClientTypes.TrustedSigners.readingClosure)
            value.priceClass = try reader["PriceClass"].readIfPresent()
            value.enabled = try reader["Enabled"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The RTMP distribution's configuration information.
    public struct StreamingDistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the StreamingDistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// Any comments you want to include about the streaming distribution.
        /// This member is required.
        public var comment: Swift.String?
        /// Whether the streaming distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the streaming distribution.
        public var logging: CloudFrontClientTypes.StreamingLoggingConfig?
        /// A complex type that contains information about price class for this streaming distribution.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// A complex type that specifies any Amazon Web Services accounts that you want to permit to create signed URLs for private content. If you want the distribution to use signed URLs, include this element; if you want the distribution to use public URLs, remove this element. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.StreamingLoggingConfig? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.callerReference = callerReference
            self.comment = comment
            self.enabled = enabled
            self.logging = logging
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags {

    static func writingClosure(_ value: CloudFrontClientTypes.StreamingDistributionConfigWithTags?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StreamingDistributionConfig"].write(value.streamingDistributionConfig, writingClosure: CloudFrontClientTypes.StreamingDistributionConfig.writingClosure(_:to:))
        try writer["Tags"].write(value.tags, writingClosure: CloudFrontClientTypes.Tags.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StreamingDistributionConfigWithTags, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StreamingDistributionConfigWithTags()
            value.streamingDistributionConfig = try reader["StreamingDistributionConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistributionConfig.readingClosure)
            value.tags = try reader["Tags"].readIfPresent(readingClosure: CloudFrontClientTypes.Tags.readingClosure)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution Configuration and a list of tags to be associated with the streaming distribution.
    public struct StreamingDistributionConfigWithTags: Swift.Equatable {
        /// A streaming distribution Configuration.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init(
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.streamingDistributionConfig = streamingDistributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionList {

    static func writingClosure(_ value: CloudFrontClientTypes.StreamingDistributionList?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["IsTruncated"].write(value.isTruncated)
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.StreamingDistributionSummary.writingClosure(_:to:), memberNodeInfo: "StreamingDistributionSummary", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxItems"].write(value.maxItems)
        try writer["NextMarker"].write(value.nextMarker)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StreamingDistributionList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StreamingDistributionList()
            value.marker = try reader["Marker"].readIfPresent()
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            value.maxItems = try reader["MaxItems"].readIfPresent()
            value.isTruncated = try reader["IsTruncated"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.StreamingDistributionSummary.readingClosure, memberNodeInfo: "StreamingDistributionSummary", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution list.
    public struct StreamingDistributionList: Swift.Equatable {
        /// A flag that indicates whether more streaming distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one StreamingDistributionSummary element for each distribution that was created by the current Amazon Web Services account.
        public var items: [CloudFrontClientTypes.StreamingDistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your RTMP distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of streaming distributions that were created by the current Amazon Web Services account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.StreamingDistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension StreamingDistributionNotDisabled {

    static var readingClosure: SmithyReadWrite.ReadingClosure<StreamingDistributionNotDisabled, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = StreamingDistributionNotDisabled()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension StreamingDistributionNotDisabled {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = StreamingDistributionNotDisabled()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct StreamingDistributionNotDisabled: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamingDistributionNotDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary {

    static func writingClosure(_ value: CloudFrontClientTypes.StreamingDistributionSummary?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["Aliases"].write(value.aliases, writingClosure: CloudFrontClientTypes.Aliases.writingClosure(_:to:))
        try writer["Comment"].write(value.comment)
        try writer["DomainName"].write(value.domainName)
        try writer["Enabled"].write(value.enabled)
        try writer["Id"].write(value.id)
        try writer["LastModifiedTime"].writeTimestamp(value.lastModifiedTime, format: .dateTime)
        try writer["PriceClass"].write(value.priceClass)
        try writer["S3Origin"].write(value.s3Origin, writingClosure: CloudFrontClientTypes.S3Origin.writingClosure(_:to:))
        try writer["Status"].write(value.status)
        try writer["TrustedSigners"].write(value.trustedSigners, writingClosure: CloudFrontClientTypes.TrustedSigners.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StreamingDistributionSummary, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StreamingDistributionSummary()
            value.id = try reader["Id"].readIfPresent()
            value.arn = try reader["ARN"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .dateTime)
            value.domainName = try reader["DomainName"].readIfPresent()
            value.s3Origin = try reader["S3Origin"].readIfPresent(readingClosure: CloudFrontClientTypes.S3Origin.readingClosure)
            value.aliases = try reader["Aliases"].readIfPresent(readingClosure: CloudFrontClientTypes.Aliases.readingClosure)
            value.trustedSigners = try reader["TrustedSigners"].readIfPresent(readingClosure: CloudFrontClientTypes.TrustedSigners.readingClosure)
            value.comment = try reader["Comment"].readIfPresent()
            value.priceClass = try reader["PriceClass"].readIfPresent()
            value.enabled = try reader["Enabled"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information for a CloudFront streaming distribution.
    public struct StreamingDistributionSummary: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The ARN (Amazon Resource Name) for the streaming distribution. For example: arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5, where 123456789012 is your Amazon Web Services account ID.
        /// This member is required.
        public var arn: Swift.String?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// The domain name corresponding to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept end user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The identifier for the distribution, for example, EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// Indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that specifies the Amazon Web Services accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items.If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init(
            aliases: CloudFrontClientTypes.Aliases? = nil,
            arn: Swift.String? = nil,
            comment: Swift.String? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            status: Swift.String? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.arn = arn
            self.comment = comment
            self.domainName = domainName
            self.enabled = enabled
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.status = status
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingLoggingConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.StreamingLoggingConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Bucket"].write(value.bucket)
        try writer["Enabled"].write(value.enabled)
        try writer["Prefix"].write(value.`prefix`)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.StreamingLoggingConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.StreamingLoggingConfig()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.bucket = try reader["Bucket"].readIfPresent()
            value.`prefix` = try reader["Prefix"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for this streaming distribution.
    public struct StreamingLoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a streaming distribution or if you want to disable logging for an existing streaming distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket and Prefix, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension CloudFrontClientTypes.Tag {

    static func writingClosure(_ value: CloudFrontClientTypes.Tag?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Tag, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Tag()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains Tag key and Tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains Tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional Tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.TagKeys {

    static func writingClosure(_ value: CloudFrontClientTypes.TagKeys?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Key", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.TagKeys, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.TagKeys()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "Key", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct TagKeys: Swift.Equatable {
        /// A complex type that contains Tag key elements.
        public var items: [Swift.String]?

        public init(
            items: [Swift.String]? = nil
        )
        {
            self.items = items
        }
    }

}

extension TagResourceInput {
    static func writingClosure(_ value: TagResourceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Tags"].write(value.tags, writingClosure: CloudFrontClientTypes.Tags.writingClosure(_:to:))
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "Operation", value: "Tag"))
        guard let resource = value.resource else {
            let message = "Creating a URL Query Item failed. resource is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceQueryItem = ClientRuntime.SDKURLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
        items.append(resourceQueryItem)
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to add tags to a CloudFront resource.
public struct TagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init(
        resource: Swift.String? = nil,
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

extension TagResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagResourceOutput()
        }
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTagging": return try await InvalidTagging.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.Tags {

    static func writingClosure(_ value: CloudFrontClientTypes.Tags?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Items"].writeList(value.items, memberWritingClosure: CloudFrontClientTypes.Tag.writingClosure(_:to:), memberNodeInfo: "Tag", isFlattened: false)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.Tags, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.Tags()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontClientTypes.Tag.readingClosure, memberNodeInfo: "Tag", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct Tags: Swift.Equatable {
        /// A complex type that contains Tag elements.
        public var items: [CloudFrontClientTypes.Tag]?

        public init(
            items: [CloudFrontClientTypes.Tag]? = nil
        )
        {
            self.items = items
        }
    }

}

extension TestFunctionFailed {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TestFunctionFailed, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TestFunctionFailed()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TestFunctionFailed {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TestFunctionFailed()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The CloudFront function failed.
public struct TestFunctionFailed: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TestFunctionFailed" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TestFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionInput(ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)), eventObject: \"CONTENT_REDACTED\")"}
}

extension TestFunctionInput {
    static func writingClosure(_ value: TestFunctionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["EventObject"].write(value.eventObject)
        try writer["Stage"].write(value.stage)
    }
}

extension TestFunctionInput {

    static func headerProvider(_ value: TestFunctionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension TestFunctionInput {

    static func urlPathProvider(_ value: TestFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())/test"
    }
}

public struct TestFunctionInput: Swift.Equatable {
    /// The event object to test the function with. For more information about the structure of the event object, see [Testing functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var eventObject: ClientRuntime.Data?
    /// The current version (ETag value) of the function that you are testing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are testing.
    /// This member is required.
    public var name: Swift.String?
    /// The stage of the function that you are testing, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init(
        eventObject: ClientRuntime.Data? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.eventObject = eventObject
        self.ifMatch = ifMatch
        self.name = name
        self.stage = stage
    }
}

extension TestFunctionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TestFunctionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = TestFunctionOutput()
            value.testResult = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.TestResult.readingClosure)
            return value
        }
    }
}

public struct TestFunctionOutput: Swift.Equatable {
    /// An object that represents the result of running the function with the provided event object.
    public var testResult: CloudFrontClientTypes.TestResult?

    public init(
        testResult: CloudFrontClientTypes.TestResult? = nil
    )
    {
        self.testResult = testResult
    }
}

enum TestFunctionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFunctionExists": return try await NoSuchFunctionExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TestFunctionFailed": return try await TestFunctionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.TestResult {

    static func writingClosure(_ value: CloudFrontClientTypes.TestResult?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ComputeUtilization"].write(value.computeUtilization)
        try writer["FunctionErrorMessage"].write(value.functionErrorMessage)
        try writer["FunctionExecutionLogs"].writeList(value.functionExecutionLogs, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FunctionOutput"].write(value.functionOutput)
        try writer["FunctionSummary"].write(value.functionSummary, writingClosure: CloudFrontClientTypes.FunctionSummary.writingClosure(_:to:))
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.TestResult, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.TestResult()
            value.functionSummary = try reader["FunctionSummary"].readIfPresent(readingClosure: CloudFrontClientTypes.FunctionSummary.readingClosure)
            value.computeUtilization = try reader["ComputeUtilization"].readIfPresent()
            value.functionExecutionLogs = try reader["FunctionExecutionLogs"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.functionErrorMessage = try reader["FunctionErrorMessage"].readIfPresent()
            value.functionOutput = try reader["FunctionOutput"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes.TestResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestResult(computeUtilization: \(Swift.String(describing: computeUtilization)), functionSummary: \(Swift.String(describing: functionSummary)), functionErrorMessage: \"CONTENT_REDACTED\", functionExecutionLogs: \"CONTENT_REDACTED\", functionOutput: \"CONTENT_REDACTED\")"}
}

extension CloudFrontClientTypes {
    /// Contains the result of testing a CloudFront function with TestFunction.
    public struct TestResult: Swift.Equatable {
        /// The amount of time that the function took to run as a percentage of the maximum allowed time. For example, a compute utilization of 35 means that the function completed in 35% of the maximum allowed time.
        public var computeUtilization: Swift.String?
        /// If the result of testing the function was an error, this field contains the error message.
        public var functionErrorMessage: Swift.String?
        /// Contains the log lines that the function wrote (if any) when running the test.
        public var functionExecutionLogs: [Swift.String]?
        /// The event object returned by the function. For more information about the structure of the event object, see [Event object structure](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html) in the Amazon CloudFront Developer Guide.
        public var functionOutput: Swift.String?
        /// Contains configuration information and metadata about the CloudFront function that was tested.
        public var functionSummary: CloudFrontClientTypes.FunctionSummary?

        public init(
            computeUtilization: Swift.String? = nil,
            functionErrorMessage: Swift.String? = nil,
            functionExecutionLogs: [Swift.String]? = nil,
            functionOutput: Swift.String? = nil,
            functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
        )
        {
            self.computeUtilization = computeUtilization
            self.functionErrorMessage = functionErrorMessage
            self.functionExecutionLogs = functionExecutionLogs
            self.functionOutput = functionOutput
            self.functionSummary = functionSummary
        }
    }

}

extension TooLongCSPInResponseHeadersPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooLongCSPInResponseHeadersPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooLongCSPInResponseHeadersPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooLongCSPInResponseHeadersPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooLongCSPInResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The length of the Content-Security-Policy header value in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooLongCSPInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooLongCSPInResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCacheBehaviors {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCacheBehaviors, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCacheBehaviors()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCacheBehaviors {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCacheBehaviors()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You cannot create more cache behaviors for the distribution.
public struct TooManyCacheBehaviors: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCacheBehaviors" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCachePolicies {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCachePolicies, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCachePolicies()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCachePolicies {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCachePolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of cache policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCachePolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCachePolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCertificates {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCertificates, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCertificates()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCertificates {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCertificates()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You cannot create anymore custom SSL/TLS certificates.
public struct TooManyCertificates: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCertificates" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCloudFrontOriginAccessIdentities {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCloudFrontOriginAccessIdentities, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCloudFrontOriginAccessIdentities()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCloudFrontOriginAccessIdentities {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCloudFrontOriginAccessIdentities()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Processing your request would cause you to exceed the maximum number of origin access identities allowed.
public struct TooManyCloudFrontOriginAccessIdentities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCloudFrontOriginAccessIdentities" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyContinuousDeploymentPolicies {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyContinuousDeploymentPolicies, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyContinuousDeploymentPolicies()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyContinuousDeploymentPolicies {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyContinuousDeploymentPolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of continuous deployment policies for this Amazon Web Services account.
public struct TooManyContinuousDeploymentPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyContinuousDeploymentPolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCookieNamesInWhiteList {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCookieNamesInWhiteList, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCookieNamesInWhiteList()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCookieNamesInWhiteList {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCookieNamesInWhiteList()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains more cookie names in the whitelist than are allowed per cache behavior.
public struct TooManyCookieNamesInWhiteList: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookieNamesInWhiteList" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCookiesInCachePolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCookiesInCachePolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCookiesInCachePolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCookiesInCachePolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCookiesInCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of cookies in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookiesInCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCookiesInOriginRequestPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCookiesInOriginRequestPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCookiesInOriginRequestPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCookiesInOriginRequestPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCookiesInOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of cookies in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCookiesInOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyCustomHeadersInResponseHeadersPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyCustomHeadersInResponseHeadersPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyCustomHeadersInResponseHeadersPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyCustomHeadersInResponseHeadersPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyCustomHeadersInResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of custom headers in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCustomHeadersInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyCustomHeadersInResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionCNAMEs {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionCNAMEs, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionCNAMEs()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionCNAMEs {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionCNAMEs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyDistributionCNAMEs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionCNAMEs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributions {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributions()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributions {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributions()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Processing your request would cause you to exceed the maximum number of distributions allowed.
public struct TooManyDistributions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributions" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsAssociatedToCachePolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsAssociatedToCachePolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsAssociatedToCachePolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsAssociatedToCachePolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsAssociatedToCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of distributions have been associated with the specified cache policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsAssociatedToFieldLevelEncryptionConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsAssociatedToFieldLevelEncryptionConfig()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsAssociatedToFieldLevelEncryptionConfig()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of distributions have been associated with the specified configuration for field-level encryption.
public struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsAssociatedToKeyGroup {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsAssociatedToKeyGroup, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsAssociatedToKeyGroup()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsAssociatedToKeyGroup {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsAssociatedToKeyGroup()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of distributions that reference this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToKeyGroup: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToKeyGroup" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsAssociatedToOriginAccessControl {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsAssociatedToOriginAccessControl, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsAssociatedToOriginAccessControl()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsAssociatedToOriginAccessControl {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsAssociatedToOriginAccessControl()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of distributions have been associated with the specified origin access control. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginAccessControl: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToOriginAccessControl" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsAssociatedToOriginRequestPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsAssociatedToOriginRequestPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsAssociatedToOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of distributions have been associated with the specified origin request policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsAssociatedToResponseHeadersPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsAssociatedToResponseHeadersPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsAssociatedToResponseHeadersPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsAssociatedToResponseHeadersPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsAssociatedToResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of distributions have been associated with the specified response headers policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsAssociatedToResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsWithFunctionAssociations {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsWithFunctionAssociations, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsWithFunctionAssociations()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsWithFunctionAssociations {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsWithFunctionAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsWithFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithFunctionAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsWithLambdaAssociations {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsWithLambdaAssociations, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsWithLambdaAssociations()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsWithLambdaAssociations {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsWithLambdaAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.
public struct TooManyDistributionsWithLambdaAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithLambdaAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyDistributionsWithSingleFunctionARN {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyDistributionsWithSingleFunctionARN, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyDistributionsWithSingleFunctionARN()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyDistributionsWithSingleFunctionARN {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyDistributionsWithSingleFunctionARN()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of distributions have been associated with the specified Lambda@Edge function.
public struct TooManyDistributionsWithSingleFunctionARN: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyDistributionsWithSingleFunctionARN" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFieldLevelEncryptionConfigs {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFieldLevelEncryptionConfigs, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFieldLevelEncryptionConfigs()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFieldLevelEncryptionConfigs {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFieldLevelEncryptionConfigs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of configurations for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionConfigs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionConfigs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFieldLevelEncryptionContentTypeProfiles, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFieldLevelEncryptionContentTypeProfiles()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFieldLevelEncryptionContentTypeProfiles()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of content type profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionContentTypeProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionContentTypeProfiles" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFieldLevelEncryptionEncryptionEntities, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFieldLevelEncryptionEncryptionEntities()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFieldLevelEncryptionEncryptionEntities()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of encryption entities for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionEncryptionEntities: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionEncryptionEntities" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFieldLevelEncryptionFieldPatterns, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFieldLevelEncryptionFieldPatterns()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFieldLevelEncryptionFieldPatterns()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of field patterns for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionFieldPatterns: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionFieldPatterns" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFieldLevelEncryptionProfiles {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFieldLevelEncryptionProfiles, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFieldLevelEncryptionProfiles()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFieldLevelEncryptionProfiles {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFieldLevelEncryptionProfiles()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionProfiles" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFieldLevelEncryptionQueryArgProfiles, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFieldLevelEncryptionQueryArgProfiles()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFieldLevelEncryptionQueryArgProfiles()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of query arg profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionQueryArgProfiles: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFieldLevelEncryptionQueryArgProfiles" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFunctionAssociations {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFunctionAssociations, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFunctionAssociations()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFunctionAssociations {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFunctionAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of CloudFront function associations for this distribution. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFunctionAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyFunctions {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyFunctions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyFunctions()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyFunctions {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyFunctions()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of CloudFront functions for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyFunctions" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyHeadersInCachePolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyHeadersInCachePolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyHeadersInCachePolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyHeadersInCachePolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyHeadersInCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of headers in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyHeadersInForwardedValues {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyHeadersInForwardedValues, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyHeadersInForwardedValues()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyHeadersInForwardedValues {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyHeadersInForwardedValues()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains too many headers in forwarded values.
public struct TooManyHeadersInForwardedValues: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInForwardedValues" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyHeadersInOriginRequestPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyHeadersInOriginRequestPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyHeadersInOriginRequestPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyHeadersInOriginRequestPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyHeadersInOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of headers in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyHeadersInOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyInvalidationsInProgress {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyInvalidationsInProgress, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyInvalidationsInProgress()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyInvalidationsInProgress {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyInvalidationsInProgress()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.
public struct TooManyInvalidationsInProgress: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyInvalidationsInProgress" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyKeyGroups {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyKeyGroups, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyKeyGroups()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyKeyGroups {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyKeyGroups()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of key groups for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroups: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyKeyGroups" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyKeyGroupsAssociatedToDistribution {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyKeyGroupsAssociatedToDistribution, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyKeyGroupsAssociatedToDistribution()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyKeyGroupsAssociatedToDistribution {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyKeyGroupsAssociatedToDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroupsAssociatedToDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyKeyGroupsAssociatedToDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyLambdaFunctionAssociations {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyLambdaFunctionAssociations, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyLambdaFunctionAssociations()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyLambdaFunctionAssociations {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyLambdaFunctionAssociations()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains more Lambda@Edge function associations than are allowed per distribution.
public struct TooManyLambdaFunctionAssociations: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyLambdaFunctionAssociations" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyOriginAccessControls {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyOriginAccessControls, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyOriginAccessControls()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyOriginAccessControls {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyOriginAccessControls()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of origin access controls in your Amazon Web Services account exceeds the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginAccessControls: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginAccessControls" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyOriginCustomHeaders {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyOriginCustomHeaders, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyOriginCustomHeaders()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyOriginCustomHeaders {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyOriginCustomHeaders()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains too many origin custom headers.
public struct TooManyOriginCustomHeaders: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginCustomHeaders" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyOriginGroupsPerDistribution {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyOriginGroupsPerDistribution, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyOriginGroupsPerDistribution()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyOriginGroupsPerDistribution {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyOriginGroupsPerDistribution()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Processing your request would cause you to exceed the maximum number of origin groups allowed.
public struct TooManyOriginGroupsPerDistribution: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginGroupsPerDistribution" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyOriginRequestPolicies {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyOriginRequestPolicies, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyOriginRequestPolicies()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyOriginRequestPolicies {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyOriginRequestPolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of origin request policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginRequestPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOriginRequestPolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyOrigins {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyOrigins, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyOrigins()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyOrigins {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyOrigins()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You cannot create more origins for the distribution.
public struct TooManyOrigins: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyOrigins" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyPublicKeys {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyPublicKeys, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyPublicKeys()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyPublicKeys {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyPublicKeys()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.
public struct TooManyPublicKeys: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPublicKeys" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyPublicKeysInKeyGroup {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyPublicKeysInKeyGroup, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyPublicKeysInKeyGroup()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyPublicKeysInKeyGroup {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyPublicKeysInKeyGroup()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of public keys in this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyPublicKeysInKeyGroup: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPublicKeysInKeyGroup" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyQueryStringParameters {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyQueryStringParameters, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyQueryStringParameters()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyQueryStringParameters {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyQueryStringParameters()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains too many query string parameters.
public struct TooManyQueryStringParameters: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringParameters" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyQueryStringsInCachePolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyQueryStringsInCachePolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyQueryStringsInCachePolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyQueryStringsInCachePolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyQueryStringsInCachePolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of query strings in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInCachePolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringsInCachePolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyQueryStringsInOriginRequestPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyQueryStringsInOriginRequestPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyQueryStringsInOriginRequestPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyQueryStringsInOriginRequestPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyQueryStringsInOriginRequestPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of query strings in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInOriginRequestPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyQueryStringsInOriginRequestPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyRealtimeLogConfigs {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyRealtimeLogConfigs, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyRealtimeLogConfigs()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyRealtimeLogConfigs {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyRealtimeLogConfigs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of real-time log configurations for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRealtimeLogConfigs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRealtimeLogConfigs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyRemoveHeadersInResponseHeadersPolicy {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyRemoveHeadersInResponseHeadersPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyRemoveHeadersInResponseHeadersPolicy()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyRemoveHeadersInResponseHeadersPolicy {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyRemoveHeadersInResponseHeadersPolicy()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The number of headers in RemoveHeadersConfig in the response headers policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRemoveHeadersInResponseHeadersPolicy: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRemoveHeadersInResponseHeadersPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyResponseHeadersPolicies {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyResponseHeadersPolicies, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyResponseHeadersPolicies()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyResponseHeadersPolicies {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyResponseHeadersPolicies()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// You have reached the maximum number of response headers policies for this Amazon Web Services account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyResponseHeadersPolicies: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyResponseHeadersPolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyStreamingDistributionCNAMEs {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyStreamingDistributionCNAMEs, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyStreamingDistributionCNAMEs()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyStreamingDistributionCNAMEs {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyStreamingDistributionCNAMEs()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyStreamingDistributionCNAMEs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyStreamingDistributionCNAMEs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyStreamingDistributions {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyStreamingDistributions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyStreamingDistributions()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyStreamingDistributions {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyStreamingDistributions()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Processing your request would cause you to exceed the maximum number of streaming distributions allowed.
public struct TooManyStreamingDistributions: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyStreamingDistributions" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyTrustedSigners {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TooManyTrustedSigners, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TooManyTrustedSigners()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TooManyTrustedSigners {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyTrustedSigners()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Your request contains more trusted signers than are allowed per distribution.
public struct TooManyTrustedSigners: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTrustedSigners" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.TrafficConfig {

    static func writingClosure(_ value: CloudFrontClientTypes.TrafficConfig?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["SingleHeaderConfig"].write(value.singleHeaderConfig, writingClosure: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig.writingClosure(_:to:))
        try writer["SingleWeightConfig"].write(value.singleWeightConfig, writingClosure: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig.writingClosure(_:to:))
        try writer["Type"].write(value.type)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.TrafficConfig, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.TrafficConfig()
            value.singleWeightConfig = try reader["SingleWeightConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig.readingClosure)
            value.singleHeaderConfig = try reader["SingleHeaderConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig.readingClosure)
            value.type = try reader["Type"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// The traffic configuration of your continuous deployment.
    public struct TrafficConfig: Swift.Equatable {
        /// Determines which HTTP requests are sent to the staging distribution.
        public var singleHeaderConfig: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig?
        /// Contains the percentage of traffic to send to the staging distribution.
        public var singleWeightConfig: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig?
        /// The type of traffic configuration.
        /// This member is required.
        public var type: CloudFrontClientTypes.ContinuousDeploymentPolicyType?

        public init(
            singleHeaderConfig: CloudFrontClientTypes.ContinuousDeploymentSingleHeaderConfig? = nil,
            singleWeightConfig: CloudFrontClientTypes.ContinuousDeploymentSingleWeightConfig? = nil,
            type: CloudFrontClientTypes.ContinuousDeploymentPolicyType? = nil
        )
        {
            self.singleHeaderConfig = singleHeaderConfig
            self.singleWeightConfig = singleWeightConfig
            self.type = type
        }
    }

}

extension TrustedKeyGroupDoesNotExist {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TrustedKeyGroupDoesNotExist, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TrustedKeyGroupDoesNotExist()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TrustedKeyGroupDoesNotExist {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TrustedKeyGroupDoesNotExist()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified key group does not exist.
public struct TrustedKeyGroupDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrustedKeyGroupDoesNotExist" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups {

    static func writingClosure(_ value: CloudFrontClientTypes.TrustedKeyGroups?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Enabled"].write(value.enabled)
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "KeyGroup", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.TrustedKeyGroups, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.TrustedKeyGroups()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "KeyGroup", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups in the list have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups identifiers.
        public var items: [Swift.String]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension TrustedSignerDoesNotExist {

    static var readingClosure: SmithyReadWrite.ReadingClosure<TrustedSignerDoesNotExist, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = TrustedSignerDoesNotExist()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension TrustedSignerDoesNotExist {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TrustedSignerDoesNotExist()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// One or more of your trusted signers don't exist.
public struct TrustedSignerDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrustedSignerDoesNotExist" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudFrontClientTypes.TrustedSigners {

    static func writingClosure(_ value: CloudFrontClientTypes.TrustedSigners?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Enabled"].write(value.enabled)
        try writer["Items"].writeList(value.items, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "AwsAccountNumber", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.TrustedSigners, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.TrustedSigners()
            value.enabled = try reader["Enabled"].readIfPresent()
            value.quantity = try reader["Quantity"].readIfPresent()
            value.items = try reader["Items"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "AwsAccountNumber", isFlattened: false)
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A list of Amazon Web Services accounts whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedSigners: Swift.Equatable {
        /// This field is true if any of the Amazon Web Services accounts in the list are configured as trusted signers. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of Amazon Web Services account identifiers.
        public var items: [Swift.String]?
        /// The number of Amazon Web Services accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension UnsupportedOperation {

    static var readingClosure: SmithyReadWrite.ReadingClosure<UnsupportedOperation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = UnsupportedOperation()
            value.properties.message = try reader["Message"].readIfPresent()
            return value
        }
    }
}

extension UnsupportedOperation {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = UnsupportedOperation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// This operation is not supported in this region.
public struct UnsupportedOperation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagResourceInput {
    static func writingClosure(_ value: UntagResourceInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["TagKeys"].write(value.tagKeys, writingClosure: CloudFrontClientTypes.TagKeys.writingClosure(_:to:))
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "Operation", value: "Untag"))
        guard let resource = value.resource else {
            let message = "Creating a URL Query Item failed. resource is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceQueryItem = ClientRuntime.SDKURLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
        items.append(resourceQueryItem)
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/2020-05-31/tagging"
    }
}

/// The request to remove tags from a CloudFront resource.
public struct UntagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag key elements.
    /// This member is required.
    public var tagKeys: CloudFrontClientTypes.TagKeys?

    public init(
        resource: Swift.String? = nil,
        tagKeys: CloudFrontClientTypes.TagKeys? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagResourceOutput()
        }
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTagging": return try await InvalidTagging.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateCachePolicyInput {
    static func writingClosure(_ value: UpdateCachePolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CachePolicyConfig"].write(value.cachePolicyConfig, writingClosure: CloudFrontClientTypes.CachePolicyConfig.writingClosure(_:to:))
    }
}

extension UpdateCachePolicyInput {

    static func headerProvider(_ value: UpdateCachePolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateCachePolicyInput {

    static func urlPathProvider(_ value: UpdateCachePolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The unique identifier for the cache policy that you are updating. The identifier is returned in a cache behavior's CachePolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are updating. The version is returned in the cache policy's ETag field in the response to GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init(
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension UpdateCachePolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateCachePolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateCachePolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.cachePolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CachePolicy.readingClosure)
            return value
        }
    }
}

public struct UpdateCachePolicyOutput: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init(
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

enum UpdateCachePolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CachePolicyAlreadyExists": return try await CachePolicyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookiesInCachePolicy": return try await TooManyCookiesInCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInCachePolicy": return try await TooManyHeadersInCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringsInCachePolicy": return try await TooManyQueryStringsInCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput {
    static func writingClosure(_ value: UpdateCloudFrontOriginAccessIdentityInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["CloudFrontOriginAccessIdentityConfig"].write(value.cloudFrontOriginAccessIdentityConfig, writingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.writingClosure(_:to:))
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput {

    static func headerProvider(_ value: UpdateCloudFrontOriginAccessIdentityInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput {

    static func urlPathProvider(_ value: UpdateCloudFrontOriginAccessIdentityInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update an origin access identity.
public struct UpdateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's configuration information.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The identity's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the identity's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateCloudFrontOriginAccessIdentityOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateCloudFrontOriginAccessIdentityOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.cloudFrontOriginAccessIdentity = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.CloudFrontOriginAccessIdentity.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateCloudFrontOriginAccessIdentityOutput: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

enum UpdateCloudFrontOriginAccessIdentityOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCloudFrontOriginAccessIdentity": return try await NoSuchCloudFrontOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateContinuousDeploymentPolicyInput {
    static func writingClosure(_ value: UpdateContinuousDeploymentPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ContinuousDeploymentPolicyConfig"].write(value.continuousDeploymentPolicyConfig, writingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig.writingClosure(_:to:))
    }
}

extension UpdateContinuousDeploymentPolicyInput {

    static func headerProvider(_ value: UpdateContinuousDeploymentPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateContinuousDeploymentPolicyInput {

    static func urlPathProvider(_ value: UpdateContinuousDeploymentPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/continuous-deployment-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateContinuousDeploymentPolicyInput: Swift.Equatable {
    /// The continuous deployment policy configuration.
    /// This member is required.
    public var continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig?
    /// The identifier of the continuous deployment policy that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the continuous deployment policy that you are updating.
    public var ifMatch: Swift.String?

    public init(
        continuousDeploymentPolicyConfig: CloudFrontClientTypes.ContinuousDeploymentPolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicyConfig = continuousDeploymentPolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension UpdateContinuousDeploymentPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateContinuousDeploymentPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateContinuousDeploymentPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.continuousDeploymentPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ContinuousDeploymentPolicy.readingClosure)
            return value
        }
    }
}

public struct UpdateContinuousDeploymentPolicyOutput: Swift.Equatable {
    /// A continuous deployment policy.
    public var continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy?
    /// The version identifier for the current version of the continuous deployment policy.
    public var eTag: Swift.String?

    public init(
        continuousDeploymentPolicy: CloudFrontClientTypes.ContinuousDeploymentPolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.continuousDeploymentPolicy = continuousDeploymentPolicy
        self.eTag = eTag
    }
}

enum UpdateContinuousDeploymentPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "StagingDistributionInUse": return try await StagingDistributionInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateDistributionInput {
    static func writingClosure(_ value: UpdateDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["DistributionConfig"].write(value.distributionConfig, writingClosure: CloudFrontClientTypes.DistributionConfig.writingClosure(_:to:))
    }
}

extension UpdateDistributionInput {

    static func headerProvider(_ value: UpdateDistributionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionInput {

    static func urlPathProvider(_ value: UpdateDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update a distribution.
public struct UpdateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension UpdateDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateDistributionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.distribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Distribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateDistributionOutput: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

enum UpdateDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ContinuousDeploymentPolicyInUse": return try await ContinuousDeploymentPolicyInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalOriginAccessConfiguration": return try await IllegalOriginAccessConfiguration.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDomainNameForOriginAccessControl": return try await InvalidDomainNameForOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidErrorCode": return try await InvalidErrorCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidForwardCookies": return try await InvalidForwardCookies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLocationCode": return try await InvalidLocationCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRelativePath": return try await InvalidRelativePath.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidResponseCode": return try await InvalidResponseCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTTLOrder": return try await InvalidTTLOrder.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidViewerCertificate": return try await InvalidViewerCertificate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidWebACLId": return try await InvalidWebACLId.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchContinuousDeploymentPolicy": return try await NoSuchContinuousDeploymentPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOrigin": return try await NoSuchOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "StagingDistributionInUse": return try await StagingDistributionInUse.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCertificates": return try await TooManyCertificates.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOrigins": return try await TooManyOrigins.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateDistributionWithStagingConfigInput {

    static func headerProvider(_ value: UpdateDistributionWithStagingConfigInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateDistributionWithStagingConfigInput {

    static func queryItemProvider(_ value: UpdateDistributionWithStagingConfigInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let stagingDistributionId = value.stagingDistributionId {
            let stagingDistributionIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "StagingDistributionId".urlPercentEncoding(), value: Swift.String(stagingDistributionId).urlPercentEncoding())
            items.append(stagingDistributionIdQueryItem)
        }
        return items
    }
}

extension UpdateDistributionWithStagingConfigInput {

    static func urlPathProvider(_ value: UpdateDistributionWithStagingConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/distribution/\(id.urlPercentEncoding())/promote-staging-config"
    }
}

public struct UpdateDistributionWithStagingConfigInput: Swift.Equatable {
    /// The identifier of the primary distribution to which you are copying a staging distribution's configuration.
    /// This member is required.
    public var id: Swift.String?
    /// The current versions (ETag values) of both primary and staging distributions. Provide these in the following format: ,
    public var ifMatch: Swift.String?
    /// The identifier of the staging distribution whose configuration you are copying to the primary distribution.
    public var stagingDistributionId: Swift.String?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        stagingDistributionId: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.stagingDistributionId = stagingDistributionId
    }
}

extension UpdateDistributionWithStagingConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateDistributionWithStagingConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateDistributionWithStagingConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.distribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.Distribution.readingClosure)
            return value
        }
    }
}

public struct UpdateDistributionWithStagingConfigOutput: Swift.Equatable {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the primary distribution (after it's updated).
    public var eTag: Swift.String?

    public init(
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

enum UpdateDistributionWithStagingConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior": return try await IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidDefaultRootObject": return try await InvalidDefaultRootObject.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidErrorCode": return try await InvalidErrorCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidForwardCookies": return try await InvalidForwardCookies.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidFunctionAssociation": return try await InvalidFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidGeoRestrictionParameter": return try await InvalidGeoRestrictionParameter.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidHeadersForS3Origin": return try await InvalidHeadersForS3Origin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLambdaFunctionAssociation": return try await InvalidLambdaFunctionAssociation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidLocationCode": return try await InvalidLocationCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidMinimumProtocolVersion": return try await InvalidMinimumProtocolVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginKeepaliveTimeout": return try await InvalidOriginKeepaliveTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginReadTimeout": return try await InvalidOriginReadTimeout.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidQueryStringParameters": return try await InvalidQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRelativePath": return try await InvalidRelativePath.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidRequiredProtocol": return try await InvalidRequiredProtocol.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidResponseCode": return try await InvalidResponseCode.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidTTLOrder": return try await InvalidTTLOrder.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidViewerCertificate": return try await InvalidViewerCertificate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidWebACLId": return try await InvalidWebACLId.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchCachePolicy": return try await NoSuchCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchDistribution": return try await NoSuchDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOrigin": return try await NoSuchOrigin.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "RealtimeLogConfigOwnerMismatch": return try await RealtimeLogConfigOwnerMismatch.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCacheBehaviors": return try await TooManyCacheBehaviors.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCertificates": return try await TooManyCertificates.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookieNamesInWhiteList": return try await TooManyCookieNamesInWhiteList.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionCNAMEs": return try await TooManyDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToCachePolicy": return try await TooManyDistributionsAssociatedToCachePolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig": return try await TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToKeyGroup": return try await TooManyDistributionsAssociatedToKeyGroup.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginAccessControl": return try await TooManyDistributionsAssociatedToOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToOriginRequestPolicy": return try await TooManyDistributionsAssociatedToOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsAssociatedToResponseHeadersPolicy": return try await TooManyDistributionsAssociatedToResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithFunctionAssociations": return try await TooManyDistributionsWithFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithLambdaAssociations": return try await TooManyDistributionsWithLambdaAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyDistributionsWithSingleFunctionARN": return try await TooManyDistributionsWithSingleFunctionARN.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFunctionAssociations": return try await TooManyFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInForwardedValues": return try await TooManyHeadersInForwardedValues.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyKeyGroupsAssociatedToDistribution": return try await TooManyKeyGroupsAssociatedToDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyLambdaFunctionAssociations": return try await TooManyLambdaFunctionAssociations.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginCustomHeaders": return try await TooManyOriginCustomHeaders.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOriginGroupsPerDistribution": return try await TooManyOriginGroupsPerDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyOrigins": return try await TooManyOrigins.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringParameters": return try await TooManyQueryStringParameters.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedKeyGroupDoesNotExist": return try await TrustedKeyGroupDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateFieldLevelEncryptionConfigInput {
    static func writingClosure(_ value: UpdateFieldLevelEncryptionConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FieldLevelEncryptionConfig"].write(value.fieldLevelEncryptionConfig, writingClosure: CloudFrontClientTypes.FieldLevelEncryptionConfig.writingClosure(_:to:))
    }
}

extension UpdateFieldLevelEncryptionConfigInput {

    static func headerProvider(_ value: UpdateFieldLevelEncryptionConfigInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionConfigInput {

    static func urlPathProvider(_ value: UpdateFieldLevelEncryptionConfigInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request to update a field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
    /// The ID of the configuration you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension UpdateFieldLevelEncryptionConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateFieldLevelEncryptionConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateFieldLevelEncryptionConfigOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.fieldLevelEncryption = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryption.readingClosure)
            return value
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigOutput: Swift.Equatable {
    /// The value of the ETag header that you received when updating the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the results of updating the configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

enum UpdateFieldLevelEncryptionConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionConfig": return try await NoSuchFieldLevelEncryptionConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "QueryArgProfileEmpty": return try await QueryArgProfileEmpty.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionContentTypeProfiles": return try await TooManyFieldLevelEncryptionContentTypeProfiles.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionQueryArgProfiles": return try await TooManyFieldLevelEncryptionQueryArgProfiles.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateFieldLevelEncryptionProfileInput {
    static func writingClosure(_ value: UpdateFieldLevelEncryptionProfileInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FieldLevelEncryptionProfileConfig"].write(value.fieldLevelEncryptionProfileConfig, writingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.writingClosure(_:to:))
    }
}

extension UpdateFieldLevelEncryptionProfileInput {

    static func headerProvider(_ value: UpdateFieldLevelEncryptionProfileInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFieldLevelEncryptionProfileInput {

    static func urlPathProvider(_ value: UpdateFieldLevelEncryptionProfileInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request to update a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
    /// The ID of the field-level encryption profile request.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init(
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

extension UpdateFieldLevelEncryptionProfileOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateFieldLevelEncryptionProfileOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateFieldLevelEncryptionProfileOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.fieldLevelEncryptionProfile = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FieldLevelEncryptionProfile.readingClosure)
            return value
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileOutput: Swift.Equatable {
    /// The result of the field-level encryption profile request.
    public var eTag: Swift.String?
    /// Return the results of updating the profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init(
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

enum UpdateFieldLevelEncryptionProfileOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "FieldLevelEncryptionProfileAlreadyExists": return try await FieldLevelEncryptionProfileAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "FieldLevelEncryptionProfileSizeExceeded": return try await FieldLevelEncryptionProfileSizeExceeded.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFieldLevelEncryptionProfile": return try await NoSuchFieldLevelEncryptionProfile.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchPublicKey": return try await NoSuchPublicKey.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionEncryptionEntities": return try await TooManyFieldLevelEncryptionEncryptionEntities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyFieldLevelEncryptionFieldPatterns": return try await TooManyFieldLevelEncryptionFieldPatterns.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionInput(functionConfig: \(Swift.String(describing: functionConfig)), ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), functionCode: \"CONTENT_REDACTED\")"}
}

extension UpdateFunctionInput {
    static func writingClosure(_ value: UpdateFunctionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["FunctionCode"].write(value.functionCode)
        try writer["FunctionConfig"].write(value.functionConfig, writingClosure: CloudFrontClientTypes.FunctionConfig.writingClosure(_:to:))
    }
}

extension UpdateFunctionInput {

    static func headerProvider(_ value: UpdateFunctionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateFunctionInput {

    static func urlPathProvider(_ value: UpdateFunctionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/function/\(name.urlPercentEncoding())"
    }
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// The current version (ETag value) of the function that you are updating, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are updating.
    /// This member is required.
    public var name: Swift.String?

    public init(
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.ifMatch = ifMatch
        self.name = name
    }
}

extension UpdateFunctionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateFunctionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateFunctionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETtag") {
                value.eTag = eTagHeaderValue
            }
            value.functionSummary = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.FunctionSummary.readingClosure)
            return value
        }
    }
}

public struct UpdateFunctionOutput: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init(
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

enum UpdateFunctionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "FunctionSizeLimitExceeded": return try await FunctionSizeLimitExceeded.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchFunctionExists": return try await NoSuchFunctionExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "UnsupportedOperation": return try await UnsupportedOperation.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateKeyGroupInput {
    static func writingClosure(_ value: UpdateKeyGroupInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["KeyGroupConfig"].write(value.keyGroupConfig, writingClosure: CloudFrontClientTypes.KeyGroupConfig.writingClosure(_:to:))
    }
}

extension UpdateKeyGroupInput {

    static func headerProvider(_ value: UpdateKeyGroupInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeyGroupInput {

    static func urlPathProvider(_ value: UpdateKeyGroupInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/key-group/\(id.urlPercentEncoding())"
    }
}

public struct UpdateKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are updating. The version is the key group's ETag value.
    public var ifMatch: Swift.String?
    /// The key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.keyGroupConfig = keyGroupConfig
    }
}

extension UpdateKeyGroupOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateKeyGroupOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateKeyGroupOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.keyGroup = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyGroup.readingClosure)
            return value
        }
    }
}

public struct UpdateKeyGroupOutput: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just updated.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init(
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

enum UpdateKeyGroupOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "KeyGroupAlreadyExists": return try await KeyGroupAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResource": return try await NoSuchResource.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyPublicKeysInKeyGroup": return try await TooManyPublicKeysInKeyGroup.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateKeyValueStoreInput {
    static func writingClosure(_ value: UpdateKeyValueStoreInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["Comment"].write(value.comment)
    }
}

extension UpdateKeyValueStoreInput {

    static func headerProvider(_ value: UpdateKeyValueStoreInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeyValueStoreInput {

    static func urlPathProvider(_ value: UpdateKeyValueStoreInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/2020-05-31/key-value-store/\(name.urlPercentEncoding())"
    }
}

public struct UpdateKeyValueStoreInput: Swift.Equatable {
    /// The comment of the Key Value Store to update.
    /// This member is required.
    public var comment: Swift.String?
    /// The Key Value Store to update, if a match occurs.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the Key Value Store to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        comment: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.comment = comment
        self.ifMatch = ifMatch
        self.name = name
    }
}

extension UpdateKeyValueStoreOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateKeyValueStoreOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateKeyValueStoreOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.keyValueStore = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.KeyValueStore.readingClosure)
            return value
        }
    }
}

public struct UpdateKeyValueStoreOutput: Swift.Equatable {
    /// The ETag of the resulting Key Value Store.
    public var eTag: Swift.String?
    /// The resulting Key Value Store to update.
    public var keyValueStore: CloudFrontClientTypes.KeyValueStore?

    public init(
        eTag: Swift.String? = nil,
        keyValueStore: CloudFrontClientTypes.KeyValueStore? = nil
    )
    {
        self.eTag = eTag
        self.keyValueStore = keyValueStore
    }
}

enum UpdateKeyValueStoreOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "EntityNotFound": return try await EntityNotFound.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateOriginAccessControlInput {
    static func writingClosure(_ value: UpdateOriginAccessControlInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["OriginAccessControlConfig"].write(value.originAccessControlConfig, writingClosure: CloudFrontClientTypes.OriginAccessControlConfig.writingClosure(_:to:))
    }
}

extension UpdateOriginAccessControlInput {

    static func headerProvider(_ value: UpdateOriginAccessControlInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateOriginAccessControlInput {

    static func urlPathProvider(_ value: UpdateOriginAccessControlInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-access-control/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdateOriginAccessControlInput: Swift.Equatable {
    /// The unique identifier of the origin access control that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The current version (ETag value) of the origin access control that you are updating.
    public var ifMatch: Swift.String?
    /// An origin access control.
    /// This member is required.
    public var originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originAccessControlConfig: CloudFrontClientTypes.OriginAccessControlConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originAccessControlConfig = originAccessControlConfig
    }
}

extension UpdateOriginAccessControlOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateOriginAccessControlOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateOriginAccessControlOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.originAccessControl = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginAccessControl.readingClosure)
            return value
        }
    }
}

public struct UpdateOriginAccessControlOutput: Swift.Equatable {
    /// The new version of the origin access control after it has been updated.
    public var eTag: Swift.String?
    /// The origin access control after it has been updated.
    public var originAccessControl: CloudFrontClientTypes.OriginAccessControl?

    public init(
        eTag: Swift.String? = nil,
        originAccessControl: CloudFrontClientTypes.OriginAccessControl? = nil
    )
    {
        self.eTag = eTag
        self.originAccessControl = originAccessControl
    }
}

enum UpdateOriginAccessControlOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginAccessControl": return try await NoSuchOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "OriginAccessControlAlreadyExists": return try await OriginAccessControlAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateOriginRequestPolicyInput {
    static func writingClosure(_ value: UpdateOriginRequestPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["OriginRequestPolicyConfig"].write(value.originRequestPolicyConfig, writingClosure: CloudFrontClientTypes.OriginRequestPolicyConfig.writingClosure(_:to:))
    }
}

extension UpdateOriginRequestPolicyInput {

    static func headerProvider(_ value: UpdateOriginRequestPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateOriginRequestPolicyInput {

    static func urlPathProvider(_ value: UpdateOriginRequestPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are updating. The identifier is returned in a cache behavior's OriginRequestPolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are updating. The version is returned in the origin request policy's ETag field in the response to GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

extension UpdateOriginRequestPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateOriginRequestPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateOriginRequestPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.originRequestPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.OriginRequestPolicy.readingClosure)
            return value
        }
    }
}

public struct UpdateOriginRequestPolicyOutput: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init(
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

enum UpdateOriginRequestPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchOriginRequestPolicy": return try await NoSuchOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "OriginRequestPolicyAlreadyExists": return try await OriginRequestPolicyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCookiesInOriginRequestPolicy": return try await TooManyCookiesInOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyHeadersInOriginRequestPolicy": return try await TooManyHeadersInOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyQueryStringsInOriginRequestPolicy": return try await TooManyQueryStringsInOriginRequestPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdatePublicKeyInput {
    static func writingClosure(_ value: UpdatePublicKeyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["PublicKeyConfig"].write(value.publicKeyConfig, writingClosure: CloudFrontClientTypes.PublicKeyConfig.writingClosure(_:to:))
    }
}

extension UpdatePublicKeyInput {

    static func headerProvider(_ value: UpdatePublicKeyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdatePublicKeyInput {

    static func urlPathProvider(_ value: UpdatePublicKeyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
    }
}

public struct UpdatePublicKeyInput: Swift.Equatable {
    /// The identifier of the public key that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// A public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.publicKeyConfig = publicKeyConfig
    }
}

extension UpdatePublicKeyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdatePublicKeyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdatePublicKeyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.publicKey = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.PublicKey.readingClosure)
            return value
        }
    }
}

public struct UpdatePublicKeyOutput: Swift.Equatable {
    /// The identifier of the current version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init(
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

enum UpdatePublicKeyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CannotChangeImmutablePublicKeyFields": return try await CannotChangeImmutablePublicKeyFields.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchPublicKey": return try await NoSuchPublicKey.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateRealtimeLogConfigInput {
    static func writingClosure(_ value: UpdateRealtimeLogConfigInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ARN"].write(value.arn)
        try writer["EndPoints"].writeList(value.endPoints, memberWritingClosure: CloudFrontClientTypes.EndPoint.writingClosure(_:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Fields"].writeList(value.fields, memberWritingClosure: Swift.String.writingClosure(_:to:), memberNodeInfo: "Field", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["SamplingRate"].write(value.samplingRate)
    }
}

extension UpdateRealtimeLogConfigInput {

    static func urlPathProvider(_ value: UpdateRealtimeLogConfigInput) -> Swift.String? {
        return "/2020-05-31/realtime-log-config"
    }
}

public struct UpdateRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this real-time log configuration.
    public var arn: Swift.String?
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    public var fields: [Swift.String]?
    /// The name for this real-time log configuration.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    public var samplingRate: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

extension UpdateRealtimeLogConfigOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateRealtimeLogConfigOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateRealtimeLogConfigOutput()
            value.realtimeLogConfig = try reader["RealtimeLogConfig"].readIfPresent(readingClosure: CloudFrontClientTypes.RealtimeLogConfig.readingClosure)
            return value
        }
    }
}

public struct UpdateRealtimeLogConfigOutput: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init(
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

enum UpdateRealtimeLogConfigOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchRealtimeLogConfig": return try await NoSuchRealtimeLogConfig.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateResponseHeadersPolicyInput {
    static func writingClosure(_ value: UpdateResponseHeadersPolicyInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ResponseHeadersPolicyConfig"].write(value.responseHeadersPolicyConfig, writingClosure: CloudFrontClientTypes.ResponseHeadersPolicyConfig.writingClosure(_:to:))
    }
}

extension UpdateResponseHeadersPolicyInput {

    static func headerProvider(_ value: UpdateResponseHeadersPolicyInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateResponseHeadersPolicyInput {

    static func urlPathProvider(_ value: UpdateResponseHeadersPolicyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/response-headers-policy/\(id.urlPercentEncoding())"
    }
}

public struct UpdateResponseHeadersPolicyInput: Swift.Equatable {
    /// The identifier for the response headers policy that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the response headers policy that you are updating. The version is returned in the cache policy's ETag field in the response to GetResponseHeadersPolicyConfig.
    public var ifMatch: Swift.String?
    /// A response headers policy configuration.
    /// This member is required.
    public var responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        responseHeadersPolicyConfig: CloudFrontClientTypes.ResponseHeadersPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.responseHeadersPolicyConfig = responseHeadersPolicyConfig
    }
}

extension UpdateResponseHeadersPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateResponseHeadersPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateResponseHeadersPolicyOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.responseHeadersPolicy = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.ResponseHeadersPolicy.readingClosure)
            return value
        }
    }
}

public struct UpdateResponseHeadersPolicyOutput: Swift.Equatable {
    /// The current version of the response headers policy.
    public var eTag: Swift.String?
    /// A response headers policy.
    public var responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy?

    public init(
        eTag: Swift.String? = nil,
        responseHeadersPolicy: CloudFrontClientTypes.ResponseHeadersPolicy? = nil
    )
    {
        self.eTag = eTag
        self.responseHeadersPolicy = responseHeadersPolicy
    }
}

enum UpdateResponseHeadersPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchResponseHeadersPolicy": return try await NoSuchResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "ResponseHeadersPolicyAlreadyExists": return try await ResponseHeadersPolicyAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooLongCSPInResponseHeadersPolicy": return try await TooLongCSPInResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyCustomHeadersInResponseHeadersPolicy": return try await TooManyCustomHeadersInResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyRemoveHeadersInResponseHeadersPolicy": return try await TooManyRemoveHeadersInResponseHeadersPolicy.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension UpdateStreamingDistributionInput {
    static func writingClosure(_ value: UpdateStreamingDistributionInput?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["StreamingDistributionConfig"].write(value.streamingDistributionConfig, writingClosure: CloudFrontClientTypes.StreamingDistributionConfig.writingClosure(_:to:))
    }
}

extension UpdateStreamingDistributionInput {

    static func headerProvider(_ value: UpdateStreamingDistributionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = value.ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateStreamingDistributionInput {

    static func urlPathProvider(_ value: UpdateStreamingDistributionInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
    }
}

/// The request to update a streaming distribution.
public struct UpdateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the streaming distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init(
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

extension UpdateStreamingDistributionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateStreamingDistributionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader
            var value = UpdateStreamingDistributionOutput()
            if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
                value.eTag = eTagHeaderValue
            }
            value.streamingDistribution = try reader.readIfPresent(readingClosure: CloudFrontClientTypes.StreamingDistribution.readingClosure)
            return value
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateStreamingDistributionOutput: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init(
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

enum UpdateStreamingDistributionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let errorBodyReader = AWSClientRuntime.RestXMLError.errorBodyReader(responseReader: responseReader, noErrorWrapping: false)
            let restXMLError = try AWSClientRuntime.RestXMLError(responseReader: responseReader, noErrorWrapping: false)
            switch restXMLError.code {
                case "AccessDenied": return try await AccessDenied.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "CNAMEAlreadyExists": return try await CNAMEAlreadyExists.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "IllegalUpdate": return try await IllegalUpdate.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InconsistentQuantities": return try await InconsistentQuantities.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidArgument": return try await InvalidArgument.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidIfMatchVersion": return try await InvalidIfMatchVersion.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessControl": return try await InvalidOriginAccessControl.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "InvalidOriginAccessIdentity": return try await InvalidOriginAccessIdentity.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "MissingBody": return try await MissingBody.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "NoSuchStreamingDistribution": return try await NoSuchStreamingDistribution.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "PreconditionFailed": return try await PreconditionFailed.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyStreamingDistributionCNAMEs": return try await TooManyStreamingDistributionCNAMEs.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TooManyTrustedSigners": return try await TooManyTrustedSigners.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                case "TrustedSignerDoesNotExist": return try await TrustedSignerDoesNotExist.responseErrorBinding(httpResponse: httpResponse, reader: errorBodyReader, message: restXMLError.message, requestID: restXMLError.requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restXMLError.message, requestID: restXMLError.requestID, typeName: restXMLError.code)
            }
        }
    }
}

extension CloudFrontClientTypes.ViewerCertificate {

    static func writingClosure(_ value: CloudFrontClientTypes.ViewerCertificate?, to writer: SmithyXML.Writer) throws {
        guard let value else { writer.detach(); return }
        try writer["ACMCertificateArn"].write(value.acmCertificateArn)
        try writer["Certificate"].write(value.certificate)
        try writer["CertificateSource"].write(value.certificateSource)
        try writer["CloudFrontDefaultCertificate"].write(value.cloudFrontDefaultCertificate)
        try writer["IAMCertificateId"].write(value.iamCertificateId)
        try writer["MinimumProtocolVersion"].write(value.minimumProtocolVersion)
        try writer["SSLSupportMethod"].write(value.sslSupportMethod)
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudFrontClientTypes.ViewerCertificate, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudFrontClientTypes.ViewerCertificate()
            value.cloudFrontDefaultCertificate = try reader["CloudFrontDefaultCertificate"].readIfPresent()
            value.iamCertificateId = try reader["IAMCertificateId"].readIfPresent()
            value.acmCertificateArn = try reader["ACMCertificateArn"].readIfPresent()
            value.sslSupportMethod = try reader["SSLSupportMethod"].readIfPresent()
            value.minimumProtocolVersion = try reader["MinimumProtocolVersion"].readIfPresent()
            value.certificate = try reader["Certificate"].readIfPresent()
            value.certificateSource = try reader["CertificateSource"].readIfPresent()
            return value
        }
    }
}

extension CloudFrontClientTypes {
    /// A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers. If the distribution doesn't use Aliases (also known as alternate domain names or CNAMEs)—that is, if the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net—set CloudFrontDefaultCertificate to true and leave all other fields empty. If the distribution uses Aliases (alternate domain names or CNAMEs), use the fields in this type to specify the following settings:
    ///
    /// * Which viewers the distribution accepts HTTPS connections from: only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication) (recommended), or all viewers including those that don't support SNI.
    ///
    /// * To accept HTTPS connections from only viewers that support SNI, set SSLSupportMethod to sni-only. This is recommended. Most browsers and clients support SNI.
    ///
    /// * To accept HTTPS connections from all viewers, including those that don't support SNI, set SSLSupportMethod to vip. This is not recommended, and results in additional monthly charges from CloudFront.
    ///
    ///
    ///
    ///
    /// * The minimum SSL/TLS protocol version that the distribution can use to communicate with viewers. To specify a minimum version, choose a value for MinimumProtocolVersion. For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) in the Amazon CloudFront Developer Guide.
    ///
    /// * The location of the SSL/TLS certificate, [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended) or [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html). You specify the location by setting a value in one of the following fields (not both):
    ///
    /// * ACMCertificateArn
    ///
    /// * IAMCertificateId
    ///
    ///
    ///
    ///
    ///
    /// All distributions support HTTPS connections from viewers. To require viewers to use HTTPS only, or to redirect them from HTTP to HTTPS, use ViewerProtocolPolicy in the CacheBehavior or DefaultCacheBehavior. To specify how CloudFront should use SSL/TLS to communicate with your custom origin, use CustomOriginConfig. For more information, see [Using HTTPS with CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html) and [ Using Alternate Domain Names and HTTPS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html) in the Amazon CloudFront Developer Guide.
    public struct ViewerCertificate: Swift.Equatable {
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html), provide the Amazon Resource Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US East (N. Virginia) Region (us-east-1). If you specify an ACM certificate ARN, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var acmCertificateArn: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificate: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificateSource: CloudFrontClientTypes.CertificateSource?
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, set this field to true. If the distribution uses Aliases (alternate domain names or CNAMEs), set this field to false and specify values for the following fields:
        ///
        /// * ACMCertificateArn or IAMCertificateId (specify a value for one, not both)
        ///
        /// * MinimumProtocolVersion
        ///
        /// * SSLSupportMethod
        public var cloudFrontDefaultCertificate: Swift.Bool?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html), provide the ID of the IAM certificate. If you specify an IAM certificate ID, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var iamCertificateId: Swift.String?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify the security policy that you want CloudFront to use for HTTPS connections with viewers. The security policy determines two settings:
        ///
        /// * The minimum SSL/TLS protocol that CloudFront can use to communicate with viewers.
        ///
        /// * The ciphers that CloudFront can use to encrypt the content that it returns to viewers.
        ///
        ///
        /// For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) and [Supported Protocols and Ciphers Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers) in the Amazon CloudFront Developer Guide. On the CloudFront console, this setting is called Security Policy. When you're using SNI only (you set SSLSupportMethod to sni-only), you must specify TLSv1 or higher. If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net (you set CloudFrontDefaultCertificate to true), CloudFront automatically sets the security policy to TLSv1 regardless of the value that you set here.
        public var minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify which viewers the distribution accepts HTTPS connections from.
        ///
        /// * sni-only – The distribution accepts HTTPS connections from only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication). This is recommended. Most browsers and clients support SNI.
        ///
        /// * vip – The distribution accepts HTTPS connections from all viewers including those that don't support SNI. This is not recommended, and results in additional monthly charges from CloudFront.
        ///
        /// * static-ip - Do not specify this value unless your distribution has been enabled for this feature by the CloudFront team. If you have a use case that requires static IP addresses for a distribution, contact CloudFront through the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home).
        ///
        ///
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, don't set a value for this field.
        public var sslSupportMethod: CloudFrontClientTypes.SSLSupportMethod?

        public init(
            acmCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: CloudFrontClientTypes.CertificateSource? = nil,
            cloudFrontDefaultCertificate: Swift.Bool? = nil,
            iamCertificateId: Swift.String? = nil,
            minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion? = nil,
            sslSupportMethod: CloudFrontClientTypes.SSLSupportMethod? = nil
        )
        {
            self.acmCertificateArn = acmCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iamCertificateId = iamCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sslSupportMethod = sslSupportMethod
        }
    }

}

extension CloudFrontClientTypes {
    public enum ViewerProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowAll
        case httpsOnly
        case redirectToHttps
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewerProtocolPolicy] {
            return [
                .allowAll,
                .httpsOnly,
                .redirectToHttps,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "allow-all"
            case .httpsOnly: return "https-only"
            case .redirectToHttps: return "redirect-to-https"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViewerProtocolPolicy(rawValue: rawValue) ?? ViewerProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}
