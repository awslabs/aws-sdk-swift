//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum OrganizationRuleMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anyAllowed
        case noneAllowed
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationRuleMode] {
            return [
                .anyAllowed,
                .noneAllowed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anyAllowed: return "AnyAllowed"
            case .noneAllowed: return "NoneAllowed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum EnrollmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EnrollmentStatus] {
            return [
                .active,
                .failed,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case .inactive: return "Inactive"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Contains information about an Amazon Web Services account's enrollment and association status with Compute Optimizer Automation.
    public struct AccountInfo: Swift.Sendable {
        /// The ID of the Amazon Web Services account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The timestamp when the account's Automation enrollment status was last updated.
        /// This member is required.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// Specifies whether the management account can create Automation rules that implement optimization actions for this account.
        /// This member is required.
        public var organizationRuleMode: ComputeOptimizerAutomationClientTypes.OrganizationRuleMode?
        /// The enrollment status of the account: Active, Inactive, Pending, or Failed.
        /// This member is required.
        public var status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus?
        /// The reason for the current Automation enrollment status.
        public var statusReason: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            organizationRuleMode: ComputeOptimizerAutomationClientTypes.OrganizationRuleMode? = nil,
            status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.accountId = accountId
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.organizationRuleMode = organizationRuleMode
            self.status = status
            self.statusReason = statusReason
        }
    }
}

/// You are not authorized to perform this action.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified client token is already in use.
public struct IdempotencyTokenInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyTokenInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Exception thrown when the same client token is used with different parameters, indicating a mismatch in idempotent request parameters.
public struct IdempotentParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An internal error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The operation can only be performed by a management account.
public struct NotManagementAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotManagementAccountException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The account must be opted in to Compute Optimizer Automation before performing this action.
public struct OptInRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OptInRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct AssociateAccountsInput: Swift.Sendable {
    /// The IDs of the member accounts to associate. You can specify up to 50 account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// A unique identifier to ensure idempotency of the request. Valid for 24 hours after creation.
    public var clientToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil
    ) {
        self.accountIds = accountIds
        self.clientToken = clientToken
    }
}

public struct AssociateAccountsOutput: Swift.Sendable {
    /// The IDs of the member accounts that were successfully associated.
    public var accountIds: [Swift.String]?
    /// Any errors that occurred during the association process.
    public var errors: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil,
        errors: [Swift.String]? = nil
    ) {
        self.accountIds = accountIds
        self.errors = errors
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum SavingsEstimationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterDiscount
        case beforeDiscount
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsEstimationMode] {
            return [
                .afterDiscount,
                .beforeDiscount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterDiscount: return "AfterDiscount"
            case .beforeDiscount: return "BeforeDiscount"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Contains information about estimated monthly cost savings.
    public struct EstimatedMonthlySavings: Swift.Sendable {
        /// The estimated monthly savings after applying any discounts.
        /// This member is required.
        public var afterDiscountSavings: Swift.Double?
        /// The estimated monthly savings before applying any discounts.
        /// This member is required.
        public var beforeDiscountSavings: Swift.Double?
        /// The currency of the estimated savings.
        /// This member is required.
        public var currency: Swift.String?
        /// The mode used to calculate savings, either BeforeDiscount or AfterDiscount.
        /// This member is required.
        public var savingsEstimationMode: ComputeOptimizerAutomationClientTypes.SavingsEstimationMode?

        public init(
            afterDiscountSavings: Swift.Double? = nil,
            beforeDiscountSavings: Swift.Double? = nil,
            currency: Swift.String? = nil,
            savingsEstimationMode: ComputeOptimizerAutomationClientTypes.SavingsEstimationMode? = nil
        ) {
            self.afterDiscountSavings = afterDiscountSavings
            self.beforeDiscountSavings = beforeDiscountSavings
            self.currency = currency
            self.savingsEstimationMode = savingsEstimationMode
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum EventStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case complete
        case failed
        case inProgress
        case ready
        case rollbackComplete
        case rollbackFailed
        case rollbackInProgress
        case rollbackReady
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatus] {
            return [
                .cancelled,
                .complete,
                .failed,
                .inProgress,
                .ready,
                .rollbackComplete,
                .rollbackFailed,
                .rollbackInProgress,
                .rollbackReady
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .ready: return "Ready"
            case .rollbackComplete: return "RollbackComplete"
            case .rollbackFailed: return "RollbackFailed"
            case .rollbackInProgress: return "RollbackInProgress"
            case .rollbackReady: return "RollbackReady"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Event type enumeration
    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case snapshotAndDeleteUnattachedEbsVolume
        case upgradeEbsVolumeType
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .snapshotAndDeleteUnattachedEbsVolume,
                .upgradeEbsVolumeType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .snapshotAndDeleteUnattachedEbsVolume: return "SnapshotAndDeleteUnattachedEbsVolume"
            case .upgradeEbsVolumeType: return "UpgradeEbsVolumeType"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ebsVolume
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ebsVolume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ebsVolume: return "EbsVolume"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Contains information about an automation event.
    public struct AutomationEvent: Swift.Sendable {
        /// The Amazon Web Services account ID associated with the automation event.
        public var accountId: Swift.String?
        /// The timestamp when the automation event completed.
        public var completedTimestamp: Foundation.Date?
        /// The timestamp when the automation event was created.
        public var createdTimestamp: Foundation.Date?
        /// The estimated monthly cost savings associated with this automation event.
        public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?
        /// A description of the automation event.
        public var eventDescription: Swift.String?
        /// The unique identifier for the automation event.
        public var eventId: Swift.String?
        /// The current status of the automation event.
        public var eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus?
        /// The reason for the current event status.
        public var eventStatusReason: Swift.String?
        /// The type of automation event.
        public var eventType: ComputeOptimizerAutomationClientTypes.EventType?
        /// The ID of the recommended action associated with this automation event.
        public var recommendedActionId: Swift.String?
        /// The Amazon Web Services Region where the automation event occurred.
        public var region: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource affected by the automation event.
        public var resourceArn: Swift.String?
        /// The ID of the resource affected by the automation event.
        public var resourceId: Swift.String?
        /// The type of resource affected by the automation event.
        public var resourceType: ComputeOptimizerAutomationClientTypes.ResourceType?
        /// The ID of the automation rule that triggered this event.
        public var ruleId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            completedTimestamp: Foundation.Date? = nil,
            createdTimestamp: Foundation.Date? = nil,
            estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil,
            eventDescription: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus? = nil,
            eventStatusReason: Swift.String? = nil,
            eventType: ComputeOptimizerAutomationClientTypes.EventType? = nil,
            recommendedActionId: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: ComputeOptimizerAutomationClientTypes.ResourceType? = nil,
            ruleId: Swift.String? = nil
        ) {
            self.accountId = accountId
            self.completedTimestamp = completedTimestamp
            self.createdTimestamp = createdTimestamp
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.eventDescription = eventDescription
            self.eventId = eventId
            self.eventStatus = eventStatus
            self.eventStatusReason = eventStatusReason
            self.eventType = eventType
            self.recommendedActionId = recommendedActionId
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.ruleId = ruleId
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum AutomationEventFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case eventStatus
        case eventType
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationEventFilterName] {
            return [
                .accountId,
                .eventStatus,
                .eventType,
                .resourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "AccountId"
            case .eventStatus: return "EventStatus"
            case .eventType: return "EventType"
            case .resourceType: return "ResourceType"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// A filter to apply when listing automation events.
    public struct AutomationEventFilter: Swift.Sendable {
        /// The name of the filter to apply.
        /// This member is required.
        public var name: ComputeOptimizerAutomationClientTypes.AutomationEventFilterName?
        /// The values to use for the specified filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: ComputeOptimizerAutomationClientTypes.AutomationEventFilterName? = nil,
            values: [Swift.String]? = nil
        ) {
            self.name = name
            self.values = values
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum StepStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StepStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .ready: return "Ready"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum StepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createEbsSnapshot
        case createEbsVolume
        case deleteEbsVolume
        case modifyEbsVolume
        case sdkUnknown(Swift.String)

        public static var allCases: [StepType] {
            return [
                .createEbsSnapshot,
                .createEbsVolume,
                .deleteEbsVolume,
                .modifyEbsVolume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createEbsSnapshot: return "CreateEbsSnapshot"
            case .createEbsVolume: return "CreateEbsVolume"
            case .deleteEbsVolume: return "DeleteEbsVolume"
            case .modifyEbsVolume: return "ModifyEbsVolume"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Contains information about a step in an automation event.
    public struct AutomationEventStep: Swift.Sendable {
        /// The timestamp when this automation event step completed execution.
        public var completedTimestamp: Foundation.Date?
        /// Contains information about estimated monthly cost savings.
        public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?
        /// The ID of the automation event this step belongs to.
        public var eventId: Swift.String?
        /// The unique identifier of the resource being acted upon in this step.
        public var resourceId: Swift.String?
        /// The timestamp when this automation event step started execution.
        public var startTimestamp: Foundation.Date?
        /// The unique identifier for this step.
        public var stepId: Swift.String?
        /// The current status of the step.
        public var stepStatus: ComputeOptimizerAutomationClientTypes.StepStatus?
        /// The type of step.
        public var stepType: ComputeOptimizerAutomationClientTypes.StepType?

        public init(
            completedTimestamp: Foundation.Date? = nil,
            estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil,
            eventId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            startTimestamp: Foundation.Date? = nil,
            stepId: Swift.String? = nil,
            stepStatus: ComputeOptimizerAutomationClientTypes.StepStatus? = nil,
            stepType: ComputeOptimizerAutomationClientTypes.StepType? = nil
        ) {
            self.completedTimestamp = completedTimestamp
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.eventId = eventId
            self.resourceId = resourceId
            self.startTimestamp = startTimestamp
            self.stepId = stepId
            self.stepStatus = stepStatus
            self.stepType = stepType
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum SummaryDimensionKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eventStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [SummaryDimensionKey] {
            return [
                .eventStatus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eventStatus: return "EventStatus"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// A key-value pair used to categorize and group summary data for analysis and reporting.
    public struct SummaryDimension: Swift.Sendable {
        /// The dimension key used for categorizing summary data.
        /// This member is required.
        public var key: ComputeOptimizerAutomationClientTypes.SummaryDimensionKey?
        /// The specific value for this dimension key used in the summary grouping.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: ComputeOptimizerAutomationClientTypes.SummaryDimensionKey? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Defines a time range with inclusive start time and exclusive end time for filtering and analysis.
    public struct TimePeriod: Swift.Sendable {
        /// The end time of the period, exclusive. Events before this time are included.
        public var endTimeExclusive: Foundation.Date?
        /// The start time of the period, inclusive. Events at or after this time are included.
        public var startTimeInclusive: Foundation.Date?

        public init(
            endTimeExclusive: Foundation.Date? = nil,
            startTimeInclusive: Foundation.Date? = nil
        ) {
            self.endTimeExclusive = endTimeExclusive
            self.startTimeInclusive = startTimeInclusive
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Aggregate totals for automation events, including counts and estimated savings.
    public struct SummaryTotals: Swift.Sendable {
        /// The total number of automation events in this summary group.
        public var automationEventCount: Swift.Int?
        /// Contains information about estimated monthly cost savings.
        public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?

        public init(
            automationEventCount: Swift.Int? = nil,
            estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil
        ) {
            self.automationEventCount = automationEventCount
            self.estimatedMonthlySavings = estimatedMonthlySavings
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// A summary of automation events grouped by specified dimensions.
    public struct AutomationEventSummary: Swift.Sendable {
        /// The dimensions used to group this summary, such as event status.
        public var dimensions: [ComputeOptimizerAutomationClientTypes.SummaryDimension]?
        /// The key identifier for this summary grouping.
        public var key: Swift.String?
        /// The time period covered by this summary, with inclusive start time and exclusive end time.
        public var timePeriod: ComputeOptimizerAutomationClientTypes.TimePeriod?
        /// The aggregated totals for this summary, including event count and estimated savings.
        public var total: ComputeOptimizerAutomationClientTypes.SummaryTotals?

        public init(
            dimensions: [ComputeOptimizerAutomationClientTypes.SummaryDimension]? = nil,
            key: Swift.String? = nil,
            timePeriod: ComputeOptimizerAutomationClientTypes.TimePeriod? = nil,
            total: ComputeOptimizerAutomationClientTypes.SummaryTotals? = nil
        ) {
            self.dimensions = dimensions
            self.key = key
            self.timePeriod = timePeriod
            self.total = total
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum RuleApplyOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterAccountRules
        case beforeAccountRules
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleApplyOrder] {
            return [
                .afterAccountRules,
                .beforeAccountRules
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterAccountRules: return "AfterAccountRules"
            case .beforeAccountRules: return "BeforeAccountRules"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Configuration settings for organization-wide automation rules.
    public struct OrganizationConfiguration: Swift.Sendable {
        /// List of specific Amazon Web Services account IDs where the organization rule should be applied.
        public var accountIds: [Swift.String]?
        /// Specifies when organization rules should be applied relative to account rules.
        public var ruleApplyOrder: ComputeOptimizerAutomationClientTypes.RuleApplyOrder?

        public init(
            accountIds: [Swift.String]? = nil,
            ruleApplyOrder: ComputeOptimizerAutomationClientTypes.RuleApplyOrder? = nil
        ) {
            self.accountIds = accountIds
            self.ruleApplyOrder = ruleApplyOrder
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Recommended action type enumeration
    public enum RecommendedActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case snapshotAndDeleteUnattachedEbsVolume
        case upgradeEbsVolumeType
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendedActionType] {
            return [
                .snapshotAndDeleteUnattachedEbsVolume,
                .upgradeEbsVolumeType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .snapshotAndDeleteUnattachedEbsVolume: return "SnapshotAndDeleteUnattachedEbsVolume"
            case .upgradeEbsVolumeType: return "UpgradeEbsVolumeType"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum RuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountRule
        case organizationalRule
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleType] {
            return [
                .accountRule,
                .organizationalRule
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountRule: return "AccountRule"
            case .organizationalRule: return "OrganizationRule"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Configuration for scheduling when automation rules should execute, including timing and execution windows.
    public struct Schedule: Swift.Sendable {
        /// The time window in minutes during which the automation rule can start implementing recommended actions.
        public var executionWindowInMinutes: Swift.Int?
        /// The expression that defines when the schedule runs. cron expression is supported. A cron expression consists of six fields separated by white spaces: (minutes
        ///     hours
        ///
        ///
        ///     day_of_month
        ///
        ///
        ///     month
        ///
        ///
        ///     day_of_week
        ///
        /// year) You can schedule rules to run at most once per day. Your cron expression must use specific values (not wildcards) for the minutes and hours fields. For example: (30 12 * * *) runs daily at 12:30 PM UTC.
        public var scheduleExpression: Swift.String?
        /// The timezone to use when interpreting the schedule expression.
        public var scheduleExpressionTimezone: Swift.String?

        public init(
            executionWindowInMinutes: Swift.Int? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleExpressionTimezone: Swift.String? = nil
        ) {
            self.executionWindowInMinutes = executionWindowInMinutes
            self.scheduleExpression = scheduleExpression
            self.scheduleExpressionTimezone = scheduleExpressionTimezone
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum RuleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Represents a complete automation rule configuration including criteria, schedule, and execution settings.
    public struct AutomationRule: Swift.Sendable {
        /// The 12-digit Amazon Web Services account ID that owns this automation rule.
        public var accountId: Swift.String?
        /// The timestamp when the automation rule was created.
        public var createdTimestamp: Foundation.Date?
        /// A description of the automation rule.
        public var description: Swift.String?
        /// The timestamp when the automation rule was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The name of the automation rule.
        public var name: Swift.String?
        /// Configuration settings for organization-wide rules.
        public var organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration?
        /// A string representation of a decimal number between 0 and 1 (having up to 30 digits after the decimal point) that determines the priority of the rule. When multiple rules match the same recommended action, Compute Optimizer assigns the action to the rule with the lowest priority value (highest priority), even if that rule is scheduled to run later than other matching rules.
        public var priority: Swift.String?
        /// List of recommended action types that this rule can execute.
        public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
        /// The Amazon Resource Name (ARN) of the automation rule.
        public var ruleArn: Swift.String?
        /// The unique identifier of the automation rule.
        public var ruleId: Swift.String?
        /// The revision number of the automation rule.
        public var ruleRevision: Swift.Int?
        /// The type of automation rule (OrganizationRule or AccountRule).
        public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?
        /// The schedule configuration for when the automation rule should execute.
        public var schedule: ComputeOptimizerAutomationClientTypes.Schedule?
        /// The current status of the automation rule (Active or Inactive).
        public var status: ComputeOptimizerAutomationClientTypes.RuleStatus?

        public init(
            accountId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration? = nil,
            priority: Swift.String? = nil,
            recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
            ruleArn: Swift.String? = nil,
            ruleId: Swift.String? = nil,
            ruleRevision: Swift.Int? = nil,
            ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil,
            schedule: ComputeOptimizerAutomationClientTypes.Schedule? = nil,
            status: ComputeOptimizerAutomationClientTypes.RuleStatus? = nil
        ) {
            self.accountId = accountId
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.organizationConfiguration = organizationConfiguration
            self.priority = priority
            self.recommendedActionTypes = recommendedActionTypes
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.ruleRevision = ruleRevision
            self.ruleType = ruleType
            self.schedule = schedule
            self.status = status
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum AutomationRuleFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case name
        case organizationConfigurationRuleApplyOrder
        case recommendedActionType
        case ruleType
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationRuleFilterName] {
            return [
                .accountId,
                .name,
                .organizationConfigurationRuleApplyOrder,
                .recommendedActionType,
                .ruleType,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "AccountId"
            case .name: return "Name"
            case .organizationConfigurationRuleApplyOrder: return "OrganizationConfigurationRuleApplyOrder"
            case .recommendedActionType: return "RecommendedActionType"
            case .ruleType: return "RuleType"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum ComparisonOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case numericEquals
        case numericGreaterThan
        case numericGreaterThanEquals
        case numericLessThan
        case numericLessThanEquals
        case numericNotEquals
        case stringEquals
        case stringEqualsIgnoreCase
        case stringLike
        case stringNotEquals
        case stringNotEqualsIgnoreCase
        case stringNotLike
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .numericEquals,
                .numericGreaterThan,
                .numericGreaterThanEquals,
                .numericLessThan,
                .numericLessThanEquals,
                .numericNotEquals,
                .stringEquals,
                .stringEqualsIgnoreCase,
                .stringLike,
                .stringNotEquals,
                .stringNotEqualsIgnoreCase,
                .stringNotLike
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .numericEquals: return "NumericEquals"
            case .numericGreaterThan: return "NumericGreaterThan"
            case .numericGreaterThanEquals: return "NumericGreaterThanEquals"
            case .numericLessThan: return "NumericLessThan"
            case .numericLessThanEquals: return "NumericLessThanEquals"
            case .numericNotEquals: return "NumericNotEquals"
            case .stringEquals: return "StringEquals"
            case .stringEqualsIgnoreCase: return "StringEqualsIgnoreCase"
            case .stringLike: return "StringLike"
            case .stringNotEquals: return "StringNotEquals"
            case .stringNotEqualsIgnoreCase: return "StringNotEqualsIgnoreCase"
            case .stringNotLike: return "StringNotLike"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request would exceed service quotas.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Defines a condition for filtering based on integer values with comparison operators.
    public struct IntegerCriteriaCondition: Swift.Sendable {
        /// The comparison operator to use, such as equals, greater than, less than, etc.
        public var comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator?
        /// The list of integer values to compare against using the specified comparison operator.
        public var values: [Swift.Int]?

        public init(
            comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator? = nil,
            values: [Swift.Int]? = nil
        ) {
            self.comparison = comparison
            self.values = values
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Criteria condition for filtering based on string values, including comparison operators and target values.
    public struct StringCriteriaCondition: Swift.Sendable {
        /// The comparison operator used to evaluate the string criteria, such as equals, not equals, or contains.
        public var comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator?
        /// List of string values to compare against when applying the criteria condition.
        public var values: [Swift.String]?

        public init(
            comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator? = nil,
            values: [Swift.String]? = nil
        ) {
            self.comparison = comparison
            self.values = values
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Defines a condition for filtering based on double/floating-point numeric values with comparison operators.
    public struct DoubleCriteriaCondition: Swift.Sendable {
        /// The comparison operator to use, such as equals, greater than, less than, etc.
        public var comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator?
        /// The list of double values to compare against using the specified comparison operator.
        public var values: [Swift.Double]?

        public init(
            comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator? = nil,
            values: [Swift.Double]? = nil
        ) {
            self.comparison = comparison
            self.values = values
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Criteria condition for filtering resources based on their tags, including comparison operators and values.
    public struct ResourceTagsCriteriaCondition: Swift.Sendable {
        /// The comparison operator used to evaluate the tag criteria, such as equals, not equals, or contains.
        public var comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator?
        /// The tag key to use for comparison when filtering resources.
        public var key: Swift.String?
        /// List of tag values to compare against when filtering resources.
        public var values: [Swift.String]?

        public init(
            comparison: ComputeOptimizerAutomationClientTypes.ComparisonOperator? = nil,
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.comparison = comparison
            self.key = key
            self.values = values
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time. You can specify up to 20 conditions per filter criteria and 20 values per condition.
    public struct Criteria: Swift.Sendable {
        /// Filter criteria for EBS volume sizes in gibibytes (GiB).
        public var ebsVolumeSizeInGib: [ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition]?
        /// Filter criteria for EBS volume types, such as gp2, gp3, io1, io2, st1, or sc1.
        public var ebsVolumeType: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]?
        /// Filter criteria for estimated monthly cost savings from the recommended action.
        public var estimatedMonthlySavings: [ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition]?
        /// Filter criteria for the lookback period in days used to analyze resource utilization.
        public var lookBackPeriodInDays: [ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition]?
        /// Filter criteria for Amazon Web Services regions where resources must be located.
        public var region: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]?
        /// Filter criteria for specific resource ARNs to include or exclude.
        public var resourceArn: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]?
        /// Filter criteria for resource tags, allowing filtering by tag key and value combinations.
        public var resourceTag: [ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition]?
        /// Filter criteria indicating whether the recommended action requires a resource restart.
        public var restartNeeded: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]?

        public init(
            ebsVolumeSizeInGib: [ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition]? = nil,
            ebsVolumeType: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]? = nil,
            estimatedMonthlySavings: [ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition]? = nil,
            lookBackPeriodInDays: [ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition]? = nil,
            region: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]? = nil,
            resourceArn: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]? = nil,
            resourceTag: [ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition]? = nil,
            restartNeeded: [ComputeOptimizerAutomationClientTypes.StringCriteriaCondition]? = nil
        ) {
            self.ebsVolumeSizeInGib = ebsVolumeSizeInGib
            self.ebsVolumeType = ebsVolumeType
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.lookBackPeriodInDays = lookBackPeriodInDays
            self.region = region
            self.resourceArn = resourceArn
            self.resourceTag = resourceTag
            self.restartNeeded = restartNeeded
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// A key-value pair used to categorize and organize Amazon Web Services resources and automation rules.
    public struct Tag: Swift.Sendable {
        /// The tag key, which can be up to 128 characters long.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value, which can be up to 256 characters long.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateAutomationRuleInput: Swift.Sendable {
    /// A unique identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time.
    public var criteria: ComputeOptimizerAutomationClientTypes.Criteria?
    /// A description of the automation rule.
    public var description: Swift.String?
    /// The name of the automation rule.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration for organization-level rules. Required for OrganizationRule type.
    public var organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration?
    /// A string representation of a decimal number between 0 and 1 (having up to 30 digits after the decimal point) that determines the priority of the rule. When multiple rules match the same recommended action, Compute Optimizer assigns the action to the rule with the lowest priority value (highest priority), even if that rule is scheduled to run later than other matching rules.
    public var priority: Swift.String?
    /// The types of recommended actions this rule will automate.
    /// This member is required.
    public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
    /// The type of rule. Only the management account or a delegated administrator can set the ruleType to be OrganizationRule.
    /// This member is required.
    public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?
    /// The schedule for when the rule should run.
    /// This member is required.
    public var schedule: ComputeOptimizerAutomationClientTypes.Schedule?
    /// The status of the rule
    /// This member is required.
    public var status: ComputeOptimizerAutomationClientTypes.RuleStatus?
    /// The tags to associate with the rule.
    public var tags: [ComputeOptimizerAutomationClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        criteria: ComputeOptimizerAutomationClientTypes.Criteria? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration? = nil,
        priority: Swift.String? = nil,
        recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
        ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil,
        schedule: ComputeOptimizerAutomationClientTypes.Schedule? = nil,
        status: ComputeOptimizerAutomationClientTypes.RuleStatus? = nil,
        tags: [ComputeOptimizerAutomationClientTypes.Tag]? = nil
    ) {
        self.clientToken = clientToken
        self.criteria = criteria
        self.description = description
        self.name = name
        self.organizationConfiguration = organizationConfiguration
        self.priority = priority
        self.recommendedActionTypes = recommendedActionTypes
        self.ruleType = ruleType
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

public struct CreateAutomationRuleOutput: Swift.Sendable {
    /// The timestamp when the automation rule was created.
    public var createdTimestamp: Foundation.Date?
    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time. You can specify up to 20 conditions per filter criteria and 20 values per condition.
    public var criteria: ComputeOptimizerAutomationClientTypes.Criteria?
    /// A description of the automation rule. Can be up to 1024 characters long and contain alphanumeric characters, underscores, hyphens, spaces, and certain special characters.
    public var description: Swift.String?
    /// The name of the automation rule. Must be 1-128 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var name: Swift.String?
    /// Configuration settings for organization-wide rules, including rule application order and target account IDs.
    public var organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration?
    /// The priority level of the automation rule, used to determine execution order when multiple rules apply to the same resource.
    public var priority: Swift.String?
    /// List of recommended action types that this rule can execute, such as SnapshotAndDeleteUnattachedEbsVolume or UpgradeEbsVolumeType.
    public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
    /// The Amazon Resource Name (ARN) of the created rule.
    public var ruleArn: Swift.String?
    /// The unique identifier of the created rule.
    public var ruleId: Swift.String?
    /// The revision number of the automation rule. This is incremented each time the rule is updated.
    public var ruleRevision: Swift.Int?
    /// The type of automation rule. Can be either OrganizationRule for organization-wide rules or AccountRule for account-specific rules.
    public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?
    /// The schedule configuration for when the automation rule should execute, including cron expression, timezone, and execution window.
    public var schedule: ComputeOptimizerAutomationClientTypes.Schedule?
    /// The current status of the automation rule. Can be Active or Inactive.
    public var status: ComputeOptimizerAutomationClientTypes.RuleStatus?
    /// A list of key-value pairs used to categorize and organize the automation rule. Maximum of 200 tags allowed.
    public var tags: [ComputeOptimizerAutomationClientTypes.Tag]?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        criteria: ComputeOptimizerAutomationClientTypes.Criteria? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration? = nil,
        priority: Swift.String? = nil,
        recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
        ruleArn: Swift.String? = nil,
        ruleId: Swift.String? = nil,
        ruleRevision: Swift.Int? = nil,
        ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil,
        schedule: ComputeOptimizerAutomationClientTypes.Schedule? = nil,
        status: ComputeOptimizerAutomationClientTypes.RuleStatus? = nil,
        tags: [ComputeOptimizerAutomationClientTypes.Tag]? = nil
    ) {
        self.createdTimestamp = createdTimestamp
        self.criteria = criteria
        self.description = description
        self.name = name
        self.organizationConfiguration = organizationConfiguration
        self.priority = priority
        self.recommendedActionTypes = recommendedActionTypes
        self.ruleArn = ruleArn
        self.ruleId = ruleId
        self.ruleRevision = ruleRevision
        self.ruleType = ruleType
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

public struct DeleteAutomationRuleInput: Swift.Sendable {
    /// A unique identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The ARN of the rule to delete.
    /// This member is required.
    public var ruleArn: Swift.String?
    /// The revision number of the rule to delete.
    /// This member is required.
    public var ruleRevision: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        ruleArn: Swift.String? = nil,
        ruleRevision: Swift.Int? = nil
    ) {
        self.clientToken = clientToken
        self.ruleArn = ruleArn
        self.ruleRevision = ruleRevision
    }
}

public struct DeleteAutomationRuleOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateAccountsInput: Swift.Sendable {
    /// The IDs of the member accounts to disassociate.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// A unique identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil
    ) {
        self.accountIds = accountIds
        self.clientToken = clientToken
    }
}

public struct DisassociateAccountsOutput: Swift.Sendable {
    /// The IDs of the member accounts that were successfully disassociated.
    public var accountIds: [Swift.String]?
    /// Any errors that occurred during the disassociation process.
    public var errors: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil,
        errors: [Swift.String]? = nil
    ) {
        self.accountIds = accountIds
        self.errors = errors
    }
}

public struct GetAutomationEventInput: Swift.Sendable {
    /// The ID of the automation event to retrieve.
    /// This member is required.
    public var eventId: Swift.String?

    public init(
        eventId: Swift.String? = nil
    ) {
        self.eventId = eventId
    }
}

public struct GetAutomationEventOutput: Swift.Sendable {
    /// The Amazon Web Services account ID associated with the automation event.
    public var accountId: Swift.String?
    /// The timestamp when the automation event completed.
    public var completedTimestamp: Foundation.Date?
    /// The timestamp when the automation event was created.
    public var createdTimestamp: Foundation.Date?
    /// Contains information about estimated monthly cost savings.
    public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?
    /// A description of the automation event.
    public var eventDescription: Swift.String?
    /// The ID of the automation event to retrieve.
    public var eventId: Swift.String?
    /// The current status of the automation event.
    public var eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus?
    /// The reason for the current event status.
    public var eventStatusReason: Swift.String?
    /// The type of automation event.
    public var eventType: ComputeOptimizerAutomationClientTypes.EventType?
    /// The ID of the recommended action associated with this automation event.
    public var recommendedActionId: Swift.String?
    /// The Amazon Web Services Region where the automation event occurred.
    public var region: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource affected by the automation event.
    public var resourceArn: Swift.String?
    /// The ID of the resource affected by the automation event.
    public var resourceId: Swift.String?
    /// The type of resource affected by the automation event.
    public var resourceType: ComputeOptimizerAutomationClientTypes.ResourceType?
    /// The ID of the automation rule that triggered this event.
    public var ruleId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        completedTimestamp: Foundation.Date? = nil,
        createdTimestamp: Foundation.Date? = nil,
        estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil,
        eventDescription: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus? = nil,
        eventStatusReason: Swift.String? = nil,
        eventType: ComputeOptimizerAutomationClientTypes.EventType? = nil,
        recommendedActionId: Swift.String? = nil,
        region: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ComputeOptimizerAutomationClientTypes.ResourceType? = nil,
        ruleId: Swift.String? = nil
    ) {
        self.accountId = accountId
        self.completedTimestamp = completedTimestamp
        self.createdTimestamp = createdTimestamp
        self.estimatedMonthlySavings = estimatedMonthlySavings
        self.eventDescription = eventDescription
        self.eventId = eventId
        self.eventStatus = eventStatus
        self.eventStatusReason = eventStatusReason
        self.eventType = eventType
        self.recommendedActionId = recommendedActionId
        self.region = region
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.ruleId = ruleId
    }
}

public struct GetAutomationRuleInput: Swift.Sendable {
    /// The ARN of the rule to retrieve.
    /// This member is required.
    public var ruleArn: Swift.String?

    public init(
        ruleArn: Swift.String? = nil
    ) {
        self.ruleArn = ruleArn
    }
}

public struct GetAutomationRuleOutput: Swift.Sendable {
    /// The 12-digit Amazon Web Services account ID that owns this automation rule.
    public var accountId: Swift.String?
    /// The timestamp when the automation rule was created.
    public var createdTimestamp: Foundation.Date?
    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time. You can specify up to 20 conditions per filter criteria and 20 values per condition.
    public var criteria: ComputeOptimizerAutomationClientTypes.Criteria?
    /// A description of the automation rule.
    public var description: Swift.String?
    /// The timestamp when the automation rule was last updated.
    public var lastUpdatedTimestamp: Foundation.Date?
    /// The name of the automation rule.
    public var name: Swift.String?
    /// Configuration settings for organization-wide automation rules.
    public var organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration?
    /// A string representation of a decimal number between 0 and 1 (having up to 30 digits after the decimal point) that determines the priority of the rule.
    public var priority: Swift.String?
    /// List of recommended action types that this rule can execute.
    public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
    /// The Amazon Resource Name (ARN) of the automation rule.
    public var ruleArn: Swift.String?
    /// The unique identifier of the automation rule.
    public var ruleId: Swift.String?
    /// The revision number of the automation rule.
    public var ruleRevision: Swift.Int?
    /// The type of automation rule.
    public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?
    /// Configuration for scheduling when automation rules should execute, including timing and execution windows.
    public var schedule: ComputeOptimizerAutomationClientTypes.Schedule?
    /// The current status of the automation rule (Active or Inactive).
    public var status: ComputeOptimizerAutomationClientTypes.RuleStatus?
    /// The tags associated with the automation rule.
    public var tags: [ComputeOptimizerAutomationClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        criteria: ComputeOptimizerAutomationClientTypes.Criteria? = nil,
        description: Swift.String? = nil,
        lastUpdatedTimestamp: Foundation.Date? = nil,
        name: Swift.String? = nil,
        organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration? = nil,
        priority: Swift.String? = nil,
        recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
        ruleArn: Swift.String? = nil,
        ruleId: Swift.String? = nil,
        ruleRevision: Swift.Int? = nil,
        ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil,
        schedule: ComputeOptimizerAutomationClientTypes.Schedule? = nil,
        status: ComputeOptimizerAutomationClientTypes.RuleStatus? = nil,
        tags: [ComputeOptimizerAutomationClientTypes.Tag]? = nil
    ) {
        self.accountId = accountId
        self.createdTimestamp = createdTimestamp
        self.criteria = criteria
        self.description = description
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.name = name
        self.organizationConfiguration = organizationConfiguration
        self.priority = priority
        self.recommendedActionTypes = recommendedActionTypes
        self.ruleArn = ruleArn
        self.ruleId = ruleId
        self.ruleRevision = ruleRevision
        self.ruleType = ruleType
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

public struct GetEnrollmentConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct GetEnrollmentConfigurationOutput: Swift.Sendable {
    /// The timestamp of the last update to the enrollment configuration.
    public var lastUpdatedTimestamp: Foundation.Date?
    /// Specifies whether the management account can create Automation rules that implement optimization actions for this account.
    public var organizationRuleMode: ComputeOptimizerAutomationClientTypes.OrganizationRuleMode?
    /// The current enrollment status.
    /// This member is required.
    public var status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus?
    /// The reason for the current enrollment status.
    public var statusReason: Swift.String?

    public init(
        lastUpdatedTimestamp: Foundation.Date? = nil,
        organizationRuleMode: ComputeOptimizerAutomationClientTypes.OrganizationRuleMode? = nil,
        status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.organizationRuleMode = organizationRuleMode
        self.status = status
        self.statusReason = statusReason
    }
}

public struct ListAccountsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAccountsOutput: Swift.Sendable {
    /// The list of accounts in your organization enrolled in Compute Optimizer
    /// This member is required.
    public var accounts: [ComputeOptimizerAutomationClientTypes.AccountInfo]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accounts: [ComputeOptimizerAutomationClientTypes.AccountInfo]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.accounts = accounts
        self.nextToken = nextToken
    }
}

public struct ListAutomationEventsInput: Swift.Sendable {
    /// The end of the time range to query for events.
    public var endTimeExclusive: Foundation.Date?
    /// The filters to apply to the list of automation events.
    public var filters: [ComputeOptimizerAutomationClientTypes.AutomationEventFilter]?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The start of the time range to query for events.
    public var startTimeInclusive: Foundation.Date?

    public init(
        endTimeExclusive: Foundation.Date? = nil,
        filters: [ComputeOptimizerAutomationClientTypes.AutomationEventFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeInclusive: Foundation.Date? = nil
    ) {
        self.endTimeExclusive = endTimeExclusive
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeInclusive = startTimeInclusive
    }
}

public struct ListAutomationEventsOutput: Swift.Sendable {
    /// The list of automation events that match the specified criteria.
    public var automationEvents: [ComputeOptimizerAutomationClientTypes.AutomationEvent]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        automationEvents: [ComputeOptimizerAutomationClientTypes.AutomationEvent]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.automationEvents = automationEvents
        self.nextToken = nextToken
    }
}

public struct ListAutomationEventStepsInput: Swift.Sendable {
    /// The ID of the automation event.
    /// This member is required.
    public var eventId: Swift.String?
    /// The maximum number of automation event steps to return in a single response. Valid range is 1-1000.
    public var maxResults: Swift.Int?
    /// A token used for pagination to retrieve the next set of results when the response is truncated.
    public var nextToken: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.eventId = eventId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAutomationEventStepsOutput: Swift.Sendable {
    /// The list of steps for the specified automation event.
    public var automationEventSteps: [ComputeOptimizerAutomationClientTypes.AutomationEventStep]?
    /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
    public var nextToken: Swift.String?

    public init(
        automationEventSteps: [ComputeOptimizerAutomationClientTypes.AutomationEventStep]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.automationEventSteps = automationEventSteps
        self.nextToken = nextToken
    }
}

public struct ListAutomationEventSummariesInput: Swift.Sendable {
    /// The end date for filtering automation event summaries, exclusive. Events created before this date will be included.
    public var endDateExclusive: Swift.String?
    /// The filters to apply to the list of automation event summaries.
    public var filters: [ComputeOptimizerAutomationClientTypes.AutomationEventFilter]?
    /// The maximum number of automation event summaries to return in a single response. Valid range is 1-1000.
    public var maxResults: Swift.Int?
    /// A token used for pagination to retrieve the next set of results when the response is truncated.
    public var nextToken: Swift.String?
    /// The start date for filtering automation event summaries, inclusive. Events created on or after this date will be included.
    public var startDateInclusive: Swift.String?

    public init(
        endDateExclusive: Swift.String? = nil,
        filters: [ComputeOptimizerAutomationClientTypes.AutomationEventFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startDateInclusive: Swift.String? = nil
    ) {
        self.endDateExclusive = endDateExclusive
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startDateInclusive = startDateInclusive
    }
}

public struct ListAutomationEventSummariesOutput: Swift.Sendable {
    /// The list of automation event summaries that match the specified criteria.
    public var automationEventSummaries: [ComputeOptimizerAutomationClientTypes.AutomationEventSummary]?
    /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
    public var nextToken: Swift.String?

    public init(
        automationEventSummaries: [ComputeOptimizerAutomationClientTypes.AutomationEventSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.automationEventSummaries = automationEventSummaries
        self.nextToken = nextToken
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Defines the scope for organization-level rules when previewing matching actions.
    public struct OrganizationScope: Swift.Sendable {
        /// List of Amazon Web Services account IDs to include in the organization scope.
        public var accountIds: [Swift.String]?

        public init(
            accountIds: [Swift.String]? = nil
        ) {
            self.accountIds = accountIds
        }
    }
}

public struct ListAutomationRulePreviewInput: Swift.Sendable {
    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time.
    public var criteria: ComputeOptimizerAutomationClientTypes.Criteria?
    /// The maximum number of automation rule preview results to return in a single response. Valid range is 1-1000.
    public var maxResults: Swift.Int?
    /// A token used for pagination to retrieve the next set of results when the response is truncated.
    public var nextToken: Swift.String?
    /// The organizational scope for the rule preview.
    public var organizationScope: ComputeOptimizerAutomationClientTypes.OrganizationScope?
    /// The types of recommended actions to include in the preview.
    /// This member is required.
    public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
    /// The type of rule. Only the management account or a delegated administrator can set the ruleType to be OrganizationRule.
    /// This member is required.
    public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?

    public init(
        criteria: ComputeOptimizerAutomationClientTypes.Criteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationScope: ComputeOptimizerAutomationClientTypes.OrganizationScope? = nil,
        recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
        ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil
    ) {
        self.criteria = criteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationScope = organizationScope
        self.recommendedActionTypes = recommendedActionTypes
        self.ruleType = ruleType
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Configuration details for an Amazon EBS volume.
    public struct EbsVolumeConfiguration: Swift.Sendable {
        /// The number of I/O operations per second (IOPS) provisioned for the volume.
        public var iops: Swift.Int?
        /// The size of the EBS volume in gibibytes (GiB).
        public var sizeInGib: Swift.Int?
        /// The throughput in MiB/s provisioned for the volume (applicable to gp3, io1, and io2bx volumes).
        public var throughput: Swift.Int?
        /// The EBS volume type, such as gp2, gp3, io1, io2, st1, or sc1.
        public var type: Swift.String?

        public init(
            iops: Swift.Int? = nil,
            sizeInGib: Swift.Int? = nil,
            throughput: Swift.Int? = nil,
            type: Swift.String? = nil
        ) {
            self.iops = iops
            self.sizeInGib = sizeInGib
            self.throughput = throughput
            self.type = type
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Represents an Amazon EBS volume with its configuration and snapshot usage information.
    public struct EbsVolume: Swift.Sendable {
        /// The configuration details of the EBS volume, including type, size, IOPS, and throughput.
        public var configuration: ComputeOptimizerAutomationClientTypes.EbsVolumeConfiguration?

        public init(
            configuration: ComputeOptimizerAutomationClientTypes.EbsVolumeConfiguration? = nil
        ) {
            self.configuration = configuration
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Detailed configuration information for a specific Amazon Web Services resource, with type-specific details.
    public enum ResourceDetails: Swift.Sendable {
        /// Detailed configuration information specific to EBS volumes, including volume type, size, IOPS, and throughput settings.
        case ebsvolume(ComputeOptimizerAutomationClientTypes.EbsVolume)
        case sdkUnknown(Swift.String)
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Contains the results of previewing an automation rule against available recommendations.
    public struct PreviewResult: Swift.Sendable {
        /// The Amazon Web Services account ID associated with the resource.
        public var accountId: Swift.String?
        /// Detailed configuration information for a specific Amazon Web Services resource, with type-specific details.
        public var currentResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails?
        /// A summary of the resource's current configuration.
        public var currentResourceSummary: Swift.String?
        /// Contains information about estimated monthly cost savings.
        public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?
        /// The number of days of historical data used to analyze the resource.
        public var lookBackPeriodInDays: Swift.Int?
        /// The ID of the recommended action being previewed.
        public var recommendedActionId: Swift.String?
        /// The type of recommended action being previewed.
        public var recommendedActionType: ComputeOptimizerAutomationClientTypes.RecommendedActionType?
        /// Detailed configuration information for a specific Amazon Web Services resource, with type-specific details.
        public var recommendedResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails?
        /// A summary of the resource's recommended configuration.
        public var recommendedResourceSummary: Swift.String?
        /// The Amazon Web Services Region where the resource is located.
        public var region: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource affected by the recommended action.
        public var resourceArn: Swift.String?
        /// The ID of the resource affected by the recommended action.
        public var resourceId: Swift.String?
        /// The tags associated with the resource.
        public var resourceTags: [ComputeOptimizerAutomationClientTypes.Tag]?
        /// The type of resource being evaluated.
        public var resourceType: ComputeOptimizerAutomationClientTypes.ResourceType?
        /// Indicates whether implementing the recommended action requires a resource restart.
        public var restartNeeded: Swift.Bool?

        public init(
            accountId: Swift.String? = nil,
            currentResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails? = nil,
            currentResourceSummary: Swift.String? = nil,
            estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil,
            lookBackPeriodInDays: Swift.Int? = nil,
            recommendedActionId: Swift.String? = nil,
            recommendedActionType: ComputeOptimizerAutomationClientTypes.RecommendedActionType? = nil,
            recommendedResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails? = nil,
            recommendedResourceSummary: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceTags: [ComputeOptimizerAutomationClientTypes.Tag]? = nil,
            resourceType: ComputeOptimizerAutomationClientTypes.ResourceType? = nil,
            restartNeeded: Swift.Bool? = nil
        ) {
            self.accountId = accountId
            self.currentResourceDetails = currentResourceDetails
            self.currentResourceSummary = currentResourceSummary
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.lookBackPeriodInDays = lookBackPeriodInDays
            self.recommendedActionId = recommendedActionId
            self.recommendedActionType = recommendedActionType
            self.recommendedResourceDetails = recommendedResourceDetails
            self.recommendedResourceSummary = recommendedResourceSummary
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.restartNeeded = restartNeeded
        }
    }
}

public struct ListAutomationRulePreviewOutput: Swift.Sendable {
    /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The list of actions that would be taken based on the specified criteria.
    public var previewResults: [ComputeOptimizerAutomationClientTypes.PreviewResult]?

    public init(
        nextToken: Swift.String? = nil,
        previewResults: [ComputeOptimizerAutomationClientTypes.PreviewResult]? = nil
    ) {
        self.nextToken = nextToken
        self.previewResults = previewResults
    }
}

public struct ListAutomationRulePreviewSummariesInput: Swift.Sendable {
    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time. You can specify up to 20 conditions per filter criteria and 20 values per condition.
    public var criteria: ComputeOptimizerAutomationClientTypes.Criteria?
    /// The maximum number of automation rule preview summaries to return in a single response. Valid range is 1-1000.
    public var maxResults: Swift.Int?
    /// A token used for pagination to retrieve the next set of results when the response is truncated.
    public var nextToken: Swift.String?
    /// The organizational scope for the rule preview.
    public var organizationScope: ComputeOptimizerAutomationClientTypes.OrganizationScope?
    /// The types of recommended actions to include in the preview.
    /// This member is required.
    public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
    /// The type of rule.
    /// This member is required.
    public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?

    public init(
        criteria: ComputeOptimizerAutomationClientTypes.Criteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationScope: ComputeOptimizerAutomationClientTypes.OrganizationScope? = nil,
        recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
        ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil
    ) {
        self.criteria = criteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationScope = organizationScope
        self.recommendedActionTypes = recommendedActionTypes
        self.ruleType = ruleType
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Aggregate totals for automation rule preview results, including count and estimated savings.
    public struct RulePreviewTotal: Swift.Sendable {
        /// Contains information about estimated monthly cost savings.
        /// This member is required.
        public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?
        /// The total number of recommended actions matching the rule preview configuration.
        /// This member is required.
        public var recommendedActionCount: Swift.Int?

        public init(
            estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil,
            recommendedActionCount: Swift.Int? = nil
        ) {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.recommendedActionCount = recommendedActionCount
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Contains a summary of preview results for an automation rule.
    public struct PreviewResultSummary: Swift.Sendable {
        /// The key identifier for this preview result summary.
        /// This member is required.
        public var key: Swift.String?
        /// Aggregate totals for automation rule preview results, including count and estimated savings.
        /// This member is required.
        public var total: ComputeOptimizerAutomationClientTypes.RulePreviewTotal?

        public init(
            key: Swift.String? = nil,
            total: ComputeOptimizerAutomationClientTypes.RulePreviewTotal? = nil
        ) {
            self.key = key
            self.total = total
        }
    }
}

public struct ListAutomationRulePreviewSummariesOutput: Swift.Sendable {
    /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The list of automation rule preview summaries that match the specified criteria.
    public var previewResultSummaries: [ComputeOptimizerAutomationClientTypes.PreviewResultSummary]?

    public init(
        nextToken: Swift.String? = nil,
        previewResultSummaries: [ComputeOptimizerAutomationClientTypes.PreviewResultSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.previewResultSummaries = previewResultSummaries
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// A filter used to narrow down results based on specific criteria.
    public struct Filter: Swift.Sendable {
        /// The name of the filter field to apply.
        /// This member is required.
        public var name: ComputeOptimizerAutomationClientTypes.AutomationRuleFilterName?
        /// The list of values to filter by for the specified filter field.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: ComputeOptimizerAutomationClientTypes.AutomationRuleFilterName? = nil,
            values: [Swift.String]? = nil
        ) {
            self.name = name
            self.values = values
        }
    }
}

public struct ListAutomationRulesInput: Swift.Sendable {
    /// The filters to apply to the list of automation rules.
    public var filters: [ComputeOptimizerAutomationClientTypes.Filter]?
    /// The maximum number of automation rules to return in a single response. Valid range is 1-1000.
    public var maxResults: Swift.Int?
    /// A token used for pagination to retrieve the next set of results when the response is truncated.
    public var nextToken: Swift.String?

    public init(
        filters: [ComputeOptimizerAutomationClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAutomationRulesOutput: Swift.Sendable {
    /// The list of automation rules that match the specified criteria.
    public var automationRules: [ComputeOptimizerAutomationClientTypes.AutomationRule]?
    /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
    public var nextToken: Swift.String?

    public init(
        automationRules: [ComputeOptimizerAutomationClientTypes.AutomationRule]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.automationRules = automationRules
        self.nextToken = nextToken
    }
}

extension ComputeOptimizerAutomationClientTypes {

    public enum RecommendedActionFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case currentResourceDetailsEbsVolumeType
        case lookBackPeriodInDays
        case recommendedActionType
        case resourceId
        case resourceTagsKey
        case resourceTagsValue
        case resourceType
        case restartNeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendedActionFilterName] {
            return [
                .accountId,
                .currentResourceDetailsEbsVolumeType,
                .lookBackPeriodInDays,
                .recommendedActionType,
                .resourceId,
                .resourceTagsKey,
                .resourceTagsValue,
                .resourceType,
                .restartNeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "AccountId"
            case .currentResourceDetailsEbsVolumeType: return "CurrentResourceDetailsEbsVolumeType"
            case .lookBackPeriodInDays: return "LookBackPeriodInDays"
            case .recommendedActionType: return "RecommendedActionType"
            case .resourceId: return "ResourceId"
            case .resourceTagsKey: return "ResourceTagsKey"
            case .resourceTagsValue: return "ResourceTagsValue"
            case .resourceType: return "ResourceType"
            case .restartNeeded: return "RestartNeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// A filter used to narrow down recommended action results based on specific criteria.
    public struct RecommendedActionFilter: Swift.Sendable {
        /// The name of the filter field to apply.
        /// This member is required.
        public var name: ComputeOptimizerAutomationClientTypes.RecommendedActionFilterName?
        /// List of filter values to match against the specified filter name. Used to narrow down recommended actions based on specific criteria.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: ComputeOptimizerAutomationClientTypes.RecommendedActionFilterName? = nil,
            values: [Swift.String]? = nil
        ) {
            self.name = name
            self.values = values
        }
    }
}

public struct ListRecommendedActionsInput: Swift.Sendable {
    /// The filters to apply to the list of recommended actions.
    public var filters: [ComputeOptimizerAutomationClientTypes.RecommendedActionFilter]?
    /// The maximum number of recommended actions to return in a single response. Valid range is 1-1000.
    public var maxResults: Swift.Int?
    /// A token used for pagination to retrieve the next set of results when the response is truncated.
    public var nextToken: Swift.String?

    public init(
        filters: [ComputeOptimizerAutomationClientTypes.RecommendedActionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Contains information about a recommended action that can be applied to optimize an Amazon Web Services resource.
    public struct RecommendedAction: Swift.Sendable {
        /// The Amazon Web Services account ID that owns the resource.
        public var accountId: Swift.String?
        /// Detailed configuration information for a specific Amazon Web Services resource, with type-specific details.
        public var currentResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails?
        /// A summary of the resource's current configuration.
        public var currentResourceSummary: Swift.String?
        /// Contains information about estimated monthly cost savings.
        public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?
        /// The number of days of historical data used to generate the recommendation.
        public var lookBackPeriodInDays: Swift.Int?
        /// The unique identifier of the recommended action.
        public var recommendedActionId: Swift.String?
        /// The type of action being recommended.
        public var recommendedActionType: ComputeOptimizerAutomationClientTypes.RecommendedActionType?
        /// Detailed configuration information for a specific Amazon Web Services resource, with type-specific details.
        public var recommendedResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails?
        /// A summary of the resource's recommended configuration.
        public var recommendedResourceSummary: Swift.String?
        /// The Amazon Web Services Region where the resource is located.
        public var region: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource that the recommendation applies to.
        public var resourceArn: Swift.String?
        /// The ID of the resource that the recommendation applies to.
        public var resourceId: Swift.String?
        /// The tags associated with the resource.
        public var resourceTags: [ComputeOptimizerAutomationClientTypes.Tag]?
        /// The type of resource being evaluated.
        public var resourceType: ComputeOptimizerAutomationClientTypes.ResourceType?
        /// Indicates whether implementing the recommended action requires a resource restart.
        public var restartNeeded: Swift.Bool?

        public init(
            accountId: Swift.String? = nil,
            currentResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails? = nil,
            currentResourceSummary: Swift.String? = nil,
            estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil,
            lookBackPeriodInDays: Swift.Int? = nil,
            recommendedActionId: Swift.String? = nil,
            recommendedActionType: ComputeOptimizerAutomationClientTypes.RecommendedActionType? = nil,
            recommendedResourceDetails: ComputeOptimizerAutomationClientTypes.ResourceDetails? = nil,
            recommendedResourceSummary: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceTags: [ComputeOptimizerAutomationClientTypes.Tag]? = nil,
            resourceType: ComputeOptimizerAutomationClientTypes.ResourceType? = nil,
            restartNeeded: Swift.Bool? = nil
        ) {
            self.accountId = accountId
            self.currentResourceDetails = currentResourceDetails
            self.currentResourceSummary = currentResourceSummary
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.lookBackPeriodInDays = lookBackPeriodInDays
            self.recommendedActionId = recommendedActionId
            self.recommendedActionType = recommendedActionType
            self.recommendedResourceDetails = recommendedResourceDetails
            self.recommendedResourceSummary = recommendedResourceSummary
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.restartNeeded = restartNeeded
        }
    }
}

public struct ListRecommendedActionsOutput: Swift.Sendable {
    /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The list of recommended actions that match the specified criteria.
    public var recommendedActions: [ComputeOptimizerAutomationClientTypes.RecommendedAction]?

    public init(
        nextToken: Swift.String? = nil,
        recommendedActions: [ComputeOptimizerAutomationClientTypes.RecommendedAction]? = nil
    ) {
        self.nextToken = nextToken
        self.recommendedActions = recommendedActions
    }
}

public struct ListRecommendedActionSummariesInput: Swift.Sendable {
    /// A list of filters to apply when retrieving recommended action summaries. Filters can be based on resource type, action type, account ID, and other criteria.
    public var filters: [ComputeOptimizerAutomationClientTypes.RecommendedActionFilter]?
    /// The maximum number of recommended action summaries to return in a single response. Valid range is 1-1000.
    public var maxResults: Swift.Int?
    /// A token used for pagination to retrieve the next set of results when the response is truncated.
    public var nextToken: Swift.String?

    public init(
        filters: [ComputeOptimizerAutomationClientTypes.RecommendedActionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Aggregate totals for a group of recommended actions, including count and estimated monthly savings.
    public struct RecommendedActionTotal: Swift.Sendable {
        /// Contains information about estimated monthly cost savings.
        /// This member is required.
        public var estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings?
        /// The total number of recommended actions in this group.
        /// This member is required.
        public var recommendedActionCount: Swift.Int?

        public init(
            estimatedMonthlySavings: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings? = nil,
            recommendedActionCount: Swift.Int? = nil
        ) {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.recommendedActionCount = recommendedActionCount
        }
    }
}

extension ComputeOptimizerAutomationClientTypes {

    /// Summary information about recommended actions, grouped by specific criteria with totals and counts.
    public struct RecommendedActionSummary: Swift.Sendable {
        /// The grouping key used to categorize the recommended actions in this summary.
        /// This member is required.
        public var key: Swift.String?
        /// Aggregate totals for the recommended actions in this group, including count and estimated savings.
        /// This member is required.
        public var total: ComputeOptimizerAutomationClientTypes.RecommendedActionTotal?

        public init(
            key: Swift.String? = nil,
            total: ComputeOptimizerAutomationClientTypes.RecommendedActionTotal? = nil
        ) {
            self.key = key
            self.total = total
        }
    }
}

public struct ListRecommendedActionSummariesOutput: Swift.Sendable {
    /// A token used for pagination. If present, indicates there are more results available and can be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The summary of recommended actions that match the specified criteria.
    public var recommendedActionSummaries: [ComputeOptimizerAutomationClientTypes.RecommendedActionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recommendedActionSummaries: [ComputeOptimizerAutomationClientTypes.RecommendedActionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.recommendedActionSummaries = recommendedActionSummaries
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags associated with the specified resource.
    public var tags: [ComputeOptimizerAutomationClientTypes.Tag]?

    public init(
        tags: [ComputeOptimizerAutomationClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct RollbackAutomationEventInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var clientToken: Swift.String?
    /// The ID of the automation event to roll back.
    /// This member is required.
    public var eventId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eventId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.eventId = eventId
    }
}

public struct RollbackAutomationEventOutput: Swift.Sendable {
    /// The ID of the automation event being rolled back.
    public var eventId: Swift.String?
    /// The current status of the rollback operation.
    public var eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus?

    public init(
        eventId: Swift.String? = nil,
        eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus? = nil
    ) {
        self.eventId = eventId
        self.eventStatus = eventStatus
    }
}

public struct StartAutomationEventInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var clientToken: Swift.String?
    /// The ID of the recommended action to automate.
    /// This member is required.
    public var recommendedActionId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        recommendedActionId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.recommendedActionId = recommendedActionId
    }
}

public struct StartAutomationEventOutput: Swift.Sendable {
    /// The ID of the automation event.
    public var eventId: Swift.String?
    /// The current status of the automation event.
    public var eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus?
    /// The ID of the recommended action being automated.
    public var recommendedActionId: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        eventStatus: ComputeOptimizerAutomationClientTypes.EventStatus? = nil,
        recommendedActionId: Swift.String? = nil
    ) {
        self.eventId = eventId
        self.eventStatus = eventStatus
        self.recommendedActionId = recommendedActionId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var clientToken: Swift.String?
    /// The ARN of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The revision number of the automation rule to tag. This ensures you're tagging the correct version of the rule.
    /// This member is required.
    public var ruleRevision: Swift.Int?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [ComputeOptimizerAutomationClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        ruleRevision: Swift.Int? = nil,
        tags: [ComputeOptimizerAutomationClientTypes.Tag]? = nil
    ) {
        self.clientToken = clientToken
        self.resourceArn = resourceArn
        self.ruleRevision = ruleRevision
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var clientToken: Swift.String?
    /// The ARN of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The revision number of the automation rule to untag. This ensures you're untagging the correct version of the rule.
    /// This member is required.
    public var ruleRevision: Swift.Int?
    /// The keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        ruleRevision: Swift.Int? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.resourceArn = resourceArn
        self.ruleRevision = ruleRevision
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAutomationRuleInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var clientToken: Swift.String?
    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time. You can specify up to 20 conditions per filter criteria and 20 values per condition.
    public var criteria: ComputeOptimizerAutomationClientTypes.Criteria?
    /// The updated description of the automation rule. Can be up to 1024 characters long and contain alphanumeric characters, underscores, hyphens, spaces, and certain special characters.
    public var description: Swift.String?
    /// The updated name of the automation rule. Must be 1-128 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var name: Swift.String?
    /// Updated configuration settings for organization-wide rules, including rule application order and target account IDs.
    public var organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration?
    /// The updated priority level of the automation rule, used to determine execution order when multiple rules apply to the same resource.
    public var priority: Swift.String?
    /// Updated list of recommended action types that this rule can execute, such as SnapshotAndDeleteUnattachedEbsVolume or UpgradeEbsVolumeType.
    public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
    /// The ARN of the rule to update.
    /// This member is required.
    public var ruleArn: Swift.String?
    /// The revision number of the rule to update.
    /// This member is required.
    public var ruleRevision: Swift.Int?
    /// The updated type of automation rule. Can be either OrganizationRule for organization-wide rules or AccountRule for account-specific rules.
    public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?
    /// The updated schedule configuration for when the automation rule should execute, including cron expression, timezone, and execution window.
    public var schedule: ComputeOptimizerAutomationClientTypes.Schedule?
    /// The updated status of the automation rule. Can be Active or Inactive.
    public var status: ComputeOptimizerAutomationClientTypes.RuleStatus?

    public init(
        clientToken: Swift.String? = nil,
        criteria: ComputeOptimizerAutomationClientTypes.Criteria? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration? = nil,
        priority: Swift.String? = nil,
        recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
        ruleArn: Swift.String? = nil,
        ruleRevision: Swift.Int? = nil,
        ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil,
        schedule: ComputeOptimizerAutomationClientTypes.Schedule? = nil,
        status: ComputeOptimizerAutomationClientTypes.RuleStatus? = nil
    ) {
        self.clientToken = clientToken
        self.criteria = criteria
        self.description = description
        self.name = name
        self.organizationConfiguration = organizationConfiguration
        self.priority = priority
        self.recommendedActionTypes = recommendedActionTypes
        self.ruleArn = ruleArn
        self.ruleRevision = ruleRevision
        self.ruleType = ruleType
        self.schedule = schedule
        self.status = status
    }
}

public struct UpdateAutomationRuleOutput: Swift.Sendable {
    /// The timestamp when the automation rule was originally created.
    public var createdTimestamp: Foundation.Date?
    /// A set of conditions that specify which recommended action qualify for implementation. When a rule is active and a recommended action matches these criteria, Compute Optimizer implements the action at the scheduled run time. You can specify up to 20 conditions per filter criteria and 20 values per condition.
    public var criteria: ComputeOptimizerAutomationClientTypes.Criteria?
    /// The updated description of the automation rule.
    public var description: Swift.String?
    /// The timestamp when the automation rule was last updated.
    public var lastUpdatedTimestamp: Foundation.Date?
    /// The updated name of the automation rule.
    public var name: Swift.String?
    /// The updated organization configuration settings.
    public var organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration?
    /// The updated priority level of the automation rule.
    public var priority: Swift.String?
    /// The updated list of recommended action types.
    public var recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]?
    /// The ARN of the updated rule.
    public var ruleArn: Swift.String?
    /// The new revision number of the updated rule.
    public var ruleRevision: Swift.Int?
    /// The updated type of automation rule.
    public var ruleType: ComputeOptimizerAutomationClientTypes.RuleType?
    /// The updated schedule configuration.
    public var schedule: ComputeOptimizerAutomationClientTypes.Schedule?
    /// The updated status of the automation rule.
    public var status: ComputeOptimizerAutomationClientTypes.RuleStatus?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        criteria: ComputeOptimizerAutomationClientTypes.Criteria? = nil,
        description: Swift.String? = nil,
        lastUpdatedTimestamp: Foundation.Date? = nil,
        name: Swift.String? = nil,
        organizationConfiguration: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration? = nil,
        priority: Swift.String? = nil,
        recommendedActionTypes: [ComputeOptimizerAutomationClientTypes.RecommendedActionType]? = nil,
        ruleArn: Swift.String? = nil,
        ruleRevision: Swift.Int? = nil,
        ruleType: ComputeOptimizerAutomationClientTypes.RuleType? = nil,
        schedule: ComputeOptimizerAutomationClientTypes.Schedule? = nil,
        status: ComputeOptimizerAutomationClientTypes.RuleStatus? = nil
    ) {
        self.createdTimestamp = createdTimestamp
        self.criteria = criteria
        self.description = description
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.name = name
        self.organizationConfiguration = organizationConfiguration
        self.priority = priority
        self.recommendedActionTypes = recommendedActionTypes
        self.ruleArn = ruleArn
        self.ruleRevision = ruleRevision
        self.ruleType = ruleType
        self.schedule = schedule
        self.status = status
    }
}

public struct UpdateEnrollmentConfigurationInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Must be 1-64 characters long and contain only alphanumeric characters, underscores, and hyphens.
    public var clientToken: Swift.String?
    /// The desired enrollment status.
    ///
    /// * Active - Enables the Automation feature for your account.
    ///
    /// * Inactive - Disables the Automation feature for your account and stops all of your automation rules. If you opt in again later, all rules will be inactive, and you must enable the rules you want to run. You must wait at least 24 hours after opting out to opt in again.
    ///
    ///
    /// The Pending and Failed options cannot be used to update the enrollment status of an account. They are returned in the response of a request to update the enrollment status of an account. If you are a member account, your account must be disassociated from your organizations management account before you can disable Automation. Contact your administrator to make this change.
    /// This member is required.
    public var status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus?

    public init(
        clientToken: Swift.String? = nil,
        status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus? = nil
    ) {
        self.clientToken = clientToken
        self.status = status
    }
}

public struct UpdateEnrollmentConfigurationOutput: Swift.Sendable {
    /// The timestamp when the enrollment configuration was last updated.
    /// This member is required.
    public var lastUpdatedTimestamp: Foundation.Date?
    /// The updated enrollment status.
    /// This member is required.
    public var status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus?
    /// The reason for the updated enrollment status.
    public var statusReason: Swift.String?

    public init(
        lastUpdatedTimestamp: Foundation.Date? = nil,
        status: ComputeOptimizerAutomationClientTypes.EnrollmentStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.status = status
        self.statusReason = statusReason
    }
}

extension AssociateAccountsInput {

    static func urlPathProvider(_ value: AssociateAccountsInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAutomationRuleInput {

    static func urlPathProvider(_ value: CreateAutomationRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAutomationRuleInput {

    static func urlPathProvider(_ value: DeleteAutomationRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateAccountsInput {

    static func urlPathProvider(_ value: DisassociateAccountsInput) -> Swift.String? {
        return "/"
    }
}

extension GetAutomationEventInput {

    static func urlPathProvider(_ value: GetAutomationEventInput) -> Swift.String? {
        return "/"
    }
}

extension GetAutomationRuleInput {

    static func urlPathProvider(_ value: GetAutomationRuleInput) -> Swift.String? {
        return "/"
    }
}

extension GetEnrollmentConfigurationInput {

    static func urlPathProvider(_ value: GetEnrollmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountsInput {

    static func urlPathProvider(_ value: ListAccountsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutomationEventsInput {

    static func urlPathProvider(_ value: ListAutomationEventsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutomationEventStepsInput {

    static func urlPathProvider(_ value: ListAutomationEventStepsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutomationEventSummariesInput {

    static func urlPathProvider(_ value: ListAutomationEventSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutomationRulePreviewInput {

    static func urlPathProvider(_ value: ListAutomationRulePreviewInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutomationRulePreviewSummariesInput {

    static func urlPathProvider(_ value: ListAutomationRulePreviewSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutomationRulesInput {

    static func urlPathProvider(_ value: ListAutomationRulesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRecommendedActionsInput {

    static func urlPathProvider(_ value: ListRecommendedActionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRecommendedActionSummariesInput {

    static func urlPathProvider(_ value: ListRecommendedActionSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RollbackAutomationEventInput {

    static func urlPathProvider(_ value: RollbackAutomationEventInput) -> Swift.String? {
        return "/"
    }
}

extension StartAutomationEventInput {

    static func urlPathProvider(_ value: StartAutomationEventInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAutomationRuleInput {

    static func urlPathProvider(_ value: UpdateAutomationRuleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEnrollmentConfigurationInput {

    static func urlPathProvider(_ value: UpdateEnrollmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateAccountsInput {

    static func write(value: AssociateAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateAutomationRuleInput {

    static func write(value: CreateAutomationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["criteria"].write(value.criteria, with: ComputeOptimizerAutomationClientTypes.Criteria.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["organizationConfiguration"].write(value.organizationConfiguration, with: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration.write(value:to:))
        try writer["priority"].write(value.priority)
        try writer["recommendedActionTypes"].writeList(value.recommendedActionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleType"].write(value.ruleType)
        try writer["schedule"].write(value.schedule, with: ComputeOptimizerAutomationClientTypes.Schedule.write(value:to:))
        try writer["status"].write(value.status)
        try writer["tags"].writeList(value.tags, memberWritingClosure: ComputeOptimizerAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteAutomationRuleInput {

    static func write(value: DeleteAutomationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["ruleArn"].write(value.ruleArn)
        try writer["ruleRevision"].write(value.ruleRevision)
    }
}

extension DisassociateAccountsInput {

    static func write(value: DisassociateAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension GetAutomationEventInput {

    static func write(value: GetAutomationEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventId"].write(value.eventId)
    }
}

extension GetAutomationRuleInput {

    static func write(value: GetAutomationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ruleArn"].write(value.ruleArn)
    }
}

extension GetEnrollmentConfigurationInput {

    static func write(value: GetEnrollmentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListAccountsInput {

    static func write(value: ListAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAutomationEventsInput {

    static func write(value: ListAutomationEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTimeExclusive"].writeTimestamp(value.endTimeExclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ComputeOptimizerAutomationClientTypes.AutomationEventFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["startTimeInclusive"].writeTimestamp(value.startTimeInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListAutomationEventStepsInput {

    static func write(value: ListAutomationEventStepsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventId"].write(value.eventId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAutomationEventSummariesInput {

    static func write(value: ListAutomationEventSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endDateExclusive"].write(value.endDateExclusive)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ComputeOptimizerAutomationClientTypes.AutomationEventFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["startDateInclusive"].write(value.startDateInclusive)
    }
}

extension ListAutomationRulePreviewInput {

    static func write(value: ListAutomationRulePreviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteria"].write(value.criteria, with: ComputeOptimizerAutomationClientTypes.Criteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["organizationScope"].write(value.organizationScope, with: ComputeOptimizerAutomationClientTypes.OrganizationScope.write(value:to:))
        try writer["recommendedActionTypes"].writeList(value.recommendedActionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleType"].write(value.ruleType)
    }
}

extension ListAutomationRulePreviewSummariesInput {

    static func write(value: ListAutomationRulePreviewSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteria"].write(value.criteria, with: ComputeOptimizerAutomationClientTypes.Criteria.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["organizationScope"].write(value.organizationScope, with: ComputeOptimizerAutomationClientTypes.OrganizationScope.write(value:to:))
        try writer["recommendedActionTypes"].writeList(value.recommendedActionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleType"].write(value.ruleType)
    }
}

extension ListAutomationRulesInput {

    static func write(value: ListAutomationRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ComputeOptimizerAutomationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRecommendedActionsInput {

    static func write(value: ListRecommendedActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ComputeOptimizerAutomationClientTypes.RecommendedActionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRecommendedActionSummariesInput {

    static func write(value: ListRecommendedActionSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ComputeOptimizerAutomationClientTypes.RecommendedActionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension RollbackAutomationEventInput {

    static func write(value: RollbackAutomationEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["eventId"].write(value.eventId)
    }
}

extension StartAutomationEventInput {

    static func write(value: StartAutomationEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["recommendedActionId"].write(value.recommendedActionId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["ruleRevision"].write(value.ruleRevision)
        try writer["tags"].writeList(value.tags, memberWritingClosure: ComputeOptimizerAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["ruleRevision"].write(value.ruleRevision)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAutomationRuleInput {

    static func write(value: UpdateAutomationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["criteria"].write(value.criteria, with: ComputeOptimizerAutomationClientTypes.Criteria.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["organizationConfiguration"].write(value.organizationConfiguration, with: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration.write(value:to:))
        try writer["priority"].write(value.priority)
        try writer["recommendedActionTypes"].writeList(value.recommendedActionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleArn"].write(value.ruleArn)
        try writer["ruleRevision"].write(value.ruleRevision)
        try writer["ruleType"].write(value.ruleType)
        try writer["schedule"].write(value.schedule, with: ComputeOptimizerAutomationClientTypes.Schedule.write(value:to:))
        try writer["status"].write(value.status)
    }
}

extension UpdateEnrollmentConfigurationInput {

    static func write(value: UpdateEnrollmentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["status"].write(value.status)
    }
}

extension AssociateAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateAccountsOutput()
        value.accountIds = try reader["accountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateAutomationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAutomationRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAutomationRuleOutput()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.criteria = try reader["criteria"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.Criteria.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.organizationConfiguration = try reader["organizationConfiguration"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.recommendedActionTypes = try reader["recommendedActionTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleArn = try reader["ruleArn"].readIfPresent()
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.ruleRevision = try reader["ruleRevision"].readIfPresent()
        value.ruleType = try reader["ruleType"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.Schedule.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteAutomationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAutomationRuleOutput {
        return DeleteAutomationRuleOutput()
    }
}

extension DisassociateAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateAccountsOutput()
        value.accountIds = try reader["accountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAutomationEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomationEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomationEventOutput()
        value.accountId = try reader["accountId"].readIfPresent()
        value.completedTimestamp = try reader["completedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        value.eventDescription = try reader["eventDescription"].readIfPresent()
        value.eventId = try reader["eventId"].readIfPresent()
        value.eventStatus = try reader["eventStatus"].readIfPresent()
        value.eventStatusReason = try reader["eventStatusReason"].readIfPresent()
        value.eventType = try reader["eventType"].readIfPresent()
        value.recommendedActionId = try reader["recommendedActionId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.ruleId = try reader["ruleId"].readIfPresent()
        return value
    }
}

extension GetAutomationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomationRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomationRuleOutput()
        value.accountId = try reader["accountId"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.criteria = try reader["criteria"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.Criteria.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.organizationConfiguration = try reader["organizationConfiguration"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.recommendedActionTypes = try reader["recommendedActionTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleArn = try reader["ruleArn"].readIfPresent()
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.ruleRevision = try reader["ruleRevision"].readIfPresent()
        value.ruleType = try reader["ruleType"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.Schedule.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetEnrollmentConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnrollmentConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnrollmentConfigurationOutput()
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.organizationRuleMode = try reader["organizationRuleMode"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension ListAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountsOutput()
        value.accounts = try reader["accounts"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.AccountInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAutomationEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomationEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomationEventsOutput()
        value.automationEvents = try reader["automationEvents"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.AutomationEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAutomationEventStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomationEventStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomationEventStepsOutput()
        value.automationEventSteps = try reader["automationEventSteps"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.AutomationEventStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAutomationEventSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomationEventSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomationEventSummariesOutput()
        value.automationEventSummaries = try reader["automationEventSummaries"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.AutomationEventSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAutomationRulePreviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomationRulePreviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomationRulePreviewOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.previewResults = try reader["previewResults"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.PreviewResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAutomationRulePreviewSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomationRulePreviewSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomationRulePreviewSummariesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.previewResultSummaries = try reader["previewResultSummaries"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.PreviewResultSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAutomationRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomationRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomationRulesOutput()
        value.automationRules = try reader["automationRules"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.AutomationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRecommendedActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecommendedActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecommendedActionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recommendedActions = try reader["recommendedActions"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.RecommendedAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRecommendedActionSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecommendedActionSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecommendedActionSummariesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recommendedActionSummaries = try reader["recommendedActionSummaries"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.RecommendedActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RollbackAutomationEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RollbackAutomationEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RollbackAutomationEventOutput()
        value.eventId = try reader["eventId"].readIfPresent()
        value.eventStatus = try reader["eventStatus"].readIfPresent()
        return value
    }
}

extension StartAutomationEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAutomationEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAutomationEventOutput()
        value.eventId = try reader["eventId"].readIfPresent()
        value.eventStatus = try reader["eventStatus"].readIfPresent()
        value.recommendedActionId = try reader["recommendedActionId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAutomationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAutomationRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAutomationRuleOutput()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.criteria = try reader["criteria"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.Criteria.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.organizationConfiguration = try reader["organizationConfiguration"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.recommendedActionTypes = try reader["recommendedActionTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleArn = try reader["ruleArn"].readIfPresent()
        value.ruleRevision = try reader["ruleRevision"].readIfPresent()
        value.ruleType = try reader["ruleType"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.Schedule.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateEnrollmentConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEnrollmentConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnrollmentConfigurationOutput()
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

enum AssociateAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NotManagementAccountException": return try NotManagementAccountException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAutomationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAutomationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NotManagementAccountException": return try NotManagementAccountException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomationEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnrollmentConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NotManagementAccountException": return try NotManagementAccountException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomationEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomationEventStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomationEventSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomationRulePreviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomationRulePreviewSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomationRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecommendedActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecommendedActionSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RollbackAutomationEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAutomationEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAutomationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEnrollmentConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "IdempotencyTokenInUseException": return try IdempotencyTokenInUseException.makeError(baseError: baseError)
            case "IdempotentParameterMismatchException": return try IdempotentParameterMismatchException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NotManagementAccountException": return try NotManagementAccountException.makeError(baseError: baseError)
            case "OptInRequiredException": return try OptInRequiredException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotencyTokenInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IdempotencyTokenInUseException {
        let reader = baseError.errorBodyReader
        var value = IdempotencyTokenInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotentParameterMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IdempotentParameterMismatchException {
        let reader = baseError.errorBodyReader
        var value = IdempotentParameterMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotManagementAccountException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotManagementAccountException {
        let reader = baseError.errorBodyReader
        var value = NotManagementAccountException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OptInRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OptInRequiredException {
        let reader = baseError.errorBodyReader
        var value = OptInRequiredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.OrganizationConfiguration {

    static func write(value: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleApplyOrder"].write(value.ruleApplyOrder)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.OrganizationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.OrganizationConfiguration()
        value.ruleApplyOrder = try reader["ruleApplyOrder"].readIfPresent()
        value.accountIds = try reader["accountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.Criteria {

    static func write(value: ComputeOptimizerAutomationClientTypes.Criteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ebsVolumeSizeInGib"].writeList(value.ebsVolumeSizeInGib, memberWritingClosure: ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ebsVolumeType"].writeList(value.ebsVolumeType, memberWritingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["estimatedMonthlySavings"].writeList(value.estimatedMonthlySavings, memberWritingClosure: ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lookBackPeriodInDays"].writeList(value.lookBackPeriodInDays, memberWritingClosure: ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["region"].writeList(value.region, memberWritingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceArn"].writeList(value.resourceArn, memberWritingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTag"].writeList(value.resourceTag, memberWritingClosure: ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["restartNeeded"].writeList(value.restartNeeded, memberWritingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.Criteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.Criteria()
        value.region = try reader["region"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceArn = try reader["resourceArn"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ebsVolumeType = try reader["ebsVolumeType"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ebsVolumeSizeInGib = try reader["ebsVolumeSizeInGib"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTag = try reader["resourceTag"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lookBackPeriodInDays = try reader["lookBackPeriodInDays"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.restartNeeded = try reader["restartNeeded"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.StringCriteriaCondition {

    static func write(value: ComputeOptimizerAutomationClientTypes.StringCriteriaCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.StringCriteriaCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.StringCriteriaCondition()
        value.comparison = try reader["comparison"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition {

    static func write(value: ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.IntegerCriteriaCondition()
        value.comparison = try reader["comparison"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition {

    static func write(value: ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["key"].write(value.key)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.ResourceTagsCriteriaCondition()
        value.comparison = try reader["comparison"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition {

    static func write(value: ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparison"].write(value.comparison)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.DoubleCriteriaCondition()
        value.comparison = try reader["comparison"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.Schedule {

    static func write(value: ComputeOptimizerAutomationClientTypes.Schedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionWindowInMinutes"].write(value.executionWindowInMinutes)
        try writer["scheduleExpression"].write(value.scheduleExpression)
        try writer["scheduleExpressionTimezone"].write(value.scheduleExpressionTimezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.Schedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.Schedule()
        value.scheduleExpression = try reader["scheduleExpression"].readIfPresent()
        value.scheduleExpressionTimezone = try reader["scheduleExpressionTimezone"].readIfPresent()
        value.executionWindowInMinutes = try reader["executionWindowInMinutes"].readIfPresent()
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.Tag {

    static func write(value: ComputeOptimizerAutomationClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings()
        value.currency = try reader["currency"].readIfPresent() ?? ""
        value.beforeDiscountSavings = try reader["beforeDiscountSavings"].readIfPresent() ?? 0.0
        value.afterDiscountSavings = try reader["afterDiscountSavings"].readIfPresent() ?? 0.0
        value.savingsEstimationMode = try reader["savingsEstimationMode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.AccountInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.AccountInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.AccountInfo()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.organizationRuleMode = try reader["organizationRuleMode"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.AutomationEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.AutomationEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.AutomationEvent()
        value.eventId = try reader["eventId"].readIfPresent()
        value.eventDescription = try reader["eventDescription"].readIfPresent()
        value.eventType = try reader["eventType"].readIfPresent()
        value.eventStatus = try reader["eventStatus"].readIfPresent()
        value.eventStatusReason = try reader["eventStatusReason"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.recommendedActionId = try reader["recommendedActionId"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedTimestamp = try reader["completedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.AutomationEventStep {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.AutomationEventStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.AutomationEventStep()
        value.eventId = try reader["eventId"].readIfPresent()
        value.stepId = try reader["stepId"].readIfPresent()
        value.stepType = try reader["stepType"].readIfPresent()
        value.stepStatus = try reader["stepStatus"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.startTimestamp = try reader["startTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedTimestamp = try reader["completedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.AutomationEventSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.AutomationEventSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.AutomationEventSummary()
        value.key = try reader["key"].readIfPresent()
        value.dimensions = try reader["dimensions"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.SummaryDimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timePeriod = try reader["timePeriod"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.TimePeriod.read(from:))
        value.total = try reader["total"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.SummaryTotals.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.SummaryTotals {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.SummaryTotals {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.SummaryTotals()
        value.automationEventCount = try reader["automationEventCount"].readIfPresent()
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.TimePeriod {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.TimePeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.TimePeriod()
        value.startTimeInclusive = try reader["startTimeInclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTimeExclusive = try reader["endTimeExclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.SummaryDimension {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.SummaryDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.SummaryDimension()
        value.key = try reader["key"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.PreviewResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.PreviewResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.PreviewResult()
        value.recommendedActionId = try reader["recommendedActionId"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.lookBackPeriodInDays = try reader["lookBackPeriodInDays"].readIfPresent()
        value.recommendedActionType = try reader["recommendedActionType"].readIfPresent()
        value.currentResourceSummary = try reader["currentResourceSummary"].readIfPresent()
        value.currentResourceDetails = try reader["currentResourceDetails"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.ResourceDetails.read(from:))
        value.recommendedResourceSummary = try reader["recommendedResourceSummary"].readIfPresent()
        value.recommendedResourceDetails = try reader["recommendedResourceDetails"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.ResourceDetails.read(from:))
        value.restartNeeded = try reader["restartNeeded"].readIfPresent()
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        value.resourceTags = try reader["resourceTags"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.ResourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.ResourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ebsVolume":
                return .ebsvolume(try reader["ebsVolume"].read(with: ComputeOptimizerAutomationClientTypes.EbsVolume.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ComputeOptimizerAutomationClientTypes.EbsVolume {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.EbsVolume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.EbsVolume()
        value.configuration = try reader["configuration"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EbsVolumeConfiguration.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.EbsVolumeConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.EbsVolumeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.EbsVolumeConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.sizeInGib = try reader["sizeInGib"].readIfPresent()
        value.iops = try reader["iops"].readIfPresent()
        value.throughput = try reader["throughput"].readIfPresent()
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.PreviewResultSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.PreviewResultSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.PreviewResultSummary()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.total = try reader["total"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.RulePreviewTotal.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.RulePreviewTotal {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.RulePreviewTotal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.RulePreviewTotal()
        value.recommendedActionCount = try reader["recommendedActionCount"].readIfPresent() ?? 0
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.AutomationRule {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.AutomationRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.AutomationRule()
        value.ruleArn = try reader["ruleArn"].readIfPresent()
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.ruleType = try reader["ruleType"].readIfPresent()
        value.ruleRevision = try reader["ruleRevision"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.organizationConfiguration = try reader["organizationConfiguration"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.OrganizationConfiguration.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.recommendedActionTypes = try reader["recommendedActionTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ComputeOptimizerAutomationClientTypes.RecommendedActionType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.schedule = try reader["schedule"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.Schedule.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.createdTimestamp = try reader["createdTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["lastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.RecommendedAction {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.RecommendedAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.RecommendedAction()
        value.recommendedActionId = try reader["recommendedActionId"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.lookBackPeriodInDays = try reader["lookBackPeriodInDays"].readIfPresent()
        value.recommendedActionType = try reader["recommendedActionType"].readIfPresent()
        value.currentResourceSummary = try reader["currentResourceSummary"].readIfPresent()
        value.currentResourceDetails = try reader["currentResourceDetails"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.ResourceDetails.read(from:))
        value.recommendedResourceSummary = try reader["recommendedResourceSummary"].readIfPresent()
        value.recommendedResourceDetails = try reader["recommendedResourceDetails"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.ResourceDetails.read(from:))
        value.restartNeeded = try reader["restartNeeded"].readIfPresent()
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        value.resourceTags = try reader["resourceTags"].readListIfPresent(memberReadingClosure: ComputeOptimizerAutomationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.RecommendedActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.RecommendedActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.RecommendedActionSummary()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.total = try reader["total"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.RecommendedActionTotal.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.RecommendedActionTotal {

    static func read(from reader: SmithyJSON.Reader) throws -> ComputeOptimizerAutomationClientTypes.RecommendedActionTotal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ComputeOptimizerAutomationClientTypes.RecommendedActionTotal()
        value.recommendedActionCount = try reader["recommendedActionCount"].readIfPresent() ?? 0
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent(with: ComputeOptimizerAutomationClientTypes.EstimatedMonthlySavings.read(from:))
        return value
    }
}

extension ComputeOptimizerAutomationClientTypes.AutomationEventFilter {

    static func write(value: ComputeOptimizerAutomationClientTypes.AutomationEventFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ComputeOptimizerAutomationClientTypes.OrganizationScope {

    static func write(value: ComputeOptimizerAutomationClientTypes.OrganizationScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ComputeOptimizerAutomationClientTypes.Filter {

    static func write(value: ComputeOptimizerAutomationClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ComputeOptimizerAutomationClientTypes.RecommendedActionFilter {

    static func write(value: ComputeOptimizerAutomationClientTypes.RecommendedActionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum ComputeOptimizerAutomationClientTypes {}
