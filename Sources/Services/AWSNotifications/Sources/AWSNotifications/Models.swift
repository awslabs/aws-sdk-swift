//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension NotificationsClientTypes {

    public enum AggregationDuration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Aggregate notifications for long periods of time (12 hours)
        case long
        /// Do not aggregate notifications sourced from a notification configuration
        case `none`
        /// Aggregate notifications for short periods of time (5 mins)
        case short
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationDuration] {
            return [
                .long,
                .none,
                .short
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .long: return "LONG"
            case .none: return "NONE"
            case .short: return "SHORT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotificationsClientTypes {

    public enum AggregationEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aggregate
        case child
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationEventType] {
            return [
                .aggregate,
                .child,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aggregate: return "AGGREGATE"
            case .child: return "CHILD"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID that prompted the conflict error.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that wasn't found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the service quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that exceeds the service quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeds the service quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service quota exceeded in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifies the quota that is being throttled.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds a client should wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Identifies the service being throttled.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension NotificationsClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension NotificationsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// This exception is thrown when the notification event fails validation.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The list of input fields that are invalid.
        public internal(set) var fieldList: [NotificationsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why your input is considered invalid.
        public internal(set) var reason: NotificationsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [NotificationsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: NotificationsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateChannelInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Channel to associate with the NotificationConfiguration. Supported ARNs include AWS Chatbot, the Console Mobile Application, and notifications-contacts.
    /// This member is required.
    public var arn: Swift.String?
    /// The ARN of the NotificationConfiguration to associate with the Channel.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        notificationConfigurationArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.notificationConfigurationArn = notificationConfigurationArn
    }
}

public struct AssociateChannelOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateChannelInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Channel to disassociate.
    /// This member is required.
    public var arn: Swift.String?
    /// The ARN of the NotificationConfiguration to disassociate.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        notificationConfigurationArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.notificationConfigurationArn = notificationConfigurationArn
    }
}

public struct DisassociateChannelOutput: Swift.Sendable {

    public init() { }
}

public struct ListChannelsInput: Swift.Sendable {
    /// The maximum number of results to be returned in this call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The start token for paginated calls. Retrieved from the response of a previous ListNotificationEvents call. NextToken uses Base64 encoding.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the NotificationConfiguration.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notificationConfigurationArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notificationConfigurationArn = notificationConfigurationArn
    }
}

public struct ListChannelsOutput: Swift.Sendable {
    /// A list of Channels.
    /// This member is required.
    public var channels: [Swift.String]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        channels: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

public struct CreateEventRuleInput: Swift.Sendable {
    /// An additional event pattern used to further filter the events this EventRule receives. For more information, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html) in the Amazon EventBridge User Guide.
    public var eventPattern: Swift.String?
    /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
    /// This member is required.
    public var eventType: Swift.String?
    /// The Amazon Resource Name (ARN) of the NotificationConfiguration associated with this EventRule.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?
    /// A list of AWS Regions that send events to this EventRule.
    /// This member is required.
    public var regions: [Swift.String]?
    /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
    /// This member is required.
    public var source: Swift.String?

    public init(
        eventPattern: Swift.String? = nil,
        eventType: Swift.String? = nil,
        notificationConfigurationArn: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        source: Swift.String? = nil
    )
    {
        self.eventPattern = eventPattern
        self.eventType = eventType
        self.notificationConfigurationArn = notificationConfigurationArn
        self.regions = regions
        self.source = source
    }
}

extension NotificationsClientTypes {

    public enum EventRuleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// EventRule is processing events. Any call can be executed.
        case active
        /// This EventRule is being created. Only GET/LIST calls can be executed.
        case creating
        /// This EventRule is being deleted. Only GET/LIST calls can be executed.
        case deleting
        /// EventRule is in a bad state and may not be processing events. Any call can be executed.
        case inactive
        /// This EventRule is being updated. Only GET/LIST calls can be executed.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EventRuleStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .inactive,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .inactive: return "INACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotificationsClientTypes {

    /// Describes EventRule status information.
    public struct EventRuleStatusSummary: Swift.Sendable {
        /// A human-readable reason for EventRuleStatus.
        /// This member is required.
        public var reason: Swift.String?
        /// The status of the EventRule.
        ///
        /// * Values:
        ///
        /// * ACTIVE
        ///
        /// * The EventRule can process events.
        ///
        ///
        ///
        ///
        /// * INACTIVE
        ///
        /// * The EventRule may be unable to process events.
        ///
        ///
        ///
        ///
        /// * CREATING
        ///
        /// * The EventRule is being created. Only GET and LIST calls can be run.
        ///
        ///
        ///
        ///
        /// * UPDATING
        ///
        /// * The EventRule is being updated. Only GET and LIST calls can be run.
        ///
        ///
        ///
        ///
        /// * DELETING
        ///
        /// * The EventRule is being deleted. Only GET and LIST calls can be run.
        /// This member is required.
        public var status: NotificationsClientTypes.EventRuleStatus?

        public init(
            reason: Swift.String? = nil,
            status: NotificationsClientTypes.EventRuleStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

public struct CreateEventRuleOutput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The ARN of a NotificationConfiguration.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?
    /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
    /// This member is required.
    public var statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]?

    public init(
        arn: Swift.String? = nil,
        notificationConfigurationArn: Swift.String? = nil,
        statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]? = nil
    )
    {
        self.arn = arn
        self.notificationConfigurationArn = notificationConfigurationArn
        self.statusSummaryByRegion = statusSummaryByRegion
    }
}

public struct CreateNotificationConfigurationInput: Swift.Sendable {
    /// The aggregation preference of the NotificationConfiguration.
    ///
    /// * Values:
    ///
    /// * LONG
    ///
    /// * Aggregate notifications for long periods of time (12 hours).
    ///
    ///
    ///
    ///
    /// * SHORT
    ///
    /// * Aggregate notifications for short periods of time (5 minutes).
    ///
    ///
    ///
    ///
    /// * NONE
    ///
    /// * Don't aggregate notifications. No delay in delivery.
    public var aggregationDuration: NotificationsClientTypes.AggregationDuration?
    /// The description of the NotificationConfiguration.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the NotificationConfiguration. Supports RFC 3986's unreserved characters.
    /// This member is required.
    public var name: Swift.String?
    /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
    public var tags: [Swift.String: Swift.String]?

    public init(
        aggregationDuration: NotificationsClientTypes.AggregationDuration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.aggregationDuration = aggregationDuration
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension NotificationsClientTypes {

    public enum NotificationConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// All of the EventRules are in ACTIVE Status. Any call can be executed.
        case active
        /// This NotificationConfiguration is being deleted. Only GET/LIST calls can be executed.
        case deleting
        /// All of the EventRules are in INACTIVE Status. Any call can be executed.
        case inactive
        /// Some EventRules are in ACTIVE Status and some are INACTIVE. Any call can be executed.
        case partiallyActive
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationConfigurationStatus] {
            return [
                .active,
                .deleting,
                .inactive,
                .partiallyActive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .inactive: return "INACTIVE"
            case .partiallyActive: return "PARTIALLY_ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNotificationConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.
    ///
    /// * Values:
    ///
    /// * ACTIVE
    ///
    /// * All EventRules are ACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * PARTIALLY_ACTIVE
    ///
    /// * Some EventRules are ACTIVE and some are INACTIVE.
    ///
    /// * Any call can be run.
    ///
    ///
    ///
    ///
    /// * INACTIVE
    ///
    /// * All EventRules are INACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * DELETING
    ///
    /// * This NotificationConfiguration is being deleted.
    ///
    /// * Only GET and LIST calls can be run.
    /// This member is required.
    public var status: NotificationsClientTypes.NotificationConfigurationStatus?

    public init(
        arn: Swift.String? = nil,
        status: NotificationsClientTypes.NotificationConfigurationStatus? = nil
    )
    {
        self.arn = arn
        self.status = status
    }
}

public struct DeleteEventRuleInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the EventRule to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteEventRuleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNotificationConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the NotificationConfiguration to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteNotificationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterNotificationHubInput: Swift.Sendable {
    /// The NotificationHub Region.
    /// This member is required.
    public var notificationHubRegion: Swift.String?

    public init(
        notificationHubRegion: Swift.String? = nil
    )
    {
        self.notificationHubRegion = notificationHubRegion
    }
}

extension NotificationsClientTypes {

    public enum NotificationHubStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Incoming Notification Events are being replicated to this Notification Hub. A Notification Hub with this status can be deregistered.
        case active
        /// Notification Hub is being deleted. Cannot register a Notification Hub in the same region as one in this status.
        case deregistering
        /// Notification Hub is in a failure state. Incoming Notification Events are not being replicated to this Hub.
        case inactive
        /// Notification Hub is initializing. Cannot deregister a Notification Hub in this status.
        case registering
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationHubStatus] {
            return [
                .active,
                .deregistering,
                .inactive,
                .registering
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deregistering: return "DEREGISTERING"
            case .inactive: return "INACTIVE"
            case .registering: return "REGISTERING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotificationsClientTypes {

    /// NotificationHub status information.
    public struct NotificationHubStatusSummary: Swift.Sendable {
        /// An Explanation for the current status.
        /// This member is required.
        public var reason: Swift.String?
        /// Status information about the NotificationHub.
        ///
        /// * Values:
        ///
        /// * ACTIVE
        ///
        /// * Incoming NotificationEvents are replicated to this NotificationHub.
        ///
        ///
        ///
        ///
        /// * REGISTERING
        ///
        /// * The NotificationHub is initializing. A NotificationHub with this status can't be deregistered.
        ///
        ///
        ///
        ///
        /// * DEREGISTERING
        ///
        /// * The NotificationHub is being deleted. You can't register additional NotificationHubs in the same Region as a NotificationHub with this status.
        /// This member is required.
        public var status: NotificationsClientTypes.NotificationHubStatus?

        public init(
            reason: Swift.String? = nil,
            status: NotificationsClientTypes.NotificationHubStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }
}

public struct DeregisterNotificationHubOutput: Swift.Sendable {
    /// The NotificationHub Region.
    /// This member is required.
    public var notificationHubRegion: Swift.String?
    /// NotificationHub status information.
    /// This member is required.
    public var statusSummary: NotificationsClientTypes.NotificationHubStatusSummary?

    public init(
        notificationHubRegion: Swift.String? = nil,
        statusSummary: NotificationsClientTypes.NotificationHubStatusSummary? = nil
    )
    {
        self.notificationHubRegion = notificationHubRegion
        self.statusSummary = statusSummary
    }
}

extension NotificationsClientTypes {

    /// The key-value pair of properties for an event.
    public struct Dimension: Swift.Sendable {
        /// The name of the dimension
        /// This member is required.
        public var name: Swift.String?
        /// The value of the dimension.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

public struct GetEventRuleInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the EventRule to return.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetEventRuleOutput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The date when the EventRule was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// An additional event pattern used to further filter the events this EventRule receives. For more information, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html) in the Amazon EventBridge User Guide.
    /// This member is required.
    public var eventPattern: Swift.String?
    /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
    /// This member is required.
    public var eventType: Swift.String?
    /// A list of managed rules from EventBridge that are are associated with this EventRule. These are created by AWS User Notifications within your account so this EventRule functions.
    /// This member is required.
    public var managedRules: [Swift.String]?
    /// The ARN of a NotificationConfiguration.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?
    /// A list of AWS Regions that send events to this EventRule.
    /// This member is required.
    public var regions: [Swift.String]?
    /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
    /// This member is required.
    public var source: Swift.String?
    /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
    /// This member is required.
    public var statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        eventPattern: Swift.String? = nil,
        eventType: Swift.String? = nil,
        managedRules: [Swift.String]? = nil,
        notificationConfigurationArn: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        source: Swift.String? = nil,
        statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.eventPattern = eventPattern
        self.eventType = eventType
        self.managedRules = managedRules
        self.notificationConfigurationArn = notificationConfigurationArn
        self.regions = regions
        self.source = source
        self.statusSummaryByRegion = statusSummaryByRegion
    }
}

public struct ListEventRulesInput: Swift.Sendable {
    /// The maximum number of results to be returned in this call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the NotificationConfiguration.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notificationConfigurationArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notificationConfigurationArn = notificationConfigurationArn
    }
}

extension NotificationsClientTypes {

    /// Contains a complete list of fields related to an EventRule.
    public struct EventRuleStructure: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the resource.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// An additional event pattern used to further filter the events this EventRule receives. For more information, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html) in the Amazon EventBridge User Guide.
        /// This member is required.
        public var eventPattern: Swift.String?
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
        /// This member is required.
        public var eventType: Swift.String?
        /// A list of Amazon EventBridge Managed Rule ARNs associated with this EventRule. These are created by AWS User Notifications within your account so your EventRules can function.
        /// This member is required.
        public var managedRules: [Swift.String]?
        /// The ARN for the NotificationConfiguration associated with this EventRule.
        /// This member is required.
        public var notificationConfigurationArn: Swift.String?
        /// A list of AWS Regions that send events to this EventRule.
        /// This member is required.
        public var regions: [Swift.String]?
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
        /// This member is required.
        public var source: Swift.String?
        /// A list of an EventRule's status by Region. Regions are mapped to EventRuleStatusSummary.
        /// This member is required.
        public var statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            eventPattern: Swift.String? = nil,
            eventType: Swift.String? = nil,
            managedRules: [Swift.String]? = nil,
            notificationConfigurationArn: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            source: Swift.String? = nil,
            statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.eventPattern = eventPattern
            self.eventType = eventType
            self.managedRules = managedRules
            self.notificationConfigurationArn = notificationConfigurationArn
            self.regions = regions
            self.source = source
            self.statusSummaryByRegion = statusSummaryByRegion
        }
    }
}

public struct ListEventRulesOutput: Swift.Sendable {
    /// A list of EventRules.
    /// This member is required.
    public var eventRules: [NotificationsClientTypes.EventRuleStructure]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        eventRules: [NotificationsClientTypes.EventRuleStructure]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventRules = eventRules
        self.nextToken = nextToken
    }
}

public struct UpdateEventRuleInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to update the EventRule.
    /// This member is required.
    public var arn: Swift.String?
    /// An additional event pattern used to further filter the events this EventRule receives. For more information, see [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html) in the Amazon EventBridge User Guide.
    public var eventPattern: Swift.String?
    /// A list of AWS Regions that sends events to this EventRule.
    public var regions: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        eventPattern: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.eventPattern = eventPattern
        self.regions = regions
    }
}

public struct UpdateEventRuleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to update the EventRule.
    /// This member is required.
    public var arn: Swift.String?
    /// The ARN of the NotificationConfiguration.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?
    /// The status of the action by Region.
    /// This member is required.
    public var statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]?

    public init(
        arn: Swift.String? = nil,
        notificationConfigurationArn: Swift.String? = nil,
        statusSummaryByRegion: [Swift.String: NotificationsClientTypes.EventRuleStatusSummary]? = nil
    )
    {
        self.arn = arn
        self.notificationConfigurationArn = notificationConfigurationArn
        self.statusSummaryByRegion = statusSummaryByRegion
    }
}

extension NotificationsClientTypes {

    public enum EventStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatus] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetNotificationConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the NotificationConfiguration to return.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetNotificationConfigurationOutput: Swift.Sendable {
    /// The aggregation preference of the NotificationConfiguration.
    ///
    /// * Values:
    ///
    /// * LONG
    ///
    /// * Aggregate notifications for long periods of time (12 hours).
    ///
    ///
    ///
    ///
    /// * SHORT
    ///
    /// * Aggregate notifications for short periods of time (5 minutes).
    ///
    ///
    ///
    ///
    /// * NONE
    ///
    /// * Don't aggregate notifications. No delay in delivery.
    public var aggregationDuration: NotificationsClientTypes.AggregationDuration?
    /// The ARN of the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation time of the NotificationConfiguration.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The description of the NotificationConfiguration.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the NotificationConfiguration.
    /// This member is required.
    public var name: Swift.String?
    /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.
    ///
    /// * Values:
    ///
    /// * ACTIVE
    ///
    /// * All EventRules are ACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * PARTIALLY_ACTIVE
    ///
    /// * Some EventRules are ACTIVE and some are INACTIVE.
    ///
    /// * Any call can be run.
    ///
    ///
    ///
    ///
    /// * INACTIVE
    ///
    /// * All EventRules are INACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * DELETING
    ///
    /// * This NotificationConfiguration is being deleted. Only GET and LIST calls can be run.
    ///
    /// * Only GET and LIST calls can be run.
    /// This member is required.
    public var status: NotificationsClientTypes.NotificationConfigurationStatus?

    public init(
        aggregationDuration: NotificationsClientTypes.AggregationDuration? = nil,
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        status: NotificationsClientTypes.NotificationConfigurationStatus? = nil
    )
    {
        self.aggregationDuration = aggregationDuration
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.name = name
        self.status = status
    }
}

extension NotificationsClientTypes {

    public enum LocaleCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// German (Germany)
        case deDe
        /// English (Canada)
        case enCa
        /// English (United Kingdom)
        case enUk
        /// English (United States). This is the default locale.
        case enUs
        /// Spanish (Spain)
        case esEs
        /// French (Canada)
        case frCa
        /// French (France)
        case frFr
        /// Bahasa Indonesian (Indonesia)
        case idId
        /// Italian (Italy)
        case itIt
        /// Japanese (Japan)
        case jaJp
        /// Korean (Korea)
        case koKr
        /// Portuguese (Brazil)
        case ptBr
        /// Turkish (Turkey)
        case trTr
        /// Chinese (China)
        case zhCn
        /// Chinese (Taiwan)
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LocaleCode] {
            return [
                .deDe,
                .enCa,
                .enUk,
                .enUs,
                .esEs,
                .frCa,
                .frFr,
                .idId,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .trTr,
                .zhCn,
                .zhTw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de_DE"
            case .enCa: return "en_CA"
            case .enUk: return "en_UK"
            case .enUs: return "en_US"
            case .esEs: return "es_ES"
            case .frCa: return "fr_CA"
            case .frFr: return "fr_FR"
            case .idId: return "id_ID"
            case .itIt: return "it_IT"
            case .jaJp: return "ja_JP"
            case .koKr: return "ko_KR"
            case .ptBr: return "pt_BR"
            case .trTr: return "tr_TR"
            case .zhCn: return "zh_CN"
            case .zhTw: return "zh_TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetNotificationEventInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the NotificationEvent to return.
    /// This member is required.
    public var arn: Swift.String?
    /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English en_US.
    public var locale: NotificationsClientTypes.LocaleCode?

    public init(
        arn: Swift.String? = nil,
        locale: NotificationsClientTypes.LocaleCode? = nil
    )
    {
        self.arn = arn
        self.locale = locale
    }
}

extension NotificationsClientTypes {

    public enum MediaElementType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaElementType] {
            return [
                .image
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotificationsClientTypes {

    /// Describes a media element.
    public struct MediaElement: Swift.Sendable {
        /// The caption of the media.
        /// This member is required.
        public var caption: Swift.String?
        /// The unique ID for the media.
        /// This member is required.
        public var mediaId: Swift.String?
        /// The type of media.
        /// This member is required.
        public var type: NotificationsClientTypes.MediaElementType?
        /// The url of the media.
        /// This member is required.
        public var url: Swift.String?

        public init(
            caption: Swift.String? = nil,
            mediaId: Swift.String? = nil,
            type: NotificationsClientTypes.MediaElementType? = nil,
            url: Swift.String? = nil
        )
        {
            self.caption = caption
            self.mediaId = mediaId
            self.type = type
            self.url = url
        }
    }
}

extension NotificationsClientTypes {

    /// Describes the components of a notification message.
    public struct MessageComponents: Swift.Sendable {
        /// A complete summary with all possible relevant information.
        public var completeDescription: Swift.String?
        /// A list of properties in key-value pairs. Pairs are shown in order of importance from most important to least important. Channels may limit the number of dimensions shown to the notification viewer. Included dimensions, keys, and values are subject to change.
        public var dimensions: [NotificationsClientTypes.Dimension]?
        /// A sentence long summary. For example, titles or an email subject line.
        public var headline: Swift.String?
        /// A paragraph long or multiple sentence summary. For example, AWS Chatbot notifications.
        public var paragraphSummary: Swift.String?

        public init(
            completeDescription: Swift.String? = nil,
            dimensions: [NotificationsClientTypes.Dimension]? = nil,
            headline: Swift.String? = nil,
            paragraphSummary: Swift.String? = nil
        )
        {
            self.completeDescription = completeDescription
            self.dimensions = dimensions
            self.headline = headline
            self.paragraphSummary = paragraphSummary
        }
    }
}

extension NotificationsClientTypes {

    public enum NotificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alert
        case announcement
        case informational
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .alert,
                .announcement,
                .informational,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alert: return "ALERT"
            case .announcement: return "ANNOUNCEMENT"
            case .informational: return "INFORMATIONAL"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotificationsClientTypes {

    public enum SchemaVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case schemaVersion10
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersion] {
            return [
                .schemaVersion10
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .schemaVersion10: return "v1.0"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotificationsClientTypes {

    /// A resource affected by or closely linked to an event.
    public struct Resource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource. At least one id or ARN is required.
        public var arn: Swift.String?
        /// The URL to the resource's detail page. If a detail page URL is unavailable, it is the URL to an informational page that describes the resource's type.
        public var detailUrl: Swift.String?
        /// The unique identifier for the resource. At least one id or ARN is required.
        public var id: Swift.String?
        /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
        public var tags: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            detailUrl: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.detailUrl = detailUrl
            self.id = id
            self.tags = tags
        }
    }
}

extension NotificationsClientTypes {

    /// Describes the metadata for a source event. For more information, see [Event structure reference](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-events-structure.html) in the Amazon EventBridge User Guide.
    public struct SourceEventMetadata: Swift.Sendable {
        /// The date and time the source event occurred. This is based on the Source Event.
        /// This member is required.
        public var eventOccurrenceTime: Foundation.Date?
        /// The Region the event originated from.
        public var eventOriginRegion: Swift.String?
        /// The type of event. For example, an AWS CloudWatch state change.
        /// This member is required.
        public var eventType: Swift.String?
        /// The version of the type of event.
        /// This member is required.
        public var eventTypeVersion: Swift.String?
        /// The Primary AWS account of Source Event
        /// This member is required.
        public var relatedAccount: Swift.String?
        /// A list of resources related to this NotificationEvent.
        /// This member is required.
        public var relatedResources: [NotificationsClientTypes.Resource]?
        /// The AWS servvice the event originates from. For example aws.cloudwatch.
        /// This member is required.
        public var source: Swift.String?
        /// The source event id.
        /// This member is required.
        public var sourceEventId: Swift.String?

        public init(
            eventOccurrenceTime: Foundation.Date? = nil,
            eventOriginRegion: Swift.String? = nil,
            eventType: Swift.String? = nil,
            eventTypeVersion: Swift.String? = nil,
            relatedAccount: Swift.String? = nil,
            relatedResources: [NotificationsClientTypes.Resource]? = nil,
            source: Swift.String? = nil,
            sourceEventId: Swift.String? = nil
        )
        {
            self.eventOccurrenceTime = eventOccurrenceTime
            self.eventOriginRegion = eventOriginRegion
            self.eventType = eventType
            self.eventTypeVersion = eventTypeVersion
            self.relatedAccount = relatedAccount
            self.relatedResources = relatedResources
            self.source = source
            self.sourceEventId = sourceEventId
        }
    }
}

extension NotificationsClientTypes {

    public enum TextPartType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case localizedText
        case plainText
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [TextPartType] {
            return [
                .localizedText,
                .plainText,
                .url
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .localizedText: return "LOCALIZED_TEXT"
            case .plainText: return "PLAIN_TEXT"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotificationsClientTypes {

    /// Describes text information objects containing fields that determine how text part objects are composed.
    public struct TextPartValue: Swift.Sendable {
        /// A short single line description of the link. Must be hyperlinked with the URL itself. Used for text parts with the type URL.
        public var displayText: Swift.String?
        /// A map of locales to the text in that locale.
        public var textByLocale: [Swift.String: Swift.String]?
        /// The type of text part. Determines the usage of all other fields and whether or not they're required.
        /// This member is required.
        public var type: NotificationsClientTypes.TextPartType?
        /// The URL itself.
        public var url: Swift.String?

        public init(
            displayText: Swift.String? = nil,
            textByLocale: [Swift.String: Swift.String]? = nil,
            type: NotificationsClientTypes.TextPartType? = nil,
            url: Swift.String? = nil
        )
        {
            self.displayText = displayText
            self.textByLocale = textByLocale
            self.type = type
            self.url = url
        }
    }
}

extension NotificationsClientTypes {

    /// A NotificationEvent is a notification-focused representation of an event. They contain semantic information used by Channels to create end-user notifications.
    public struct NotificationEventSchema: Swift.Sendable {
        /// If the value of aggregationEventType is not NONE, this is the Amazon Resource Event (ARN) of the parent aggregate notification. This is omitted if notification isn't aggregated.
        public var aggregateNotificationEventArn: Swift.String?
        /// The NotificationConfiguration's aggregation type.
        ///
        /// * Values:
        ///
        /// * AGGREGATE
        ///
        /// * The notification event is an aggregate notification. Aggregate notifications summarize grouped events over a specified time period.
        ///
        ///
        ///
        ///
        /// * CHILD
        ///
        /// * Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        ///
        ///
        ///
        ///
        /// * NONE
        ///
        /// * The notification isn't aggregated.
        public var aggregationEventType: NotificationsClientTypes.AggregationEventType?
        /// The end time of the event.
        public var endTime: Foundation.Date?
        /// The assesed nature of the event.
        ///
        /// * Values:
        ///
        /// * HEALTHY
        ///
        /// * All EventRules are ACTIVE and any call can be run.
        ///
        ///
        ///
        ///
        /// * UNHEALTHY
        ///
        /// * Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        public var eventStatus: NotificationsClientTypes.EventStatus?
        /// The unique identifier for a NotificationEvent.
        /// This member is required.
        public var id: Swift.String?
        /// A list of media elements.
        /// This member is required.
        public var media: [NotificationsClientTypes.MediaElement]?
        /// Describes the components of a notification message.
        /// This member is required.
        public var messageComponents: NotificationsClientTypes.MessageComponents?
        /// The type of event causing the notification.
        ///
        /// * Values:
        ///
        /// * ALERT
        ///
        /// * A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.
        ///
        ///
        ///
        ///
        /// * WARNING
        ///
        /// * A notification about an event where an issue is about to arise. For example, something is approaching a threshold.
        ///
        ///
        ///
        ///
        /// * ANNOUNCEMENT
        ///
        /// * A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.
        ///
        ///
        ///
        ///
        /// * INFORMATIONAL
        ///
        /// * A notification about informational messages. For example, recommendations, service announcements, or reminders.
        /// This member is required.
        public var notificationType: NotificationsClientTypes.NotificationType?
        /// The schema version of the Notification Event.
        /// This member is required.
        public var schemaVersion: NotificationsClientTypes.SchemaVersion?
        /// The source event URL.
        public var sourceEventDetailUrl: Swift.String?
        /// The detailed URL for the source event.
        public var sourceEventDetailUrlDisplayText: Swift.String?
        /// The source event metadata.
        /// This member is required.
        public var sourceEventMetadata: NotificationsClientTypes.SourceEventMetadata?
        /// The notification event start time.
        public var startTime: Foundation.Date?
        /// A list of text values.
        /// This member is required.
        public var textParts: [Swift.String: NotificationsClientTypes.TextPartValue]?

        public init(
            aggregateNotificationEventArn: Swift.String? = nil,
            aggregationEventType: NotificationsClientTypes.AggregationEventType? = nil,
            endTime: Foundation.Date? = nil,
            eventStatus: NotificationsClientTypes.EventStatus? = nil,
            id: Swift.String? = nil,
            media: [NotificationsClientTypes.MediaElement]? = nil,
            messageComponents: NotificationsClientTypes.MessageComponents? = nil,
            notificationType: NotificationsClientTypes.NotificationType? = nil,
            schemaVersion: NotificationsClientTypes.SchemaVersion? = nil,
            sourceEventDetailUrl: Swift.String? = nil,
            sourceEventDetailUrlDisplayText: Swift.String? = nil,
            sourceEventMetadata: NotificationsClientTypes.SourceEventMetadata? = nil,
            startTime: Foundation.Date? = nil,
            textParts: [Swift.String: NotificationsClientTypes.TextPartValue]? = nil
        )
        {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.aggregationEventType = aggregationEventType
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.id = id
            self.media = media
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventDetailUrl = sourceEventDetailUrl
            self.sourceEventDetailUrlDisplayText = sourceEventDetailUrlDisplayText
            self.sourceEventMetadata = sourceEventMetadata
            self.startTime = startTime
            self.textParts = textParts
        }
    }
}

public struct GetNotificationEventOutput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The content of the NotificationEvent.
    /// This member is required.
    public var content: NotificationsClientTypes.NotificationEventSchema?
    /// The creation time of the NotificationEvent.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The ARN of the NotificationConfiguration.
    /// This member is required.
    public var notificationConfigurationArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        content: NotificationsClientTypes.NotificationEventSchema? = nil,
        creationTime: Foundation.Date? = nil,
        notificationConfigurationArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.content = content
        self.creationTime = creationTime
        self.notificationConfigurationArn = notificationConfigurationArn
    }
}

public struct ListNotificationConfigurationsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Channel to match.
    public var channelArn: Swift.String?
    /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
    public var eventRuleSource: Swift.String?
    /// The maximum number of results to be returned in this call. Defaults to 20.
    public var maxResults: Swift.Int?
    /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
    public var nextToken: Swift.String?
    /// The NotificationConfiguration status to match.
    ///
    /// * Values:
    ///
    /// * ACTIVE
    ///
    /// * All EventRules are ACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * PARTIALLY_ACTIVE
    ///
    /// * Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
    ///
    /// * Any call can be run.
    ///
    ///
    ///
    ///
    /// * INACTIVE
    ///
    /// * All EventRules are INACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * DELETING
    ///
    /// * This NotificationConfiguration is being deleted.
    ///
    /// * Only GET and LIST calls can be run.
    public var status: NotificationsClientTypes.NotificationConfigurationStatus?

    public init(
        channelArn: Swift.String? = nil,
        eventRuleSource: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: NotificationsClientTypes.NotificationConfigurationStatus? = nil
    )
    {
        self.channelArn = channelArn
        self.eventRuleSource = eventRuleSource
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension NotificationsClientTypes {

    /// Contains the complete list of fields for a NotificationConfiguration.
    public struct NotificationConfigurationStructure: Swift.Sendable {
        /// The aggregation preference of the NotificationConfiguration.
        ///
        /// * Values:
        ///
        /// * LONG
        ///
        /// * Aggregate notifications for long periods of time (12 hours).
        ///
        ///
        ///
        ///
        /// * SHORT
        ///
        /// * Aggregate notifications for short periods of time (5 minutes).
        ///
        ///
        ///
        ///
        /// * NONE
        ///
        /// * Don't aggregate notifications. No delay in delivery.
        public var aggregationDuration: NotificationsClientTypes.AggregationDuration?
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the resource.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The description of the NotificationConfiguration.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the NotificationConfiguration. Supports RFC 3986's unreserved characters.
        /// This member is required.
        public var name: Swift.String?
        /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.
        ///
        /// * Values:
        ///
        /// * ACTIVE
        ///
        /// * All EventRules are ACTIVE and any call can be run.
        ///
        ///
        ///
        ///
        /// * PARTIALLY_ACTIVE
        ///
        /// * Some EventRules are ACTIVE and some are INACTIVE.
        ///
        /// * Any call can be run.
        ///
        ///
        ///
        ///
        /// * INACTIVE
        ///
        /// * All EventRules are INACTIVE and any call can be run.
        ///
        ///
        ///
        ///
        /// * DELETING
        ///
        /// * This NotificationConfiguration is being deleted. Only GET and LIST calls can be run.
        ///
        /// * Only GET and LIST calls can be run.
        /// This member is required.
        public var status: NotificationsClientTypes.NotificationConfigurationStatus?

        public init(
            aggregationDuration: NotificationsClientTypes.AggregationDuration? = nil,
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: NotificationsClientTypes.NotificationConfigurationStatus? = nil
        )
        {
            self.aggregationDuration = aggregationDuration
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.status = status
        }
    }
}

public struct ListNotificationConfigurationsOutput: Swift.Sendable {
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?
    /// The NotificationConfigurations in the account.
    /// This member is required.
    public var notificationConfigurations: [NotificationsClientTypes.NotificationConfigurationStructure]?

    public init(
        nextToken: Swift.String? = nil,
        notificationConfigurations: [NotificationsClientTypes.NotificationConfigurationStructure]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationConfigurations = notificationConfigurations
    }
}

public struct ListNotificationEventsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the aggregatedNotificationEventArn to match.
    public var aggregateNotificationEventArn: Swift.String?
    /// Latest time of events to return from this call.
    public var endTime: Foundation.Date?
    /// Include aggregated child events in the result.
    public var includeChildEvents: Swift.Bool?
    /// The locale code of the language used for the retrieved NotificationEvent. The default locale is English (en_US).
    public var locale: NotificationsClientTypes.LocaleCode?
    /// The maximum number of results to be returned in this call. Defaults to 20.
    public var maxResults: Swift.Int?
    /// The start token for paginated calls. Retrieved from the response of a previous ListEventRules call. Next token uses Base64 encoding.
    public var nextToken: Swift.String?
    /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
    public var source: Swift.String?
    /// The earliest time of events to return from this call.
    public var startTime: Foundation.Date?

    public init(
        aggregateNotificationEventArn: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        includeChildEvents: Swift.Bool? = nil,
        locale: NotificationsClientTypes.LocaleCode? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        source: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.aggregateNotificationEventArn = aggregateNotificationEventArn
        self.endTime = endTime
        self.includeChildEvents = includeChildEvents
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.source = source
        self.startTime = startTime
    }
}

extension NotificationsClientTypes {

    /// Contains the headline message component.
    public struct MessageComponentsSummary: Swift.Sendable {
        /// A sentence long summary. For example, titles or an email subject line.
        /// This member is required.
        public var headline: Swift.String?

        public init(
            headline: Swift.String? = nil
        )
        {
            self.headline = headline
        }
    }
}

extension NotificationsClientTypes {

    /// Contains metadata about the event that caused the NotificationEvent. For other specific values, see sourceEventMetadata.
    public struct SourceEventMetadataSummary: Swift.Sendable {
        /// The Region where the notification originated. Unavailable for aggregated notifications.
        public var eventOriginRegion: Swift.String?
        /// The event type to match. Must match one of the valid Amazon EventBridge event types. For example, EC2 Instance State-change Notification and AWS CloudWatch Alarm State Change. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
        /// This member is required.
        public var eventType: Swift.String?
        /// The matched event source. Must match one of the valid EventBridge sources. Only AWS service sourced events are supported. For example, aws.ec2 and aws.cloudwatch. For more information, see [Event delivery from AWS services](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-service-event.html#eb-service-event-delivery-level) in the Amazon EventBridge User Guide.
        /// This member is required.
        public var source: Swift.String?

        public init(
            eventOriginRegion: Swift.String? = nil,
            eventType: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.eventOriginRegion = eventOriginRegion
            self.eventType = eventType
            self.source = source
        }
    }
}

extension NotificationsClientTypes {

    /// Describes a short summary and metadata for a notification event.
    public struct NotificationEventSummary: Swift.Sendable {
        /// The notification event status.
        ///
        /// * Values:
        ///
        /// * HEALTHY
        ///
        /// * All EventRules are ACTIVE and any call can be run.
        ///
        ///
        ///
        ///
        /// * UNHEALTHY
        ///
        /// * Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        /// This member is required.
        public var eventStatus: NotificationsClientTypes.EventStatus?
        /// The message components of a notification event.
        /// This member is required.
        public var messageComponents: NotificationsClientTypes.MessageComponentsSummary?
        /// The type of event causing the notification.
        ///
        /// * Values:
        ///
        /// * ALERT
        ///
        /// * A notification about an event where something was triggered, initiated, reopened, deployed, or a threshold was breached.
        ///
        ///
        ///
        ///
        /// * WARNING
        ///
        /// * A notification about an event where an issue is about to arise. For example, something is approaching a threshold.
        ///
        ///
        ///
        ///
        /// * ANNOUNCEMENT
        ///
        /// * A notification about an important event. For example, a step in a workflow or escalation path or that a workflow was updated.
        ///
        ///
        ///
        ///
        /// * INFORMATIONAL
        ///
        /// * A notification about informational messages. For example, recommendations, service announcements, or reminders.
        /// This member is required.
        public var notificationType: NotificationsClientTypes.NotificationType?
        /// The schema version of the Notification Event.
        /// This member is required.
        public var schemaVersion: NotificationsClientTypes.SchemaVersion?
        /// The source event metadata.
        /// This member is required.
        public var sourceEventMetadata: NotificationsClientTypes.SourceEventMetadataSummary?

        public init(
            eventStatus: NotificationsClientTypes.EventStatus? = nil,
            messageComponents: NotificationsClientTypes.MessageComponentsSummary? = nil,
            notificationType: NotificationsClientTypes.NotificationType? = nil,
            schemaVersion: NotificationsClientTypes.SchemaVersion? = nil,
            sourceEventMetadata: NotificationsClientTypes.SourceEventMetadataSummary? = nil
        )
        {
            self.eventStatus = eventStatus
            self.messageComponents = messageComponents
            self.notificationType = notificationType
            self.schemaVersion = schemaVersion
            self.sourceEventMetadata = sourceEventMetadata
        }
    }
}

extension NotificationsClientTypes {

    /// Describes a short summary of a NotificationEvent. This is only used when listing notification events.
    public struct NotificationEventOverview: Swift.Sendable {
        /// The ARN of the aggregatedNotificationEventArn to match.
        public var aggregateNotificationEventArn: Swift.String?
        /// The NotificationConfiguration's aggregation type.
        ///
        /// * Values:
        ///
        /// * AGGREGATE
        ///
        /// * The notification event is an aggregate notification. Aggregate notifications summarize grouped events over a specified time period.
        ///
        ///
        ///
        ///
        /// * CHILD
        ///
        /// * Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
        ///
        ///
        ///
        ///
        /// * NONE
        ///
        /// * The notification isn't aggregated.
        public var aggregationEventType: NotificationsClientTypes.AggregationEventType?
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the NotificationEvent.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The ARN of the NotificationConfiguration.
        /// This member is required.
        public var notificationConfigurationArn: Swift.String?
        /// Refers to a NotificationEventSummary object. Similar in structure to content in the GetNotificationEvent response.
        /// This member is required.
        public var notificationEvent: NotificationsClientTypes.NotificationEventSummary?
        /// The account name containing the NotificationHub.
        /// This member is required.
        public var relatedAccount: Swift.String?

        public init(
            aggregateNotificationEventArn: Swift.String? = nil,
            aggregationEventType: NotificationsClientTypes.AggregationEventType? = nil,
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            notificationConfigurationArn: Swift.String? = nil,
            notificationEvent: NotificationsClientTypes.NotificationEventSummary? = nil,
            relatedAccount: Swift.String? = nil
        )
        {
            self.aggregateNotificationEventArn = aggregateNotificationEventArn
            self.aggregationEventType = aggregationEventType
            self.arn = arn
            self.creationTime = creationTime
            self.notificationConfigurationArn = notificationConfigurationArn
            self.notificationEvent = notificationEvent
            self.relatedAccount = relatedAccount
        }
    }
}

public struct ListNotificationEventsOutput: Swift.Sendable {
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?
    /// The list of notification events.
    /// This member is required.
    public var notificationEvents: [NotificationsClientTypes.NotificationEventOverview]?

    public init(
        nextToken: Swift.String? = nil,
        notificationEvents: [NotificationsClientTypes.NotificationEventOverview]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationEvents = notificationEvents
    }
}

public struct ListNotificationHubsInput: Swift.Sendable {
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing notification hubs from the start.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension NotificationsClientTypes {

    /// Describes an overview of a NotificationHub. A NotificationHub is an account-level setting used to select the Regions where you want to store, process and replicate your notifications.
    public struct NotificationHubOverview: Swift.Sendable {
        /// The date and time the resource was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The most recent time this NotificationHub had an ACTIVE status.
        public var lastActivationTime: Foundation.Date?
        /// The Region of the resource.
        /// This member is required.
        public var notificationHubRegion: Swift.String?
        /// The status summary of the resource.
        /// This member is required.
        public var statusSummary: NotificationsClientTypes.NotificationHubStatusSummary?

        public init(
            creationTime: Foundation.Date? = nil,
            lastActivationTime: Foundation.Date? = nil,
            notificationHubRegion: Swift.String? = nil,
            statusSummary: NotificationsClientTypes.NotificationHubStatusSummary? = nil
        )
        {
            self.creationTime = creationTime
            self.lastActivationTime = lastActivationTime
            self.notificationHubRegion = notificationHubRegion
            self.statusSummary = statusSummary
        }
    }
}

public struct ListNotificationHubsOutput: Swift.Sendable {
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?
    /// The NotificationHubs in the account.
    /// This member is required.
    public var notificationHubs: [NotificationsClientTypes.NotificationHubOverview]?

    public init(
        nextToken: Swift.String? = nil,
        notificationHubs: [NotificationsClientTypes.NotificationHubOverview]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationHubs = notificationHubs
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to list tags.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags for the specified ARN.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct UpdateNotificationConfigurationInput: Swift.Sendable {
    /// The status of this NotificationConfiguration. The status should always be INACTIVE when part of the CreateNotificationConfiguration response.
    ///
    /// * Values:
    ///
    /// * ACTIVE
    ///
    /// * All EventRules are ACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * PARTIALLY_ACTIVE
    ///
    /// * Some EventRules are ACTIVE and some are INACTIVE. Any call can be run.
    ///
    /// * Any call can be run.
    ///
    ///
    ///
    ///
    /// * INACTIVE
    ///
    /// * All EventRules are INACTIVE and any call can be run.
    ///
    ///
    ///
    ///
    /// * DELETING
    ///
    /// * This NotificationConfiguration is being deleted.
    ///
    /// * Only GET and LIST calls can be run.
    public var aggregationDuration: NotificationsClientTypes.AggregationDuration?
    /// The Amazon Resource Name (ARN) used to update the NotificationConfiguration.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the NotificationConfiguration.
    public var description: Swift.String?
    /// The name of the NotificationConfiguration.
    public var name: Swift.String?

    public init(
        aggregationDuration: NotificationsClientTypes.AggregationDuration? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aggregationDuration = aggregationDuration
        self.arn = arn
        self.description = description
        self.name = name
    }
}

public struct UpdateNotificationConfigurationOutput: Swift.Sendable {
    /// The ARN used to update the NotificationConfiguration.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct RegisterNotificationHubInput: Swift.Sendable {
    /// The Region of the NotificationHub.
    /// This member is required.
    public var notificationHubRegion: Swift.String?

    public init(
        notificationHubRegion: Swift.String? = nil
    )
    {
        self.notificationHubRegion = notificationHubRegion
    }
}

public struct RegisterNotificationHubOutput: Swift.Sendable {
    /// The date the resource was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The date the resource was last activated.
    public var lastActivationTime: Foundation.Date?
    /// The Region of the NotificationHub.
    /// This member is required.
    public var notificationHubRegion: Swift.String?
    /// NotificationHub status information.
    /// This member is required.
    public var statusSummary: NotificationsClientTypes.NotificationHubStatusSummary?

    public init(
        creationTime: Foundation.Date? = nil,
        lastActivationTime: Foundation.Date? = nil,
        notificationHubRegion: Swift.String? = nil,
        statusSummary: NotificationsClientTypes.NotificationHubStatusSummary? = nil
    )
    {
        self.creationTime = creationTime
        self.lastActivationTime = lastActivationTime
        self.notificationHubRegion = notificationHubRegion
        self.statusSummary = statusSummary
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to tag a resource.
    /// This member is required.
    public var arn: Swift.String?
    /// A map of tags assigned to a resource. A tag is a string-to-string map of key-value pairs.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to untag a resource.
    /// This member is required.
    public var arn: Swift.String?
    /// The tag keys to use to untag a resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateChannelInput {

    static func urlPathProvider(_ value: AssociateChannelInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/channels/associate/\(arn.urlPercentEncoding())"
    }
}

extension CreateEventRuleInput {

    static func urlPathProvider(_ value: CreateEventRuleInput) -> Swift.String? {
        return "/event-rules"
    }
}

extension CreateNotificationConfigurationInput {

    static func urlPathProvider(_ value: CreateNotificationConfigurationInput) -> Swift.String? {
        return "/notification-configurations"
    }
}

extension DeleteEventRuleInput {

    static func urlPathProvider(_ value: DeleteEventRuleInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/event-rules/\(arn.urlPercentEncoding())"
    }
}

extension DeleteNotificationConfigurationInput {

    static func urlPathProvider(_ value: DeleteNotificationConfigurationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/notification-configurations/\(arn.urlPercentEncoding())"
    }
}

extension DeregisterNotificationHubInput {

    static func urlPathProvider(_ value: DeregisterNotificationHubInput) -> Swift.String? {
        guard let notificationHubRegion = value.notificationHubRegion else {
            return nil
        }
        return "/notification-hubs/\(notificationHubRegion.urlPercentEncoding())"
    }
}

extension DisassociateChannelInput {

    static func urlPathProvider(_ value: DisassociateChannelInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/channels/disassociate/\(arn.urlPercentEncoding())"
    }
}

extension GetEventRuleInput {

    static func urlPathProvider(_ value: GetEventRuleInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/event-rules/\(arn.urlPercentEncoding())"
    }
}

extension GetNotificationConfigurationInput {

    static func urlPathProvider(_ value: GetNotificationConfigurationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/notification-configurations/\(arn.urlPercentEncoding())"
    }
}

extension GetNotificationEventInput {

    static func urlPathProvider(_ value: GetNotificationEventInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/notification-events/\(arn.urlPercentEncoding())"
    }
}

extension GetNotificationEventInput {

    static func queryItemProvider(_ value: GetNotificationEventInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let locale = value.locale {
            let localeQueryItem = Smithy.URIQueryItem(name: "locale".urlPercentEncoding(), value: Swift.String(locale.rawValue).urlPercentEncoding())
            items.append(localeQueryItem)
        }
        return items
    }
}

extension ListChannelsInput {

    static func urlPathProvider(_ value: ListChannelsInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsInput {

    static func queryItemProvider(_ value: ListChannelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let notificationConfigurationArn = value.notificationConfigurationArn else {
            let message = "Creating a URL Query Item failed. notificationConfigurationArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let notificationConfigurationArnQueryItem = Smithy.URIQueryItem(name: "notificationConfigurationArn".urlPercentEncoding(), value: Swift.String(notificationConfigurationArn).urlPercentEncoding())
        items.append(notificationConfigurationArnQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListEventRulesInput {

    static func urlPathProvider(_ value: ListEventRulesInput) -> Swift.String? {
        return "/event-rules"
    }
}

extension ListEventRulesInput {

    static func queryItemProvider(_ value: ListEventRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let notificationConfigurationArn = value.notificationConfigurationArn else {
            let message = "Creating a URL Query Item failed. notificationConfigurationArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let notificationConfigurationArnQueryItem = Smithy.URIQueryItem(name: "notificationConfigurationArn".urlPercentEncoding(), value: Swift.String(notificationConfigurationArn).urlPercentEncoding())
        items.append(notificationConfigurationArnQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListNotificationConfigurationsInput {

    static func urlPathProvider(_ value: ListNotificationConfigurationsInput) -> Swift.String? {
        return "/notification-configurations"
    }
}

extension ListNotificationConfigurationsInput {

    static func queryItemProvider(_ value: ListNotificationConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let channelArn = value.channelArn {
            let channelArnQueryItem = Smithy.URIQueryItem(name: "channelArn".urlPercentEncoding(), value: Swift.String(channelArn).urlPercentEncoding())
            items.append(channelArnQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let eventRuleSource = value.eventRuleSource {
            let eventRuleSourceQueryItem = Smithy.URIQueryItem(name: "eventRuleSource".urlPercentEncoding(), value: Swift.String(eventRuleSource).urlPercentEncoding())
            items.append(eventRuleSourceQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListNotificationEventsInput {

    static func urlPathProvider(_ value: ListNotificationEventsInput) -> Swift.String? {
        return "/notification-events"
    }
}

extension ListNotificationEventsInput {

    static func queryItemProvider(_ value: ListNotificationEventsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeChildEvents = value.includeChildEvents {
            let includeChildEventsQueryItem = Smithy.URIQueryItem(name: "includeChildEvents".urlPercentEncoding(), value: Swift.String(includeChildEvents).urlPercentEncoding())
            items.append(includeChildEventsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let source = value.source {
            let sourceQueryItem = Smithy.URIQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source).urlPercentEncoding())
            items.append(sourceQueryItem)
        }
        if let aggregateNotificationEventArn = value.aggregateNotificationEventArn {
            let aggregateNotificationEventArnQueryItem = Smithy.URIQueryItem(name: "aggregateNotificationEventArn".urlPercentEncoding(), value: Swift.String(aggregateNotificationEventArn).urlPercentEncoding())
            items.append(aggregateNotificationEventArnQueryItem)
        }
        if let locale = value.locale {
            let localeQueryItem = Smithy.URIQueryItem(name: "locale".urlPercentEncoding(), value: Swift.String(locale.rawValue).urlPercentEncoding())
            items.append(localeQueryItem)
        }
        return items
    }
}

extension ListNotificationHubsInput {

    static func urlPathProvider(_ value: ListNotificationHubsInput) -> Swift.String? {
        return "/notification-hubs"
    }
}

extension ListNotificationHubsInput {

    static func queryItemProvider(_ value: ListNotificationHubsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

extension RegisterNotificationHubInput {

    static func urlPathProvider(_ value: RegisterNotificationHubInput) -> Swift.String? {
        return "/notification-hubs"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateEventRuleInput {

    static func urlPathProvider(_ value: UpdateEventRuleInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/event-rules/\(arn.urlPercentEncoding())"
    }
}

extension UpdateNotificationConfigurationInput {

    static func urlPathProvider(_ value: UpdateNotificationConfigurationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/notification-configurations/\(arn.urlPercentEncoding())"
    }
}

extension AssociateChannelInput {

    static func write(value: AssociateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationConfigurationArn"].write(value.notificationConfigurationArn)
    }
}

extension CreateEventRuleInput {

    static func write(value: CreateEventRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventPattern"].write(value.eventPattern)
        try writer["eventType"].write(value.eventType)
        try writer["notificationConfigurationArn"].write(value.notificationConfigurationArn)
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["source"].write(value.source)
    }
}

extension CreateNotificationConfigurationInput {

    static func write(value: CreateNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationDuration"].write(value.aggregationDuration)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DisassociateChannelInput {

    static func write(value: DisassociateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationConfigurationArn"].write(value.notificationConfigurationArn)
    }
}

extension RegisterNotificationHubInput {

    static func write(value: RegisterNotificationHubInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["notificationHubRegion"].write(value.notificationHubRegion)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateEventRuleInput {

    static func write(value: UpdateEventRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventPattern"].write(value.eventPattern)
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateNotificationConfigurationInput {

    static func write(value: UpdateNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationDuration"].write(value.aggregationDuration)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension AssociateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateChannelOutput {
        return AssociateChannelOutput()
    }
}

extension CreateEventRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventRuleOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.notificationConfigurationArn = try reader["notificationConfigurationArn"].readIfPresent() ?? ""
        value.statusSummaryByRegion = try reader["statusSummaryByRegion"].readMapIfPresent(valueReadingClosure: NotificationsClientTypes.EventRuleStatusSummary.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension CreateNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNotificationConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteEventRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventRuleOutput {
        return DeleteEventRuleOutput()
    }
}

extension DeleteNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNotificationConfigurationOutput {
        return DeleteNotificationConfigurationOutput()
    }
}

extension DeregisterNotificationHubOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterNotificationHubOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterNotificationHubOutput()
        value.notificationHubRegion = try reader["notificationHubRegion"].readIfPresent() ?? ""
        value.statusSummary = try reader["statusSummary"].readIfPresent(with: NotificationsClientTypes.NotificationHubStatusSummary.read(from:))
        return value
    }
}

extension DisassociateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateChannelOutput {
        return DisassociateChannelOutput()
    }
}

extension GetEventRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventRuleOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.eventPattern = try reader["eventPattern"].readIfPresent() ?? ""
        value.eventType = try reader["eventType"].readIfPresent() ?? ""
        value.managedRules = try reader["managedRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.notificationConfigurationArn = try reader["notificationConfigurationArn"].readIfPresent() ?? ""
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.source = try reader["source"].readIfPresent() ?? ""
        value.statusSummaryByRegion = try reader["statusSummaryByRegion"].readMapIfPresent(valueReadingClosure: NotificationsClientTypes.EventRuleStatusSummary.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension GetNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNotificationConfigurationOutput()
        value.aggregationDuration = try reader["aggregationDuration"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetNotificationEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNotificationEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNotificationEventOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: NotificationsClientTypes.NotificationEventSchema.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.notificationConfigurationArn = try reader["notificationConfigurationArn"].readIfPresent() ?? ""
        return value
    }
}

extension ListChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsOutput()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEventRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventRulesOutput()
        value.eventRules = try reader["eventRules"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.EventRuleStructure.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNotificationConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.notificationConfigurations = try reader["notificationConfigurations"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.NotificationConfigurationStructure.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListNotificationEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationEventsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.notificationEvents = try reader["notificationEvents"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.NotificationEventOverview.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListNotificationHubsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationHubsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationHubsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.notificationHubs = try reader["notificationHubs"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.NotificationHubOverview.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RegisterNotificationHubOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterNotificationHubOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterNotificationHubOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastActivationTime = try reader["lastActivationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.notificationHubRegion = try reader["notificationHubRegion"].readIfPresent() ?? ""
        value.statusSummary = try reader["statusSummary"].readIfPresent(with: NotificationsClientTypes.NotificationHubStatusSummary.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateEventRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEventRuleOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.notificationConfigurationArn = try reader["notificationConfigurationArn"].readIfPresent() ?? ""
        value.statusSummaryByRegion = try reader["statusSummaryByRegion"].readMapIfPresent(valueReadingClosure: NotificationsClientTypes.EventRuleStatusSummary.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension UpdateNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNotificationConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

enum AssociateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterNotificationHubOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNotificationEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationHubsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterNotificationHubOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotificationsClientTypes.EventRuleStatusSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.EventRuleStatusSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.EventRuleStatusSummary()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.reason = try reader["reason"].readIfPresent() ?? ""
        return value
    }
}

extension NotificationsClientTypes.NotificationHubStatusSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.NotificationHubStatusSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.NotificationHubStatusSummary()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.reason = try reader["reason"].readIfPresent() ?? ""
        return value
    }
}

extension NotificationsClientTypes.NotificationEventSchema {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.NotificationEventSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.NotificationEventSchema()
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.sourceEventMetadata = try reader["sourceEventMetadata"].readIfPresent(with: NotificationsClientTypes.SourceEventMetadata.read(from:))
        value.messageComponents = try reader["messageComponents"].readIfPresent(with: NotificationsClientTypes.MessageComponents.read(from:))
        value.sourceEventDetailUrl = try reader["sourceEventDetailUrl"].readIfPresent()
        value.sourceEventDetailUrlDisplayText = try reader["sourceEventDetailUrlDisplayText"].readIfPresent()
        value.notificationType = try reader["notificationType"].readIfPresent() ?? .sdkUnknown("")
        value.eventStatus = try reader["eventStatus"].readIfPresent()
        value.aggregationEventType = try reader["aggregationEventType"].readIfPresent()
        value.aggregateNotificationEventArn = try reader["aggregateNotificationEventArn"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.textParts = try reader["textParts"].readMapIfPresent(valueReadingClosure: NotificationsClientTypes.TextPartValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.media = try reader["media"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.MediaElement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension NotificationsClientTypes.MediaElement {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.MediaElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.MediaElement()
        value.mediaId = try reader["mediaId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.url = try reader["url"].readIfPresent() ?? ""
        value.caption = try reader["caption"].readIfPresent() ?? ""
        return value
    }
}

extension NotificationsClientTypes.TextPartValue {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.TextPartValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.TextPartValue()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.displayText = try reader["displayText"].readIfPresent()
        value.textByLocale = try reader["textByLocale"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension NotificationsClientTypes.MessageComponents {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.MessageComponents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.MessageComponents()
        value.headline = try reader["headline"].readIfPresent()
        value.paragraphSummary = try reader["paragraphSummary"].readIfPresent()
        value.completeDescription = try reader["completeDescription"].readIfPresent()
        value.dimensions = try reader["dimensions"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.Dimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NotificationsClientTypes.Dimension {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.Dimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.Dimension()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension NotificationsClientTypes.SourceEventMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.SourceEventMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.SourceEventMetadata()
        value.eventTypeVersion = try reader["eventTypeVersion"].readIfPresent() ?? ""
        value.sourceEventId = try reader["sourceEventId"].readIfPresent() ?? ""
        value.eventOriginRegion = try reader["eventOriginRegion"].readIfPresent()
        value.relatedAccount = try reader["relatedAccount"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        value.eventOccurrenceTime = try reader["eventOccurrenceTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.eventType = try reader["eventType"].readIfPresent() ?? ""
        value.relatedResources = try reader["relatedResources"].readListIfPresent(memberReadingClosure: NotificationsClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension NotificationsClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.Resource()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.detailUrl = try reader["detailUrl"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NotificationsClientTypes.EventRuleStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.EventRuleStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.EventRuleStructure()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.notificationConfigurationArn = try reader["notificationConfigurationArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.source = try reader["source"].readIfPresent() ?? ""
        value.eventType = try reader["eventType"].readIfPresent() ?? ""
        value.eventPattern = try reader["eventPattern"].readIfPresent() ?? ""
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.managedRules = try reader["managedRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.statusSummaryByRegion = try reader["statusSummaryByRegion"].readMapIfPresent(valueReadingClosure: NotificationsClientTypes.EventRuleStatusSummary.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension NotificationsClientTypes.NotificationConfigurationStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.NotificationConfigurationStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.NotificationConfigurationStructure()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.aggregationDuration = try reader["aggregationDuration"].readIfPresent()
        return value
    }
}

extension NotificationsClientTypes.NotificationEventOverview {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.NotificationEventOverview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.NotificationEventOverview()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.notificationConfigurationArn = try reader["notificationConfigurationArn"].readIfPresent() ?? ""
        value.relatedAccount = try reader["relatedAccount"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.notificationEvent = try reader["notificationEvent"].readIfPresent(with: NotificationsClientTypes.NotificationEventSummary.read(from:))
        value.aggregationEventType = try reader["aggregationEventType"].readIfPresent()
        value.aggregateNotificationEventArn = try reader["aggregateNotificationEventArn"].readIfPresent()
        return value
    }
}

extension NotificationsClientTypes.NotificationEventSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.NotificationEventSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.NotificationEventSummary()
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? .sdkUnknown("")
        value.sourceEventMetadata = try reader["sourceEventMetadata"].readIfPresent(with: NotificationsClientTypes.SourceEventMetadataSummary.read(from:))
        value.messageComponents = try reader["messageComponents"].readIfPresent(with: NotificationsClientTypes.MessageComponentsSummary.read(from:))
        value.eventStatus = try reader["eventStatus"].readIfPresent() ?? .sdkUnknown("")
        value.notificationType = try reader["notificationType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NotificationsClientTypes.MessageComponentsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.MessageComponentsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.MessageComponentsSummary()
        value.headline = try reader["headline"].readIfPresent() ?? ""
        return value
    }
}

extension NotificationsClientTypes.SourceEventMetadataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.SourceEventMetadataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.SourceEventMetadataSummary()
        value.eventOriginRegion = try reader["eventOriginRegion"].readIfPresent()
        value.source = try reader["source"].readIfPresent() ?? ""
        value.eventType = try reader["eventType"].readIfPresent() ?? ""
        return value
    }
}

extension NotificationsClientTypes.NotificationHubOverview {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.NotificationHubOverview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.NotificationHubOverview()
        value.notificationHubRegion = try reader["notificationHubRegion"].readIfPresent() ?? ""
        value.statusSummary = try reader["statusSummary"].readIfPresent(with: NotificationsClientTypes.NotificationHubStatusSummary.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastActivationTime = try reader["lastActivationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension NotificationsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> NotificationsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NotificationsClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum NotificationsClientTypes {}
