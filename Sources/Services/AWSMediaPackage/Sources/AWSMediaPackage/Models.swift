//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

extension MediaPackageClientTypes {

    public enum __AdTriggersElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `break`
        case distributorAdvertisement
        case distributorOverlayPlacementOpportunity
        case distributorPlacementOpportunity
        case providerAdvertisement
        case providerOverlayPlacementOpportunity
        case providerPlacementOpportunity
        case spliceInsert
        case sdkUnknown(Swift.String)

        public static var allCases: [__AdTriggersElement] {
            return [
                .break,
                .distributorAdvertisement,
                .distributorOverlayPlacementOpportunity,
                .distributorPlacementOpportunity,
                .providerAdvertisement,
                .providerOverlayPlacementOpportunity,
                .providerPlacementOpportunity,
                .spliceInsert
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .break: return "BREAK"
            case .distributorAdvertisement: return "DISTRIBUTOR_ADVERTISEMENT"
            case .distributorOverlayPlacementOpportunity: return "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .distributorPlacementOpportunity: return "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
            case .providerAdvertisement: return "PROVIDER_ADVERTISEMENT"
            case .providerOverlayPlacementOpportunity: return "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .providerPlacementOpportunity: return "PROVIDER_PLACEMENT_OPPORTUNITY"
            case .spliceInsert: return "SPLICE_INSERT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    public enum __PeriodTriggersElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ads
        case sdkUnknown(Swift.String)

        public static var allCases: [__PeriodTriggersElement] {
            return [
                .ads
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ADS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// Configure egress access logging.
    public struct EgressAccessLogs {
        /// Customize the log group name.
        public var logGroupName: Swift.String?

        public init(
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension MediaPackageClientTypes {
    /// An endpoint for ingesting source content for a Channel.
    public struct IngestEndpoint {
        /// The system generated unique identifier for the IngestEndpoint
        public var id: Swift.String?
        /// The system generated password for ingest authentication.
        public var password: Swift.String?
        /// The ingest URL to which the source stream should be sent.
        public var url: Swift.String?
        /// The system generated username for ingest authentication.
        public var username: Swift.String?

        public init(
            id: Swift.String? = nil,
            password: Swift.String? = nil,
            url: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.id = id
            self.password = password
            self.url = url
            self.username = username
        }
    }

}

extension MediaPackageClientTypes.IngestEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IngestEndpoint(id: \(Swift.String(describing: id)), url: \(Swift.String(describing: url)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public struct HlsIngest {
        /// A list of endpoints to which the source stream should be sent.
        public var ingestEndpoints: [MediaPackageClientTypes.IngestEndpoint]?

        public init(
            ingestEndpoints: [MediaPackageClientTypes.IngestEndpoint]? = nil
        )
        {
            self.ingestEndpoints = ingestEndpoints
        }
    }

}

extension MediaPackageClientTypes {
    /// Configure ingress access logging.
    public struct IngressAccessLogs {
        /// Customize the log group name.
        public var logGroupName: Swift.String?

        public init(
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension MediaPackageClientTypes {
    /// A Channel resource configuration.
    public struct Channel {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public var arn: Swift.String?
        /// The date and time the Channel was created.
        public var createdAt: Swift.String?
        /// A short text description of the Channel.
        public var description: Swift.String?
        /// Configure egress access logging.
        public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
        /// An HTTP Live Streaming (HLS) ingest resource configuration.
        public var hlsIngest: MediaPackageClientTypes.HlsIngest?
        /// The ID of the Channel.
        public var id: Swift.String?
        /// Configure ingress access logging.
        public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            description: Swift.String? = nil,
            egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
            hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
            id: Swift.String? = nil,
            ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }
    }

}

extension MediaPackageClientTypes {
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public struct S3Destination {
        /// The name of an S3 bucket within which harvested content will be exported
        /// This member is required.
        public var bucketName: Swift.String?
        /// The key in the specified S3 bucket where the harvested top-level manifest will be placed.
        /// This member is required.
        public var manifestKey: Swift.String?
        /// The IAM role used to write to the specified S3 bucket
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            manifestKey: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.manifestKey = manifestKey
            self.roleArn = roleArn
        }
    }

}

extension MediaPackageClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// A HarvestJob resource configuration
    public struct HarvestJob {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public var arn: Swift.String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public var channelId: Swift.String?
        /// The date and time the HarvestJob was submitted.
        public var createdAt: Swift.String?
        /// The end of the time-window which will be harvested.
        public var endTime: Swift.String?
        /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted.
        public var id: Swift.String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
        public var originEndpointId: Swift.String?
        /// Configuration parameters for where in an S3 bucket to place the harvested content
        public var s3Destination: MediaPackageClientTypes.S3Destination?
        /// The start of the time-window which will be harvested.
        public var startTime: Swift.String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will include an explanation of why the HarvestJob failed.
        public var status: MediaPackageClientTypes.Status?

        public init(
            arn: Swift.String? = nil,
            channelId: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            endTime: Swift.String? = nil,
            id: Swift.String? = nil,
            originEndpointId: Swift.String? = nil,
            s3Destination: MediaPackageClientTypes.S3Destination? = nil,
            startTime: Swift.String? = nil,
            status: MediaPackageClientTypes.Status? = nil
        )
        {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }
    }

}

extension MediaPackageClientTypes {

    public enum AdMarkers: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daterange
        case `none`
        case passthrough
        case scte35Enhanced
        case sdkUnknown(Swift.String)

        public static var allCases: [AdMarkers] {
            return [
                .daterange,
                .none,
                .passthrough,
                .scte35Enhanced
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daterange: return "DATERANGE"
            case .none: return "NONE"
            case .passthrough: return "PASSTHROUGH"
            case .scte35Enhanced: return "SCTE35_ENHANCED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
    public enum AdsOnDeliveryRestrictions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case both
        case `none`
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [AdsOnDeliveryRestrictions] {
            return [
                .both,
                .none,
                .restricted,
                .unrestricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .both: return "BOTH"
            case .none: return "NONE"
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    public enum PlaylistType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case `none`
        case vod
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaylistType] {
            return [
                .event,
                .none,
                .vod
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .none: return "NONE"
            case .vod: return "VOD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// A HTTP Live Streaming (HLS) manifest configuration.
    public struct HlsManifest {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        /// This member is required.
        public var id: Swift.String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public var manifestName: Swift.String?
        /// The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public var url: Swift.String?

        public init(
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            id: Swift.String? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestName: Swift.String? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            url: Swift.String? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.url = url
        }
    }

}

extension MediaPackageClientTypes {
    /// A HTTP Live Streaming (HLS) manifest configuration.
    public struct HlsManifestCreateOrUpdateParameters {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        /// This member is required.
        public var id: Swift.String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public var manifestName: Swift.String?
        /// The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?

        public init(
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            id: Swift.String? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestName: Swift.String? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        }
    }

}

extension MediaPackageClientTypes {
    /// CDN Authorization credentials
    public struct Authorization {
        /// The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
        /// This member is required.
        public var cdnIdentifierSecret: Swift.String?
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        /// This member is required.
        public var secretsRoleArn: Swift.String?

        public init(
            cdnIdentifierSecret: Swift.String? = nil,
            secretsRoleArn: Swift.String? = nil
        )
        {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }
    }

}

extension MediaPackageClientTypes {

    /// The encryption method to use.
    public enum CmafEncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aesCtr
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [CmafEncryptionMethod] {
            return [
                .aesCtr,
                .sampleAes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aesCtr: return "AES_CTR"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    public enum PresetSpeke20Audio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case presetAudio1
        case presetAudio2
        case presetAudio3
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Audio] {
            return [
                .presetAudio1,
                .presetAudio2,
                .presetAudio3,
                .shared,
                .unencrypted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .presetAudio1: return "PRESET-AUDIO-1"
            case .presetAudio2: return "PRESET-AUDIO-2"
            case .presetAudio3: return "PRESET-AUDIO-3"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    public enum PresetSpeke20Video: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case presetVideo1
        case presetVideo2
        case presetVideo3
        case presetVideo4
        case presetVideo5
        case presetVideo6
        case presetVideo7
        case presetVideo8
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Video] {
            return [
                .presetVideo1,
                .presetVideo2,
                .presetVideo3,
                .presetVideo4,
                .presetVideo5,
                .presetVideo6,
                .presetVideo7,
                .presetVideo8,
                .shared,
                .unencrypted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .presetVideo1: return "PRESET-VIDEO-1"
            case .presetVideo2: return "PRESET-VIDEO-2"
            case .presetVideo3: return "PRESET-VIDEO-3"
            case .presetVideo4: return "PRESET-VIDEO-4"
            case .presetVideo5: return "PRESET-VIDEO-5"
            case .presetVideo6: return "PRESET-VIDEO-6"
            case .presetVideo7: return "PRESET-VIDEO-7"
            case .presetVideo8: return "PRESET-VIDEO-8"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use. Note the following considerations when using encryptionContractConfiguration: encryptionContractConfiguration can be used for DASH or CMAF endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification. You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
    public struct EncryptionContractConfiguration {
        /// A collection of audio encryption presets.
        /// This member is required.
        public var presetSpeke20Audio: MediaPackageClientTypes.PresetSpeke20Audio?
        /// A collection of video encryption presets.
        /// This member is required.
        public var presetSpeke20Video: MediaPackageClientTypes.PresetSpeke20Video?

        public init(
            presetSpeke20Audio: MediaPackageClientTypes.PresetSpeke20Audio? = nil,
            presetSpeke20Video: MediaPackageClientTypes.PresetSpeke20Video? = nil
        )
        {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }
    }

}

extension MediaPackageClientTypes {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public struct SpekeKeyProvider {
        /// An Amazon Resource Name (ARN) of a Certificate Manager certificate that MediaPackage will use for enforcing secure end-to-end data transfer with the key provider service.
        public var certificateArn: Swift.String?
        /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use. Note the following considerations when using encryptionContractConfiguration: encryptionContractConfiguration can be used for DASH or CMAF endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification. You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
        public var encryptionContractConfiguration: MediaPackageClientTypes.EncryptionContractConfiguration?
        /// The resource ID to include in key requests.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental MediaPackage will assume when accessing the key provider service.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The system IDs to include in key requests.
        /// This member is required.
        public var systemIds: [Swift.String]?
        /// The URL of the external key provider service.
        /// This member is required.
        public var url: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            encryptionContractConfiguration: MediaPackageClientTypes.EncryptionContractConfiguration? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            systemIds: [Swift.String]? = nil,
            url: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }
    }

}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) encryption configuration.
    public struct CmafEncryption {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        public var encryptionMethod: MediaPackageClientTypes.CmafEncryptionMethod?
        /// Time (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageClientTypes.CmafEncryptionMethod? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes {

    public enum StreamOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case original
        case videoBitrateAscending
        case videoBitrateDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamOrder] {
            return [
                .original,
                .videoBitrateAscending,
                .videoBitrateDescending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .original: return "ORIGINAL"
            case .videoBitrateAscending: return "VIDEO_BITRATE_ASCENDING"
            case .videoBitrateDescending: return "VIDEO_BITRATE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// A StreamSelection configuration.
    public struct StreamSelection {
        /// The maximum video bitrate (bps) to include in output.
        public var maxVideoBitsPerSecond: Swift.Int?
        /// The minimum video bitrate (bps) to include in output.
        public var minVideoBitsPerSecond: Swift.Int?
        /// A directive that determines the order of streams in the output.
        public var streamOrder: MediaPackageClientTypes.StreamOrder?

        public init(
            maxVideoBitsPerSecond: Swift.Int? = nil,
            minVideoBitsPerSecond: Swift.Int? = nil,
            streamOrder: MediaPackageClientTypes.StreamOrder? = nil
        )
        {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }
    }

}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) packaging configuration.
    public struct CmafPackage {
        /// A Common Media Application Format (CMAF) encryption configuration.
        public var encryption: MediaPackageClientTypes.CmafEncryption?
        /// A list of HLS manifest configurations
        public var hlsManifests: [MediaPackageClientTypes.HlsManifest]?
        /// Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public var segmentPrefix: Swift.String?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init(
            encryption: MediaPackageClientTypes.CmafEncryption? = nil,
            hlsManifests: [MediaPackageClientTypes.HlsManifest]? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentPrefix: Swift.String? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }
    }

}

extension MediaPackageClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
    public struct DashEncryption {
        /// Time (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes {

    public enum ManifestLayout: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compact
        case drmTopLevelCompact
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [ManifestLayout] {
            return [
                .compact,
                .drmTopLevelCompact,
                .full
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compact: return "COMPACT"
            case .drmTopLevelCompact: return "DRM_TOP_LEVEL_COMPACT"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    public enum Profile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dvbDash2014
        case hbbtv15
        case hybridcast
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Profile] {
            return [
                .dvbDash2014,
                .hbbtv15,
                .hybridcast,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dvbDash2014: return "DVB_DASH_2014"
            case .hbbtv15: return "HBBTV_1_5"
            case .hybridcast: return "HYBRIDCAST"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    public enum SegmentTemplateFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case numberWithDuration
        case numberWithTimeline
        case timeWithTimeline
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentTemplateFormat] {
            return [
                .numberWithDuration,
                .numberWithTimeline,
                .timeWithTimeline
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .numberWithDuration: return "NUMBER_WITH_DURATION"
            case .numberWithTimeline: return "NUMBER_WITH_TIMELINE"
            case .timeWithTimeline: return "TIME_WITH_TIMELINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {

    public enum UtcTiming: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case httpHead
        case httpIso
        case httpXsdate
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [UtcTiming] {
            return [
                .httpHead,
                .httpIso,
                .httpXsdate,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .httpHead: return "HTTP-HEAD"
            case .httpIso: return "HTTP-ISO"
            case .httpXsdate: return "HTTP-XSDATE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public struct DashPackage {
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
        public var encryption: MediaPackageClientTypes.DashEncryption?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// Determines the position of some tags in the Media Presentation Description (MPD). When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation. When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level. When set to DRM_TOP_LEVEL_COMPACT, content protection elements are placed the MPD level and referenced at the AdaptationSet level.
        public var manifestLayout: MediaPackageClientTypes.ManifestLayout?
        /// Time window (in seconds) contained in each manifest.
        public var manifestWindowSeconds: Swift.Int?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public var minBufferTimeSeconds: Swift.Int?
        /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
        public var minUpdatePeriodSeconds: Swift.Int?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Channel source contains SCTE-35 ad markers.
        public var periodTriggers: [MediaPackageClientTypes.__PeriodTriggersElement]?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type. When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled. When set to "DVB-DASH_2014", DVB-DASH 2014 compliant output is enabled.
        public var profile: MediaPackageClientTypes.Profile?
        /// Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD). When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs. When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public var segmentTemplateFormat: MediaPackageClientTypes.SegmentTemplateFormat?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?
        /// Duration (in seconds) to delay live content before presentation.
        public var suggestedPresentationDelaySeconds: Swift.Int?
        /// Determines the type of UTCTiming included in the Media Presentation Description (MPD)
        public var utcTiming: MediaPackageClientTypes.UtcTiming?
        /// Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO, HTTP-HEAD or HTTP-XSDATE
        public var utcTimingUri: Swift.String?

        public init(
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            encryption: MediaPackageClientTypes.DashEncryption? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestLayout: MediaPackageClientTypes.ManifestLayout? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            minBufferTimeSeconds: Swift.Int? = nil,
            minUpdatePeriodSeconds: Swift.Int? = nil,
            periodTriggers: [MediaPackageClientTypes.__PeriodTriggersElement]? = nil,
            profile: MediaPackageClientTypes.Profile? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentTemplateFormat: MediaPackageClientTypes.SegmentTemplateFormat? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil,
            suggestedPresentationDelaySeconds: Swift.Int? = nil,
            utcTiming: MediaPackageClientTypes.UtcTiming? = nil,
            utcTimingUri: Swift.String? = nil
        )
        {
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestLayout = manifestLayout
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.profile = profile
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
            self.streamSelection = streamSelection
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
            self.utcTiming = utcTiming
            self.utcTimingUri = utcTimingUri
        }
    }

}

extension MediaPackageClientTypes {

    public enum EncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aes128
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionMethod] {
            return [
                .aes128,
                .sampleAes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) encryption configuration.
    public struct HlsEncryption {
        /// A constant initialization vector for encryption (optional). When not specified the initialization vector will be periodically rotated.
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        public var encryptionMethod: MediaPackageClientTypes.EncryptionMethod?
        /// Interval (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public var repeatExtXKey: Swift.Bool?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageClientTypes.EncryptionMethod? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            repeatExtXKey: Swift.Bool? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public struct HlsPackage {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// An HTTP Live Streaming (HLS) encryption configuration.
        public var encryption: MediaPackageClientTypes.HlsEncryption?
        /// When enabled, MediaPackage passes through digital video broadcasting (DVB) subtitles into the output.
        public var includeDvbSubtitles: Swift.Bool?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public var useAudioRenditionGroup: Swift.Bool?

        public init(
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            encryption: MediaPackageClientTypes.HlsEncryption? = nil,
            includeDvbSubtitles: Swift.Bool? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil,
            useAudioRenditionGroup: Swift.Bool? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.includeDvbSubtitles = includeDvbSubtitles
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }
    }

}

extension MediaPackageClientTypes {
    /// A Microsoft Smooth Streaming (MSS) encryption configuration.
    public struct MssEncryption {
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes {
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public struct MssPackage {
        /// A Microsoft Smooth Streaming (MSS) encryption configuration.
        public var encryption: MediaPackageClientTypes.MssEncryption?
        /// The time window (in seconds) contained in each manifest.
        public var manifestWindowSeconds: Swift.Int?
        /// The duration (in seconds) of each segment.
        public var segmentDurationSeconds: Swift.Int?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init(
            encryption: MediaPackageClientTypes.MssEncryption? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.manifestWindowSeconds = manifestWindowSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
        }
    }

}

extension MediaPackageClientTypes {

    public enum Origination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [Origination] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MediaPackageClientTypes {
    /// An OriginEndpoint resource configuration.
    public struct OriginEndpoint {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public var arn: Swift.String?
        /// CDN Authorization credentials
        public var authorization: MediaPackageClientTypes.Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public var channelId: Swift.String?
        /// A Common Media Application Format (CMAF) packaging configuration.
        public var cmafPackage: MediaPackageClientTypes.CmafPackage?
        /// The date and time the OriginEndpoint was created.
        public var createdAt: Swift.String?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
        public var dashPackage: MediaPackageClientTypes.DashPackage?
        /// A short text description of the OriginEndpoint.
        public var description: Swift.String?
        /// An HTTP Live Streaming (HLS) packaging configuration.
        public var hlsPackage: MediaPackageClientTypes.HlsPackage?
        /// The ID of the OriginEndpoint.
        public var id: Swift.String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public var manifestName: Swift.String?
        /// A Microsoft Smooth Streaming (MSS) packaging configuration.
        public var mssPackage: MediaPackageClientTypes.MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public var origination: MediaPackageClientTypes.Origination?
        /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
        public var startoverWindowSeconds: Swift.Int?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String: Swift.String]?
        /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
        public var timeDelaySeconds: Swift.Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public var url: Swift.String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public var whitelist: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            authorization: MediaPackageClientTypes.Authorization? = nil,
            channelId: Swift.String? = nil,
            cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
            createdAt: Swift.String? = nil,
            dashPackage: MediaPackageClientTypes.DashPackage? = nil,
            description: Swift.String? = nil,
            hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
            id: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            mssPackage: MediaPackageClientTypes.MssPackage? = nil,
            origination: MediaPackageClientTypes.Origination? = nil,
            startoverWindowSeconds: Swift.Int? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            timeDelaySeconds: Swift.Int? = nil,
            url: Swift.String? = nil,
            whitelist: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }
    }

}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) packaging configuration.
    public struct CmafPackageCreateOrUpdateParameters {
        /// A Common Media Application Format (CMAF) encryption configuration.
        public var encryption: MediaPackageClientTypes.CmafEncryption?
        /// A list of HLS manifest configurations
        public var hlsManifests: [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]?
        /// Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public var segmentPrefix: Swift.String?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init(
            encryption: MediaPackageClientTypes.CmafEncryption? = nil,
            hlsManifests: [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentPrefix: Swift.String? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }
    }

}

/// The client is not authorized to access the requested resource.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested resource does not exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An unexpected error occurred.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The client has exceeded their resource or throttling limits.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parameters sent in the request are not valid.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// the option to configure log subscription.
public struct ConfigureLogsInput {
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// The ID of the channel to log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?

    public init(
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil
    )
    {
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
    }
}

public struct ConfigureLogsOutput {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

/// A new Channel configuration.
public struct CreateChannelInput {
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// The ID of the Channel. The ID must be unique within the region and it cannot be changed after a Channel is created.
    /// This member is required.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.tags = tags
    }
}

public struct CreateChannelOutput {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

/// Configuration parameters used to create a new HarvestJob.
public struct CreateHarvestJobInput {
    /// The end of the time-window which will be harvested
    /// This member is required.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
    /// This member is required.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    /// This member is required.
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested
    /// This member is required.
    public var startTime: Swift.String?

    public init(
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
    }
}

public struct CreateHarvestJobOutput {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public var arn: Swift.String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public var channelId: Swift.String?
    /// The date and time the HarvestJob was submitted.
    public var createdAt: Swift.String?
    /// The end of the time-window which will be harvested.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested.
    public var startTime: Swift.String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will include an explanation of why the HarvestJob failed.
    public var status: MediaPackageClientTypes.Status?

    public init(
        arn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil,
        status: MediaPackageClientTypes.Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

/// Configuration parameters used to create a new OriginEndpoint.
public struct CreateOriginEndpointInput {
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel that the OriginEndpoint will be associated with. This cannot be changed after the OriginEndpoint is created.
    /// This member is required.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint. The ID must be unique within the region and it cannot be changed after the OriginEndpoint is created.
    /// This member is required.
    public var id: Swift.String?
    /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

public struct CreateOriginEndpointOutput {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// The date and time the OriginEndpoint was created.
    public var createdAt: Swift.String?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        createdAt: Swift.String? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.createdAt = createdAt
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

public struct DeleteChannelInput {
    /// The ID of the Channel to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteChannelOutput {

    public init() { }
}

public struct DeleteOriginEndpointInput {
    /// The ID of the OriginEndpoint to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteOriginEndpointOutput {

    public init() { }
}

public struct DescribeChannelInput {
    /// The ID of a Channel.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DescribeChannelOutput {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

public struct DescribeHarvestJobInput {
    /// The ID of the HarvestJob.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DescribeHarvestJobOutput {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public var arn: Swift.String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public var channelId: Swift.String?
    /// The date and time the HarvestJob was submitted.
    public var createdAt: Swift.String?
    /// The end of the time-window which will be harvested.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested.
    public var startTime: Swift.String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will include an explanation of why the HarvestJob failed.
    public var status: MediaPackageClientTypes.Status?

    public init(
        arn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil,
        status: MediaPackageClientTypes.Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

public struct DescribeOriginEndpointInput {
    /// The ID of the OriginEndpoint.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DescribeOriginEndpointOutput {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// The date and time the OriginEndpoint was created.
    public var createdAt: Swift.String?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        createdAt: Swift.String? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.createdAt = createdAt
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

public struct ListChannelsInput {
    /// Upper bound on number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListChannelsOutput {
    /// A list of Channel records.
    public var channels: [MediaPackageClientTypes.Channel]?
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?

    public init(
        channels: [MediaPackageClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

public struct ListHarvestJobsInput {
    /// When specified, the request will return only HarvestJobs associated with the given Channel ID.
    public var includeChannelId: Swift.String?
    /// When specified, the request will return only HarvestJobs in the given status.
    public var includeStatus: Swift.String?
    /// The upper bound on the number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init(
        includeChannelId: Swift.String? = nil,
        includeStatus: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeChannelId = includeChannelId
        self.includeStatus = includeStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListHarvestJobsOutput {
    /// A list of HarvestJob records.
    public var harvestJobs: [MediaPackageClientTypes.HarvestJob]?
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?

    public init(
        harvestJobs: [MediaPackageClientTypes.HarvestJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.harvestJobs = harvestJobs
        self.nextToken = nextToken
    }
}

public struct ListOriginEndpointsInput {
    /// When specified, the request will return only OriginEndpoints associated with the given Channel ID.
    public var channelId: Swift.String?
    /// The upper bound on the number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init(
        channelId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListOriginEndpointsOutput {
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?
    /// A list of OriginEndpoint records.
    public var originEndpoints: [MediaPackageClientTypes.OriginEndpoint]?

    public init(
        nextToken: Swift.String? = nil,
        originEndpoints: [MediaPackageClientTypes.OriginEndpoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.originEndpoints = originEndpoints
    }
}

public struct ListTagsForResourceInput {
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

@available(*, deprecated)
public struct RotateChannelCredentialsInput {
    /// The ID of the channel to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

@available(*, deprecated)
public struct RotateChannelCredentialsOutput {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

public struct RotateIngestEndpointCredentialsInput {
    /// The ID of the channel the IngestEndpoint is on.
    /// This member is required.
    public var id: Swift.String?
    /// The id of the IngestEndpoint whose credentials should be rotated
    /// This member is required.
    public var ingestEndpointId: Swift.String?

    public init(
        id: Swift.String? = nil,
        ingestEndpointId: Swift.String? = nil
    )
    {
        self.id = id
        self.ingestEndpointId = ingestEndpointId
    }
}

public struct RotateIngestEndpointCredentialsOutput {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// This member is required.
    public var resourceArn: Swift.String?
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput {
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key(s) of tag to be deleted
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// Configuration parameters used to update the Channel.
public struct UpdateChannelInput {
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// The ID of the Channel to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
    }
}

public struct UpdateChannelOutput {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

/// Configuration parameters used to update an existing OriginEndpoint.
public struct UpdateOriginEndpointInput {
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint to update.
    /// This member is required.
    public var id: Swift.String?
    /// A short string that will be appended to the end of the Endpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (in seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// Amount of delay (in seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        authorization: MediaPackageClientTypes.Authorization? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.authorization = authorization
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

public struct UpdateOriginEndpointOutput {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// The date and time the OriginEndpoint was created.
    public var createdAt: Swift.String?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String: Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        createdAt: Swift.String? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.createdAt = createdAt
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

extension ConfigureLogsInput {

    static func urlPathProvider(_ value: ConfigureLogsInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())/configure_logs"
    }
}

extension CreateChannelInput {

    static func urlPathProvider(_ value: CreateChannelInput) -> Swift.String? {
        return "/channels"
    }
}

extension CreateHarvestJobInput {

    static func urlPathProvider(_ value: CreateHarvestJobInput) -> Swift.String? {
        return "/harvest_jobs"
    }
}

extension CreateOriginEndpointInput {

    static func urlPathProvider(_ value: CreateOriginEndpointInput) -> Swift.String? {
        return "/origin_endpoints"
    }
}

extension DeleteChannelInput {

    static func urlPathProvider(_ value: DeleteChannelInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

extension DeleteOriginEndpointInput {

    static func urlPathProvider(_ value: DeleteOriginEndpointInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/origin_endpoints/\(id.urlPercentEncoding())"
    }
}

extension DescribeChannelInput {

    static func urlPathProvider(_ value: DescribeChannelInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

extension DescribeHarvestJobInput {

    static func urlPathProvider(_ value: DescribeHarvestJobInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/harvest_jobs/\(id.urlPercentEncoding())"
    }
}

extension DescribeOriginEndpointInput {

    static func urlPathProvider(_ value: DescribeOriginEndpointInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/origin_endpoints/\(id.urlPercentEncoding())"
    }
}

extension ListChannelsInput {

    static func urlPathProvider(_ value: ListChannelsInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsInput {

    static func queryItemProvider(_ value: ListChannelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListHarvestJobsInput {

    static func urlPathProvider(_ value: ListHarvestJobsInput) -> Swift.String? {
        return "/harvest_jobs"
    }
}

extension ListHarvestJobsInput {

    static func queryItemProvider(_ value: ListHarvestJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let includeChannelId = value.includeChannelId {
            let includeChannelIdQueryItem = Smithy.URIQueryItem(name: "includeChannelId".urlPercentEncoding(), value: Swift.String(includeChannelId).urlPercentEncoding())
            items.append(includeChannelIdQueryItem)
        }
        if let includeStatus = value.includeStatus {
            let includeStatusQueryItem = Smithy.URIQueryItem(name: "includeStatus".urlPercentEncoding(), value: Swift.String(includeStatus).urlPercentEncoding())
            items.append(includeStatusQueryItem)
        }
        return items
    }
}

extension ListOriginEndpointsInput {

    static func urlPathProvider(_ value: ListOriginEndpointsInput) -> Swift.String? {
        return "/origin_endpoints"
    }
}

extension ListOriginEndpointsInput {

    static func queryItemProvider(_ value: ListOriginEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let channelId = value.channelId {
            let channelIdQueryItem = Smithy.URIQueryItem(name: "channelId".urlPercentEncoding(), value: Swift.String(channelId).urlPercentEncoding())
            items.append(channelIdQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension RotateChannelCredentialsInput {

    static func urlPathProvider(_ value: RotateChannelCredentialsInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())/credentials"
    }
}

extension RotateIngestEndpointCredentialsInput {

    static func urlPathProvider(_ value: RotateIngestEndpointCredentialsInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        guard let ingestEndpointId = value.ingestEndpointId else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())/ingest_endpoints/\(ingestEndpointId.urlPercentEncoding())/credentials"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateChannelInput {

    static func urlPathProvider(_ value: UpdateChannelInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

extension UpdateOriginEndpointInput {

    static func urlPathProvider(_ value: UpdateOriginEndpointInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/origin_endpoints/\(id.urlPercentEncoding())"
    }
}

extension ConfigureLogsInput {

    static func write(value: ConfigureLogsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["egressAccessLogs"].write(value.egressAccessLogs, with: MediaPackageClientTypes.EgressAccessLogs.write(value:to:))
        try writer["ingressAccessLogs"].write(value.ingressAccessLogs, with: MediaPackageClientTypes.IngressAccessLogs.write(value:to:))
    }
}

extension CreateChannelInput {

    static func write(value: CreateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["id"].write(value.id)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateHarvestJobInput {

    static func write(value: CreateHarvestJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].write(value.endTime)
        try writer["id"].write(value.id)
        try writer["originEndpointId"].write(value.originEndpointId)
        try writer["s3Destination"].write(value.s3Destination, with: MediaPackageClientTypes.S3Destination.write(value:to:))
        try writer["startTime"].write(value.startTime)
    }
}

extension CreateOriginEndpointInput {

    static func write(value: CreateOriginEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorization"].write(value.authorization, with: MediaPackageClientTypes.Authorization.write(value:to:))
        try writer["channelId"].write(value.channelId)
        try writer["cmafPackage"].write(value.cmafPackage, with: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters.write(value:to:))
        try writer["dashPackage"].write(value.dashPackage, with: MediaPackageClientTypes.DashPackage.write(value:to:))
        try writer["description"].write(value.description)
        try writer["hlsPackage"].write(value.hlsPackage, with: MediaPackageClientTypes.HlsPackage.write(value:to:))
        try writer["id"].write(value.id)
        try writer["manifestName"].write(value.manifestName)
        try writer["mssPackage"].write(value.mssPackage, with: MediaPackageClientTypes.MssPackage.write(value:to:))
        try writer["origination"].write(value.origination)
        try writer["startoverWindowSeconds"].write(value.startoverWindowSeconds)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["timeDelaySeconds"].write(value.timeDelaySeconds)
        try writer["whitelist"].writeList(value.whitelist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateChannelInput {

    static func write(value: UpdateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateOriginEndpointInput {

    static func write(value: UpdateOriginEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorization"].write(value.authorization, with: MediaPackageClientTypes.Authorization.write(value:to:))
        try writer["cmafPackage"].write(value.cmafPackage, with: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters.write(value:to:))
        try writer["dashPackage"].write(value.dashPackage, with: MediaPackageClientTypes.DashPackage.write(value:to:))
        try writer["description"].write(value.description)
        try writer["hlsPackage"].write(value.hlsPackage, with: MediaPackageClientTypes.HlsPackage.write(value:to:))
        try writer["manifestName"].write(value.manifestName)
        try writer["mssPackage"].write(value.mssPackage, with: MediaPackageClientTypes.MssPackage.write(value:to:))
        try writer["origination"].write(value.origination)
        try writer["startoverWindowSeconds"].write(value.startoverWindowSeconds)
        try writer["timeDelaySeconds"].write(value.timeDelaySeconds)
        try writer["whitelist"].writeList(value.whitelist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConfigureLogsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfigureLogsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfigureLogsOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.egressAccessLogs = try reader["egressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.EgressAccessLogs.read(from:))
        value.hlsIngest = try reader["hlsIngest"].readIfPresent(with: MediaPackageClientTypes.HlsIngest.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.ingressAccessLogs = try reader["ingressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.IngressAccessLogs.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.egressAccessLogs = try reader["egressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.EgressAccessLogs.read(from:))
        value.hlsIngest = try reader["hlsIngest"].readIfPresent(with: MediaPackageClientTypes.HlsIngest.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.ingressAccessLogs = try reader["ingressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.IngressAccessLogs.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateHarvestJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateHarvestJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateHarvestJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.channelId = try reader["channelId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.originEndpointId = try reader["originEndpointId"].readIfPresent()
        value.s3Destination = try reader["s3Destination"].readIfPresent(with: MediaPackageClientTypes.S3Destination.read(from:))
        value.startTime = try reader["startTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateOriginEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOriginEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOriginEndpointOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authorization = try reader["authorization"].readIfPresent(with: MediaPackageClientTypes.Authorization.read(from:))
        value.channelId = try reader["channelId"].readIfPresent()
        value.cmafPackage = try reader["cmafPackage"].readIfPresent(with: MediaPackageClientTypes.CmafPackage.read(from:))
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.dashPackage = try reader["dashPackage"].readIfPresent(with: MediaPackageClientTypes.DashPackage.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.hlsPackage = try reader["hlsPackage"].readIfPresent(with: MediaPackageClientTypes.HlsPackage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.manifestName = try reader["manifestName"].readIfPresent()
        value.mssPackage = try reader["mssPackage"].readIfPresent(with: MediaPackageClientTypes.MssPackage.read(from:))
        value.origination = try reader["origination"].readIfPresent()
        value.startoverWindowSeconds = try reader["startoverWindowSeconds"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeDelaySeconds = try reader["timeDelaySeconds"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.whitelist = try reader["whitelist"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelOutput {
        return DeleteChannelOutput()
    }
}

extension DeleteOriginEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOriginEndpointOutput {
        return DeleteOriginEndpointOutput()
    }
}

extension DescribeChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.egressAccessLogs = try reader["egressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.EgressAccessLogs.read(from:))
        value.hlsIngest = try reader["hlsIngest"].readIfPresent(with: MediaPackageClientTypes.HlsIngest.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.ingressAccessLogs = try reader["ingressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.IngressAccessLogs.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeHarvestJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeHarvestJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeHarvestJobOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.channelId = try reader["channelId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.originEndpointId = try reader["originEndpointId"].readIfPresent()
        value.s3Destination = try reader["s3Destination"].readIfPresent(with: MediaPackageClientTypes.S3Destination.read(from:))
        value.startTime = try reader["startTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DescribeOriginEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOriginEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOriginEndpointOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authorization = try reader["authorization"].readIfPresent(with: MediaPackageClientTypes.Authorization.read(from:))
        value.channelId = try reader["channelId"].readIfPresent()
        value.cmafPackage = try reader["cmafPackage"].readIfPresent(with: MediaPackageClientTypes.CmafPackage.read(from:))
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.dashPackage = try reader["dashPackage"].readIfPresent(with: MediaPackageClientTypes.DashPackage.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.hlsPackage = try reader["hlsPackage"].readIfPresent(with: MediaPackageClientTypes.HlsPackage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.manifestName = try reader["manifestName"].readIfPresent()
        value.mssPackage = try reader["mssPackage"].readIfPresent(with: MediaPackageClientTypes.MssPackage.read(from:))
        value.origination = try reader["origination"].readIfPresent()
        value.startoverWindowSeconds = try reader["startoverWindowSeconds"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeDelaySeconds = try reader["timeDelaySeconds"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.whitelist = try reader["whitelist"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsOutput()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: MediaPackageClientTypes.Channel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListHarvestJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListHarvestJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHarvestJobsOutput()
        value.harvestJobs = try reader["harvestJobs"].readListIfPresent(memberReadingClosure: MediaPackageClientTypes.HarvestJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOriginEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOriginEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOriginEndpointsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.originEndpoints = try reader["originEndpoints"].readListIfPresent(memberReadingClosure: MediaPackageClientTypes.OriginEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RotateChannelCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RotateChannelCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RotateChannelCredentialsOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.egressAccessLogs = try reader["egressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.EgressAccessLogs.read(from:))
        value.hlsIngest = try reader["hlsIngest"].readIfPresent(with: MediaPackageClientTypes.HlsIngest.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.ingressAccessLogs = try reader["ingressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.IngressAccessLogs.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RotateIngestEndpointCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RotateIngestEndpointCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RotateIngestEndpointCredentialsOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.egressAccessLogs = try reader["egressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.EgressAccessLogs.read(from:))
        value.hlsIngest = try reader["hlsIngest"].readIfPresent(with: MediaPackageClientTypes.HlsIngest.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.ingressAccessLogs = try reader["ingressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.IngressAccessLogs.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.egressAccessLogs = try reader["egressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.EgressAccessLogs.read(from:))
        value.hlsIngest = try reader["hlsIngest"].readIfPresent(with: MediaPackageClientTypes.HlsIngest.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.ingressAccessLogs = try reader["ingressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.IngressAccessLogs.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateOriginEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOriginEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOriginEndpointOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authorization = try reader["authorization"].readIfPresent(with: MediaPackageClientTypes.Authorization.read(from:))
        value.channelId = try reader["channelId"].readIfPresent()
        value.cmafPackage = try reader["cmafPackage"].readIfPresent(with: MediaPackageClientTypes.CmafPackage.read(from:))
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.dashPackage = try reader["dashPackage"].readIfPresent(with: MediaPackageClientTypes.DashPackage.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.hlsPackage = try reader["hlsPackage"].readIfPresent(with: MediaPackageClientTypes.HlsPackage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.manifestName = try reader["manifestName"].readIfPresent()
        value.mssPackage = try reader["mssPackage"].readIfPresent(with: MediaPackageClientTypes.MssPackage.read(from:))
        value.origination = try reader["origination"].readIfPresent()
        value.startoverWindowSeconds = try reader["startoverWindowSeconds"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeDelaySeconds = try reader["timeDelaySeconds"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.whitelist = try reader["whitelist"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum ConfigureLogsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateHarvestJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOriginEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOriginEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeHarvestJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOriginEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListHarvestJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOriginEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RotateChannelCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RotateIngestEndpointCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOriginEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnprocessableEntityException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnprocessableEntityException {
        let reader = baseError.errorBodyReader
        var value = UnprocessableEntityException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MediaPackageClientTypes.EgressAccessLogs {

    static func write(value: MediaPackageClientTypes.EgressAccessLogs?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupName"].write(value.logGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.EgressAccessLogs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.EgressAccessLogs()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.HlsIngest {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.HlsIngest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.HlsIngest()
        value.ingestEndpoints = try reader["ingestEndpoints"].readListIfPresent(memberReadingClosure: MediaPackageClientTypes.IngestEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaPackageClientTypes.IngestEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.IngestEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.IngestEndpoint()
        value.id = try reader["id"].readIfPresent()
        value.password = try reader["password"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.username = try reader["username"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.IngressAccessLogs {

    static func write(value: MediaPackageClientTypes.IngressAccessLogs?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupName"].write(value.logGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.IngressAccessLogs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.IngressAccessLogs()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.S3Destination {

    static func write(value: MediaPackageClientTypes.S3Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["manifestKey"].write(value.manifestKey)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.S3Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.S3Destination()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.manifestKey = try reader["manifestKey"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension MediaPackageClientTypes.Authorization {

    static func write(value: MediaPackageClientTypes.Authorization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cdnIdentifierSecret"].write(value.cdnIdentifierSecret)
        try writer["secretsRoleArn"].write(value.secretsRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.Authorization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.Authorization()
        value.cdnIdentifierSecret = try reader["cdnIdentifierSecret"].readIfPresent() ?? ""
        value.secretsRoleArn = try reader["secretsRoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension MediaPackageClientTypes.CmafPackage {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.CmafPackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.CmafPackage()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaPackageClientTypes.CmafEncryption.read(from:))
        value.hlsManifests = try reader["hlsManifests"].readListIfPresent(memberReadingClosure: MediaPackageClientTypes.HlsManifest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.segmentDurationSeconds = try reader["segmentDurationSeconds"].readIfPresent()
        value.segmentPrefix = try reader["segmentPrefix"].readIfPresent()
        value.streamSelection = try reader["streamSelection"].readIfPresent(with: MediaPackageClientTypes.StreamSelection.read(from:))
        return value
    }
}

extension MediaPackageClientTypes.StreamSelection {

    static func write(value: MediaPackageClientTypes.StreamSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxVideoBitsPerSecond"].write(value.maxVideoBitsPerSecond)
        try writer["minVideoBitsPerSecond"].write(value.minVideoBitsPerSecond)
        try writer["streamOrder"].write(value.streamOrder)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.StreamSelection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.StreamSelection()
        value.maxVideoBitsPerSecond = try reader["maxVideoBitsPerSecond"].readIfPresent()
        value.minVideoBitsPerSecond = try reader["minVideoBitsPerSecond"].readIfPresent()
        value.streamOrder = try reader["streamOrder"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.HlsManifest {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.HlsManifest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.HlsManifest()
        value.adMarkers = try reader["adMarkers"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.includeIframeOnlyStream = try reader["includeIframeOnlyStream"].readIfPresent()
        value.manifestName = try reader["manifestName"].readIfPresent()
        value.playlistType = try reader["playlistType"].readIfPresent()
        value.playlistWindowSeconds = try reader["playlistWindowSeconds"].readIfPresent()
        value.programDateTimeIntervalSeconds = try reader["programDateTimeIntervalSeconds"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.adTriggers = try reader["adTriggers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaPackageClientTypes.__AdTriggersElement>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.adsOnDeliveryRestrictions = try reader["adsOnDeliveryRestrictions"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.CmafEncryption {

    static func write(value: MediaPackageClientTypes.CmafEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["constantInitializationVector"].write(value.constantInitializationVector)
        try writer["encryptionMethod"].write(value.encryptionMethod)
        try writer["keyRotationIntervalSeconds"].write(value.keyRotationIntervalSeconds)
        try writer["spekeKeyProvider"].write(value.spekeKeyProvider, with: MediaPackageClientTypes.SpekeKeyProvider.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.CmafEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.CmafEncryption()
        value.constantInitializationVector = try reader["constantInitializationVector"].readIfPresent()
        value.encryptionMethod = try reader["encryptionMethod"].readIfPresent()
        value.keyRotationIntervalSeconds = try reader["keyRotationIntervalSeconds"].readIfPresent()
        value.spekeKeyProvider = try reader["spekeKeyProvider"].readIfPresent(with: MediaPackageClientTypes.SpekeKeyProvider.read(from:))
        return value
    }
}

extension MediaPackageClientTypes.SpekeKeyProvider {

    static func write(value: MediaPackageClientTypes.SpekeKeyProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
        try writer["encryptionContractConfiguration"].write(value.encryptionContractConfiguration, with: MediaPackageClientTypes.EncryptionContractConfiguration.write(value:to:))
        try writer["resourceId"].write(value.resourceId)
        try writer["roleArn"].write(value.roleArn)
        try writer["systemIds"].writeList(value.systemIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.SpekeKeyProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.SpekeKeyProvider()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.encryptionContractConfiguration = try reader["encryptionContractConfiguration"].readIfPresent(with: MediaPackageClientTypes.EncryptionContractConfiguration.read(from:))
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.systemIds = try reader["systemIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.url = try reader["url"].readIfPresent() ?? ""
        return value
    }
}

extension MediaPackageClientTypes.EncryptionContractConfiguration {

    static func write(value: MediaPackageClientTypes.EncryptionContractConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["presetSpeke20Audio"].write(value.presetSpeke20Audio)
        try writer["presetSpeke20Video"].write(value.presetSpeke20Video)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.EncryptionContractConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.EncryptionContractConfiguration()
        value.presetSpeke20Audio = try reader["presetSpeke20Audio"].readIfPresent() ?? .sdkUnknown("")
        value.presetSpeke20Video = try reader["presetSpeke20Video"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension MediaPackageClientTypes.DashPackage {

    static func write(value: MediaPackageClientTypes.DashPackage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adTriggers"].writeList(value.adTriggers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaPackageClientTypes.__AdTriggersElement>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["adsOnDeliveryRestrictions"].write(value.adsOnDeliveryRestrictions)
        try writer["encryption"].write(value.encryption, with: MediaPackageClientTypes.DashEncryption.write(value:to:))
        try writer["includeIframeOnlyStream"].write(value.includeIframeOnlyStream)
        try writer["manifestLayout"].write(value.manifestLayout)
        try writer["manifestWindowSeconds"].write(value.manifestWindowSeconds)
        try writer["minBufferTimeSeconds"].write(value.minBufferTimeSeconds)
        try writer["minUpdatePeriodSeconds"].write(value.minUpdatePeriodSeconds)
        try writer["periodTriggers"].writeList(value.periodTriggers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaPackageClientTypes.__PeriodTriggersElement>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["profile"].write(value.profile)
        try writer["segmentDurationSeconds"].write(value.segmentDurationSeconds)
        try writer["segmentTemplateFormat"].write(value.segmentTemplateFormat)
        try writer["streamSelection"].write(value.streamSelection, with: MediaPackageClientTypes.StreamSelection.write(value:to:))
        try writer["suggestedPresentationDelaySeconds"].write(value.suggestedPresentationDelaySeconds)
        try writer["utcTiming"].write(value.utcTiming)
        try writer["utcTimingUri"].write(value.utcTimingUri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.DashPackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.DashPackage()
        value.adTriggers = try reader["adTriggers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaPackageClientTypes.__AdTriggersElement>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.adsOnDeliveryRestrictions = try reader["adsOnDeliveryRestrictions"].readIfPresent()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaPackageClientTypes.DashEncryption.read(from:))
        value.includeIframeOnlyStream = try reader["includeIframeOnlyStream"].readIfPresent()
        value.manifestLayout = try reader["manifestLayout"].readIfPresent()
        value.manifestWindowSeconds = try reader["manifestWindowSeconds"].readIfPresent()
        value.minBufferTimeSeconds = try reader["minBufferTimeSeconds"].readIfPresent()
        value.minUpdatePeriodSeconds = try reader["minUpdatePeriodSeconds"].readIfPresent()
        value.periodTriggers = try reader["periodTriggers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaPackageClientTypes.__PeriodTriggersElement>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.profile = try reader["profile"].readIfPresent()
        value.segmentDurationSeconds = try reader["segmentDurationSeconds"].readIfPresent()
        value.segmentTemplateFormat = try reader["segmentTemplateFormat"].readIfPresent()
        value.streamSelection = try reader["streamSelection"].readIfPresent(with: MediaPackageClientTypes.StreamSelection.read(from:))
        value.suggestedPresentationDelaySeconds = try reader["suggestedPresentationDelaySeconds"].readIfPresent()
        value.utcTiming = try reader["utcTiming"].readIfPresent()
        value.utcTimingUri = try reader["utcTimingUri"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.DashEncryption {

    static func write(value: MediaPackageClientTypes.DashEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyRotationIntervalSeconds"].write(value.keyRotationIntervalSeconds)
        try writer["spekeKeyProvider"].write(value.spekeKeyProvider, with: MediaPackageClientTypes.SpekeKeyProvider.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.DashEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.DashEncryption()
        value.keyRotationIntervalSeconds = try reader["keyRotationIntervalSeconds"].readIfPresent()
        value.spekeKeyProvider = try reader["spekeKeyProvider"].readIfPresent(with: MediaPackageClientTypes.SpekeKeyProvider.read(from:))
        return value
    }
}

extension MediaPackageClientTypes.HlsPackage {

    static func write(value: MediaPackageClientTypes.HlsPackage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adMarkers"].write(value.adMarkers)
        try writer["adTriggers"].writeList(value.adTriggers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaPackageClientTypes.__AdTriggersElement>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["adsOnDeliveryRestrictions"].write(value.adsOnDeliveryRestrictions)
        try writer["encryption"].write(value.encryption, with: MediaPackageClientTypes.HlsEncryption.write(value:to:))
        try writer["includeDvbSubtitles"].write(value.includeDvbSubtitles)
        try writer["includeIframeOnlyStream"].write(value.includeIframeOnlyStream)
        try writer["playlistType"].write(value.playlistType)
        try writer["playlistWindowSeconds"].write(value.playlistWindowSeconds)
        try writer["programDateTimeIntervalSeconds"].write(value.programDateTimeIntervalSeconds)
        try writer["segmentDurationSeconds"].write(value.segmentDurationSeconds)
        try writer["streamSelection"].write(value.streamSelection, with: MediaPackageClientTypes.StreamSelection.write(value:to:))
        try writer["useAudioRenditionGroup"].write(value.useAudioRenditionGroup)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.HlsPackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.HlsPackage()
        value.adMarkers = try reader["adMarkers"].readIfPresent()
        value.adTriggers = try reader["adTriggers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MediaPackageClientTypes.__AdTriggersElement>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.adsOnDeliveryRestrictions = try reader["adsOnDeliveryRestrictions"].readIfPresent()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaPackageClientTypes.HlsEncryption.read(from:))
        value.includeDvbSubtitles = try reader["includeDvbSubtitles"].readIfPresent()
        value.includeIframeOnlyStream = try reader["includeIframeOnlyStream"].readIfPresent()
        value.playlistType = try reader["playlistType"].readIfPresent()
        value.playlistWindowSeconds = try reader["playlistWindowSeconds"].readIfPresent()
        value.programDateTimeIntervalSeconds = try reader["programDateTimeIntervalSeconds"].readIfPresent()
        value.segmentDurationSeconds = try reader["segmentDurationSeconds"].readIfPresent()
        value.streamSelection = try reader["streamSelection"].readIfPresent(with: MediaPackageClientTypes.StreamSelection.read(from:))
        value.useAudioRenditionGroup = try reader["useAudioRenditionGroup"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.HlsEncryption {

    static func write(value: MediaPackageClientTypes.HlsEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["constantInitializationVector"].write(value.constantInitializationVector)
        try writer["encryptionMethod"].write(value.encryptionMethod)
        try writer["keyRotationIntervalSeconds"].write(value.keyRotationIntervalSeconds)
        try writer["repeatExtXKey"].write(value.repeatExtXKey)
        try writer["spekeKeyProvider"].write(value.spekeKeyProvider, with: MediaPackageClientTypes.SpekeKeyProvider.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.HlsEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.HlsEncryption()
        value.constantInitializationVector = try reader["constantInitializationVector"].readIfPresent()
        value.encryptionMethod = try reader["encryptionMethod"].readIfPresent()
        value.keyRotationIntervalSeconds = try reader["keyRotationIntervalSeconds"].readIfPresent()
        value.repeatExtXKey = try reader["repeatExtXKey"].readIfPresent()
        value.spekeKeyProvider = try reader["spekeKeyProvider"].readIfPresent(with: MediaPackageClientTypes.SpekeKeyProvider.read(from:))
        return value
    }
}

extension MediaPackageClientTypes.MssPackage {

    static func write(value: MediaPackageClientTypes.MssPackage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryption"].write(value.encryption, with: MediaPackageClientTypes.MssEncryption.write(value:to:))
        try writer["manifestWindowSeconds"].write(value.manifestWindowSeconds)
        try writer["segmentDurationSeconds"].write(value.segmentDurationSeconds)
        try writer["streamSelection"].write(value.streamSelection, with: MediaPackageClientTypes.StreamSelection.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.MssPackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.MssPackage()
        value.encryption = try reader["encryption"].readIfPresent(with: MediaPackageClientTypes.MssEncryption.read(from:))
        value.manifestWindowSeconds = try reader["manifestWindowSeconds"].readIfPresent()
        value.segmentDurationSeconds = try reader["segmentDurationSeconds"].readIfPresent()
        value.streamSelection = try reader["streamSelection"].readIfPresent(with: MediaPackageClientTypes.StreamSelection.read(from:))
        return value
    }
}

extension MediaPackageClientTypes.MssEncryption {

    static func write(value: MediaPackageClientTypes.MssEncryption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["spekeKeyProvider"].write(value.spekeKeyProvider, with: MediaPackageClientTypes.SpekeKeyProvider.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.MssEncryption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.MssEncryption()
        value.spekeKeyProvider = try reader["spekeKeyProvider"].readIfPresent(with: MediaPackageClientTypes.SpekeKeyProvider.read(from:))
        return value
    }
}

extension MediaPackageClientTypes.Channel {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.Channel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.Channel()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.egressAccessLogs = try reader["egressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.EgressAccessLogs.read(from:))
        value.hlsIngest = try reader["hlsIngest"].readIfPresent(with: MediaPackageClientTypes.HlsIngest.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.ingressAccessLogs = try reader["ingressAccessLogs"].readIfPresent(with: MediaPackageClientTypes.IngressAccessLogs.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension MediaPackageClientTypes.HarvestJob {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.HarvestJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.HarvestJob()
        value.arn = try reader["arn"].readIfPresent()
        value.channelId = try reader["channelId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.originEndpointId = try reader["originEndpointId"].readIfPresent()
        value.s3Destination = try reader["s3Destination"].readIfPresent(with: MediaPackageClientTypes.S3Destination.read(from:))
        value.startTime = try reader["startTime"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension MediaPackageClientTypes.OriginEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> MediaPackageClientTypes.OriginEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MediaPackageClientTypes.OriginEndpoint()
        value.arn = try reader["arn"].readIfPresent()
        value.authorization = try reader["authorization"].readIfPresent(with: MediaPackageClientTypes.Authorization.read(from:))
        value.channelId = try reader["channelId"].readIfPresent()
        value.cmafPackage = try reader["cmafPackage"].readIfPresent(with: MediaPackageClientTypes.CmafPackage.read(from:))
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.dashPackage = try reader["dashPackage"].readIfPresent(with: MediaPackageClientTypes.DashPackage.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.hlsPackage = try reader["hlsPackage"].readIfPresent(with: MediaPackageClientTypes.HlsPackage.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.manifestName = try reader["manifestName"].readIfPresent()
        value.mssPackage = try reader["mssPackage"].readIfPresent(with: MediaPackageClientTypes.MssPackage.read(from:))
        value.origination = try reader["origination"].readIfPresent()
        value.startoverWindowSeconds = try reader["startoverWindowSeconds"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.timeDelaySeconds = try reader["timeDelaySeconds"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.whitelist = try reader["whitelist"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters {

    static func write(value: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryption"].write(value.encryption, with: MediaPackageClientTypes.CmafEncryption.write(value:to:))
        try writer["hlsManifests"].writeList(value.hlsManifests, memberWritingClosure: MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["segmentDurationSeconds"].write(value.segmentDurationSeconds)
        try writer["segmentPrefix"].write(value.segmentPrefix)
        try writer["streamSelection"].write(value.streamSelection, with: MediaPackageClientTypes.StreamSelection.write(value:to:))
    }
}

extension MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters {

    static func write(value: MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adMarkers"].write(value.adMarkers)
        try writer["adTriggers"].writeList(value.adTriggers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MediaPackageClientTypes.__AdTriggersElement>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["adsOnDeliveryRestrictions"].write(value.adsOnDeliveryRestrictions)
        try writer["id"].write(value.id)
        try writer["includeIframeOnlyStream"].write(value.includeIframeOnlyStream)
        try writer["manifestName"].write(value.manifestName)
        try writer["playlistType"].write(value.playlistType)
        try writer["playlistWindowSeconds"].write(value.playlistWindowSeconds)
        try writer["programDateTimeIntervalSeconds"].write(value.programDateTimeIntervalSeconds)
    }
}

public enum MediaPackageClientTypes {}
