// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaPackageClientTypes {
    public enum AdMarkers: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daterange
        case `none`
        case passthrough
        case scte35Enhanced
        case sdkUnknown(Swift.String)

        public static var allCases: [AdMarkers] {
            return [
                .daterange,
                .none,
                .passthrough,
                .scte35Enhanced,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daterange: return "DATERANGE"
            case .none: return "NONE"
            case .passthrough: return "PASSTHROUGH"
            case .scte35Enhanced: return "SCTE35_ENHANCED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdMarkers(rawValue: rawValue) ?? AdMarkers.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
    public enum AdsOnDeliveryRestrictions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case both
        case `none`
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [AdsOnDeliveryRestrictions] {
            return [
                .both,
                .none,
                .restricted,
                .unrestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .both: return "BOTH"
            case .none: return "NONE"
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdsOnDeliveryRestrictions(rawValue: rawValue) ?? AdsOnDeliveryRestrictions.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes.Authorization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdnIdentifierSecret = "cdnIdentifierSecret"
        case secretsRoleArn = "secretsRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdnIdentifierSecret = self.cdnIdentifierSecret {
            try encodeContainer.encode(cdnIdentifierSecret, forKey: .cdnIdentifierSecret)
        }
        if let secretsRoleArn = self.secretsRoleArn {
            try encodeContainer.encode(secretsRoleArn, forKey: .secretsRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdnIdentifierSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdnIdentifierSecret)
        cdnIdentifierSecret = cdnIdentifierSecretDecoded
        let secretsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsRoleArn)
        secretsRoleArn = secretsRoleArnDecoded
    }
}

extension MediaPackageClientTypes {
    /// CDN Authorization credentials
    public struct Authorization: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
        /// This member is required.
        public var cdnIdentifierSecret: Swift.String?
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        /// This member is required.
        public var secretsRoleArn: Swift.String?

        public init(
            cdnIdentifierSecret: Swift.String? = nil,
            secretsRoleArn: Swift.String? = nil
        )
        {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }
    }

}

extension MediaPackageClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let egressAccessLogs = self.egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let hlsIngest = self.hlsIngest {
            try encodeContainer.encode(hlsIngest, forKey: .hlsIngest)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ingressAccessLogs = self.ingressAccessLogs {
            try encodeContainer.encode(ingressAccessLogs, forKey: .ingressAccessLogs)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageClientTypes {
    /// A Channel resource configuration.
    public struct Channel: Swift.Equatable {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public var arn: Swift.String?
        /// The date and time the Channel was created.
        public var createdAt: Swift.String?
        /// A short text description of the Channel.
        public var description: Swift.String?
        /// Configure egress access logging.
        public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
        /// An HTTP Live Streaming (HLS) ingest resource configuration.
        public var hlsIngest: MediaPackageClientTypes.HlsIngest?
        /// The ID of the Channel.
        public var id: Swift.String?
        /// Configure ingress access logging.
        public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            description: Swift.String? = nil,
            egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
            hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
            id: Swift.String? = nil,
            ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }
    }

}

extension MediaPackageClientTypes.CmafEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case encryptionMethod = "encryptionMethod"
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = self.encryptionMethod {
            try encodeContainer.encode(encryptionMethod.rawValue, forKey: .encryptionMethod)
        }
        if let keyRotationIntervalSeconds = self.keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafEncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) encryption configuration.
    public struct CmafEncryption: Swift.Equatable {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        public var encryptionMethod: MediaPackageClientTypes.CmafEncryptionMethod?
        /// Time (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageClientTypes.CmafEncryptionMethod? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes {
    /// The encryption method to use.
    public enum CmafEncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aesCtr
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [CmafEncryptionMethod] {
            return [
                .aesCtr,
                .sampleAes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aesCtr: return "AES_CTR"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CmafEncryptionMethod(rawValue: rawValue) ?? CmafEncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes.CmafPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentPrefix = "segmentPrefix"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for hlsmanifest0 in hlsManifests {
                try hlsManifestsContainer.encode(hlsmanifest0)
            }
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentPrefix = self.segmentPrefix {
            try encodeContainer.encode(segmentPrefix, forKey: .segmentPrefix)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.HlsManifest?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageClientTypes.HlsManifest]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageClientTypes.HlsManifest]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentPrefix)
        segmentPrefix = segmentPrefixDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) packaging configuration.
    public struct CmafPackage: Swift.Equatable {
        /// A Common Media Application Format (CMAF) encryption configuration.
        public var encryption: MediaPackageClientTypes.CmafEncryption?
        /// A list of HLS manifest configurations
        public var hlsManifests: [MediaPackageClientTypes.HlsManifest]?
        /// Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public var segmentPrefix: Swift.String?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init(
            encryption: MediaPackageClientTypes.CmafEncryption? = nil,
            hlsManifests: [MediaPackageClientTypes.HlsManifest]? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentPrefix: Swift.String? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }
    }

}

extension MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentPrefix = "segmentPrefix"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for hlsmanifestcreateorupdateparameters0 in hlsManifests {
                try hlsManifestsContainer.encode(hlsmanifestcreateorupdateparameters0)
            }
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentPrefix = self.segmentPrefix {
            try encodeContainer.encode(segmentPrefix, forKey: .segmentPrefix)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentPrefix)
        segmentPrefix = segmentPrefixDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) packaging configuration.
    public struct CmafPackageCreateOrUpdateParameters: Swift.Equatable {
        /// A Common Media Application Format (CMAF) encryption configuration.
        public var encryption: MediaPackageClientTypes.CmafEncryption?
        /// A list of HLS manifest configurations
        public var hlsManifests: [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]?
        /// Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public var segmentPrefix: Swift.String?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init(
            encryption: MediaPackageClientTypes.CmafEncryption? = nil,
            hlsManifests: [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentPrefix: Swift.String? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }
    }

}

extension ConfigureLogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressAccessLogs = "egressAccessLogs"
        case ingressAccessLogs = "ingressAccessLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressAccessLogs = self.egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let ingressAccessLogs = self.ingressAccessLogs {
            try encodeContainer.encode(ingressAccessLogs, forKey: .ingressAccessLogs)
        }
    }
}

extension ConfigureLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())/configure_logs"
    }
}

/// the option to configure log subscription.
public struct ConfigureLogsInput: Swift.Equatable {
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// The ID of the channel to log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?

    public init(
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil
    )
    {
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
    }
}

struct ConfigureLogsInputBody: Swift.Equatable {
    let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
}

extension ConfigureLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressAccessLogs = "egressAccessLogs"
        case ingressAccessLogs = "ingressAccessLogs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
    }
}

extension ConfigureLogsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConfigureLogsOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct ConfigureLogsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct ConfigureLogsOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let description: Swift.String?
    let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    let hlsIngest: MediaPackageClientTypes.HlsIngest?
    let id: Swift.String?
    let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    let tags: [Swift.String:Swift.String]?
}

extension ConfigureLogsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ConfigureLogsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case id = "id"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

/// A new Channel configuration.
public struct CreateChannelInput: Swift.Equatable {
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// The ID of the Channel. The ID must be unique within the region and it cannot be changed after a Channel is created.
    /// This member is required.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let description: Swift.String?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case id = "id"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct CreateChannelOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let description: Swift.String?
    let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    let hlsIngest: MediaPackageClientTypes.HlsIngest?
    let id: Swift.String?
    let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateHarvestJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originEndpointId = self.originEndpointId {
            try encodeContainer.encode(originEndpointId, forKey: .originEndpointId)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

extension CreateHarvestJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/harvest_jobs"
    }
}

/// Configuration parameters used to create a new HarvestJob.
public struct CreateHarvestJobInput: Swift.Equatable {
    /// The end of the time-window which will be harvested
    /// This member is required.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
    /// This member is required.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    /// This member is required.
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested
    /// This member is required.
    public var startTime: Swift.String?

    public init(
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
    }
}

struct CreateHarvestJobInputBody: Swift.Equatable {
    let endTime: Swift.String?
    let id: Swift.String?
    let originEndpointId: Swift.String?
    let s3Destination: MediaPackageClientTypes.S3Destination?
    let startTime: Swift.String?
}

extension CreateHarvestJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension CreateHarvestJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateHarvestJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelId = output.channelId
            self.createdAt = output.createdAt
            self.endTime = output.endTime
            self.id = output.id
            self.originEndpointId = output.originEndpointId
            self.s3Destination = output.s3Destination
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.arn = nil
            self.channelId = nil
            self.createdAt = nil
            self.endTime = nil
            self.id = nil
            self.originEndpointId = nil
            self.s3Destination = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct CreateHarvestJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public var arn: Swift.String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public var channelId: Swift.String?
    /// The date and time the HarvestJob was submitted.
    public var createdAt: Swift.String?
    /// The end of the time-window which will be harvested.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested.
    public var startTime: Swift.String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will include an explanation of why the HarvestJob failed.
    public var status: MediaPackageClientTypes.Status?

    public init(
        arn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil,
        status: MediaPackageClientTypes.Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

struct CreateHarvestJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelId: Swift.String?
    let createdAt: Swift.String?
    let endTime: Swift.String?
    let id: Swift.String?
    let originEndpointId: Swift.String?
    let s3Destination: MediaPackageClientTypes.S3Destination?
    let startTime: Swift.String?
    let status: MediaPackageClientTypes.Status?
}

extension CreateHarvestJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateHarvestJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateOriginEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = self.authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let cmafPackage = self.cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = self.dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = self.hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = self.mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = self.origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if let startoverWindowSeconds = self.startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeDelaySeconds = self.timeDelaySeconds {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __string0 in whitelist {
                try whitelistContainer.encode(__string0)
            }
        }
    }
}

extension CreateOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/origin_endpoints"
    }
}

/// Configuration parameters used to create a new OriginEndpoint.
public struct CreateOriginEndpointInput: Swift.Equatable {
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel that the OriginEndpoint will be associated with. This cannot be changed after the OriginEndpoint is created.
    /// This member is required.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint. The ID must be unique within the region and it cannot be changed after the OriginEndpoint is created.
    /// This member is required.
    public var id: Swift.String?
    /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

struct CreateOriginEndpointInputBody: Swift.Equatable {
    let authorization: MediaPackageClientTypes.Authorization?
    let channelId: Swift.String?
    let cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    let dashPackage: MediaPackageClientTypes.DashPackage?
    let description: Swift.String?
    let hlsPackage: MediaPackageClientTypes.HlsPackage?
    let id: Swift.String?
    let manifestName: Swift.String?
    let mssPackage: MediaPackageClientTypes.MssPackage?
    let origination: MediaPackageClientTypes.Origination?
    let startoverWindowSeconds: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let timeDelaySeconds: Swift.Int?
    let whitelist: [Swift.String]?
}

extension CreateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension CreateOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOriginEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.createdAt = output.createdAt
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.createdAt = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
            self.timeDelaySeconds = nil
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct CreateOriginEndpointOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// The date and time the OriginEndpoint was created.
    public var createdAt: Swift.String?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        createdAt: Swift.String? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.createdAt = createdAt
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct CreateOriginEndpointOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let authorization: MediaPackageClientTypes.Authorization?
    let channelId: Swift.String?
    let cmafPackage: MediaPackageClientTypes.CmafPackage?
    let createdAt: Swift.String?
    let dashPackage: MediaPackageClientTypes.DashPackage?
    let description: Swift.String?
    let hlsPackage: MediaPackageClientTypes.HlsPackage?
    let id: Swift.String?
    let manifestName: Swift.String?
    let mssPackage: MediaPackageClientTypes.MssPackage?
    let origination: MediaPackageClientTypes.Origination?
    let startoverWindowSeconds: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let timeDelaySeconds: Swift.Int?
    let url: Swift.String?
    let whitelist: [Swift.String]?
}

extension CreateOriginEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case createdAt = "createdAt"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

enum CreateOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageClientTypes.DashEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyRotationIntervalSeconds = self.keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
    public struct DashEncryption: Swift.Equatable {
        /// Time (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes.DashPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case encryption = "encryption"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestLayout = "manifestLayout"
        case manifestWindowSeconds = "manifestWindowSeconds"
        case minBufferTimeSeconds = "minBufferTimeSeconds"
        case minUpdatePeriodSeconds = "minUpdatePeriodSeconds"
        case periodTriggers = "periodTriggers"
        case profile = "profile"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentTemplateFormat = "segmentTemplateFormat"
        case streamSelection = "streamSelection"
        case suggestedPresentationDelaySeconds = "suggestedPresentationDelaySeconds"
        case utcTiming = "utcTiming"
        case utcTimingUri = "utcTimingUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for __adtriggerselement0 in adTriggers {
                try adTriggersContainer.encode(__adtriggerselement0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = self.adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let includeIframeOnlyStream = self.includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestLayout = self.manifestLayout {
            try encodeContainer.encode(manifestLayout.rawValue, forKey: .manifestLayout)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let minBufferTimeSeconds = self.minBufferTimeSeconds {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if let minUpdatePeriodSeconds = self.minUpdatePeriodSeconds {
            try encodeContainer.encode(minUpdatePeriodSeconds, forKey: .minUpdatePeriodSeconds)
        }
        if let periodTriggers = periodTriggers {
            var periodTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .periodTriggers)
            for __periodtriggerselement0 in periodTriggers {
                try periodTriggersContainer.encode(__periodtriggerselement0.rawValue)
            }
        }
        if let profile = self.profile {
            try encodeContainer.encode(profile.rawValue, forKey: .profile)
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentTemplateFormat = self.segmentTemplateFormat {
            try encodeContainer.encode(segmentTemplateFormat.rawValue, forKey: .segmentTemplateFormat)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
        if let suggestedPresentationDelaySeconds = self.suggestedPresentationDelaySeconds {
            try encodeContainer.encode(suggestedPresentationDelaySeconds, forKey: .suggestedPresentationDelaySeconds)
        }
        if let utcTiming = self.utcTiming {
            try encodeContainer.encode(utcTiming.rawValue, forKey: .utcTiming)
        }
        if let utcTimingUri = self.utcTimingUri {
            try encodeContainer.encode(utcTimingUri, forKey: .utcTimingUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[MediaPackageClientTypes.__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [MediaPackageClientTypes.__AdTriggersElement]()
            for enum0 in adTriggersContainer {
                if let enum0 = enum0 {
                    adTriggersDecoded0?.append(enum0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestLayoutDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.ManifestLayout.self, forKey: .manifestLayout)
        manifestLayout = manifestLayoutDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let minUpdatePeriodSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUpdatePeriodSeconds)
        minUpdatePeriodSeconds = minUpdatePeriodSecondsDecoded
        let periodTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__PeriodTriggersElement?].self, forKey: .periodTriggers)
        var periodTriggersDecoded0:[MediaPackageClientTypes.__PeriodTriggersElement]? = nil
        if let periodTriggersContainer = periodTriggersContainer {
            periodTriggersDecoded0 = [MediaPackageClientTypes.__PeriodTriggersElement]()
            for enum0 in periodTriggersContainer {
                if let enum0 = enum0 {
                    periodTriggersDecoded0?.append(enum0)
                }
            }
        }
        periodTriggers = periodTriggersDecoded0
        let profileDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Profile.self, forKey: .profile)
        profile = profileDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentTemplateFormatDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SegmentTemplateFormat.self, forKey: .segmentTemplateFormat)
        segmentTemplateFormat = segmentTemplateFormatDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
        let suggestedPresentationDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .suggestedPresentationDelaySeconds)
        suggestedPresentationDelaySeconds = suggestedPresentationDelaySecondsDecoded
        let utcTimingDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.UtcTiming.self, forKey: .utcTiming)
        utcTiming = utcTimingDecoded
        let utcTimingUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utcTimingUri)
        utcTimingUri = utcTimingUriDecoded
    }
}

extension MediaPackageClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public struct DashPackage: Swift.Equatable {
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
        public var encryption: MediaPackageClientTypes.DashEncryption?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// Determines the position of some tags in the Media Presentation Description (MPD). When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation. When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public var manifestLayout: MediaPackageClientTypes.ManifestLayout?
        /// Time window (in seconds) contained in each manifest.
        public var manifestWindowSeconds: Swift.Int?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public var minBufferTimeSeconds: Swift.Int?
        /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
        public var minUpdatePeriodSeconds: Swift.Int?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Channel source contains SCTE-35 ad markers.
        public var periodTriggers: [MediaPackageClientTypes.__PeriodTriggersElement]?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type. When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled. When set to "DVB-DASH_2014", DVB-DASH 2014 compliant output is enabled.
        public var profile: MediaPackageClientTypes.Profile?
        /// Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD). When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs. When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public var segmentTemplateFormat: MediaPackageClientTypes.SegmentTemplateFormat?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?
        /// Duration (in seconds) to delay live content before presentation.
        public var suggestedPresentationDelaySeconds: Swift.Int?
        /// Determines the type of UTCTiming included in the Media Presentation Description (MPD)
        public var utcTiming: MediaPackageClientTypes.UtcTiming?
        /// Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO, HTTP-HEAD or HTTP-XSDATE
        public var utcTimingUri: Swift.String?

        public init(
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            encryption: MediaPackageClientTypes.DashEncryption? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestLayout: MediaPackageClientTypes.ManifestLayout? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            minBufferTimeSeconds: Swift.Int? = nil,
            minUpdatePeriodSeconds: Swift.Int? = nil,
            periodTriggers: [MediaPackageClientTypes.__PeriodTriggersElement]? = nil,
            profile: MediaPackageClientTypes.Profile? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentTemplateFormat: MediaPackageClientTypes.SegmentTemplateFormat? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil,
            suggestedPresentationDelaySeconds: Swift.Int? = nil,
            utcTiming: MediaPackageClientTypes.UtcTiming? = nil,
            utcTimingUri: Swift.String? = nil
        )
        {
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestLayout = manifestLayout
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.profile = profile
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
            self.streamSelection = streamSelection
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
            self.utcTiming = utcTiming
            self.utcTimingUri = utcTimingUri
        }
    }

}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ID of the Channel to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/origin_endpoints/\(id.urlPercentEncoding())"
    }
}

public struct DeleteOriginEndpointInput: Swift.Equatable {
    /// The ID of the OriginEndpoint to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteOriginEndpointInputBody: Swift.Equatable {
}

extension DeleteOriginEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOriginEndpointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The ID of a Channel.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct DescribeChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct DescribeChannelOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let description: Swift.String?
    let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    let hlsIngest: MediaPackageClientTypes.HlsIngest?
    let id: Swift.String?
    let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeHarvestJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/harvest_jobs/\(id.urlPercentEncoding())"
    }
}

public struct DescribeHarvestJobInput: Swift.Equatable {
    /// The ID of the HarvestJob.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeHarvestJobInputBody: Swift.Equatable {
}

extension DescribeHarvestJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHarvestJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeHarvestJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelId = output.channelId
            self.createdAt = output.createdAt
            self.endTime = output.endTime
            self.id = output.id
            self.originEndpointId = output.originEndpointId
            self.s3Destination = output.s3Destination
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.arn = nil
            self.channelId = nil
            self.createdAt = nil
            self.endTime = nil
            self.id = nil
            self.originEndpointId = nil
            self.s3Destination = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeHarvestJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public var arn: Swift.String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public var channelId: Swift.String?
    /// The date and time the HarvestJob was submitted.
    public var createdAt: Swift.String?
    /// The end of the time-window which will be harvested.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested.
    public var startTime: Swift.String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will include an explanation of why the HarvestJob failed.
    public var status: MediaPackageClientTypes.Status?

    public init(
        arn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil,
        status: MediaPackageClientTypes.Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeHarvestJobOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let channelId: Swift.String?
    let createdAt: Swift.String?
    let endTime: Swift.String?
    let id: Swift.String?
    let originEndpointId: Swift.String?
    let s3Destination: MediaPackageClientTypes.S3Destination?
    let startTime: Swift.String?
    let status: MediaPackageClientTypes.Status?
}

extension DescribeHarvestJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum DescribeHarvestJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/origin_endpoints/\(id.urlPercentEncoding())"
    }
}

public struct DescribeOriginEndpointInput: Swift.Equatable {
    /// The ID of the OriginEndpoint.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeOriginEndpointInputBody: Swift.Equatable {
}

extension DescribeOriginEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOriginEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.createdAt = output.createdAt
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.createdAt = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
            self.timeDelaySeconds = nil
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct DescribeOriginEndpointOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// The date and time the OriginEndpoint was created.
    public var createdAt: Swift.String?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        createdAt: Swift.String? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.createdAt = createdAt
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct DescribeOriginEndpointOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let authorization: MediaPackageClientTypes.Authorization?
    let channelId: Swift.String?
    let cmafPackage: MediaPackageClientTypes.CmafPackage?
    let createdAt: Swift.String?
    let dashPackage: MediaPackageClientTypes.DashPackage?
    let description: Swift.String?
    let hlsPackage: MediaPackageClientTypes.HlsPackage?
    let id: Swift.String?
    let manifestName: Swift.String?
    let mssPackage: MediaPackageClientTypes.MssPackage?
    let origination: MediaPackageClientTypes.Origination?
    let startoverWindowSeconds: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let timeDelaySeconds: Swift.Int?
    let url: Swift.String?
    let whitelist: [Swift.String]?
}

extension DescribeOriginEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case createdAt = "createdAt"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

enum DescribeOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageClientTypes.EgressAccessLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension MediaPackageClientTypes {
    /// Configure egress access logging.
    public struct EgressAccessLogs: Swift.Equatable {
        /// Customize the log group name.
        public var logGroupName: Swift.String?

        public init(
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension MediaPackageClientTypes.EncryptionContractConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case presetSpeke20Audio = "presetSpeke20Audio"
        case presetSpeke20Video = "presetSpeke20Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presetSpeke20Audio = self.presetSpeke20Audio {
            try encodeContainer.encode(presetSpeke20Audio.rawValue, forKey: .presetSpeke20Audio)
        }
        if let presetSpeke20Video = self.presetSpeke20Video {
            try encodeContainer.encode(presetSpeke20Video.rawValue, forKey: .presetSpeke20Video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetSpeke20AudioDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PresetSpeke20Audio.self, forKey: .presetSpeke20Audio)
        presetSpeke20Audio = presetSpeke20AudioDecoded
        let presetSpeke20VideoDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PresetSpeke20Video.self, forKey: .presetSpeke20Video)
        presetSpeke20Video = presetSpeke20VideoDecoded
    }
}

extension MediaPackageClientTypes {
    /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use. Note the following considerations when using encryptionContractConfiguration: encryptionContractConfiguration can be used for DASH or CMAF endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification. You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
    public struct EncryptionContractConfiguration: Swift.Equatable {
        /// A collection of audio encryption presets.
        /// This member is required.
        public var presetSpeke20Audio: MediaPackageClientTypes.PresetSpeke20Audio?
        /// A collection of video encryption presets.
        /// This member is required.
        public var presetSpeke20Video: MediaPackageClientTypes.PresetSpeke20Video?

        public init(
            presetSpeke20Audio: MediaPackageClientTypes.PresetSpeke20Audio? = nil,
            presetSpeke20Video: MediaPackageClientTypes.PresetSpeke20Video? = nil
        )
        {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }
    }

}

extension MediaPackageClientTypes {
    public enum EncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionMethod] {
            return [
                .aes128,
                .sampleAes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionMethod(rawValue: rawValue) ?? EncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is not authorized to access the requested resource.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageClientTypes.HarvestJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originEndpointId = self.originEndpointId {
            try encodeContainer.encode(originEndpointId, forKey: .originEndpointId)
        }
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension MediaPackageClientTypes {
    /// A HarvestJob resource configuration
    public struct HarvestJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public var arn: Swift.String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public var channelId: Swift.String?
        /// The date and time the HarvestJob was submitted.
        public var createdAt: Swift.String?
        /// The end of the time-window which will be harvested.
        public var endTime: Swift.String?
        /// The ID of the HarvestJob. The ID must be unique within the region and it cannot be changed after the HarvestJob is submitted.
        public var id: Swift.String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from. This cannot be changed after the HarvestJob is submitted.
        public var originEndpointId: Swift.String?
        /// Configuration parameters for where in an S3 bucket to place the harvested content
        public var s3Destination: MediaPackageClientTypes.S3Destination?
        /// The start of the time-window which will be harvested.
        public var startTime: Swift.String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will include an explanation of why the HarvestJob failed.
        public var status: MediaPackageClientTypes.Status?

        public init(
            arn: Swift.String? = nil,
            channelId: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            endTime: Swift.String? = nil,
            id: Swift.String? = nil,
            originEndpointId: Swift.String? = nil,
            s3Destination: MediaPackageClientTypes.S3Destination? = nil,
            startTime: Swift.String? = nil,
            status: MediaPackageClientTypes.Status? = nil
        )
        {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }
    }

}

extension MediaPackageClientTypes.HlsEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case encryptionMethod = "encryptionMethod"
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case repeatExtXKey = "repeatExtXKey"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = self.encryptionMethod {
            try encodeContainer.encode(encryptionMethod.rawValue, forKey: .encryptionMethod)
        }
        if let keyRotationIntervalSeconds = self.keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let repeatExtXKey = self.repeatExtXKey {
            try encodeContainer.encode(repeatExtXKey, forKey: .repeatExtXKey)
        }
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let repeatExtXKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .repeatExtXKey)
        repeatExtXKey = repeatExtXKeyDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) encryption configuration.
    public struct HlsEncryption: Swift.Equatable {
        /// A constant initialization vector for encryption (optional). When not specified the initialization vector will be periodically rotated.
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        public var encryptionMethod: MediaPackageClientTypes.EncryptionMethod?
        /// Interval (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public var repeatExtXKey: Swift.Bool?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageClientTypes.EncryptionMethod? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            repeatExtXKey: Swift.Bool? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes.HlsIngest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestEndpoints = "ingestEndpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingestEndpoints = ingestEndpoints {
            var ingestEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ingestEndpoints)
            for ingestendpoint0 in ingestEndpoints {
                try ingestEndpointsContainer.encode(ingestendpoint0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
    }
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public struct HlsIngest: Swift.Equatable {
        /// A list of endpoints to which the source stream should be sent.
        public var ingestEndpoints: [MediaPackageClientTypes.IngestEndpoint]?

        public init(
            ingestEndpoints: [MediaPackageClientTypes.IngestEndpoint]? = nil
        )
        {
            self.ingestEndpoints = ingestEndpoints
        }
    }

}

extension MediaPackageClientTypes.HlsManifest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkers = "adMarkers"
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case id = "id"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = self.adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for __adtriggerselement0 in adTriggers {
                try adTriggersContainer.encode(__adtriggerselement0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = self.adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let includeIframeOnlyStream = self.includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playlistType = self.playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if let playlistWindowSeconds = self.playlistWindowSeconds {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let adTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[MediaPackageClientTypes.__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [MediaPackageClientTypes.__AdTriggersElement]()
            for enum0 in adTriggersContainer {
                if let enum0 = enum0 {
                    adTriggersDecoded0?.append(enum0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
    }
}

extension MediaPackageClientTypes {
    /// A HTTP Live Streaming (HLS) manifest configuration.
    public struct HlsManifest: Swift.Equatable {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        /// This member is required.
        public var id: Swift.String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public var manifestName: Swift.String?
        /// The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public var url: Swift.String?

        public init(
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            id: Swift.String? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestName: Swift.String? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            url: Swift.String? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.url = url
        }
    }

}

extension MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkers = "adMarkers"
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case id = "id"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = self.adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for __adtriggerselement0 in adTriggers {
                try adTriggersContainer.encode(__adtriggerselement0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = self.adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let includeIframeOnlyStream = self.includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playlistType = self.playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if let playlistWindowSeconds = self.playlistWindowSeconds {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let adTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[MediaPackageClientTypes.__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [MediaPackageClientTypes.__AdTriggersElement]()
            for enum0 in adTriggersContainer {
                if let enum0 = enum0 {
                    adTriggersDecoded0?.append(enum0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
    }
}

extension MediaPackageClientTypes {
    /// A HTTP Live Streaming (HLS) manifest configuration.
    public struct HlsManifestCreateOrUpdateParameters: Swift.Equatable {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        /// This member is required.
        public var id: Swift.String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public var manifestName: Swift.String?
        /// The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?

        public init(
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            id: Swift.String? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestName: Swift.String? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        }
    }

}

extension MediaPackageClientTypes.HlsPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkers = "adMarkers"
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case encryption = "encryption"
        case includeDvbSubtitles = "includeDvbSubtitles"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case streamSelection = "streamSelection"
        case useAudioRenditionGroup = "useAudioRenditionGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = self.adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for __adtriggerselement0 in adTriggers {
                try adTriggersContainer.encode(__adtriggerselement0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = self.adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let includeDvbSubtitles = self.includeDvbSubtitles {
            try encodeContainer.encode(includeDvbSubtitles, forKey: .includeDvbSubtitles)
        }
        if let includeIframeOnlyStream = self.includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let playlistType = self.playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if let playlistWindowSeconds = self.playlistWindowSeconds {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
        if let useAudioRenditionGroup = self.useAudioRenditionGroup {
            try encodeContainer.encode(useAudioRenditionGroup, forKey: .useAudioRenditionGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let adTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[MediaPackageClientTypes.__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [MediaPackageClientTypes.__AdTriggersElement]()
            for enum0 in adTriggersContainer {
                if let enum0 = enum0 {
                    adTriggersDecoded0?.append(enum0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let includeDvbSubtitlesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDvbSubtitles)
        includeDvbSubtitles = includeDvbSubtitlesDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
        let useAudioRenditionGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAudioRenditionGroup)
        useAudioRenditionGroup = useAudioRenditionGroupDecoded
    }
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public struct HlsPackage: Swift.Equatable {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output. If empty, no ad markers are output. Specify multiple items to create ad markers for all of the included message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to determine whether a message signals an ad. Choosing "NONE" means no SCTE-35 messages become ads. Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that contain delivery restrictions will be treated as ads. Choosing "UNRESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that do not contain delivery restrictions will be treated as ads. Choosing "BOTH" means all SCTE-35 messages of the types specified in AdTriggers will be treated as ads. Note that Splice Insert messages do not have these flags and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// An HTTP Live Streaming (HLS) encryption configuration.
        public var encryption: MediaPackageClientTypes.HlsEncryption?
        /// When enabled, MediaPackage passes through digital video broadcasting (DVB) subtitles into the output.
        public var includeDvbSubtitles: Swift.Bool?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public var useAudioRenditionGroup: Swift.Bool?

        public init(
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            encryption: MediaPackageClientTypes.HlsEncryption? = nil,
            includeDvbSubtitles: Swift.Bool? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil,
            useAudioRenditionGroup: Swift.Bool? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.includeDvbSubtitles = includeDvbSubtitles
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }
    }

}

extension MediaPackageClientTypes.IngestEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case password = "password"
        case url = "url"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MediaPackageClientTypes.IngestEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IngestEndpoint(id: \(Swift.String(describing: id)), url: \(Swift.String(describing: url)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension MediaPackageClientTypes {
    /// An endpoint for ingesting source content for a Channel.
    public struct IngestEndpoint: Swift.Equatable {
        /// The system generated unique identifier for the IngestEndpoint
        public var id: Swift.String?
        /// The system generated password for ingest authentication.
        public var password: Swift.String?
        /// The ingest URL to which the source stream should be sent.
        public var url: Swift.String?
        /// The system generated username for ingest authentication.
        public var username: Swift.String?

        public init(
            id: Swift.String? = nil,
            password: Swift.String? = nil,
            url: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.id = id
            self.password = password
            self.url = url
            self.username = username
        }
    }

}

extension MediaPackageClientTypes.IngressAccessLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension MediaPackageClientTypes {
    /// Configure ingress access logging.
    public struct IngressAccessLogs: Swift.Equatable {
        /// Customize the log group name.
        public var logGroupName: Swift.String?

        public init(
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutput: Swift.Equatable {
    /// A list of Channel records.
    public var channels: [MediaPackageClientTypes.Channel]?
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?

    public init(
        channels: [MediaPackageClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputBody: Swift.Equatable {
    let channels: [MediaPackageClientTypes.Channel]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "channels"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[MediaPackageClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [MediaPackageClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListHarvestJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let includeChannelId = includeChannelId {
                let includeChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "includeChannelId".urlPercentEncoding(), value: Swift.String(includeChannelId).urlPercentEncoding())
                items.append(includeChannelIdQueryItem)
            }
            if let includeStatus = includeStatus {
                let includeStatusQueryItem = ClientRuntime.URLQueryItem(name: "includeStatus".urlPercentEncoding(), value: Swift.String(includeStatus).urlPercentEncoding())
                items.append(includeStatusQueryItem)
            }
            return items
        }
    }
}

extension ListHarvestJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/harvest_jobs"
    }
}

public struct ListHarvestJobsInput: Swift.Equatable {
    /// When specified, the request will return only HarvestJobs associated with the given Channel ID.
    public var includeChannelId: Swift.String?
    /// When specified, the request will return only HarvestJobs in the given status.
    public var includeStatus: Swift.String?
    /// The upper bound on the number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init(
        includeChannelId: Swift.String? = nil,
        includeStatus: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeChannelId = includeChannelId
        self.includeStatus = includeStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHarvestJobsInputBody: Swift.Equatable {
}

extension ListHarvestJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListHarvestJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListHarvestJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.harvestJobs = output.harvestJobs
            self.nextToken = output.nextToken
        } else {
            self.harvestJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListHarvestJobsOutput: Swift.Equatable {
    /// A list of HarvestJob records.
    public var harvestJobs: [MediaPackageClientTypes.HarvestJob]?
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?

    public init(
        harvestJobs: [MediaPackageClientTypes.HarvestJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.harvestJobs = harvestJobs
        self.nextToken = nextToken
    }
}

struct ListHarvestJobsOutputBody: Swift.Equatable {
    let harvestJobs: [MediaPackageClientTypes.HarvestJob]?
    let nextToken: Swift.String?
}

extension ListHarvestJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case harvestJobs = "harvestJobs"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let harvestJobsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.HarvestJob?].self, forKey: .harvestJobs)
        var harvestJobsDecoded0:[MediaPackageClientTypes.HarvestJob]? = nil
        if let harvestJobsContainer = harvestJobsContainer {
            harvestJobsDecoded0 = [MediaPackageClientTypes.HarvestJob]()
            for structure0 in harvestJobsContainer {
                if let structure0 = structure0 {
                    harvestJobsDecoded0?.append(structure0)
                }
            }
        }
        harvestJobs = harvestJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListHarvestJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOriginEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let channelId = channelId {
                let channelIdQueryItem = ClientRuntime.URLQueryItem(name: "channelId".urlPercentEncoding(), value: Swift.String(channelId).urlPercentEncoding())
                items.append(channelIdQueryItem)
            }
            return items
        }
    }
}

extension ListOriginEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/origin_endpoints"
    }
}

public struct ListOriginEndpointsInput: Swift.Equatable {
    /// When specified, the request will return only OriginEndpoints associated with the given Channel ID.
    public var channelId: Swift.String?
    /// The upper bound on the number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init(
        channelId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOriginEndpointsInputBody: Swift.Equatable {
}

extension ListOriginEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOriginEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.originEndpoints = output.originEndpoints
        } else {
            self.nextToken = nil
            self.originEndpoints = nil
        }
    }
}

public struct ListOriginEndpointsOutput: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?
    /// A list of OriginEndpoint records.
    public var originEndpoints: [MediaPackageClientTypes.OriginEndpoint]?

    public init(
        nextToken: Swift.String? = nil,
        originEndpoints: [MediaPackageClientTypes.OriginEndpoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.originEndpoints = originEndpoints
    }
}

struct ListOriginEndpointsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let originEndpoints: [MediaPackageClientTypes.OriginEndpoint]?
}

extension ListOriginEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case originEndpoints = "originEndpoints"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let originEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.OriginEndpoint?].self, forKey: .originEndpoints)
        var originEndpointsDecoded0:[MediaPackageClientTypes.OriginEndpoint]? = nil
        if let originEndpointsContainer = originEndpointsContainer {
            originEndpointsDecoded0 = [MediaPackageClientTypes.OriginEndpoint]()
            for structure0 in originEndpointsContainer {
                if let structure0 = structure0 {
                    originEndpointsDecoded0?.append(structure0)
                }
            }
        }
        originEndpoints = originEndpointsDecoded0
    }
}

enum ListOriginEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageClientTypes {
    public enum ManifestLayout: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compact
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [ManifestLayout] {
            return [
                .compact,
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compact: return "COMPACT"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManifestLayout(rawValue: rawValue) ?? ManifestLayout.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes.MssEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes {
    /// A Microsoft Smooth Streaming (MSS) encryption configuration.
    public struct MssEncryption: Swift.Equatable {
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init(
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes.MssPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case manifestWindowSeconds = "manifestWindowSeconds"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageClientTypes {
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public struct MssPackage: Swift.Equatable {
        /// A Microsoft Smooth Streaming (MSS) encryption configuration.
        public var encryption: MediaPackageClientTypes.MssEncryption?
        /// The time window (in seconds) contained in each manifest.
        public var manifestWindowSeconds: Swift.Int?
        /// The duration (in seconds) of each segment.
        public var segmentDurationSeconds: Swift.Int?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init(
            encryption: MediaPackageClientTypes.MssEncryption? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.manifestWindowSeconds = manifestWindowSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource does not exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageClientTypes.OriginEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case createdAt = "createdAt"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authorization = self.authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let cmafPackage = self.cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let dashPackage = self.dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = self.hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = self.mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = self.origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if let startoverWindowSeconds = self.startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeDelaySeconds = self.timeDelaySeconds {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __string0 in whitelist {
                try whitelistContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension MediaPackageClientTypes {
    /// An OriginEndpoint resource configuration.
    public struct OriginEndpoint: Swift.Equatable {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public var arn: Swift.String?
        /// CDN Authorization credentials
        public var authorization: MediaPackageClientTypes.Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public var channelId: Swift.String?
        /// A Common Media Application Format (CMAF) packaging configuration.
        public var cmafPackage: MediaPackageClientTypes.CmafPackage?
        /// The date and time the OriginEndpoint was created.
        public var createdAt: Swift.String?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
        public var dashPackage: MediaPackageClientTypes.DashPackage?
        /// A short text description of the OriginEndpoint.
        public var description: Swift.String?
        /// An HTTP Live Streaming (HLS) packaging configuration.
        public var hlsPackage: MediaPackageClientTypes.HlsPackage?
        /// The ID of the OriginEndpoint.
        public var id: Swift.String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public var manifestName: Swift.String?
        /// A Microsoft Smooth Streaming (MSS) packaging configuration.
        public var mssPackage: MediaPackageClientTypes.MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public var origination: MediaPackageClientTypes.Origination?
        /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
        public var startoverWindowSeconds: Swift.Int?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String:Swift.String]?
        /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
        public var timeDelaySeconds: Swift.Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public var url: Swift.String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public var whitelist: [Swift.String]?

        public init(
            arn: Swift.String? = nil,
            authorization: MediaPackageClientTypes.Authorization? = nil,
            channelId: Swift.String? = nil,
            cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
            createdAt: Swift.String? = nil,
            dashPackage: MediaPackageClientTypes.DashPackage? = nil,
            description: Swift.String? = nil,
            hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
            id: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            mssPackage: MediaPackageClientTypes.MssPackage? = nil,
            origination: MediaPackageClientTypes.Origination? = nil,
            startoverWindowSeconds: Swift.Int? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeDelaySeconds: Swift.Int? = nil,
            url: Swift.String? = nil,
            whitelist: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }
    }

}

extension MediaPackageClientTypes {
    public enum Origination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [Origination] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Origination(rawValue: rawValue) ?? Origination.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum PlaylistType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case `none`
        case vod
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaylistType] {
            return [
                .event,
                .none,
                .vod,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .none: return "NONE"
            case .vod: return "VOD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlaylistType(rawValue: rawValue) ?? PlaylistType.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum PresetSpeke20Audio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetAudio1
        case presetAudio2
        case presetAudio3
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Audio] {
            return [
                .presetAudio1,
                .presetAudio2,
                .presetAudio3,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetAudio1: return "PRESET-AUDIO-1"
            case .presetAudio2: return "PRESET-AUDIO-2"
            case .presetAudio3: return "PRESET-AUDIO-3"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Audio(rawValue: rawValue) ?? PresetSpeke20Audio.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum PresetSpeke20Video: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetVideo1
        case presetVideo2
        case presetVideo3
        case presetVideo4
        case presetVideo5
        case presetVideo6
        case presetVideo7
        case presetVideo8
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Video] {
            return [
                .presetVideo1,
                .presetVideo2,
                .presetVideo3,
                .presetVideo4,
                .presetVideo5,
                .presetVideo6,
                .presetVideo7,
                .presetVideo8,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetVideo1: return "PRESET-VIDEO-1"
            case .presetVideo2: return "PRESET-VIDEO-2"
            case .presetVideo3: return "PRESET-VIDEO-3"
            case .presetVideo4: return "PRESET-VIDEO-4"
            case .presetVideo5: return "PRESET-VIDEO-5"
            case .presetVideo6: return "PRESET-VIDEO-6"
            case .presetVideo7: return "PRESET-VIDEO-7"
            case .presetVideo8: return "PRESET-VIDEO-8"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Video(rawValue: rawValue) ?? PresetSpeke20Video.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum Profile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dvbDash2014
        case hbbtv15
        case hybridcast
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Profile] {
            return [
                .dvbDash2014,
                .hbbtv15,
                .hybridcast,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dvbDash2014: return "DVB_DASH_2014"
            case .hbbtv15: return "HBBTV_1_5"
            case .hybridcast: return "HYBRIDCAST"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Profile(rawValue: rawValue) ?? Profile.sdkUnknown(rawValue)
        }
    }
}

extension RotateChannelCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())/credentials"
    }
}

@available(*, deprecated)
public struct RotateChannelCredentialsInput: Swift.Equatable {
    /// The ID of the channel to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct RotateChannelCredentialsInputBody: Swift.Equatable {
}

extension RotateChannelCredentialsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RotateChannelCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RotateChannelCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated)
public struct RotateChannelCredentialsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct RotateChannelCredentialsOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let description: Swift.String?
    let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    let hlsIngest: MediaPackageClientTypes.HlsIngest?
    let id: Swift.String?
    let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    let tags: [Swift.String:Swift.String]?
}

extension RotateChannelCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum RotateChannelCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RotateIngestEndpointCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let ingestEndpointId = ingestEndpointId else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())/ingest_endpoints/\(ingestEndpointId.urlPercentEncoding())/credentials"
    }
}

public struct RotateIngestEndpointCredentialsInput: Swift.Equatable {
    /// The ID of the channel the IngestEndpoint is on.
    /// This member is required.
    public var id: Swift.String?
    /// The id of the IngestEndpoint whose credentials should be rotated
    /// This member is required.
    public var ingestEndpointId: Swift.String?

    public init(
        id: Swift.String? = nil,
        ingestEndpointId: Swift.String? = nil
    )
    {
        self.id = id
        self.ingestEndpointId = ingestEndpointId
    }
}

struct RotateIngestEndpointCredentialsInputBody: Swift.Equatable {
}

extension RotateIngestEndpointCredentialsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RotateIngestEndpointCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RotateIngestEndpointCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct RotateIngestEndpointCredentialsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct RotateIngestEndpointCredentialsOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let description: Swift.String?
    let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    let hlsIngest: MediaPackageClientTypes.HlsIngest?
    let id: Swift.String?
    let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    let tags: [Swift.String:Swift.String]?
}

extension RotateIngestEndpointCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum RotateIngestEndpointCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case manifestKey = "manifestKey"
        case roleArn = "roleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let manifestKey = self.manifestKey {
            try encodeContainer.encode(manifestKey, forKey: .manifestKey)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let manifestKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestKey)
        manifestKey = manifestKeyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension MediaPackageClientTypes {
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public struct S3Destination: Swift.Equatable {
        /// The name of an S3 bucket within which harvested content will be exported
        /// This member is required.
        public var bucketName: Swift.String?
        /// The key in the specified S3 bucket where the harvested top-level manifest will be placed.
        /// This member is required.
        public var manifestKey: Swift.String?
        /// The IAM role used to write to the specified S3 bucket
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            manifestKey: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.manifestKey = manifestKey
            self.roleArn = roleArn
        }
    }

}

extension MediaPackageClientTypes {
    public enum SegmentTemplateFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case numberWithDuration
        case numberWithTimeline
        case timeWithTimeline
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentTemplateFormat] {
            return [
                .numberWithDuration,
                .numberWithTimeline,
                .timeWithTimeline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .numberWithDuration: return "NUMBER_WITH_DURATION"
            case .numberWithTimeline: return "NUMBER_WITH_TIMELINE"
            case .timeWithTimeline: return "TIME_WITH_TIMELINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SegmentTemplateFormat(rawValue: rawValue) ?? SegmentTemplateFormat.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageClientTypes.SpekeKeyProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "certificateArn"
        case encryptionContractConfiguration = "encryptionContractConfiguration"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case systemIds = "systemIds"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let encryptionContractConfiguration = self.encryptionContractConfiguration {
            try encodeContainer.encode(encryptionContractConfiguration, forKey: .encryptionContractConfiguration)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let systemIds = systemIds {
            var systemIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemIds)
            for __string0 in systemIds {
                try systemIdsContainer.encode(__string0)
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let encryptionContractConfigurationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EncryptionContractConfiguration.self, forKey: .encryptionContractConfiguration)
        encryptionContractConfiguration = encryptionContractConfigurationDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let systemIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .systemIds)
        var systemIdsDecoded0:[Swift.String]? = nil
        if let systemIdsContainer = systemIdsContainer {
            systemIdsDecoded0 = [Swift.String]()
            for string0 in systemIdsContainer {
                if let string0 = string0 {
                    systemIdsDecoded0?.append(string0)
                }
            }
        }
        systemIds = systemIdsDecoded0
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageClientTypes {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public struct SpekeKeyProvider: Swift.Equatable {
        /// An Amazon Resource Name (ARN) of a Certificate Manager certificate that MediaPackage will use for enforcing secure end-to-end data transfer with the key provider service.
        public var certificateArn: Swift.String?
        /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use. Note the following considerations when using encryptionContractConfiguration: encryptionContractConfiguration can be used for DASH or CMAF endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification. You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
        public var encryptionContractConfiguration: MediaPackageClientTypes.EncryptionContractConfiguration?
        /// The resource ID to include in key requests.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental MediaPackage will assume when accessing the key provider service.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The system IDs to include in key requests.
        /// This member is required.
        public var systemIds: [Swift.String]?
        /// The URL of the external key provider service.
        /// This member is required.
        public var url: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            encryptionContractConfiguration: MediaPackageClientTypes.EncryptionContractConfiguration? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            systemIds: [Swift.String]? = nil,
            url: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }
    }

}

extension MediaPackageClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum StreamOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case original
        case videoBitrateAscending
        case videoBitrateDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamOrder] {
            return [
                .original,
                .videoBitrateAscending,
                .videoBitrateDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .original: return "ORIGINAL"
            case .videoBitrateAscending: return "VIDEO_BITRATE_ASCENDING"
            case .videoBitrateDescending: return "VIDEO_BITRATE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamOrder(rawValue: rawValue) ?? StreamOrder.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes.StreamSelection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
        case minVideoBitsPerSecond = "minVideoBitsPerSecond"
        case streamOrder = "streamOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxVideoBitsPerSecond = self.maxVideoBitsPerSecond {
            try encodeContainer.encode(maxVideoBitsPerSecond, forKey: .maxVideoBitsPerSecond)
        }
        if let minVideoBitsPerSecond = self.minVideoBitsPerSecond {
            try encodeContainer.encode(minVideoBitsPerSecond, forKey: .minVideoBitsPerSecond)
        }
        if let streamOrder = self.streamOrder {
            try encodeContainer.encode(streamOrder.rawValue, forKey: .streamOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxVideoBitsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVideoBitsPerSecond)
        maxVideoBitsPerSecond = maxVideoBitsPerSecondDecoded
        let minVideoBitsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minVideoBitsPerSecond)
        minVideoBitsPerSecond = minVideoBitsPerSecondDecoded
        let streamOrderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamOrder.self, forKey: .streamOrder)
        streamOrder = streamOrderDecoded
    }
}

extension MediaPackageClientTypes {
    /// A StreamSelection configuration.
    public struct StreamSelection: Swift.Equatable {
        /// The maximum video bitrate (bps) to include in output.
        public var maxVideoBitsPerSecond: Swift.Int?
        /// The minimum video bitrate (bps) to include in output.
        public var minVideoBitsPerSecond: Swift.Int?
        /// A directive that determines the order of streams in the output.
        public var streamOrder: MediaPackageClientTypes.StreamOrder?

        public init(
            maxVideoBitsPerSecond: Swift.Int? = nil,
            minVideoBitsPerSecond: Swift.Int? = nil,
            streamOrder: MediaPackageClientTypes.StreamOrder? = nil
        )
        {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// This member is required.
    public var resourceArn: Swift.String?
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client has exceeded their resource or throttling limits.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The parameters sent in the request are not valid.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key(s) of tag to be deleted
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

/// Configuration parameters used to update the Channel.
public struct UpdateChannelInput: Swift.Equatable {
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// The ID of the Channel to update.
    /// This member is required.
    public var id: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// The date and time the Channel was created.
    public var createdAt: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct UpdateChannelOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let description: Swift.String?
    let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    let hlsIngest: MediaPackageClientTypes.HlsIngest?
    let id: Swift.String?
    let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateOriginEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = self.authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let cmafPackage = self.cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = self.dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = self.hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = self.mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = self.origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if let startoverWindowSeconds = self.startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let timeDelaySeconds = self.timeDelaySeconds {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __string0 in whitelist {
                try whitelistContainer.encode(__string0)
            }
        }
    }
}

extension UpdateOriginEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/origin_endpoints/\(id.urlPercentEncoding())"
    }
}

/// Configuration parameters used to update an existing OriginEndpoint.
public struct UpdateOriginEndpointInput: Swift.Equatable {
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint to update.
    /// This member is required.
    public var id: Swift.String?
    /// A short string that will be appended to the end of the Endpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (in seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// Amount of delay (in seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        authorization: MediaPackageClientTypes.Authorization? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.authorization = authorization
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

struct UpdateOriginEndpointInputBody: Swift.Equatable {
    let authorization: MediaPackageClientTypes.Authorization?
    let cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    let dashPackage: MediaPackageClientTypes.DashPackage?
    let description: Swift.String?
    let hlsPackage: MediaPackageClientTypes.HlsPackage?
    let manifestName: Swift.String?
    let mssPackage: MediaPackageClientTypes.MssPackage?
    let origination: MediaPackageClientTypes.Origination?
    let startoverWindowSeconds: Swift.Int?
    let timeDelaySeconds: Swift.Int?
    let whitelist: [Swift.String]?
}

extension UpdateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension UpdateOriginEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateOriginEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.createdAt = output.createdAt
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.createdAt = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
            self.timeDelaySeconds = nil
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct UpdateOriginEndpointOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// The date and time the OriginEndpoint was created.
    public var createdAt: Swift.String?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback. If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content. If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        createdAt: Swift.String? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.createdAt = createdAt
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct UpdateOriginEndpointOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let authorization: MediaPackageClientTypes.Authorization?
    let channelId: Swift.String?
    let cmafPackage: MediaPackageClientTypes.CmafPackage?
    let createdAt: Swift.String?
    let dashPackage: MediaPackageClientTypes.DashPackage?
    let description: Swift.String?
    let hlsPackage: MediaPackageClientTypes.HlsPackage?
    let id: Swift.String?
    let manifestName: Swift.String?
    let mssPackage: MediaPackageClientTypes.MssPackage?
    let origination: MediaPackageClientTypes.Origination?
    let startoverWindowSeconds: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let timeDelaySeconds: Swift.Int?
    let url: Swift.String?
    let whitelist: [Swift.String]?
}

extension UpdateOriginEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case createdAt = "createdAt"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

enum UpdateOriginEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MediaPackageClientTypes {
    public enum UtcTiming: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpHead
        case httpIso
        case httpXsdate
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [UtcTiming] {
            return [
                .httpHead,
                .httpIso,
                .httpXsdate,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpHead: return "HTTP-HEAD"
            case .httpIso: return "HTTP-ISO"
            case .httpXsdate: return "HTTP-XSDATE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UtcTiming(rawValue: rawValue) ?? UtcTiming.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum __AdTriggersElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `break`
        case distributorAdvertisement
        case distributorOverlayPlacementOpportunity
        case distributorPlacementOpportunity
        case providerAdvertisement
        case providerOverlayPlacementOpportunity
        case providerPlacementOpportunity
        case spliceInsert
        case sdkUnknown(Swift.String)

        public static var allCases: [__AdTriggersElement] {
            return [
                .break,
                .distributorAdvertisement,
                .distributorOverlayPlacementOpportunity,
                .distributorPlacementOpportunity,
                .providerAdvertisement,
                .providerOverlayPlacementOpportunity,
                .providerPlacementOpportunity,
                .spliceInsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .break: return "BREAK"
            case .distributorAdvertisement: return "DISTRIBUTOR_ADVERTISEMENT"
            case .distributorOverlayPlacementOpportunity: return "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .distributorPlacementOpportunity: return "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
            case .providerAdvertisement: return "PROVIDER_ADVERTISEMENT"
            case .providerOverlayPlacementOpportunity: return "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .providerPlacementOpportunity: return "PROVIDER_PLACEMENT_OPPORTUNITY"
            case .spliceInsert: return "SPLICE_INSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = __AdTriggersElement(rawValue: rawValue) ?? __AdTriggersElement.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum __PeriodTriggersElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ads
        case sdkUnknown(Swift.String)

        public static var allCases: [__PeriodTriggersElement] {
            return [
                .ads,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ADS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = __PeriodTriggersElement(rawValue: rawValue) ?? __PeriodTriggersElement.sdkUnknown(rawValue)
        }
    }
}
