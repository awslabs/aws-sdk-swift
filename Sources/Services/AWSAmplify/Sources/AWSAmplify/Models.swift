//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// A request contains unexpected data.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An operation failed because a dependent service threw an exception.
public struct DependentServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependentServiceFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service failed to perform an operation due to an internal issue.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A resource could not be created because service quotas were exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An operation failed due to a lack of access.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AmplifyClientTypes {

    public enum Stage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beta
        case development
        case experimental
        case production
        case pullRequest
        case sdkUnknown(Swift.String)

        public static var allCases: [Stage] {
            return [
                .beta,
                .development,
                .experimental,
                .production,
                .pullRequest
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beta: return "BETA"
            case .development: return "DEVELOPMENT"
            case .experimental: return "EXPERIMENTAL"
            case .production: return "PRODUCTION"
            case .pullRequest: return "PULL_REQUEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    /// Describes the automated branch creation configuration.
    public struct AutoBranchCreationConfig: Swift.Sendable {
        /// The basic authorization credentials for the autocreated branch. You must base64-encode the authorization credentials and provide them in the format user:password.
        public var basicAuthCredentials: Swift.String?
        /// The build specification (build spec) for the autocreated branch.
        public var buildSpec: Swift.String?
        /// Enables auto building for the autocreated branch.
        public var enableAutoBuild: Swift.Bool?
        /// Enables basic authorization for the autocreated branch.
        public var enableBasicAuth: Swift.Bool?
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public var enablePerformanceMode: Swift.Bool?
        /// Enables pull request previews for the autocreated branch.
        public var enablePullRequestPreview: Swift.Bool?
        /// The environment variables for the autocreated branch.
        public var environmentVariables: [Swift.String: Swift.String]?
        /// The framework for the autocreated branch.
        public var framework: Swift.String?
        /// The Amplify environment name for the pull request.
        public var pullRequestEnvironmentName: Swift.String?
        /// Describes the current stage for the autocreated branch.
        public var stage: AmplifyClientTypes.Stage?

        public init(
            basicAuthCredentials: Swift.String? = nil,
            buildSpec: Swift.String? = nil,
            enableAutoBuild: Swift.Bool? = nil,
            enableBasicAuth: Swift.Bool? = nil,
            enablePerformanceMode: Swift.Bool? = nil,
            enablePullRequestPreview: Swift.Bool? = nil,
            environmentVariables: [Swift.String: Swift.String]? = nil,
            framework: Swift.String? = nil,
            pullRequestEnvironmentName: Swift.String? = nil,
            stage: AmplifyClientTypes.Stage? = nil
        )
        {
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.stage = stage
        }
    }
}

extension AmplifyClientTypes.AutoBranchCreationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoBranchCreationConfig(enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), stage: \(Swift.String(describing: stage)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

extension AmplifyClientTypes {

    public enum CacheConfigType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amplifyManaged
        case amplifyManagedNoCookies
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheConfigType] {
            return [
                .amplifyManaged,
                .amplifyManagedNoCookies
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amplifyManaged: return "AMPLIFY_MANAGED"
            case .amplifyManagedNoCookies: return "AMPLIFY_MANAGED_NO_COOKIES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    /// Describes the cache configuration for an Amplify app. For more information about how Amplify applies an optimal cache configuration for your app based on the type of content that is being served, see [Managing cache configuration](https://docs.aws.amazon.com/amplify/latest/userguide/managing-cache-configuration) in the Amplify User guide.
    public struct CacheConfig: Swift.Sendable {
        /// The type of cache configuration to use for an Amplify app. The AMPLIFY_MANAGED cache configuration automatically applies an optimized cache configuration for your app based on its platform, routing rules, and rewrite rules. This is the default setting. The AMPLIFY_MANAGED_NO_COOKIES cache configuration type is the same as AMPLIFY_MANAGED, except that it excludes all cookies from the cache key.
        /// This member is required.
        public var type: AmplifyClientTypes.CacheConfigType?

        public init(
            type: AmplifyClientTypes.CacheConfigType? = nil
        )
        {
            self.type = type
        }
    }
}

extension AmplifyClientTypes {

    /// Describes a custom rewrite or redirect rule.
    public struct CustomRule: Swift.Sendable {
        /// The condition for a URL rewrite or redirect rule, such as a country code.
        public var condition: Swift.String?
        /// The source pattern for a URL rewrite or redirect rule.
        /// This member is required.
        public var source: Swift.String?
        /// The status code for a URL rewrite or redirect rule. 200 Represents a 200 rewrite rule. 301 Represents a 301 (moved permanently) redirect rule. This and all future requests should be directed to the target URL. 302 Represents a 302 temporary redirect rule. 404 Represents a 404 redirect rule. 404-200 Represents a 404 rewrite rule.
        public var status: Swift.String?
        /// The target pattern for a URL rewrite or redirect rule.
        /// This member is required.
        public var target: Swift.String?

        public init(
            condition: Swift.String? = nil,
            source: Swift.String? = nil,
            status: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.condition = condition
            self.source = source
            self.status = status
            self.target = target
        }
    }
}

extension AmplifyClientTypes {

    public enum Platform: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case web
        case webCompute
        case webDynamic
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .web,
                .webCompute,
                .webDynamic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .web: return "WEB"
            case .webCompute: return "WEB_COMPUTE"
            case .webDynamic: return "WEB_DYNAMIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request structure used to create apps in Amplify.
public struct CreateAppInput: Swift.Sendable {
    /// The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use accessToken for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use oauthToken. You must specify either accessToken or oauthToken when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var accessToken: Swift.String?
    /// The automated branch creation configuration for an Amplify app.
    public var autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
    /// The automated branch creation glob patterns for an Amplify app.
    public var autoBranchCreationPatterns: [Swift.String]?
    /// The credentials for basic authorization for an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The build specification (build spec) for an Amplify app.
    public var buildSpec: Swift.String?
    /// The cache configuration for the Amplify app.
    public var cacheConfig: AmplifyClientTypes.CacheConfig?
    /// The custom HTTP headers for an Amplify app.
    public var customHeaders: Swift.String?
    /// The custom rewrite and redirect rules for an Amplify app.
    public var customRules: [AmplifyClientTypes.CustomRule]?
    /// The description of the Amplify app.
    public var description: Swift.String?
    /// Enables automated branch creation for an Amplify app.
    public var enableAutoBranchCreation: Swift.Bool?
    /// Enables basic authorization for an Amplify app. This will apply to all branches that are part of this app.
    public var enableBasicAuth: Swift.Bool?
    /// Enables the auto building of branches for an Amplify app.
    public var enableBranchAutoBuild: Swift.Bool?
    /// Automatically disconnects a branch in the Amplify console when you delete a branch from your Git repository.
    public var enableBranchAutoDeletion: Swift.Bool?
    /// The environment variables map for an Amplify app. For a list of the environment variables that are accessible to Amplify by default, see [Amplify Environment variables](https://docs.aws.amazon.com/amplify/latest/userguide/amplify-console-environment-variables.html) in the Amplify Hosting User Guide.
    public var environmentVariables: [Swift.String: Swift.String]?
    /// The AWS Identity and Access Management (IAM) service role for an Amplify app.
    public var iamServiceRoleArn: Swift.String?
    /// The name of the Amplify app.
    /// This member is required.
    public var name: Swift.String?
    /// The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use oauthToken for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use accessToken. You must specify either oauthToken or accessToken when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var oauthToken: Swift.String?
    /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC. If you are deploying an SSG only app with Next.js version 14 or later, you must set the platform type to WEB_COMPUTE and set the artifacts baseDirectory to .next in the application's build settings. For an example of the build specification settings, see [Amplify build settings for a Next.js 14 SSG application](https://docs.aws.amazon.com/amplify/latest/userguide/deploy-nextjs-app.html#build-setting-detection-ssg-14) in the Amplify Hosting User Guide.
    public var platform: AmplifyClientTypes.Platform?
    /// The Git repository for the Amplify app.
    public var repository: Swift.String?
    /// The tag for an Amplify app.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessToken: Swift.String? = nil,
        autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig? = nil,
        autoBranchCreationPatterns: [Swift.String]? = nil,
        basicAuthCredentials: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        cacheConfig: AmplifyClientTypes.CacheConfig? = nil,
        customHeaders: Swift.String? = nil,
        customRules: [AmplifyClientTypes.CustomRule]? = nil,
        description: Swift.String? = nil,
        enableAutoBranchCreation: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableBranchAutoBuild: Swift.Bool? = nil,
        enableBranchAutoDeletion: Swift.Bool? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil,
        iamServiceRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        oauthToken: Swift.String? = nil,
        platform: AmplifyClientTypes.Platform? = nil,
        repository: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessToken = accessToken
        self.autoBranchCreationConfig = autoBranchCreationConfig
        self.autoBranchCreationPatterns = autoBranchCreationPatterns
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.cacheConfig = cacheConfig
        self.customHeaders = customHeaders
        self.customRules = customRules
        self.description = description
        self.enableAutoBranchCreation = enableAutoBranchCreation
        self.enableBasicAuth = enableBasicAuth
        self.enableBranchAutoBuild = enableBranchAutoBuild
        self.enableBranchAutoDeletion = enableBranchAutoDeletion
        self.environmentVariables = environmentVariables
        self.iamServiceRoleArn = iamServiceRoleArn
        self.name = name
        self.oauthToken = oauthToken
        self.platform = platform
        self.repository = repository
        self.tags = tags
    }
}

extension CreateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInput(autoBranchCreationConfig: \(Swift.String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(Swift.String(describing: autoBranchCreationPatterns)), cacheConfig: \(Swift.String(describing: cacheConfig)), customHeaders: \(Swift.String(describing: customHeaders)), customRules: \(Swift.String(describing: customRules)), description: \(Swift.String(describing: description)), enableAutoBranchCreation: \(Swift.String(describing: enableAutoBranchCreation)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableBranchAutoBuild: \(Swift.String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(Swift.String(describing: enableBranchAutoDeletion)), environmentVariables: \(Swift.String(describing: environmentVariables)), iamServiceRoleArn: \(Swift.String(describing: iamServiceRoleArn)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), repository: \(Swift.String(describing: repository)), tags: \(Swift.String(describing: tags)), accessToken: \"CONTENT_REDACTED\", basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\", oauthToken: \"CONTENT_REDACTED\")"}
}

extension AmplifyClientTypes {

    /// Describes the information about a production branch for an Amplify app.
    public struct ProductionBranch: Swift.Sendable {
        /// The branch name for the production branch.
        public var branchName: Swift.String?
        /// The last deploy time of the production branch.
        public var lastDeployTime: Foundation.Date?
        /// The status of the production branch.
        public var status: Swift.String?
        /// The thumbnail URL for the production branch.
        public var thumbnailUrl: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            lastDeployTime: Foundation.Date? = nil,
            status: Swift.String? = nil,
            thumbnailUrl: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.lastDeployTime = lastDeployTime
            self.status = status
            self.thumbnailUrl = thumbnailUrl
        }
    }
}

extension AmplifyClientTypes {

    public enum RepositoryCloneMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sigv4
        case ssh
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryCloneMethod] {
            return [
                .sigv4,
                .ssh,
                .token
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sigv4: return "SIGV4"
            case .ssh: return "SSH"
            case .token: return "TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    public struct App: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amplify app.
        /// This member is required.
        public var appArn: Swift.String?
        /// The unique ID of the Amplify app.
        /// This member is required.
        public var appId: Swift.String?
        /// Describes the automated branch creation configuration for the Amplify app.
        public var autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
        /// Describes the automated branch creation glob patterns for the Amplify app.
        public var autoBranchCreationPatterns: [Swift.String]?
        /// The basic authorization credentials for branches for the Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public var basicAuthCredentials: Swift.String?
        /// Describes the content of the build specification (build spec) for the Amplify app.
        public var buildSpec: Swift.String?
        /// The cache configuration for the Amplify app. If you don't specify the cache configuration type, Amplify uses the default AMPLIFY_MANAGED setting.
        public var cacheConfig: AmplifyClientTypes.CacheConfig?
        /// Creates a date and time for the Amplify app.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// Describes the custom HTTP headers for the Amplify app.
        public var customHeaders: Swift.String?
        /// Describes the custom redirect and rewrite rules for the Amplify app.
        public var customRules: [AmplifyClientTypes.CustomRule]?
        /// The default domain for the Amplify app.
        /// This member is required.
        public var defaultDomain: Swift.String?
        /// The description for the Amplify app.
        /// This member is required.
        public var description: Swift.String?
        /// Enables automated branch creation for the Amplify app.
        public var enableAutoBranchCreation: Swift.Bool?
        /// Enables basic authorization for the Amplify app's branches.
        /// This member is required.
        public var enableBasicAuth: Swift.Bool?
        /// Enables the auto-building of branches for the Amplify app.
        /// This member is required.
        public var enableBranchAutoBuild: Swift.Bool?
        /// Automatically disconnect a branch in the Amplify console when you delete a branch from your Git repository.
        public var enableBranchAutoDeletion: Swift.Bool?
        /// The environment variables for the Amplify app. For a list of the environment variables that are accessible to Amplify by default, see [Amplify Environment variables](https://docs.aws.amazon.com/amplify/latest/userguide/amplify-console-environment-variables.html) in the Amplify Hosting User Guide.
        /// This member is required.
        public var environmentVariables: [Swift.String: Swift.String]?
        /// The AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) of the Amplify app.
        public var iamServiceRoleArn: Swift.String?
        /// The name for the Amplify app.
        /// This member is required.
        public var name: Swift.String?
        /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC. If you are deploying an SSG only app with Next.js 14 or later, you must use the platform type WEB_COMPUTE.
        /// This member is required.
        public var platform: AmplifyClientTypes.Platform?
        /// Describes the information about a production branch of the Amplify app.
        public var productionBranch: AmplifyClientTypes.ProductionBranch?
        /// The Git repository for the Amplify app.
        /// This member is required.
        public var repository: Swift.String?
        /// This is for internal use. The Amplify service uses this parameter to specify the authentication protocol to use to access the Git repository for an Amplify app. Amplify specifies TOKEN for a GitHub repository, SIGV4 for an Amazon Web Services CodeCommit repository, and SSH for GitLab and Bitbucket repositories.
        public var repositoryCloneMethod: AmplifyClientTypes.RepositoryCloneMethod?
        /// The tag for the Amplify app.
        public var tags: [Swift.String: Swift.String]?
        /// Updates the date and time for the Amplify app.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            appArn: Swift.String? = nil,
            appId: Swift.String? = nil,
            autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig? = nil,
            autoBranchCreationPatterns: [Swift.String]? = nil,
            basicAuthCredentials: Swift.String? = nil,
            buildSpec: Swift.String? = nil,
            cacheConfig: AmplifyClientTypes.CacheConfig? = nil,
            createTime: Foundation.Date? = nil,
            customHeaders: Swift.String? = nil,
            customRules: [AmplifyClientTypes.CustomRule]? = nil,
            defaultDomain: Swift.String? = nil,
            description: Swift.String? = nil,
            enableAutoBranchCreation: Swift.Bool? = nil,
            enableBasicAuth: Swift.Bool? = nil,
            enableBranchAutoBuild: Swift.Bool? = nil,
            enableBranchAutoDeletion: Swift.Bool? = nil,
            environmentVariables: [Swift.String: Swift.String]? = nil,
            iamServiceRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: AmplifyClientTypes.Platform? = nil,
            productionBranch: AmplifyClientTypes.ProductionBranch? = nil,
            repository: Swift.String? = nil,
            repositoryCloneMethod: AmplifyClientTypes.RepositoryCloneMethod? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.appArn = appArn
            self.appId = appId
            self.autoBranchCreationConfig = autoBranchCreationConfig
            self.autoBranchCreationPatterns = autoBranchCreationPatterns
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.cacheConfig = cacheConfig
            self.createTime = createTime
            self.customHeaders = customHeaders
            self.customRules = customRules
            self.defaultDomain = defaultDomain
            self.description = description
            self.enableAutoBranchCreation = enableAutoBranchCreation
            self.enableBasicAuth = enableBasicAuth
            self.enableBranchAutoBuild = enableBranchAutoBuild
            self.enableBranchAutoDeletion = enableBranchAutoDeletion
            self.environmentVariables = environmentVariables
            self.iamServiceRoleArn = iamServiceRoleArn
            self.name = name
            self.platform = platform
            self.productionBranch = productionBranch
            self.repository = repository
            self.repositoryCloneMethod = repositoryCloneMethod
            self.tags = tags
            self.updateTime = updateTime
        }
    }
}

extension AmplifyClientTypes.App: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "App(appArn: \(Swift.String(describing: appArn)), appId: \(Swift.String(describing: appId)), autoBranchCreationConfig: \(Swift.String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(Swift.String(describing: autoBranchCreationPatterns)), cacheConfig: \(Swift.String(describing: cacheConfig)), createTime: \(Swift.String(describing: createTime)), customHeaders: \(Swift.String(describing: customHeaders)), customRules: \(Swift.String(describing: customRules)), defaultDomain: \(Swift.String(describing: defaultDomain)), description: \(Swift.String(describing: description)), enableAutoBranchCreation: \(Swift.String(describing: enableAutoBranchCreation)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableBranchAutoBuild: \(Swift.String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(Swift.String(describing: enableBranchAutoDeletion)), environmentVariables: \(Swift.String(describing: environmentVariables)), iamServiceRoleArn: \(Swift.String(describing: iamServiceRoleArn)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), productionBranch: \(Swift.String(describing: productionBranch)), repository: \(Swift.String(describing: repository)), repositoryCloneMethod: \(Swift.String(describing: repositoryCloneMethod)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

public struct CreateAppOutput: Swift.Sendable {
    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

/// An entity was not found during an operation.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request structure for the backend environment create request.
public struct CreateBackendEnvironmentInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of deployment artifacts.
    public var deploymentArtifacts: Swift.String?
    /// The name for the backend environment.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The AWS CloudFormation stack name of a backend environment.
    public var stackName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        deploymentArtifacts: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.deploymentArtifacts = deploymentArtifacts
        self.environmentName = environmentName
        self.stackName = stackName
    }
}

extension AmplifyClientTypes {

    /// Describes the backend environment associated with a Branch of a Gen 1 Amplify app. Amplify Gen 1 applications are created using Amplify Studio or the Amplify command line interface (CLI).
    public struct BackendEnvironment: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var backendEnvironmentArn: Swift.String?
        /// The creation date and time for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The name of deployment artifacts.
        public var deploymentArtifacts: Swift.String?
        /// The name for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The AWS CloudFormation stack name of a backend environment.
        public var stackName: Swift.String?
        /// The last updated date and time for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            backendEnvironmentArn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            deploymentArtifacts: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            stackName: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.backendEnvironmentArn = backendEnvironmentArn
            self.createTime = createTime
            self.deploymentArtifacts = deploymentArtifacts
            self.environmentName = environmentName
            self.stackName = stackName
            self.updateTime = updateTime
        }
    }
}

/// The result structure for the create backend environment request.
public struct CreateBackendEnvironmentOutput: Swift.Sendable {
    /// Describes the backend environment for an Amplify app.
    /// This member is required.
    public var backendEnvironment: AmplifyClientTypes.BackendEnvironment?

    public init(
        backendEnvironment: AmplifyClientTypes.BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

extension AmplifyClientTypes {

    /// Describes the backend associated with an Amplify Branch. This property is available to Amplify Gen 2 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
    public struct Backend: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the CloudFormation stack.
        public var stackArn: Swift.String?

        public init(
            stackArn: Swift.String? = nil
        )
        {
            self.stackArn = stackArn
        }
    }
}

/// The request structure for the create branch request.
public struct CreateBranchInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The backend for a Branch of an Amplify app. Use for a backend created from an CloudFormation stack. This field is available to Amplify Gen 2 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
    public var backend: AmplifyClientTypes.Backend?
    /// The Amazon Resource Name (ARN) for a backend environment that is part of a Gen 1 Amplify app. This field is available to Amplify Gen 1 apps only where the backend is created using Amplify Studio or the Amplify command line interface (CLI).
    public var backendEnvironmentArn: Swift.String?
    /// The basic authorization credentials for the branch. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The name for the branch.
    /// This member is required.
    public var branchName: Swift.String?
    /// The build specification (build spec) for the branch.
    public var buildSpec: Swift.String?
    /// The description for the branch.
    public var description: Swift.String?
    /// The display name for a branch. This is used as the default domain prefix.
    public var displayName: Swift.String?
    /// Enables auto building for the branch.
    public var enableAutoBuild: Swift.Bool?
    /// Enables basic authorization for the branch.
    public var enableBasicAuth: Swift.Bool?
    /// Enables notifications for the branch.
    public var enableNotification: Swift.Bool?
    /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
    public var enablePerformanceMode: Swift.Bool?
    /// Enables pull request previews for this branch.
    public var enablePullRequestPreview: Swift.Bool?
    /// The environment variables for the branch.
    public var environmentVariables: [Swift.String: Swift.String]?
    /// The framework for the branch.
    public var framework: Swift.String?
    /// The Amplify environment name for the pull request.
    public var pullRequestEnvironmentName: Swift.String?
    /// Describes the current stage for the branch.
    public var stage: AmplifyClientTypes.Stage?
    /// The tag for the branch.
    public var tags: [Swift.String: Swift.String]?
    /// The content Time To Live (TTL) for the website in seconds.
    public var ttl: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backend: AmplifyClientTypes.Backend? = nil,
        backendEnvironmentArn: Swift.String? = nil,
        basicAuthCredentials: Swift.String? = nil,
        branchName: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableAutoBuild: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableNotification: Swift.Bool? = nil,
        enablePerformanceMode: Swift.Bool? = nil,
        enablePullRequestPreview: Swift.Bool? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil,
        framework: Swift.String? = nil,
        pullRequestEnvironmentName: Swift.String? = nil,
        stage: AmplifyClientTypes.Stage? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backend = backend
        self.backendEnvironmentArn = backendEnvironmentArn
        self.basicAuthCredentials = basicAuthCredentials
        self.branchName = branchName
        self.buildSpec = buildSpec
        self.description = description
        self.displayName = displayName
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enableNotification = enableNotification
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.stage = stage
        self.tags = tags
        self.ttl = ttl
    }
}

extension CreateBranchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBranchInput(appId: \(Swift.String(describing: appId)), backend: \(Swift.String(describing: backend)), backendEnvironmentArn: \(Swift.String(describing: backendEnvironmentArn)), branchName: \(Swift.String(describing: branchName)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableNotification: \(Swift.String(describing: enableNotification)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), stage: \(Swift.String(describing: stage)), tags: \(Swift.String(describing: tags)), ttl: \(Swift.String(describing: ttl)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

extension AmplifyClientTypes {

    /// The branch for an Amplify app, which maps to a third-party repository branch.
    public struct Branch: Swift.Sendable {
        /// The ID of the active job for a branch of an Amplify app.
        /// This member is required.
        public var activeJobId: Swift.String?
        /// A list of custom resources that are linked to this branch.
        public var associatedResources: [Swift.String]?
        /// Describes the backend associated with an Amplify Branch. This property is available to Amplify Gen 2 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
        public var backend: AmplifyClientTypes.Backend?
        /// The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app. This property is available to Amplify Gen 1 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
        public var backendEnvironmentArn: Swift.String?
        /// The basic authorization credentials for a branch of an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public var basicAuthCredentials: Swift.String?
        /// The Amazon Resource Name (ARN) for a branch that is part of an Amplify app.
        /// This member is required.
        public var branchArn: Swift.String?
        /// The name for the branch that is part of an Amplify app.
        /// This member is required.
        public var branchName: Swift.String?
        /// The build specification (build spec) content for the branch of an Amplify app.
        public var buildSpec: Swift.String?
        /// The creation date and time for a branch that is part of an Amplify app.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The custom domains for a branch of an Amplify app.
        /// This member is required.
        public var customDomains: [Swift.String]?
        /// The description for the branch that is part of an Amplify app.
        /// This member is required.
        public var description: Swift.String?
        /// The destination branch if the branch is a pull request branch.
        public var destinationBranch: Swift.String?
        /// The display name for the branch. This is used as the default domain prefix.
        /// This member is required.
        public var displayName: Swift.String?
        /// Enables auto-building on push for a branch of an Amplify app.
        /// This member is required.
        public var enableAutoBuild: Swift.Bool?
        /// Enables basic authorization for a branch of an Amplify app.
        /// This member is required.
        public var enableBasicAuth: Swift.Bool?
        /// Enables notifications for a branch that is part of an Amplify app.
        /// This member is required.
        public var enableNotification: Swift.Bool?
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public var enablePerformanceMode: Swift.Bool?
        /// Enables pull request previews for the branch.
        /// This member is required.
        public var enablePullRequestPreview: Swift.Bool?
        /// The environment variables specific to a branch of an Amplify app.
        /// This member is required.
        public var environmentVariables: [Swift.String: Swift.String]?
        /// The framework for a branch of an Amplify app.
        /// This member is required.
        public var framework: Swift.String?
        /// The Amplify environment name for the pull request.
        public var pullRequestEnvironmentName: Swift.String?
        /// The source branch if the branch is a pull request branch.
        public var sourceBranch: Swift.String?
        /// The current stage for the branch that is part of an Amplify app.
        /// This member is required.
        public var stage: AmplifyClientTypes.Stage?
        /// The tag for the branch of an Amplify app.
        public var tags: [Swift.String: Swift.String]?
        /// The thumbnail URL for the branch of an Amplify app.
        public var thumbnailUrl: Swift.String?
        /// The total number of jobs that are part of an Amplify app.
        /// This member is required.
        public var totalNumberOfJobs: Swift.String?
        /// The content Time to Live (TTL) for the website in seconds.
        /// This member is required.
        public var ttl: Swift.String?
        /// The last updated date and time for a branch that is part of an Amplify app.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            activeJobId: Swift.String? = nil,
            associatedResources: [Swift.String]? = nil,
            backend: AmplifyClientTypes.Backend? = nil,
            backendEnvironmentArn: Swift.String? = nil,
            basicAuthCredentials: Swift.String? = nil,
            branchArn: Swift.String? = nil,
            branchName: Swift.String? = nil,
            buildSpec: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            customDomains: [Swift.String]? = nil,
            description: Swift.String? = nil,
            destinationBranch: Swift.String? = nil,
            displayName: Swift.String? = nil,
            enableAutoBuild: Swift.Bool? = nil,
            enableBasicAuth: Swift.Bool? = nil,
            enableNotification: Swift.Bool? = nil,
            enablePerformanceMode: Swift.Bool? = nil,
            enablePullRequestPreview: Swift.Bool? = nil,
            environmentVariables: [Swift.String: Swift.String]? = nil,
            framework: Swift.String? = nil,
            pullRequestEnvironmentName: Swift.String? = nil,
            sourceBranch: Swift.String? = nil,
            stage: AmplifyClientTypes.Stage? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            thumbnailUrl: Swift.String? = nil,
            totalNumberOfJobs: Swift.String? = nil,
            ttl: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.activeJobId = activeJobId
            self.associatedResources = associatedResources
            self.backend = backend
            self.backendEnvironmentArn = backendEnvironmentArn
            self.basicAuthCredentials = basicAuthCredentials
            self.branchArn = branchArn
            self.branchName = branchName
            self.buildSpec = buildSpec
            self.createTime = createTime
            self.customDomains = customDomains
            self.description = description
            self.destinationBranch = destinationBranch
            self.displayName = displayName
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enableNotification = enableNotification
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.sourceBranch = sourceBranch
            self.stage = stage
            self.tags = tags
            self.thumbnailUrl = thumbnailUrl
            self.totalNumberOfJobs = totalNumberOfJobs
            self.ttl = ttl
            self.updateTime = updateTime
        }
    }
}

extension AmplifyClientTypes.Branch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Branch(activeJobId: \(Swift.String(describing: activeJobId)), associatedResources: \(Swift.String(describing: associatedResources)), backend: \(Swift.String(describing: backend)), backendEnvironmentArn: \(Swift.String(describing: backendEnvironmentArn)), branchArn: \(Swift.String(describing: branchArn)), branchName: \(Swift.String(describing: branchName)), createTime: \(Swift.String(describing: createTime)), customDomains: \(Swift.String(describing: customDomains)), description: \(Swift.String(describing: description)), destinationBranch: \(Swift.String(describing: destinationBranch)), displayName: \(Swift.String(describing: displayName)), enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableNotification: \(Swift.String(describing: enableNotification)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), sourceBranch: \(Swift.String(describing: sourceBranch)), stage: \(Swift.String(describing: stage)), tags: \(Swift.String(describing: tags)), thumbnailUrl: \(Swift.String(describing: thumbnailUrl)), totalNumberOfJobs: \(Swift.String(describing: totalNumberOfJobs)), ttl: \(Swift.String(describing: ttl)), updateTime: \(Swift.String(describing: updateTime)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

/// The result structure for create branch request.
public struct CreateBranchOutput: Swift.Sendable {
    /// Describes the branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

/// The request structure for the create a new deployment request.
public struct CreateDeploymentInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch to use for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// An optional file map that contains the file name as the key and the file content md5 hash as the value. If this argument is provided, the service will generate a unique upload URL per file. Otherwise, the service will only generate a single upload URL for the zipped files.
    public var fileMap: [Swift.String: Swift.String]?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        fileMap: [Swift.String: Swift.String]? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.fileMap = fileMap
    }
}

/// The result structure for the create a new deployment request.
public struct CreateDeploymentOutput: Swift.Sendable {
    /// When the fileMap argument is provided in the request, fileUploadUrls will contain a map of file names to upload URLs.
    /// This member is required.
    public var fileUploadUrls: [Swift.String: Swift.String]?
    /// The job ID for this deployment. will supply to start deployment api.
    public var jobId: Swift.String?
    /// When the fileMap argument is not provided in the request, this zipUploadUrl is returned.
    /// This member is required.
    public var zipUploadUrl: Swift.String?

    public init(
        fileUploadUrls: [Swift.String: Swift.String]? = nil,
        jobId: Swift.String? = nil,
        zipUploadUrl: Swift.String? = nil
    )
    {
        self.fileUploadUrls = fileUploadUrls
        self.jobId = jobId
        self.zipUploadUrl = zipUploadUrl
    }
}

extension AmplifyClientTypes {

    public enum CertificateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amplifyManaged
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateType] {
            return [
                .amplifyManaged,
                .custom
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amplifyManaged: return "AMPLIFY_MANAGED"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    /// The type of SSL/TLS certificate to use for your custom domain. If a certificate type isn't specified, Amplify uses the default AMPLIFY_MANAGED certificate.
    public struct CertificateSettings: Swift.Sendable {
        /// The Amazon resource name (ARN) for the custom certificate that you have already added to Certificate Manager in your Amazon Web Services account. This field is required only when the certificate type is CUSTOM.
        public var customCertificateArn: Swift.String?
        /// The certificate type. Specify AMPLIFY_MANAGED to use the default certificate that Amplify provisions for you. Specify CUSTOM to use your own certificate that you have already added to Certificate Manager in your Amazon Web Services account. Make sure you request (or import) the certificate in the US East (N. Virginia) Region (us-east-1). For more information about using ACM, see [Importing certificates into Certificate Manager](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the ACM User guide.
        /// This member is required.
        public var type: AmplifyClientTypes.CertificateType?

        public init(
            customCertificateArn: Swift.String? = nil,
            type: AmplifyClientTypes.CertificateType? = nil
        )
        {
            self.customCertificateArn = customCertificateArn
            self.type = type
        }
    }
}

extension AmplifyClientTypes {

    /// Describes the settings for the subdomain.
    public struct SubDomainSetting: Swift.Sendable {
        /// The branch name setting for the subdomain.
        /// This member is required.
        public var branchName: Swift.String?
        /// The prefix setting for the subdomain.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.`prefix` = `prefix`
        }
    }
}

/// The request structure for the create domain association request.
public struct CreateDomainAssociationInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// Sets the branch patterns for automatic subdomain creation.
    public var autoSubDomainCreationPatterns: [Swift.String]?
    /// The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
    public var autoSubDomainIAMRole: Swift.String?
    /// The type of SSL/TLS certificate to use for your custom domain. If you don't specify a certificate type, Amplify uses the default certificate that it provisions and manages for you.
    public var certificateSettings: AmplifyClientTypes.CertificateSettings?
    /// The domain name for the domain association.
    /// This member is required.
    public var domainName: Swift.String?
    /// Enables the automated creation of subdomains for branches.
    public var enableAutoSubDomain: Swift.Bool?
    /// The setting for the subdomain.
    /// This member is required.
    public var subDomainSettings: [AmplifyClientTypes.SubDomainSetting]?

    public init(
        appId: Swift.String? = nil,
        autoSubDomainCreationPatterns: [Swift.String]? = nil,
        autoSubDomainIAMRole: Swift.String? = nil,
        certificateSettings: AmplifyClientTypes.CertificateSettings? = nil,
        domainName: Swift.String? = nil,
        enableAutoSubDomain: Swift.Bool? = nil,
        subDomainSettings: [AmplifyClientTypes.SubDomainSetting]? = nil
    )
    {
        self.appId = appId
        self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
        self.autoSubDomainIAMRole = autoSubDomainIAMRole
        self.certificateSettings = certificateSettings
        self.domainName = domainName
        self.enableAutoSubDomain = enableAutoSubDomain
        self.subDomainSettings = subDomainSettings
    }
}

extension AmplifyClientTypes {

    /// Describes the current SSL/TLS certificate that is in use for the domain. If you are using CreateDomainAssociation to create a new domain association, Certificate describes the new certificate that you are creating.
    public struct Certificate: Swift.Sendable {
        /// The DNS record for certificate verification.
        public var certificateVerificationDNSRecord: Swift.String?
        /// The Amazon resource name (ARN) for a custom certificate that you have already added to Certificate Manager in your Amazon Web Services account. This field is required only when the certificate type is CUSTOM.
        public var customCertificateArn: Swift.String?
        /// The type of SSL/TLS certificate that you want to use. Specify AMPLIFY_MANAGED to use the default certificate that Amplify provisions for you. Specify CUSTOM to use your own certificate that you have already added to Certificate Manager in your Amazon Web Services account. Make sure you request (or import) the certificate in the US East (N. Virginia) Region (us-east-1). For more information about using ACM, see [Importing certificates into Certificate Manager](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the ACM User guide.
        /// This member is required.
        public var type: AmplifyClientTypes.CertificateType?

        public init(
            certificateVerificationDNSRecord: Swift.String? = nil,
            customCertificateArn: Swift.String? = nil,
            type: AmplifyClientTypes.CertificateType? = nil
        )
        {
            self.certificateVerificationDNSRecord = certificateVerificationDNSRecord
            self.customCertificateArn = customCertificateArn
            self.type = type
        }
    }
}

extension AmplifyClientTypes {

    public enum DomainStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case awaitingAppCname
        case creating
        case failed
        case importingCustomCertificate
        case inProgress
        case pendingDeployment
        case pendingVerification
        case requestingCertificate
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .available,
                .awaitingAppCname,
                .creating,
                .failed,
                .importingCustomCertificate,
                .inProgress,
                .pendingDeployment,
                .pendingVerification,
                .requestingCertificate,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .awaitingAppCname: return "AWAITING_APP_CNAME"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .importingCustomCertificate: return "IMPORTING_CUSTOM_CERTIFICATE"
            case .inProgress: return "IN_PROGRESS"
            case .pendingDeployment: return "PENDING_DEPLOYMENT"
            case .pendingVerification: return "PENDING_VERIFICATION"
            case .requestingCertificate: return "REQUESTING_CERTIFICATE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    /// The subdomain for the domain association.
    public struct SubDomain: Swift.Sendable {
        /// The DNS record for the subdomain.
        /// This member is required.
        public var dnsRecord: Swift.String?
        /// Describes the settings for the subdomain.
        /// This member is required.
        public var subDomainSetting: AmplifyClientTypes.SubDomainSetting?
        /// The verified status of the subdomain
        /// This member is required.
        public var verified: Swift.Bool?

        public init(
            dnsRecord: Swift.String? = nil,
            subDomainSetting: AmplifyClientTypes.SubDomainSetting? = nil,
            verified: Swift.Bool? = nil
        )
        {
            self.dnsRecord = dnsRecord
            self.subDomainSetting = subDomainSetting
            self.verified = verified
        }
    }
}

extension AmplifyClientTypes {

    public enum UpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awaitingAppCname
        case importingCustomCertificate
        case pendingDeployment
        case pendingVerification
        case requestingCertificate
        case updateComplete
        case updateFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateStatus] {
            return [
                .awaitingAppCname,
                .importingCustomCertificate,
                .pendingDeployment,
                .pendingVerification,
                .requestingCertificate,
                .updateComplete,
                .updateFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awaitingAppCname: return "AWAITING_APP_CNAME"
            case .importingCustomCertificate: return "IMPORTING_CUSTOM_CERTIFICATE"
            case .pendingDeployment: return "PENDING_DEPLOYMENT"
            case .pendingVerification: return "PENDING_VERIFICATION"
            case .requestingCertificate: return "REQUESTING_CERTIFICATE"
            case .updateComplete: return "UPDATE_COMPLETE"
            case .updateFailed: return "UPDATE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    /// Describes the association between a custom domain and an Amplify app.
    public struct DomainAssociation: Swift.Sendable {
        /// Sets branch patterns for automatic subdomain creation.
        public var autoSubDomainCreationPatterns: [Swift.String]?
        /// The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
        public var autoSubDomainIAMRole: Swift.String?
        /// Describes the SSL/TLS certificate for the domain association. This can be your own custom certificate or the default certificate that Amplify provisions for you. If you are updating your domain to use a different certificate, certificate points to the new certificate that is being created instead of the current active certificate. Otherwise, certificate points to the current active certificate.
        public var certificate: AmplifyClientTypes.Certificate?
        /// The DNS record for certificate verification.
        public var certificateVerificationDNSRecord: Swift.String?
        /// The Amazon Resource Name (ARN) for the domain association.
        /// This member is required.
        public var domainAssociationArn: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The current status of the domain association.
        /// This member is required.
        public var domainStatus: AmplifyClientTypes.DomainStatus?
        /// Enables the automated creation of subdomains for branches.
        /// This member is required.
        public var enableAutoSubDomain: Swift.Bool?
        /// Additional information that describes why the domain association is in the current state.
        /// This member is required.
        public var statusReason: Swift.String?
        /// The subdomains for the domain association.
        /// This member is required.
        public var subDomains: [AmplifyClientTypes.SubDomain]?
        /// The status of the domain update operation that is currently in progress. The following list describes the valid update states. REQUESTING_CERTIFICATE The certificate is in the process of being updated. PENDING_VERIFICATION Indicates that an Amplify managed certificate is in the process of being verified. This occurs during the creation of a custom domain or when a custom domain is updated to use a managed certificate. IMPORTING_CUSTOM_CERTIFICATE Indicates that an Amplify custom certificate is in the process of being imported. This occurs during the creation of a custom domain or when a custom domain is updated to use a custom certificate. PENDING_DEPLOYMENT Indicates that the subdomain or certificate changes are being propagated. AWAITING_APP_CNAME Amplify is waiting for CNAME records corresponding to subdomains to be propagated. If your custom domain is on Route 53, Amplify handles this for you automatically. For more information about custom domains, see [Setting up custom domains](https://docs.aws.amazon.com/amplify/latest/userguide/custom-domains.html) in the Amplify Hosting User Guide. UPDATE_COMPLETE The certificate has been associated with a domain. UPDATE_FAILED The certificate has failed to be provisioned or associated, and there is no existing active certificate to roll back to.
        public var updateStatus: AmplifyClientTypes.UpdateStatus?

        public init(
            autoSubDomainCreationPatterns: [Swift.String]? = nil,
            autoSubDomainIAMRole: Swift.String? = nil,
            certificate: AmplifyClientTypes.Certificate? = nil,
            certificateVerificationDNSRecord: Swift.String? = nil,
            domainAssociationArn: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainStatus: AmplifyClientTypes.DomainStatus? = nil,
            enableAutoSubDomain: Swift.Bool? = nil,
            statusReason: Swift.String? = nil,
            subDomains: [AmplifyClientTypes.SubDomain]? = nil,
            updateStatus: AmplifyClientTypes.UpdateStatus? = nil
        )
        {
            self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
            self.autoSubDomainIAMRole = autoSubDomainIAMRole
            self.certificate = certificate
            self.certificateVerificationDNSRecord = certificateVerificationDNSRecord
            self.domainAssociationArn = domainAssociationArn
            self.domainName = domainName
            self.domainStatus = domainStatus
            self.enableAutoSubDomain = enableAutoSubDomain
            self.statusReason = statusReason
            self.subDomains = subDomains
            self.updateStatus = updateStatus
        }
    }
}

/// The result structure for the create domain association request.
public struct CreateDomainAssociationOutput: Swift.Sendable {
    /// Describes the structure of a domain association, which associates a custom domain with an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

/// The request structure for the create webhook request.
public struct CreateWebhookInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for a branch that is part of an Amplify app.
    /// This member is required.
    public var branchName: Swift.String?
    /// The description for a webhook.
    public var description: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.description = description
    }
}

extension AmplifyClientTypes {

    /// Describes a webhook that connects repository events to an Amplify app.
    public struct Webhook: Swift.Sendable {
        /// The name for a branch that is part of an Amplify app.
        /// This member is required.
        public var branchName: Swift.String?
        /// The create date and time for a webhook.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description for a webhook.
        /// This member is required.
        public var description: Swift.String?
        /// Updates the date and time for a webhook.
        /// This member is required.
        public var updateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the webhook.
        /// This member is required.
        public var webhookArn: Swift.String?
        /// The ID of the webhook.
        /// This member is required.
        public var webhookId: Swift.String?
        /// The URL of the webhook.
        /// This member is required.
        public var webhookUrl: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            updateTime: Foundation.Date? = nil,
            webhookArn: Swift.String? = nil,
            webhookId: Swift.String? = nil,
            webhookUrl: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.createTime = createTime
            self.description = description
            self.updateTime = updateTime
            self.webhookArn = webhookArn
            self.webhookId = webhookId
            self.webhookUrl = webhookUrl
        }
    }
}

/// The result structure for the create webhook request.
public struct CreateWebhookOutput: Swift.Sendable {
    /// Describes a webhook that connects repository events to an Amplify app.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

/// Describes the request structure for the delete app request.
public struct DeleteAppInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

/// The result structure for the delete app request.
public struct DeleteAppOutput: Swift.Sendable {
    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

/// The request structure for the delete backend environment request.
public struct DeleteBackendEnvironmentInput: Swift.Sendable {
    /// The unique ID of an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of a backend environment of an Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

/// The result structure of the delete backend environment result.
public struct DeleteBackendEnvironmentOutput: Swift.Sendable {
    /// Describes the backend environment for an Amplify app.
    /// This member is required.
    public var backendEnvironment: AmplifyClientTypes.BackendEnvironment?

    public init(
        backendEnvironment: AmplifyClientTypes.BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

/// The request structure for the delete branch request.
public struct DeleteBranchInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch.
    /// This member is required.
    public var branchName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
    }
}

/// The result structure for the delete branch request.
public struct DeleteBranchOutput: Swift.Sendable {
    /// The branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

/// The request structure for the delete domain association request.
public struct DeleteDomainAssociationInput: Swift.Sendable {
    /// The unique id for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
    }
}

public struct DeleteDomainAssociationOutput: Swift.Sendable {
    /// Describes the association between a custom domain and an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

/// The request structure for the delete job request.
public struct DeleteJobInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch to use for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique ID for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

extension AmplifyClientTypes {

    public enum JobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case manual
        case release
        case retry
        case webHook
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .manual,
                .release,
                .retry,
                .webHook
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .manual: return "MANUAL"
            case .release: return "RELEASE"
            case .retry: return "RETRY"
            case .webHook: return "WEB_HOOK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    public enum SourceUrlType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bucketPrefix
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceUrlType] {
            return [
                .bucketPrefix,
                .zip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bucketPrefix: return "BUCKET_PREFIX"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case pending
        case provisioning
        case running
        case succeed
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .pending,
                .provisioning,
                .running,
                .succeed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .provisioning: return "PROVISIONING"
            case .running: return "RUNNING"
            case .succeed: return "SUCCEED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AmplifyClientTypes {

    /// Describes the summary for an execution job for an Amplify app.
    public struct JobSummary: Swift.Sendable {
        /// The commit ID from a third-party repository provider for the job.
        /// This member is required.
        public var commitId: Swift.String?
        /// The commit message from a third-party repository provider for the job.
        /// This member is required.
        public var commitMessage: Swift.String?
        /// The commit date and time for the job.
        /// This member is required.
        public var commitTime: Foundation.Date?
        /// The end date and time for the job.
        public var endTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The unique ID for the job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The type for the job. If the value is RELEASE, the job was manually released from its source by using the StartJob API. This value is available only for apps that are connected to a repository. If the value is RETRY, the job was manually retried using the StartJob API. If the value is WEB_HOOK, the job was automatically triggered by webhooks. If the value is MANUAL, the job is for a manually deployed app. Manually deployed apps are not connected to a Git repository.
        /// This member is required.
        public var jobType: AmplifyClientTypes.JobType?
        /// The source URL for the files to deploy. The source URL can be either an HTTP GET URL that is publicly accessible and downloads a single .zip file, or an Amazon S3 bucket and prefix.
        public var sourceUrl: Swift.String?
        /// The type of source specified by the sourceURL. If the value is ZIP, the source is a .zip file. If the value is BUCKET_PREFIX, the source is an Amazon S3 bucket and prefix. If no value is specified, the default is ZIP.
        public var sourceUrlType: AmplifyClientTypes.SourceUrlType?
        /// The start date and time for the job.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The current status for the job.
        /// This member is required.
        public var status: AmplifyClientTypes.JobStatus?

        public init(
            commitId: Swift.String? = nil,
            commitMessage: Swift.String? = nil,
            commitTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobType: AmplifyClientTypes.JobType? = nil,
            sourceUrl: Swift.String? = nil,
            sourceUrlType: AmplifyClientTypes.SourceUrlType? = nil,
            startTime: Foundation.Date? = nil,
            status: AmplifyClientTypes.JobStatus? = nil
        )
        {
            self.commitId = commitId
            self.commitMessage = commitMessage
            self.commitTime = commitTime
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobId = jobId
            self.jobType = jobType
            self.sourceUrl = sourceUrl
            self.sourceUrlType = sourceUrlType
            self.startTime = startTime
            self.status = status
        }
    }
}

/// The result structure for the delete job request.
public struct DeleteJobOutput: Swift.Sendable {
    /// Describes the summary for an execution job for an Amplify app.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

/// The request structure for the delete webhook request.
public struct DeleteWebhookInput: Swift.Sendable {
    /// The unique ID for a webhook.
    /// This member is required.
    public var webhookId: Swift.String?

    public init(
        webhookId: Swift.String? = nil
    )
    {
        self.webhookId = webhookId
    }
}

/// The result structure for the delete webhook request.
public struct DeleteWebhookOutput: Swift.Sendable {
    /// Describes a webhook that connects repository events to an Amplify app.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

/// The request structure for the generate access logs request.
public struct GenerateAccessLogsInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The time at which the logs should end. The time range specified is inclusive of the end time.
    public var endTime: Foundation.Date?
    /// The time at which the logs should start. The time range specified is inclusive of the start time.
    public var startTime: Foundation.Date?

    public init(
        appId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
        self.endTime = endTime
        self.startTime = startTime
    }
}

/// The result structure for the generate access logs request.
public struct GenerateAccessLogsOutput: Swift.Sendable {
    /// The pre-signed URL for the requested access logs.
    public var logUrl: Swift.String?

    public init(
        logUrl: Swift.String? = nil
    )
    {
        self.logUrl = logUrl
    }
}

/// The request structure for the get app request.
public struct GetAppInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct GetAppOutput: Swift.Sendable {
    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

/// Returns the request structure for the get artifact request.
public struct GetArtifactUrlInput: Swift.Sendable {
    /// The unique ID for an artifact.
    /// This member is required.
    public var artifactId: Swift.String?

    public init(
        artifactId: Swift.String? = nil
    )
    {
        self.artifactId = artifactId
    }
}

/// Returns the result structure for the get artifact request.
public struct GetArtifactUrlOutput: Swift.Sendable {
    /// The unique ID for an artifact.
    /// This member is required.
    public var artifactId: Swift.String?
    /// The presigned URL for the artifact.
    /// This member is required.
    public var artifactUrl: Swift.String?

    public init(
        artifactId: Swift.String? = nil,
        artifactUrl: Swift.String? = nil
    )
    {
        self.artifactId = artifactId
        self.artifactUrl = artifactUrl
    }
}

/// The request structure for the get backend environment request.
public struct GetBackendEnvironmentInput: Swift.Sendable {
    /// The unique id for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the backend environment.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

/// The result structure for the get backend environment result.
public struct GetBackendEnvironmentOutput: Swift.Sendable {
    /// Describes the backend environment for an Amplify app.
    /// This member is required.
    public var backendEnvironment: AmplifyClientTypes.BackendEnvironment?

    public init(
        backendEnvironment: AmplifyClientTypes.BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

/// The request structure for the get branch request.
public struct GetBranchInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch.
    /// This member is required.
    public var branchName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
    }
}

public struct GetBranchOutput: Swift.Sendable {
    /// The branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

/// The request structure for the get domain association request.
public struct GetDomainAssociationInput: Swift.Sendable {
    /// The unique id for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
    }
}

/// The result structure for the get domain association request.
public struct GetDomainAssociationOutput: Swift.Sendable {
    /// Describes the structure of a domain association, which associates a custom domain with an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

/// The request structure for the get job request.
public struct GetJobInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch to use for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique ID for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

extension AmplifyClientTypes {

    /// Describes an execution step, for an execution job, for an Amplify app.
    public struct Step: Swift.Sendable {
        /// The URL to the artifact for the execution step.
        public var artifactsUrl: Swift.String?
        /// The context for the current step. Includes a build image if the step is build.
        public var context: Swift.String?
        /// The end date and time of the execution step.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The URL to the logs for the execution step.
        public var logUrl: Swift.String?
        /// The list of screenshot URLs for the execution step, if relevant.
        public var screenshots: [Swift.String: Swift.String]?
        /// The start date and time of the execution step.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The status of the execution step.
        /// This member is required.
        public var status: AmplifyClientTypes.JobStatus?
        /// The reason for the current step status.
        public var statusReason: Swift.String?
        /// The name of the execution step.
        /// This member is required.
        public var stepName: Swift.String?
        /// The URL to the test artifact for the execution step.
        public var testArtifactsUrl: Swift.String?
        /// The URL to the test configuration for the execution step.
        public var testConfigUrl: Swift.String?

        public init(
            artifactsUrl: Swift.String? = nil,
            context: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            logUrl: Swift.String? = nil,
            screenshots: [Swift.String: Swift.String]? = nil,
            startTime: Foundation.Date? = nil,
            status: AmplifyClientTypes.JobStatus? = nil,
            statusReason: Swift.String? = nil,
            stepName: Swift.String? = nil,
            testArtifactsUrl: Swift.String? = nil,
            testConfigUrl: Swift.String? = nil
        )
        {
            self.artifactsUrl = artifactsUrl
            self.context = context
            self.endTime = endTime
            self.logUrl = logUrl
            self.screenshots = screenshots
            self.startTime = startTime
            self.status = status
            self.statusReason = statusReason
            self.stepName = stepName
            self.testArtifactsUrl = testArtifactsUrl
            self.testConfigUrl = testConfigUrl
        }
    }
}

extension AmplifyClientTypes {

    /// Describes an execution job for an Amplify app.
    public struct Job: Swift.Sendable {
        /// The execution steps for an execution job, for an Amplify app.
        /// This member is required.
        public var steps: [AmplifyClientTypes.Step]?
        /// Describes the summary for an execution job for an Amplify app.
        /// This member is required.
        public var summary: AmplifyClientTypes.JobSummary?

        public init(
            steps: [AmplifyClientTypes.Step]? = nil,
            summary: AmplifyClientTypes.JobSummary? = nil
        )
        {
            self.steps = steps
            self.summary = summary
        }
    }
}

public struct GetJobOutput: Swift.Sendable {
    /// Describes an execution job for an Amplify app.
    /// This member is required.
    public var job: AmplifyClientTypes.Job?

    public init(
        job: AmplifyClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

/// The request structure for the get webhook request.
public struct GetWebhookInput: Swift.Sendable {
    /// The unique ID for a webhook.
    /// This member is required.
    public var webhookId: Swift.String?

    public init(
        webhookId: Swift.String? = nil
    )
    {
        self.webhookId = webhookId
    }
}

/// The result structure for the get webhook request.
public struct GetWebhookOutput: Swift.Sendable {
    /// Describes the structure of a webhook.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

/// The request structure for the list apps request.
public struct ListAppsInput: Swift.Sendable {
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. If non-null, the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The result structure for an Amplify app list request.
public struct ListAppsOutput: Swift.Sendable {
    /// A list of Amplify apps.
    /// This member is required.
    public var apps: [AmplifyClientTypes.App]?
    /// A pagination token. Set to null to start listing apps from start. If non-null, the pagination token is returned in a result. Pass its value in here to list more projects.
    public var nextToken: Swift.String?

    public init(
        apps: [AmplifyClientTypes.App]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

/// Describes the request structure for the list artifacts request.
public struct ListArtifactsInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of a branch that is part of an Amplify app.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique ID for a job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing artifacts from start. If a non-null pagination token is returned in a result, pass its value in here to list more artifacts.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AmplifyClientTypes {

    /// Describes an artifact.
    public struct Artifact: Swift.Sendable {
        /// The file name for the artifact.
        /// This member is required.
        public var artifactFileName: Swift.String?
        /// The unique ID for the artifact.
        /// This member is required.
        public var artifactId: Swift.String?

        public init(
            artifactFileName: Swift.String? = nil,
            artifactId: Swift.String? = nil
        )
        {
            self.artifactFileName = artifactFileName
            self.artifactId = artifactId
        }
    }
}

/// The result structure for the list artifacts request.
public struct ListArtifactsOutput: Swift.Sendable {
    /// A list of artifacts.
    /// This member is required.
    public var artifacts: [AmplifyClientTypes.Artifact]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        artifacts: [AmplifyClientTypes.Artifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

/// The request structure for the list backend environments request.
public struct ListBackendEnvironmentsInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment
    public var environmentName: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing backend environments from the start. If a non-null pagination token is returned in a result, pass its value in here to list more backend environments.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The result structure for the list backend environments result.
public struct ListBackendEnvironmentsOutput: Swift.Sendable {
    /// The list of backend environments for an Amplify app.
    /// This member is required.
    public var backendEnvironments: [AmplifyClientTypes.BackendEnvironment]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        backendEnvironments: [AmplifyClientTypes.BackendEnvironment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backendEnvironments = backendEnvironments
        self.nextToken = nextToken
    }
}

/// The request structure for the list branches request.
public struct ListBranchesInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing branches from the start. If a non-null pagination token is returned in a result, pass its value in here to list more branches.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The result structure for the list branches request.
public struct ListBranchesOutput: Swift.Sendable {
    /// A list of branches for an Amplify app.
    /// This member is required.
    public var branches: [AmplifyClientTypes.Branch]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        branches: [AmplifyClientTypes.Branch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.branches = branches
        self.nextToken = nextToken
    }
}

/// The request structure for the list domain associations request.
public struct ListDomainAssociationsInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing apps from the start. If non-null, a pagination token is returned in a result. Pass its value in here to list more projects.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The result structure for the list domain association request.
public struct ListDomainAssociationsOutput: Swift.Sendable {
    /// A list of domain associations.
    /// This member is required.
    public var domainAssociations: [AmplifyClientTypes.DomainAssociation]?
    /// A pagination token. If non-null, a pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        domainAssociations: [AmplifyClientTypes.DomainAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainAssociations = domainAssociations
        self.nextToken = nextToken
    }
}

/// The request structure for the list jobs request.
public struct ListJobsInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch to use for the request.
    /// This member is required.
    public var branchName: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing steps from the start. If a non-null pagination token is returned in a result, pass its value in here to list more steps.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The maximum number of records to list in a single response.
public struct ListJobsOutput: Swift.Sendable {
    /// The result structure for the list job result request.
    /// This member is required.
    public var jobSummaries: [AmplifyClientTypes.JobSummary]?
    /// A pagination token. If non-null the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [AmplifyClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

/// An operation failed due to a non-existent resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request structure to use to list tags for a resource.
public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

/// The response for the list tags for resource request.
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags for the specified The Amazon Resource Name (ARN).
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

/// The request structure for the list webhooks request.
public struct ListWebhooksInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing webhooks from the start. If non-null,the pagination token is returned in a result. Pass its value in here to list more webhooks.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The result structure for the list webhooks request.
public struct ListWebhooksOutput: Swift.Sendable {
    /// A pagination token. If non-null, the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?
    /// A list of webhooks.
    /// This member is required.
    public var webhooks: [AmplifyClientTypes.Webhook]?

    public init(
        nextToken: Swift.String? = nil,
        webhooks: [AmplifyClientTypes.Webhook]? = nil
    )
    {
        self.nextToken = nextToken
        self.webhooks = webhooks
    }
}

/// The request structure for the start a deployment request.
public struct StartDeploymentInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch to use for the deployment job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The job ID for this deployment that is generated by the CreateDeployment request.
    public var jobId: Swift.String?
    /// The source URL for the deployment that is used when calling StartDeployment without CreateDeployment. The source URL can be either an HTTP GET URL that is publicly accessible and downloads a single .zip file, or an Amazon S3 bucket and prefix.
    public var sourceUrl: Swift.String?
    /// The type of source specified by the sourceURL. If the value is ZIP, the source is a .zip file. If the value is BUCKET_PREFIX, the source is an Amazon S3 bucket and prefix. If no value is specified, the default is ZIP.
    public var sourceUrlType: AmplifyClientTypes.SourceUrlType?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        sourceUrl: Swift.String? = nil,
        sourceUrlType: AmplifyClientTypes.SourceUrlType? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
        self.sourceUrl = sourceUrl
        self.sourceUrlType = sourceUrlType
    }
}

/// The result structure for the start a deployment request.
public struct StartDeploymentOutput: Swift.Sendable {
    /// The summary for the job.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

/// The request structure for the start job request.
public struct StartJobInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch to use for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit ID from a third-party repository provider for the job.
    public var commitId: Swift.String?
    /// The commit message from a third-party repository provider for the job.
    public var commitMessage: Swift.String?
    /// The commit date and time for the job.
    public var commitTime: Foundation.Date?
    /// The unique ID for an existing job. This is required if the value of jobType is RETRY.
    public var jobId: Swift.String?
    /// A descriptive reason for starting the job.
    public var jobReason: Swift.String?
    /// Describes the type for the job. The job type RELEASE starts a new job with the latest change from the specified branch. This value is available only for apps that are connected to a repository. The job type RETRY retries an existing job. If the job type value is RETRY, the jobId is also required.
    /// This member is required.
    public var jobType: AmplifyClientTypes.JobType?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        commitId: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        commitTime: Foundation.Date? = nil,
        jobId: Swift.String? = nil,
        jobReason: Swift.String? = nil,
        jobType: AmplifyClientTypes.JobType? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.commitId = commitId
        self.commitMessage = commitMessage
        self.commitTime = commitTime
        self.jobId = jobId
        self.jobReason = jobReason
        self.jobType = jobType
    }
}

/// The result structure for the run job request.
public struct StartJobOutput: Swift.Sendable {
    /// The summary for the job.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

/// The request structure for the stop job request.
public struct StopJobInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the branch to use for the stop job request.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique id for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

/// The result structure for the stop job request.
public struct StopJobOutput: Swift.Sendable {
    /// The summary for the job.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

/// The request structure to tag a resource with a tag key and value.
public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to tag a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to tag the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

/// The response for the tag resource request.
public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request structure for the untag resource request.
public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use to untag a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to use to untag a resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// The response for the untag resource request.
public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request structure for the update app request.
public struct UpdateAppInput: Swift.Sendable {
    /// The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use accessToken for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use oauthToken. You must specify either accessToken or oauthToken when you update an app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var accessToken: Swift.String?
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The automated branch creation configuration for an Amplify app.
    public var autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
    /// Describes the automated branch creation glob patterns for an Amplify app.
    public var autoBranchCreationPatterns: [Swift.String]?
    /// The basic authorization credentials for an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The build specification (build spec) for an Amplify app.
    public var buildSpec: Swift.String?
    /// The cache configuration for the Amplify app.
    public var cacheConfig: AmplifyClientTypes.CacheConfig?
    /// The custom HTTP headers for an Amplify app.
    public var customHeaders: Swift.String?
    /// The custom redirect and rewrite rules for an Amplify app.
    public var customRules: [AmplifyClientTypes.CustomRule]?
    /// The description for an Amplify app.
    public var description: Swift.String?
    /// Enables automated branch creation for an Amplify app.
    public var enableAutoBranchCreation: Swift.Bool?
    /// Enables basic authorization for an Amplify app.
    public var enableBasicAuth: Swift.Bool?
    /// Enables branch auto-building for an Amplify app.
    public var enableBranchAutoBuild: Swift.Bool?
    /// Automatically disconnects a branch in the Amplify console when you delete a branch from your Git repository.
    public var enableBranchAutoDeletion: Swift.Bool?
    /// The environment variables for an Amplify app.
    public var environmentVariables: [Swift.String: Swift.String]?
    /// The AWS Identity and Access Management (IAM) service role for an Amplify app.
    public var iamServiceRoleArn: Swift.String?
    /// The name for an Amplify app.
    public var name: Swift.String?
    /// The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use oauthToken for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use accessToken. You must specify either oauthToken or accessToken when you update an app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/userguide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var oauthToken: Swift.String?
    /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC. If you are deploying an SSG only app with Next.js version 14 or later, you must set the platform type to WEB_COMPUTE.
    public var platform: AmplifyClientTypes.Platform?
    /// The name of the Git repository for an Amplify app.
    public var repository: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        appId: Swift.String? = nil,
        autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig? = nil,
        autoBranchCreationPatterns: [Swift.String]? = nil,
        basicAuthCredentials: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        cacheConfig: AmplifyClientTypes.CacheConfig? = nil,
        customHeaders: Swift.String? = nil,
        customRules: [AmplifyClientTypes.CustomRule]? = nil,
        description: Swift.String? = nil,
        enableAutoBranchCreation: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableBranchAutoBuild: Swift.Bool? = nil,
        enableBranchAutoDeletion: Swift.Bool? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil,
        iamServiceRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        oauthToken: Swift.String? = nil,
        platform: AmplifyClientTypes.Platform? = nil,
        repository: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.appId = appId
        self.autoBranchCreationConfig = autoBranchCreationConfig
        self.autoBranchCreationPatterns = autoBranchCreationPatterns
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.cacheConfig = cacheConfig
        self.customHeaders = customHeaders
        self.customRules = customRules
        self.description = description
        self.enableAutoBranchCreation = enableAutoBranchCreation
        self.enableBasicAuth = enableBasicAuth
        self.enableBranchAutoBuild = enableBranchAutoBuild
        self.enableBranchAutoDeletion = enableBranchAutoDeletion
        self.environmentVariables = environmentVariables
        self.iamServiceRoleArn = iamServiceRoleArn
        self.name = name
        self.oauthToken = oauthToken
        self.platform = platform
        self.repository = repository
    }
}

extension UpdateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInput(appId: \(Swift.String(describing: appId)), autoBranchCreationConfig: \(Swift.String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(Swift.String(describing: autoBranchCreationPatterns)), cacheConfig: \(Swift.String(describing: cacheConfig)), customHeaders: \(Swift.String(describing: customHeaders)), customRules: \(Swift.String(describing: customRules)), description: \(Swift.String(describing: description)), enableAutoBranchCreation: \(Swift.String(describing: enableAutoBranchCreation)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableBranchAutoBuild: \(Swift.String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(Swift.String(describing: enableBranchAutoDeletion)), environmentVariables: \(Swift.String(describing: environmentVariables)), iamServiceRoleArn: \(Swift.String(describing: iamServiceRoleArn)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), repository: \(Swift.String(describing: repository)), accessToken: \"CONTENT_REDACTED\", basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\", oauthToken: \"CONTENT_REDACTED\")"}
}

/// The result structure for an Amplify app update request.
public struct UpdateAppOutput: Swift.Sendable {
    /// Represents the updated Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

/// The request structure for the update branch request.
public struct UpdateBranchInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The backend for a Branch of an Amplify app. Use for a backend created from an CloudFormation stack. This field is available to Amplify Gen 2 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
    public var backend: AmplifyClientTypes.Backend?
    /// The Amazon Resource Name (ARN) for a backend environment that is part of a Gen 1 Amplify app. This field is available to Amplify Gen 1 apps only where the backend is created using Amplify Studio or the Amplify command line interface (CLI).
    public var backendEnvironmentArn: Swift.String?
    /// The basic authorization credentials for the branch. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The name of the branch.
    /// This member is required.
    public var branchName: Swift.String?
    /// The build specification (build spec) for the branch.
    public var buildSpec: Swift.String?
    /// The description for the branch.
    public var description: Swift.String?
    /// The display name for a branch. This is used as the default domain prefix.
    public var displayName: Swift.String?
    /// Enables auto building for the branch.
    public var enableAutoBuild: Swift.Bool?
    /// Enables basic authorization for the branch.
    public var enableBasicAuth: Swift.Bool?
    /// Enables notifications for the branch.
    public var enableNotification: Swift.Bool?
    /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
    public var enablePerformanceMode: Swift.Bool?
    /// Enables pull request previews for this branch.
    public var enablePullRequestPreview: Swift.Bool?
    /// The environment variables for the branch.
    public var environmentVariables: [Swift.String: Swift.String]?
    /// The framework for the branch.
    public var framework: Swift.String?
    /// The Amplify environment name for the pull request.
    public var pullRequestEnvironmentName: Swift.String?
    /// Describes the current stage for the branch.
    public var stage: AmplifyClientTypes.Stage?
    /// The content Time to Live (TTL) for the website in seconds.
    public var ttl: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backend: AmplifyClientTypes.Backend? = nil,
        backendEnvironmentArn: Swift.String? = nil,
        basicAuthCredentials: Swift.String? = nil,
        branchName: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableAutoBuild: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableNotification: Swift.Bool? = nil,
        enablePerformanceMode: Swift.Bool? = nil,
        enablePullRequestPreview: Swift.Bool? = nil,
        environmentVariables: [Swift.String: Swift.String]? = nil,
        framework: Swift.String? = nil,
        pullRequestEnvironmentName: Swift.String? = nil,
        stage: AmplifyClientTypes.Stage? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backend = backend
        self.backendEnvironmentArn = backendEnvironmentArn
        self.basicAuthCredentials = basicAuthCredentials
        self.branchName = branchName
        self.buildSpec = buildSpec
        self.description = description
        self.displayName = displayName
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enableNotification = enableNotification
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.stage = stage
        self.ttl = ttl
    }
}

extension UpdateBranchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBranchInput(appId: \(Swift.String(describing: appId)), backend: \(Swift.String(describing: backend)), backendEnvironmentArn: \(Swift.String(describing: backendEnvironmentArn)), branchName: \(Swift.String(describing: branchName)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableNotification: \(Swift.String(describing: enableNotification)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), stage: \(Swift.String(describing: stage)), ttl: \(Swift.String(describing: ttl)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

/// The result structure for the update branch request.
public struct UpdateBranchOutput: Swift.Sendable {
    /// The branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

/// The request structure for the update domain association request.
public struct UpdateDomainAssociationInput: Swift.Sendable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// Sets the branch patterns for automatic subdomain creation.
    public var autoSubDomainCreationPatterns: [Swift.String]?
    /// The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
    public var autoSubDomainIAMRole: Swift.String?
    /// The type of SSL/TLS certificate to use for your custom domain.
    public var certificateSettings: AmplifyClientTypes.CertificateSettings?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Enables the automated creation of subdomains for branches.
    public var enableAutoSubDomain: Swift.Bool?
    /// Describes the settings for the subdomain.
    public var subDomainSettings: [AmplifyClientTypes.SubDomainSetting]?

    public init(
        appId: Swift.String? = nil,
        autoSubDomainCreationPatterns: [Swift.String]? = nil,
        autoSubDomainIAMRole: Swift.String? = nil,
        certificateSettings: AmplifyClientTypes.CertificateSettings? = nil,
        domainName: Swift.String? = nil,
        enableAutoSubDomain: Swift.Bool? = nil,
        subDomainSettings: [AmplifyClientTypes.SubDomainSetting]? = nil
    )
    {
        self.appId = appId
        self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
        self.autoSubDomainIAMRole = autoSubDomainIAMRole
        self.certificateSettings = certificateSettings
        self.domainName = domainName
        self.enableAutoSubDomain = enableAutoSubDomain
        self.subDomainSettings = subDomainSettings
    }
}

/// The result structure for the update domain association request.
public struct UpdateDomainAssociationOutput: Swift.Sendable {
    /// Describes a domain association, which associates a custom domain with an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

/// The request structure for the update webhook request.
public struct UpdateWebhookInput: Swift.Sendable {
    /// The name for a branch that is part of an Amplify app.
    public var branchName: Swift.String?
    /// The description for a webhook.
    public var description: Swift.String?
    /// The unique ID for a webhook.
    /// This member is required.
    public var webhookId: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        description: Swift.String? = nil,
        webhookId: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.description = description
        self.webhookId = webhookId
    }
}

/// The result structure for the update webhook request.
public struct UpdateWebhookOutput: Swift.Sendable {
    /// Describes a webhook that connects repository events to an Amplify app.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

extension CreateAppInput {

    static func urlPathProvider(_ value: CreateAppInput) -> Swift.String? {
        return "/apps"
    }
}

extension CreateBackendEnvironmentInput {

    static func urlPathProvider(_ value: CreateBackendEnvironmentInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments"
    }
}

extension CreateBranchInput {

    static func urlPathProvider(_ value: CreateBranchInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches"
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/deployments"
    }
}

extension CreateDomainAssociationInput {

    static func urlPathProvider(_ value: CreateDomainAssociationInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains"
    }
}

extension CreateWebhookInput {

    static func urlPathProvider(_ value: CreateWebhookInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/webhooks"
    }
}

extension DeleteAppInput {

    static func urlPathProvider(_ value: DeleteAppInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())"
    }
}

extension DeleteBackendEnvironmentInput {

    static func urlPathProvider(_ value: DeleteBackendEnvironmentInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let environmentName = value.environmentName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments/\(environmentName.urlPercentEncoding())"
    }
}

extension DeleteBranchInput {

    static func urlPathProvider(_ value: DeleteBranchInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())"
    }
}

extension DeleteDomainAssociationInput {

    static func urlPathProvider(_ value: DeleteDomainAssociationInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let domainName = value.domainName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteJobInput {

    static func urlPathProvider(_ value: DeleteJobInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension DeleteWebhookInput {

    static func urlPathProvider(_ value: DeleteWebhookInput) -> Swift.String? {
        guard let webhookId = value.webhookId else {
            return nil
        }
        return "/webhooks/\(webhookId.urlPercentEncoding())"
    }
}

extension GenerateAccessLogsInput {

    static func urlPathProvider(_ value: GenerateAccessLogsInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/accesslogs"
    }
}

extension GetAppInput {

    static func urlPathProvider(_ value: GetAppInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())"
    }
}

extension GetArtifactUrlInput {

    static func urlPathProvider(_ value: GetArtifactUrlInput) -> Swift.String? {
        guard let artifactId = value.artifactId else {
            return nil
        }
        return "/artifacts/\(artifactId.urlPercentEncoding())"
    }
}

extension GetBackendEnvironmentInput {

    static func urlPathProvider(_ value: GetBackendEnvironmentInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let environmentName = value.environmentName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments/\(environmentName.urlPercentEncoding())"
    }
}

extension GetBranchInput {

    static func urlPathProvider(_ value: GetBranchInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())"
    }
}

extension GetDomainAssociationInput {

    static func urlPathProvider(_ value: GetDomainAssociationInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let domainName = value.domainName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains/\(domainName.urlPercentEncoding())"
    }
}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetWebhookInput {

    static func urlPathProvider(_ value: GetWebhookInput) -> Swift.String? {
        guard let webhookId = value.webhookId else {
            return nil
        }
        return "/webhooks/\(webhookId.urlPercentEncoding())"
    }
}

extension ListAppsInput {

    static func urlPathProvider(_ value: ListAppsInput) -> Swift.String? {
        return "/apps"
    }
}

extension ListAppsInput {

    static func queryItemProvider(_ value: ListAppsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListArtifactsInput {

    static func urlPathProvider(_ value: ListArtifactsInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/artifacts"
    }
}

extension ListArtifactsInput {

    static func queryItemProvider(_ value: ListArtifactsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBackendEnvironmentsInput {

    static func urlPathProvider(_ value: ListBackendEnvironmentsInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments"
    }
}

extension ListBackendEnvironmentsInput {

    static func queryItemProvider(_ value: ListBackendEnvironmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let environmentName = value.environmentName {
            let environmentNameQueryItem = Smithy.URIQueryItem(name: "environmentName".urlPercentEncoding(), value: Swift.String(environmentName).urlPercentEncoding())
            items.append(environmentNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBranchesInput {

    static func urlPathProvider(_ value: ListBranchesInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches"
    }
}

extension ListBranchesInput {

    static func queryItemProvider(_ value: ListBranchesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainAssociationsInput {

    static func urlPathProvider(_ value: ListDomainAssociationsInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains"
    }
}

extension ListDomainAssociationsInput {

    static func queryItemProvider(_ value: ListDomainAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs"
    }
}

extension ListJobsInput {

    static func queryItemProvider(_ value: ListJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWebhooksInput {

    static func urlPathProvider(_ value: ListWebhooksInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/webhooks"
    }
}

extension ListWebhooksInput {

    static func queryItemProvider(_ value: ListWebhooksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension StartDeploymentInput {

    static func urlPathProvider(_ value: StartDeploymentInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/deployments/start"
    }
}

extension StartJobInput {

    static func urlPathProvider(_ value: StartJobInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs"
    }
}

extension StopJobInput {

    static func urlPathProvider(_ value: StopJobInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAppInput {

    static func urlPathProvider(_ value: UpdateAppInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())"
    }
}

extension UpdateBranchInput {

    static func urlPathProvider(_ value: UpdateBranchInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let branchName = value.branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())"
    }
}

extension UpdateDomainAssociationInput {

    static func urlPathProvider(_ value: UpdateDomainAssociationInput) -> Swift.String? {
        guard let appId = value.appId else {
            return nil
        }
        guard let domainName = value.domainName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains/\(domainName.urlPercentEncoding())"
    }
}

extension UpdateWebhookInput {

    static func urlPathProvider(_ value: UpdateWebhookInput) -> Swift.String? {
        guard let webhookId = value.webhookId else {
            return nil
        }
        return "/webhooks/\(webhookId.urlPercentEncoding())"
    }
}

extension CreateAppInput {

    static func write(value: CreateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["autoBranchCreationConfig"].write(value.autoBranchCreationConfig, with: AmplifyClientTypes.AutoBranchCreationConfig.write(value:to:))
        try writer["autoBranchCreationPatterns"].writeList(value.autoBranchCreationPatterns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["basicAuthCredentials"].write(value.basicAuthCredentials)
        try writer["buildSpec"].write(value.buildSpec)
        try writer["cacheConfig"].write(value.cacheConfig, with: AmplifyClientTypes.CacheConfig.write(value:to:))
        try writer["customHeaders"].write(value.customHeaders)
        try writer["customRules"].writeList(value.customRules, memberWritingClosure: AmplifyClientTypes.CustomRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["enableAutoBranchCreation"].write(value.enableAutoBranchCreation)
        try writer["enableBasicAuth"].write(value.enableBasicAuth)
        try writer["enableBranchAutoBuild"].write(value.enableBranchAutoBuild)
        try writer["enableBranchAutoDeletion"].write(value.enableBranchAutoDeletion)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["iamServiceRoleArn"].write(value.iamServiceRoleArn)
        try writer["name"].write(value.name)
        try writer["oauthToken"].write(value.oauthToken)
        try writer["platform"].write(value.platform)
        try writer["repository"].write(value.repository)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateBackendEnvironmentInput {

    static func write(value: CreateBackendEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentArtifacts"].write(value.deploymentArtifacts)
        try writer["environmentName"].write(value.environmentName)
        try writer["stackName"].write(value.stackName)
    }
}

extension CreateBranchInput {

    static func write(value: CreateBranchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["backend"].write(value.backend, with: AmplifyClientTypes.Backend.write(value:to:))
        try writer["backendEnvironmentArn"].write(value.backendEnvironmentArn)
        try writer["basicAuthCredentials"].write(value.basicAuthCredentials)
        try writer["branchName"].write(value.branchName)
        try writer["buildSpec"].write(value.buildSpec)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["enableAutoBuild"].write(value.enableAutoBuild)
        try writer["enableBasicAuth"].write(value.enableBasicAuth)
        try writer["enableNotification"].write(value.enableNotification)
        try writer["enablePerformanceMode"].write(value.enablePerformanceMode)
        try writer["enablePullRequestPreview"].write(value.enablePullRequestPreview)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["framework"].write(value.framework)
        try writer["pullRequestEnvironmentName"].write(value.pullRequestEnvironmentName)
        try writer["stage"].write(value.stage)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ttl"].write(value.ttl)
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileMap"].writeMap(value.fileMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDomainAssociationInput {

    static func write(value: CreateDomainAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoSubDomainCreationPatterns"].writeList(value.autoSubDomainCreationPatterns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["autoSubDomainIAMRole"].write(value.autoSubDomainIAMRole)
        try writer["certificateSettings"].write(value.certificateSettings, with: AmplifyClientTypes.CertificateSettings.write(value:to:))
        try writer["domainName"].write(value.domainName)
        try writer["enableAutoSubDomain"].write(value.enableAutoSubDomain)
        try writer["subDomainSettings"].writeList(value.subDomainSettings, memberWritingClosure: AmplifyClientTypes.SubDomainSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWebhookInput {

    static func write(value: CreateWebhookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["description"].write(value.description)
    }
}

extension GenerateAccessLogsInput {

    static func write(value: GenerateAccessLogsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension StartDeploymentInput {

    static func write(value: StartDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
        try writer["sourceUrl"].write(value.sourceUrl)
        try writer["sourceUrlType"].write(value.sourceUrlType)
    }
}

extension StartJobInput {

    static func write(value: StartJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitId"].write(value.commitId)
        try writer["commitMessage"].write(value.commitMessage)
        try writer["commitTime"].writeTimestamp(value.commitTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["jobId"].write(value.jobId)
        try writer["jobReason"].write(value.jobReason)
        try writer["jobType"].write(value.jobType)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAppInput {

    static func write(value: UpdateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["autoBranchCreationConfig"].write(value.autoBranchCreationConfig, with: AmplifyClientTypes.AutoBranchCreationConfig.write(value:to:))
        try writer["autoBranchCreationPatterns"].writeList(value.autoBranchCreationPatterns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["basicAuthCredentials"].write(value.basicAuthCredentials)
        try writer["buildSpec"].write(value.buildSpec)
        try writer["cacheConfig"].write(value.cacheConfig, with: AmplifyClientTypes.CacheConfig.write(value:to:))
        try writer["customHeaders"].write(value.customHeaders)
        try writer["customRules"].writeList(value.customRules, memberWritingClosure: AmplifyClientTypes.CustomRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["enableAutoBranchCreation"].write(value.enableAutoBranchCreation)
        try writer["enableBasicAuth"].write(value.enableBasicAuth)
        try writer["enableBranchAutoBuild"].write(value.enableBranchAutoBuild)
        try writer["enableBranchAutoDeletion"].write(value.enableBranchAutoDeletion)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["iamServiceRoleArn"].write(value.iamServiceRoleArn)
        try writer["name"].write(value.name)
        try writer["oauthToken"].write(value.oauthToken)
        try writer["platform"].write(value.platform)
        try writer["repository"].write(value.repository)
    }
}

extension UpdateBranchInput {

    static func write(value: UpdateBranchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["backend"].write(value.backend, with: AmplifyClientTypes.Backend.write(value:to:))
        try writer["backendEnvironmentArn"].write(value.backendEnvironmentArn)
        try writer["basicAuthCredentials"].write(value.basicAuthCredentials)
        try writer["buildSpec"].write(value.buildSpec)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["enableAutoBuild"].write(value.enableAutoBuild)
        try writer["enableBasicAuth"].write(value.enableBasicAuth)
        try writer["enableNotification"].write(value.enableNotification)
        try writer["enablePerformanceMode"].write(value.enablePerformanceMode)
        try writer["enablePullRequestPreview"].write(value.enablePullRequestPreview)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["framework"].write(value.framework)
        try writer["pullRequestEnvironmentName"].write(value.pullRequestEnvironmentName)
        try writer["stage"].write(value.stage)
        try writer["ttl"].write(value.ttl)
    }
}

extension UpdateDomainAssociationInput {

    static func write(value: UpdateDomainAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoSubDomainCreationPatterns"].writeList(value.autoSubDomainCreationPatterns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["autoSubDomainIAMRole"].write(value.autoSubDomainIAMRole)
        try writer["certificateSettings"].write(value.certificateSettings, with: AmplifyClientTypes.CertificateSettings.write(value:to:))
        try writer["enableAutoSubDomain"].write(value.enableAutoSubDomain)
        try writer["subDomainSettings"].writeList(value.subDomainSettings, memberWritingClosure: AmplifyClientTypes.SubDomainSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateWebhookInput {

    static func write(value: UpdateWebhookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["description"].write(value.description)
    }
}

extension CreateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppOutput()
        value.app = try reader["app"].readIfPresent(with: AmplifyClientTypes.App.read(from:))
        return value
    }
}

extension CreateBackendEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBackendEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBackendEnvironmentOutput()
        value.backendEnvironment = try reader["backendEnvironment"].readIfPresent(with: AmplifyClientTypes.BackendEnvironment.read(from:))
        return value
    }
}

extension CreateBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBranchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBranchOutput()
        value.branch = try reader["branch"].readIfPresent(with: AmplifyClientTypes.Branch.read(from:))
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.fileUploadUrls = try reader["fileUploadUrls"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.jobId = try reader["jobId"].readIfPresent()
        value.zipUploadUrl = try reader["zipUploadUrl"].readIfPresent() ?? ""
        return value
    }
}

extension CreateDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainAssociationOutput()
        value.domainAssociation = try reader["domainAssociation"].readIfPresent(with: AmplifyClientTypes.DomainAssociation.read(from:))
        return value
    }
}

extension CreateWebhookOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWebhookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWebhookOutput()
        value.webhook = try reader["webhook"].readIfPresent(with: AmplifyClientTypes.Webhook.read(from:))
        return value
    }
}

extension DeleteAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAppOutput()
        value.app = try reader["app"].readIfPresent(with: AmplifyClientTypes.App.read(from:))
        return value
    }
}

extension DeleteBackendEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBackendEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBackendEnvironmentOutput()
        value.backendEnvironment = try reader["backendEnvironment"].readIfPresent(with: AmplifyClientTypes.BackendEnvironment.read(from:))
        return value
    }
}

extension DeleteBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBranchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBranchOutput()
        value.branch = try reader["branch"].readIfPresent(with: AmplifyClientTypes.Branch.read(from:))
        return value
    }
}

extension DeleteDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainAssociationOutput()
        value.domainAssociation = try reader["domainAssociation"].readIfPresent(with: AmplifyClientTypes.DomainAssociation.read(from:))
        return value
    }
}

extension DeleteJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteJobOutput()
        value.jobSummary = try reader["jobSummary"].readIfPresent(with: AmplifyClientTypes.JobSummary.read(from:))
        return value
    }
}

extension DeleteWebhookOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWebhookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWebhookOutput()
        value.webhook = try reader["webhook"].readIfPresent(with: AmplifyClientTypes.Webhook.read(from:))
        return value
    }
}

extension GenerateAccessLogsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateAccessLogsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateAccessLogsOutput()
        value.logUrl = try reader["logUrl"].readIfPresent()
        return value
    }
}

extension GetAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppOutput()
        value.app = try reader["app"].readIfPresent(with: AmplifyClientTypes.App.read(from:))
        return value
    }
}

extension GetArtifactUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArtifactUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArtifactUrlOutput()
        value.artifactId = try reader["artifactId"].readIfPresent() ?? ""
        value.artifactUrl = try reader["artifactUrl"].readIfPresent() ?? ""
        return value
    }
}

extension GetBackendEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBackendEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBackendEnvironmentOutput()
        value.backendEnvironment = try reader["backendEnvironment"].readIfPresent(with: AmplifyClientTypes.BackendEnvironment.read(from:))
        return value
    }
}

extension GetBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBranchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBranchOutput()
        value.branch = try reader["branch"].readIfPresent(with: AmplifyClientTypes.Branch.read(from:))
        return value
    }
}

extension GetDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainAssociationOutput()
        value.domainAssociation = try reader["domainAssociation"].readIfPresent(with: AmplifyClientTypes.DomainAssociation.read(from:))
        return value
    }
}

extension GetJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobOutput()
        value.job = try reader["job"].readIfPresent(with: AmplifyClientTypes.Job.read(from:))
        return value
    }
}

extension GetWebhookOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWebhookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWebhookOutput()
        value.webhook = try reader["webhook"].readIfPresent(with: AmplifyClientTypes.Webhook.read(from:))
        return value
    }
}

extension ListAppsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppsOutput()
        value.apps = try reader["apps"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.App.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListArtifactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListArtifactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListArtifactsOutput()
        value.artifacts = try reader["artifacts"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.Artifact.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBackendEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBackendEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBackendEnvironmentsOutput()
        value.backendEnvironments = try reader["backendEnvironments"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.BackendEnvironment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBranchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBranchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBranchesOutput()
        value.branches = try reader["branches"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.Branch.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDomainAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainAssociationsOutput()
        value.domainAssociations = try reader["domainAssociations"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.DomainAssociation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobsOutput()
        value.jobSummaries = try reader["jobSummaries"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWebhooksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWebhooksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWebhooksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.webhooks = try reader["webhooks"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.Webhook.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension StartDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDeploymentOutput()
        value.jobSummary = try reader["jobSummary"].readIfPresent(with: AmplifyClientTypes.JobSummary.read(from:))
        return value
    }
}

extension StartJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartJobOutput()
        value.jobSummary = try reader["jobSummary"].readIfPresent(with: AmplifyClientTypes.JobSummary.read(from:))
        return value
    }
}

extension StopJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopJobOutput()
        value.jobSummary = try reader["jobSummary"].readIfPresent(with: AmplifyClientTypes.JobSummary.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAppOutput()
        value.app = try reader["app"].readIfPresent(with: AmplifyClientTypes.App.read(from:))
        return value
    }
}

extension UpdateBranchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBranchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBranchOutput()
        value.branch = try reader["branch"].readIfPresent(with: AmplifyClientTypes.Branch.read(from:))
        return value
    }
}

extension UpdateDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainAssociationOutput()
        value.domainAssociation = try reader["domainAssociation"].readIfPresent(with: AmplifyClientTypes.DomainAssociation.read(from:))
        return value
    }
}

extension UpdateWebhookOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWebhookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWebhookOutput()
        value.webhook = try reader["webhook"].readIfPresent(with: AmplifyClientTypes.Webhook.read(from:))
        return value
    }
}

enum CreateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBackendEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWebhookOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBackendEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWebhookOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateAccessLogsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArtifactUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBackendEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWebhookOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListArtifactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBackendEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBranchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWebhooksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBranchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWebhookOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "DependentServiceFailureException": return try DependentServiceFailureException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependentServiceFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependentServiceFailureException {
        let reader = baseError.errorBodyReader
        var value = DependentServiceFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["code"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AmplifyClientTypes.App {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.App {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.App()
        value.appId = try reader["appId"].readIfPresent() ?? ""
        value.appArn = try reader["appArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.description = try reader["description"].readIfPresent() ?? ""
        value.repository = try reader["repository"].readIfPresent() ?? ""
        value.platform = try reader["platform"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.iamServiceRoleArn = try reader["iamServiceRoleArn"].readIfPresent()
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.defaultDomain = try reader["defaultDomain"].readIfPresent() ?? ""
        value.enableBranchAutoBuild = try reader["enableBranchAutoBuild"].readIfPresent() ?? false
        value.enableBranchAutoDeletion = try reader["enableBranchAutoDeletion"].readIfPresent()
        value.enableBasicAuth = try reader["enableBasicAuth"].readIfPresent() ?? false
        value.basicAuthCredentials = try reader["basicAuthCredentials"].readIfPresent()
        value.customRules = try reader["customRules"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.CustomRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.productionBranch = try reader["productionBranch"].readIfPresent(with: AmplifyClientTypes.ProductionBranch.read(from:))
        value.buildSpec = try reader["buildSpec"].readIfPresent()
        value.customHeaders = try reader["customHeaders"].readIfPresent()
        value.enableAutoBranchCreation = try reader["enableAutoBranchCreation"].readIfPresent()
        value.autoBranchCreationPatterns = try reader["autoBranchCreationPatterns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoBranchCreationConfig = try reader["autoBranchCreationConfig"].readIfPresent(with: AmplifyClientTypes.AutoBranchCreationConfig.read(from:))
        value.repositoryCloneMethod = try reader["repositoryCloneMethod"].readIfPresent()
        value.cacheConfig = try reader["cacheConfig"].readIfPresent(with: AmplifyClientTypes.CacheConfig.read(from:))
        return value
    }
}

extension AmplifyClientTypes.CacheConfig {

    static func write(value: AmplifyClientTypes.CacheConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.CacheConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.CacheConfig()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AmplifyClientTypes.AutoBranchCreationConfig {

    static func write(value: AmplifyClientTypes.AutoBranchCreationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["basicAuthCredentials"].write(value.basicAuthCredentials)
        try writer["buildSpec"].write(value.buildSpec)
        try writer["enableAutoBuild"].write(value.enableAutoBuild)
        try writer["enableBasicAuth"].write(value.enableBasicAuth)
        try writer["enablePerformanceMode"].write(value.enablePerformanceMode)
        try writer["enablePullRequestPreview"].write(value.enablePullRequestPreview)
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["framework"].write(value.framework)
        try writer["pullRequestEnvironmentName"].write(value.pullRequestEnvironmentName)
        try writer["stage"].write(value.stage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.AutoBranchCreationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.AutoBranchCreationConfig()
        value.stage = try reader["stage"].readIfPresent()
        value.framework = try reader["framework"].readIfPresent()
        value.enableAutoBuild = try reader["enableAutoBuild"].readIfPresent()
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.basicAuthCredentials = try reader["basicAuthCredentials"].readIfPresent()
        value.enableBasicAuth = try reader["enableBasicAuth"].readIfPresent()
        value.enablePerformanceMode = try reader["enablePerformanceMode"].readIfPresent()
        value.buildSpec = try reader["buildSpec"].readIfPresent()
        value.enablePullRequestPreview = try reader["enablePullRequestPreview"].readIfPresent()
        value.pullRequestEnvironmentName = try reader["pullRequestEnvironmentName"].readIfPresent()
        return value
    }
}

extension AmplifyClientTypes.ProductionBranch {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.ProductionBranch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.ProductionBranch()
        value.lastDeployTime = try reader["lastDeployTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.thumbnailUrl = try reader["thumbnailUrl"].readIfPresent()
        value.branchName = try reader["branchName"].readIfPresent()
        return value
    }
}

extension AmplifyClientTypes.CustomRule {

    static func write(value: AmplifyClientTypes.CustomRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["condition"].write(value.condition)
        try writer["source"].write(value.source)
        try writer["status"].write(value.status)
        try writer["target"].write(value.target)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.CustomRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.CustomRule()
        value.source = try reader["source"].readIfPresent() ?? ""
        value.target = try reader["target"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.condition = try reader["condition"].readIfPresent()
        return value
    }
}

extension AmplifyClientTypes.BackendEnvironment {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.BackendEnvironment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.BackendEnvironment()
        value.backendEnvironmentArn = try reader["backendEnvironmentArn"].readIfPresent() ?? ""
        value.environmentName = try reader["environmentName"].readIfPresent() ?? ""
        value.stackName = try reader["stackName"].readIfPresent()
        value.deploymentArtifacts = try reader["deploymentArtifacts"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AmplifyClientTypes.Branch {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.Branch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.Branch()
        value.branchArn = try reader["branchArn"].readIfPresent() ?? ""
        value.branchName = try reader["branchName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stage = try reader["stage"].readIfPresent() ?? .sdkUnknown("")
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.enableNotification = try reader["enableNotification"].readIfPresent() ?? false
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.environmentVariables = try reader["environmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.enableAutoBuild = try reader["enableAutoBuild"].readIfPresent() ?? false
        value.customDomains = try reader["customDomains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.framework = try reader["framework"].readIfPresent() ?? ""
        value.activeJobId = try reader["activeJobId"].readIfPresent() ?? ""
        value.totalNumberOfJobs = try reader["totalNumberOfJobs"].readIfPresent() ?? ""
        value.enableBasicAuth = try reader["enableBasicAuth"].readIfPresent() ?? false
        value.enablePerformanceMode = try reader["enablePerformanceMode"].readIfPresent()
        value.thumbnailUrl = try reader["thumbnailUrl"].readIfPresent()
        value.basicAuthCredentials = try reader["basicAuthCredentials"].readIfPresent()
        value.buildSpec = try reader["buildSpec"].readIfPresent()
        value.ttl = try reader["ttl"].readIfPresent() ?? ""
        value.associatedResources = try reader["associatedResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.enablePullRequestPreview = try reader["enablePullRequestPreview"].readIfPresent() ?? false
        value.pullRequestEnvironmentName = try reader["pullRequestEnvironmentName"].readIfPresent()
        value.destinationBranch = try reader["destinationBranch"].readIfPresent()
        value.sourceBranch = try reader["sourceBranch"].readIfPresent()
        value.backendEnvironmentArn = try reader["backendEnvironmentArn"].readIfPresent()
        value.backend = try reader["backend"].readIfPresent(with: AmplifyClientTypes.Backend.read(from:))
        return value
    }
}

extension AmplifyClientTypes.Backend {

    static func write(value: AmplifyClientTypes.Backend?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stackArn"].write(value.stackArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.Backend {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.Backend()
        value.stackArn = try reader["stackArn"].readIfPresent()
        return value
    }
}

extension AmplifyClientTypes.DomainAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.DomainAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.DomainAssociation()
        value.domainAssociationArn = try reader["domainAssociationArn"].readIfPresent() ?? ""
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.enableAutoSubDomain = try reader["enableAutoSubDomain"].readIfPresent() ?? false
        value.autoSubDomainCreationPatterns = try reader["autoSubDomainCreationPatterns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoSubDomainIAMRole = try reader["autoSubDomainIAMRole"].readIfPresent()
        value.domainStatus = try reader["domainStatus"].readIfPresent() ?? .sdkUnknown("")
        value.updateStatus = try reader["updateStatus"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent() ?? ""
        value.certificateVerificationDNSRecord = try reader["certificateVerificationDNSRecord"].readIfPresent()
        value.subDomains = try reader["subDomains"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.SubDomain.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.certificate = try reader["certificate"].readIfPresent(with: AmplifyClientTypes.Certificate.read(from:))
        return value
    }
}

extension AmplifyClientTypes.Certificate {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.Certificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.Certificate()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.customCertificateArn = try reader["customCertificateArn"].readIfPresent()
        value.certificateVerificationDNSRecord = try reader["certificateVerificationDNSRecord"].readIfPresent()
        return value
    }
}

extension AmplifyClientTypes.SubDomain {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.SubDomain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.SubDomain()
        value.subDomainSetting = try reader["subDomainSetting"].readIfPresent(with: AmplifyClientTypes.SubDomainSetting.read(from:))
        value.verified = try reader["verified"].readIfPresent() ?? false
        value.dnsRecord = try reader["dnsRecord"].readIfPresent() ?? ""
        return value
    }
}

extension AmplifyClientTypes.SubDomainSetting {

    static func write(value: AmplifyClientTypes.SubDomainSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["branchName"].write(value.branchName)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.SubDomainSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.SubDomainSetting()
        value.`prefix` = try reader["prefix"].readIfPresent() ?? ""
        value.branchName = try reader["branchName"].readIfPresent() ?? ""
        return value
    }
}

extension AmplifyClientTypes.Webhook {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.Webhook {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.Webhook()
        value.webhookArn = try reader["webhookArn"].readIfPresent() ?? ""
        value.webhookId = try reader["webhookId"].readIfPresent() ?? ""
        value.webhookUrl = try reader["webhookUrl"].readIfPresent() ?? ""
        value.branchName = try reader["branchName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AmplifyClientTypes.JobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.JobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.JobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.commitId = try reader["commitId"].readIfPresent() ?? ""
        value.commitMessage = try reader["commitMessage"].readIfPresent() ?? ""
        value.commitTime = try reader["commitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobType = try reader["jobType"].readIfPresent() ?? .sdkUnknown("")
        value.sourceUrl = try reader["sourceUrl"].readIfPresent()
        value.sourceUrlType = try reader["sourceUrlType"].readIfPresent()
        return value
    }
}

extension AmplifyClientTypes.Job {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.Job {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.Job()
        value.summary = try reader["summary"].readIfPresent(with: AmplifyClientTypes.JobSummary.read(from:))
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: AmplifyClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AmplifyClientTypes.Step {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.Step {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.Step()
        value.stepName = try reader["stepName"].readIfPresent() ?? ""
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.logUrl = try reader["logUrl"].readIfPresent()
        value.artifactsUrl = try reader["artifactsUrl"].readIfPresent()
        value.testArtifactsUrl = try reader["testArtifactsUrl"].readIfPresent()
        value.testConfigUrl = try reader["testConfigUrl"].readIfPresent()
        value.screenshots = try reader["screenshots"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.context = try reader["context"].readIfPresent()
        return value
    }
}

extension AmplifyClientTypes.Artifact {

    static func read(from reader: SmithyJSON.Reader) throws -> AmplifyClientTypes.Artifact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AmplifyClientTypes.Artifact()
        value.artifactFileName = try reader["artifactFileName"].readIfPresent() ?? ""
        value.artifactId = try reader["artifactId"].readIfPresent() ?? ""
        return value
    }
}

extension AmplifyClientTypes.CertificateSettings {

    static func write(value: AmplifyClientTypes.CertificateSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customCertificateArn"].write(value.customCertificateArn)
        try writer["type"].write(value.type)
    }
}

public enum AmplifyClientTypes {}
