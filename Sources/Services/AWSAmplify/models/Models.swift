// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AmplifyClientTypes.App: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appId
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case createTime
        case customHeaders
        case customRules
        case defaultDomain
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case platform
        case productionBranch
        case repository
        case repositoryCloneMethod
        case tags
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let autoBranchCreationConfig = self.autoBranchCreationConfig {
            try encodeContainer.encode(autoBranchCreationConfig, forKey: .autoBranchCreationConfig)
        }
        if let autoBranchCreationPatterns = autoBranchCreationPatterns {
            var autoBranchCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoBranchCreationPatterns)
            for autobranchcreationpattern0 in autoBranchCreationPatterns {
                try autoBranchCreationPatternsContainer.encode(autobranchcreationpattern0)
            }
        }
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = self.buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let customHeaders = self.customHeaders {
            try encodeContainer.encode(customHeaders, forKey: .customHeaders)
        }
        if let customRules = customRules {
            var customRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customRules)
            for customrule0 in customRules {
                try customRulesContainer.encode(customrule0)
            }
        }
        if let defaultDomain = self.defaultDomain {
            try encodeContainer.encode(defaultDomain, forKey: .defaultDomain)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableAutoBranchCreation = self.enableAutoBranchCreation {
            try encodeContainer.encode(enableAutoBranchCreation, forKey: .enableAutoBranchCreation)
        }
        if let enableBasicAuth = self.enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableBranchAutoBuild = self.enableBranchAutoBuild {
            try encodeContainer.encode(enableBranchAutoBuild, forKey: .enableBranchAutoBuild)
        }
        if let enableBranchAutoDeletion = self.enableBranchAutoDeletion {
            try encodeContainer.encode(enableBranchAutoDeletion, forKey: .enableBranchAutoDeletion)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let iamServiceRoleArn = self.iamServiceRoleArn {
            try encodeContainer.encode(iamServiceRoleArn, forKey: .iamServiceRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let productionBranch = self.productionBranch {
            try encodeContainer.encode(productionBranch, forKey: .productionBranch)
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let repositoryCloneMethod = self.repositoryCloneMethod {
            try encodeContainer.encode(repositoryCloneMethod.rawValue, forKey: .repositoryCloneMethod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let iamServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamServiceRoleArn)
        iamServiceRoleArn = iamServiceRoleArnDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let defaultDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultDomain)
        defaultDomain = defaultDomainDecoded
        let enableBranchAutoBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBranchAutoBuild)
        enableBranchAutoBuild = enableBranchAutoBuildDecoded
        let enableBranchAutoDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBranchAutoDeletion)
        enableBranchAutoDeletion = enableBranchAutoDeletionDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let customRulesContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.CustomRule?].self, forKey: .customRules)
        var customRulesDecoded0:[AmplifyClientTypes.CustomRule]? = nil
        if let customRulesContainer = customRulesContainer {
            customRulesDecoded0 = [AmplifyClientTypes.CustomRule]()
            for structure0 in customRulesContainer {
                if let structure0 = structure0 {
                    customRulesDecoded0?.append(structure0)
                }
            }
        }
        customRules = customRulesDecoded0
        let productionBranchDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.ProductionBranch.self, forKey: .productionBranch)
        productionBranch = productionBranchDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let enableAutoBranchCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoBranchCreation)
        enableAutoBranchCreation = enableAutoBranchCreationDecoded
        let autoBranchCreationPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoBranchCreationPatterns)
        var autoBranchCreationPatternsDecoded0:[Swift.String]? = nil
        if let autoBranchCreationPatternsContainer = autoBranchCreationPatternsContainer {
            autoBranchCreationPatternsDecoded0 = [Swift.String]()
            for string0 in autoBranchCreationPatternsContainer {
                if let string0 = string0 {
                    autoBranchCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoBranchCreationPatterns = autoBranchCreationPatternsDecoded0
        let autoBranchCreationConfigDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.AutoBranchCreationConfig.self, forKey: .autoBranchCreationConfig)
        autoBranchCreationConfig = autoBranchCreationConfigDecoded
        let repositoryCloneMethodDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.RepositoryCloneMethod.self, forKey: .repositoryCloneMethod)
        repositoryCloneMethod = repositoryCloneMethodDecoded
    }
}

extension AmplifyClientTypes.App: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "App(appArn: \(Swift.String(describing: appArn)), appId: \(Swift.String(describing: appId)), autoBranchCreationConfig: \(Swift.String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(Swift.String(describing: autoBranchCreationPatterns)), createTime: \(Swift.String(describing: createTime)), customHeaders: \(Swift.String(describing: customHeaders)), customRules: \(Swift.String(describing: customRules)), defaultDomain: \(Swift.String(describing: defaultDomain)), description: \(Swift.String(describing: description)), enableAutoBranchCreation: \(Swift.String(describing: enableAutoBranchCreation)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableBranchAutoBuild: \(Swift.String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(Swift.String(describing: enableBranchAutoDeletion)), environmentVariables: \(Swift.String(describing: environmentVariables)), iamServiceRoleArn: \(Swift.String(describing: iamServiceRoleArn)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), productionBranch: \(Swift.String(describing: productionBranch)), repository: \(Swift.String(describing: repository)), repositoryCloneMethod: \(Swift.String(describing: repositoryCloneMethod)), tags: \(Swift.String(describing: tags)), updateTime: \(Swift.String(describing: updateTime)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

extension AmplifyClientTypes {
    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    public struct App: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amplify app.
        /// This member is required.
        public var appArn: Swift.String?
        /// The unique ID of the Amplify app.
        /// This member is required.
        public var appId: Swift.String?
        /// Describes the automated branch creation configuration for the Amplify app.
        public var autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
        /// Describes the automated branch creation glob patterns for the Amplify app.
        public var autoBranchCreationPatterns: [Swift.String]?
        /// The basic authorization credentials for branches for the Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public var basicAuthCredentials: Swift.String?
        /// Describes the content of the build specification (build spec) for the Amplify app.
        public var buildSpec: Swift.String?
        /// Creates a date and time for the Amplify app.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// Describes the custom HTTP headers for the Amplify app.
        public var customHeaders: Swift.String?
        /// Describes the custom redirect and rewrite rules for the Amplify app.
        public var customRules: [AmplifyClientTypes.CustomRule]?
        /// The default domain for the Amplify app.
        /// This member is required.
        public var defaultDomain: Swift.String?
        /// The description for the Amplify app.
        /// This member is required.
        public var description: Swift.String?
        /// Enables automated branch creation for the Amplify app.
        public var enableAutoBranchCreation: Swift.Bool?
        /// Enables basic authorization for the Amplify app's branches.
        /// This member is required.
        public var enableBasicAuth: Swift.Bool?
        /// Enables the auto-building of branches for the Amplify app.
        /// This member is required.
        public var enableBranchAutoBuild: Swift.Bool?
        /// Automatically disconnect a branch in the Amplify Console when you delete a branch from your Git repository.
        public var enableBranchAutoDeletion: Swift.Bool?
        /// The environment variables for the Amplify app.
        /// This member is required.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) of the Amplify app.
        public var iamServiceRoleArn: Swift.String?
        /// The name for the Amplify app.
        /// This member is required.
        public var name: Swift.String?
        /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC.
        /// This member is required.
        public var platform: AmplifyClientTypes.Platform?
        /// Describes the information about a production branch of the Amplify app.
        public var productionBranch: AmplifyClientTypes.ProductionBranch?
        /// The Git repository for the Amplify app.
        /// This member is required.
        public var repository: Swift.String?
        /// This is for internal use. The Amplify service uses this parameter to specify the authentication protocol to use to access the Git repository for an Amplify app. Amplify specifies TOKEN for a GitHub repository, SIGV4 for an Amazon Web Services CodeCommit repository, and SSH for GitLab and Bitbucket repositories.
        public var repositoryCloneMethod: AmplifyClientTypes.RepositoryCloneMethod?
        /// The tag for the Amplify app.
        public var tags: [Swift.String:Swift.String]?
        /// Updates the date and time for the Amplify app.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            appArn: Swift.String? = nil,
            appId: Swift.String? = nil,
            autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig? = nil,
            autoBranchCreationPatterns: [Swift.String]? = nil,
            basicAuthCredentials: Swift.String? = nil,
            buildSpec: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            customHeaders: Swift.String? = nil,
            customRules: [AmplifyClientTypes.CustomRule]? = nil,
            defaultDomain: Swift.String? = nil,
            description: Swift.String? = nil,
            enableAutoBranchCreation: Swift.Bool? = nil,
            enableBasicAuth: Swift.Bool? = nil,
            enableBranchAutoBuild: Swift.Bool? = nil,
            enableBranchAutoDeletion: Swift.Bool? = nil,
            environmentVariables: [Swift.String:Swift.String]? = nil,
            iamServiceRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: AmplifyClientTypes.Platform? = nil,
            productionBranch: AmplifyClientTypes.ProductionBranch? = nil,
            repository: Swift.String? = nil,
            repositoryCloneMethod: AmplifyClientTypes.RepositoryCloneMethod? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.appArn = appArn
            self.appId = appId
            self.autoBranchCreationConfig = autoBranchCreationConfig
            self.autoBranchCreationPatterns = autoBranchCreationPatterns
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.createTime = createTime
            self.customHeaders = customHeaders
            self.customRules = customRules
            self.defaultDomain = defaultDomain
            self.description = description
            self.enableAutoBranchCreation = enableAutoBranchCreation
            self.enableBasicAuth = enableBasicAuth
            self.enableBranchAutoBuild = enableBranchAutoBuild
            self.enableBranchAutoDeletion = enableBranchAutoDeletion
            self.environmentVariables = environmentVariables
            self.iamServiceRoleArn = iamServiceRoleArn
            self.name = name
            self.platform = platform
            self.productionBranch = productionBranch
            self.repository = repository
            self.repositoryCloneMethod = repositoryCloneMethod
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

extension AmplifyClientTypes.Artifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactFileName
        case artifactId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactFileName = self.artifactFileName {
            try encodeContainer.encode(artifactFileName, forKey: .artifactFileName)
        }
        if let artifactId = self.artifactId {
            try encodeContainer.encode(artifactId, forKey: .artifactId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactFileName)
        artifactFileName = artifactFileNameDecoded
        let artifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactId)
        artifactId = artifactIdDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes an artifact.
    public struct Artifact: Swift.Equatable {
        /// The file name for the artifact.
        /// This member is required.
        public var artifactFileName: Swift.String?
        /// The unique ID for the artifact.
        /// This member is required.
        public var artifactId: Swift.String?

        public init(
            artifactFileName: Swift.String? = nil,
            artifactId: Swift.String? = nil
        )
        {
            self.artifactFileName = artifactFileName
            self.artifactId = artifactId
        }
    }

}

extension AmplifyClientTypes.AutoBranchCreationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basicAuthCredentials
        case buildSpec
        case enableAutoBuild
        case enableBasicAuth
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = self.buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let enableAutoBuild = self.enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = self.enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enablePerformanceMode = self.enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = self.enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let framework = self.framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = self.pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .framework)
        framework = frameworkDecoded
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
    }
}

extension AmplifyClientTypes.AutoBranchCreationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoBranchCreationConfig(enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), stage: \(Swift.String(describing: stage)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

extension AmplifyClientTypes {
    /// Describes the automated branch creation configuration.
    public struct AutoBranchCreationConfig: Swift.Equatable {
        /// The basic authorization credentials for the autocreated branch. You must base64-encode the authorization credentials and provide them in the format user:password.
        public var basicAuthCredentials: Swift.String?
        /// The build specification (build spec) for the autocreated branch.
        public var buildSpec: Swift.String?
        /// Enables auto building for the autocreated branch.
        public var enableAutoBuild: Swift.Bool?
        /// Enables basic authorization for the autocreated branch.
        public var enableBasicAuth: Swift.Bool?
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public var enablePerformanceMode: Swift.Bool?
        /// Enables pull request previews for the autocreated branch.
        public var enablePullRequestPreview: Swift.Bool?
        /// The environment variables for the autocreated branch.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The framework for the autocreated branch.
        public var framework: Swift.String?
        /// The Amplify environment name for the pull request.
        public var pullRequestEnvironmentName: Swift.String?
        /// Describes the current stage for the autocreated branch.
        public var stage: AmplifyClientTypes.Stage?

        public init(
            basicAuthCredentials: Swift.String? = nil,
            buildSpec: Swift.String? = nil,
            enableAutoBuild: Swift.Bool? = nil,
            enableBasicAuth: Swift.Bool? = nil,
            enablePerformanceMode: Swift.Bool? = nil,
            enablePullRequestPreview: Swift.Bool? = nil,
            environmentVariables: [Swift.String:Swift.String]? = nil,
            framework: Swift.String? = nil,
            pullRequestEnvironmentName: Swift.String? = nil,
            stage: AmplifyClientTypes.Stage? = nil
        )
        {
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.stage = stage
        }
    }

}

extension AmplifyClientTypes.BackendEnvironment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentArn
        case createTime
        case deploymentArtifacts
        case environmentName
        case stackName
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentArn = self.backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let deploymentArtifacts = self.deploymentArtifacts {
            try encodeContainer.encode(deploymentArtifacts, forKey: .deploymentArtifacts)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let deploymentArtifactsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArtifacts)
        deploymentArtifacts = deploymentArtifactsDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes the backend environment for an Amplify app.
    public struct BackendEnvironment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var backendEnvironmentArn: Swift.String?
        /// The creation date and time for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The name of deployment artifacts.
        public var deploymentArtifacts: Swift.String?
        /// The name for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The AWS CloudFormation stack name of a backend environment.
        public var stackName: Swift.String?
        /// The last updated date and time for a backend environment that is part of an Amplify app.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            backendEnvironmentArn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            deploymentArtifacts: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            stackName: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.backendEnvironmentArn = backendEnvironmentArn
            self.createTime = createTime
            self.deploymentArtifacts = deploymentArtifacts
            self.environmentName = environmentName
            self.stackName = stackName
            self.updateTime = updateTime
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A request contains unexpected data.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyClientTypes.Branch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeJobId
        case associatedResources
        case backendEnvironmentArn
        case basicAuthCredentials
        case branchArn
        case branchName
        case buildSpec
        case createTime
        case customDomains
        case description
        case destinationBranch
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case sourceBranch
        case stage
        case tags
        case thumbnailUrl
        case totalNumberOfJobs
        case ttl
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeJobId = self.activeJobId {
            try encodeContainer.encode(activeJobId, forKey: .activeJobId)
        }
        if let associatedResources = associatedResources {
            var associatedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResources)
            for associatedresource0 in associatedResources {
                try associatedResourcesContainer.encode(associatedresource0)
            }
        }
        if let backendEnvironmentArn = self.backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let branchArn = self.branchArn {
            try encodeContainer.encode(branchArn, forKey: .branchArn)
        }
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let buildSpec = self.buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let customDomains = customDomains {
            var customDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customDomains)
            for customdomain0 in customDomains {
                try customDomainsContainer.encode(customdomain0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationBranch = self.destinationBranch {
            try encodeContainer.encode(destinationBranch, forKey: .destinationBranch)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableAutoBuild = self.enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = self.enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableNotification = self.enableNotification {
            try encodeContainer.encode(enableNotification, forKey: .enableNotification)
        }
        if let enablePerformanceMode = self.enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = self.enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let framework = self.framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = self.pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let sourceBranch = self.sourceBranch {
            try encodeContainer.encode(sourceBranch, forKey: .sourceBranch)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thumbnailUrl = self.thumbnailUrl {
            try encodeContainer.encode(thumbnailUrl, forKey: .thumbnailUrl)
        }
        if let totalNumberOfJobs = self.totalNumberOfJobs {
            try encodeContainer.encode(totalNumberOfJobs, forKey: .totalNumberOfJobs)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchArn)
        branchArn = branchArnDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let stageDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableNotification)
        enableNotification = enableNotificationDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let customDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customDomains)
        var customDomainsDecoded0:[Swift.String]? = nil
        if let customDomainsContainer = customDomainsContainer {
            customDomainsDecoded0 = [Swift.String]()
            for string0 in customDomainsContainer {
                if let string0 = string0 {
                    customDomainsDecoded0?.append(string0)
                }
            }
        }
        customDomains = customDomainsDecoded0
        let frameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .framework)
        framework = frameworkDecoded
        let activeJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeJobId)
        activeJobId = activeJobIdDecoded
        let totalNumberOfJobsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalNumberOfJobs)
        totalNumberOfJobs = totalNumberOfJobsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let thumbnailUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbnailUrl)
        thumbnailUrl = thumbnailUrlDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
        let associatedResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedResources)
        var associatedResourcesDecoded0:[Swift.String]? = nil
        if let associatedResourcesContainer = associatedResourcesContainer {
            associatedResourcesDecoded0 = [Swift.String]()
            for string0 in associatedResourcesContainer {
                if let string0 = string0 {
                    associatedResourcesDecoded0?.append(string0)
                }
            }
        }
        associatedResources = associatedResourcesDecoded0
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
        let destinationBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBranch)
        destinationBranch = destinationBranchDecoded
        let sourceBranchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBranch)
        sourceBranch = sourceBranchDecoded
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
    }
}

extension AmplifyClientTypes.Branch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Branch(activeJobId: \(Swift.String(describing: activeJobId)), associatedResources: \(Swift.String(describing: associatedResources)), backendEnvironmentArn: \(Swift.String(describing: backendEnvironmentArn)), branchArn: \(Swift.String(describing: branchArn)), branchName: \(Swift.String(describing: branchName)), createTime: \(Swift.String(describing: createTime)), customDomains: \(Swift.String(describing: customDomains)), description: \(Swift.String(describing: description)), destinationBranch: \(Swift.String(describing: destinationBranch)), displayName: \(Swift.String(describing: displayName)), enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableNotification: \(Swift.String(describing: enableNotification)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), sourceBranch: \(Swift.String(describing: sourceBranch)), stage: \(Swift.String(describing: stage)), tags: \(Swift.String(describing: tags)), thumbnailUrl: \(Swift.String(describing: thumbnailUrl)), totalNumberOfJobs: \(Swift.String(describing: totalNumberOfJobs)), ttl: \(Swift.String(describing: ttl)), updateTime: \(Swift.String(describing: updateTime)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

extension AmplifyClientTypes {
    /// The branch for an Amplify app, which maps to a third-party repository branch.
    public struct Branch: Swift.Equatable {
        /// The ID of the active job for a branch of an Amplify app.
        /// This member is required.
        public var activeJobId: Swift.String?
        /// A list of custom resources that are linked to this branch.
        public var associatedResources: [Swift.String]?
        /// The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app.
        public var backendEnvironmentArn: Swift.String?
        /// The basic authorization credentials for a branch of an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public var basicAuthCredentials: Swift.String?
        /// The Amazon Resource Name (ARN) for a branch that is part of an Amplify app.
        /// This member is required.
        public var branchArn: Swift.String?
        /// The name for the branch that is part of an Amplify app.
        /// This member is required.
        public var branchName: Swift.String?
        /// The build specification (build spec) content for the branch of an Amplify app.
        public var buildSpec: Swift.String?
        /// The creation date and time for a branch that is part of an Amplify app.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The custom domains for a branch of an Amplify app.
        /// This member is required.
        public var customDomains: [Swift.String]?
        /// The description for the branch that is part of an Amplify app.
        /// This member is required.
        public var description: Swift.String?
        /// The destination branch if the branch is a pull request branch.
        public var destinationBranch: Swift.String?
        /// The display name for the branch. This is used as the default domain prefix.
        /// This member is required.
        public var displayName: Swift.String?
        /// Enables auto-building on push for a branch of an Amplify app.
        /// This member is required.
        public var enableAutoBuild: Swift.Bool?
        /// Enables basic authorization for a branch of an Amplify app.
        /// This member is required.
        public var enableBasicAuth: Swift.Bool?
        /// Enables notifications for a branch that is part of an Amplify app.
        /// This member is required.
        public var enableNotification: Swift.Bool?
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public var enablePerformanceMode: Swift.Bool?
        /// Enables pull request previews for the branch.
        /// This member is required.
        public var enablePullRequestPreview: Swift.Bool?
        /// The environment variables specific to a branch of an Amplify app.
        /// This member is required.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The framework for a branch of an Amplify app.
        /// This member is required.
        public var framework: Swift.String?
        /// The Amplify environment name for the pull request.
        public var pullRequestEnvironmentName: Swift.String?
        /// The source branch if the branch is a pull request branch.
        public var sourceBranch: Swift.String?
        /// The current stage for the branch that is part of an Amplify app.
        /// This member is required.
        public var stage: AmplifyClientTypes.Stage?
        /// The tag for the branch of an Amplify app.
        public var tags: [Swift.String:Swift.String]?
        /// The thumbnail URL for the branch of an Amplify app.
        public var thumbnailUrl: Swift.String?
        /// The total number of jobs that are part of an Amplify app.
        /// This member is required.
        public var totalNumberOfJobs: Swift.String?
        /// The content Time to Live (TTL) for the website in seconds.
        /// This member is required.
        public var ttl: Swift.String?
        /// The last updated date and time for a branch that is part of an Amplify app.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            activeJobId: Swift.String? = nil,
            associatedResources: [Swift.String]? = nil,
            backendEnvironmentArn: Swift.String? = nil,
            basicAuthCredentials: Swift.String? = nil,
            branchArn: Swift.String? = nil,
            branchName: Swift.String? = nil,
            buildSpec: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            customDomains: [Swift.String]? = nil,
            description: Swift.String? = nil,
            destinationBranch: Swift.String? = nil,
            displayName: Swift.String? = nil,
            enableAutoBuild: Swift.Bool? = nil,
            enableBasicAuth: Swift.Bool? = nil,
            enableNotification: Swift.Bool? = nil,
            enablePerformanceMode: Swift.Bool? = nil,
            enablePullRequestPreview: Swift.Bool? = nil,
            environmentVariables: [Swift.String:Swift.String]? = nil,
            framework: Swift.String? = nil,
            pullRequestEnvironmentName: Swift.String? = nil,
            sourceBranch: Swift.String? = nil,
            stage: AmplifyClientTypes.Stage? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            thumbnailUrl: Swift.String? = nil,
            totalNumberOfJobs: Swift.String? = nil,
            ttl: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.activeJobId = activeJobId
            self.associatedResources = associatedResources
            self.backendEnvironmentArn = backendEnvironmentArn
            self.basicAuthCredentials = basicAuthCredentials
            self.branchArn = branchArn
            self.branchName = branchName
            self.buildSpec = buildSpec
            self.createTime = createTime
            self.customDomains = customDomains
            self.description = description
            self.destinationBranch = destinationBranch
            self.displayName = displayName
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enableNotification = enableNotification
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.sourceBranch = sourceBranch
            self.stage = stage
            self.tags = tags
            self.thumbnailUrl = thumbnailUrl
            self.totalNumberOfJobs = totalNumberOfJobs
            self.ttl = ttl
            self.updateTime = updateTime
        }
    }

}

extension CreateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInput(autoBranchCreationConfig: \(Swift.String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(Swift.String(describing: autoBranchCreationPatterns)), customHeaders: \(Swift.String(describing: customHeaders)), customRules: \(Swift.String(describing: customRules)), description: \(Swift.String(describing: description)), enableAutoBranchCreation: \(Swift.String(describing: enableAutoBranchCreation)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableBranchAutoBuild: \(Swift.String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(Swift.String(describing: enableBranchAutoDeletion)), environmentVariables: \(Swift.String(describing: environmentVariables)), iamServiceRoleArn: \(Swift.String(describing: iamServiceRoleArn)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), repository: \(Swift.String(describing: repository)), tags: \(Swift.String(describing: tags)), accessToken: \"CONTENT_REDACTED\", basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\", oauthToken: \"CONTENT_REDACTED\")"}
}

extension CreateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let autoBranchCreationConfig = self.autoBranchCreationConfig {
            try encodeContainer.encode(autoBranchCreationConfig, forKey: .autoBranchCreationConfig)
        }
        if let autoBranchCreationPatterns = autoBranchCreationPatterns {
            var autoBranchCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoBranchCreationPatterns)
            for autobranchcreationpattern0 in autoBranchCreationPatterns {
                try autoBranchCreationPatternsContainer.encode(autobranchcreationpattern0)
            }
        }
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = self.buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let customHeaders = self.customHeaders {
            try encodeContainer.encode(customHeaders, forKey: .customHeaders)
        }
        if let customRules = customRules {
            var customRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customRules)
            for customrule0 in customRules {
                try customRulesContainer.encode(customrule0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableAutoBranchCreation = self.enableAutoBranchCreation {
            try encodeContainer.encode(enableAutoBranchCreation, forKey: .enableAutoBranchCreation)
        }
        if let enableBasicAuth = self.enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableBranchAutoBuild = self.enableBranchAutoBuild {
            try encodeContainer.encode(enableBranchAutoBuild, forKey: .enableBranchAutoBuild)
        }
        if let enableBranchAutoDeletion = self.enableBranchAutoDeletion {
            try encodeContainer.encode(enableBranchAutoDeletion, forKey: .enableBranchAutoDeletion)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let iamServiceRoleArn = self.iamServiceRoleArn {
            try encodeContainer.encode(iamServiceRoleArn, forKey: .iamServiceRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let oauthToken = self.oauthToken {
            try encodeContainer.encode(oauthToken, forKey: .oauthToken)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apps"
    }
}

/// The request structure used to create apps in Amplify.
public struct CreateAppInput: Swift.Equatable {
    /// The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use accessToken for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use oauthToken. You must specify either accessToken or oauthToken when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/UserGuide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var accessToken: Swift.String?
    /// The automated branch creation configuration for an Amplify app.
    public var autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
    /// The automated branch creation glob patterns for an Amplify app.
    public var autoBranchCreationPatterns: [Swift.String]?
    /// The credentials for basic authorization for an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The build specification (build spec) for an Amplify app.
    public var buildSpec: Swift.String?
    /// The custom HTTP headers for an Amplify app.
    public var customHeaders: Swift.String?
    /// The custom rewrite and redirect rules for an Amplify app.
    public var customRules: [AmplifyClientTypes.CustomRule]?
    /// The description for an Amplify app.
    public var description: Swift.String?
    /// Enables automated branch creation for an Amplify app.
    public var enableAutoBranchCreation: Swift.Bool?
    /// Enables basic authorization for an Amplify app. This will apply to all branches that are part of this app.
    public var enableBasicAuth: Swift.Bool?
    /// Enables the auto building of branches for an Amplify app.
    public var enableBranchAutoBuild: Swift.Bool?
    /// Automatically disconnects a branch in the Amplify Console when you delete a branch from your Git repository.
    public var enableBranchAutoDeletion: Swift.Bool?
    /// The environment variables map for an Amplify app.
    public var environmentVariables: [Swift.String:Swift.String]?
    /// The AWS Identity and Access Management (IAM) service role for an Amplify app.
    public var iamServiceRoleArn: Swift.String?
    /// The name for an Amplify app.
    /// This member is required.
    public var name: Swift.String?
    /// The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use oauthToken for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use accessToken. You must specify either oauthToken or accessToken when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/UserGuide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var oauthToken: Swift.String?
    /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC.
    public var platform: AmplifyClientTypes.Platform?
    /// The repository for an Amplify app.
    public var repository: Swift.String?
    /// The tag for an Amplify app.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accessToken: Swift.String? = nil,
        autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig? = nil,
        autoBranchCreationPatterns: [Swift.String]? = nil,
        basicAuthCredentials: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        customHeaders: Swift.String? = nil,
        customRules: [AmplifyClientTypes.CustomRule]? = nil,
        description: Swift.String? = nil,
        enableAutoBranchCreation: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableBranchAutoBuild: Swift.Bool? = nil,
        enableBranchAutoDeletion: Swift.Bool? = nil,
        environmentVariables: [Swift.String:Swift.String]? = nil,
        iamServiceRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        oauthToken: Swift.String? = nil,
        platform: AmplifyClientTypes.Platform? = nil,
        repository: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessToken = accessToken
        self.autoBranchCreationConfig = autoBranchCreationConfig
        self.autoBranchCreationPatterns = autoBranchCreationPatterns
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.customHeaders = customHeaders
        self.customRules = customRules
        self.description = description
        self.enableAutoBranchCreation = enableAutoBranchCreation
        self.enableBasicAuth = enableBasicAuth
        self.enableBranchAutoBuild = enableBranchAutoBuild
        self.enableBranchAutoDeletion = enableBranchAutoDeletion
        self.environmentVariables = environmentVariables
        self.iamServiceRoleArn = iamServiceRoleArn
        self.name = name
        self.oauthToken = oauthToken
        self.platform = platform
        self.repository = repository
        self.tags = tags
    }
}

struct CreateAppInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let repository: Swift.String?
    let platform: AmplifyClientTypes.Platform?
    let iamServiceRoleArn: Swift.String?
    let oauthToken: Swift.String?
    let accessToken: Swift.String?
    let environmentVariables: [Swift.String:Swift.String]?
    let enableBranchAutoBuild: Swift.Bool?
    let enableBranchAutoDeletion: Swift.Bool?
    let enableBasicAuth: Swift.Bool?
    let basicAuthCredentials: Swift.String?
    let customRules: [AmplifyClientTypes.CustomRule]?
    let tags: [Swift.String:Swift.String]?
    let buildSpec: Swift.String?
    let customHeaders: Swift.String?
    let enableAutoBranchCreation: Swift.Bool?
    let autoBranchCreationPatterns: [Swift.String]?
    let autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
}

extension CreateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let iamServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamServiceRoleArn)
        iamServiceRoleArn = iamServiceRoleArnDecoded
        let oauthTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oauthToken)
        oauthToken = oauthTokenDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let enableBranchAutoBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBranchAutoBuild)
        enableBranchAutoBuild = enableBranchAutoBuildDecoded
        let enableBranchAutoDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBranchAutoDeletion)
        enableBranchAutoDeletion = enableBranchAutoDeletionDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let customRulesContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.CustomRule?].self, forKey: .customRules)
        var customRulesDecoded0:[AmplifyClientTypes.CustomRule]? = nil
        if let customRulesContainer = customRulesContainer {
            customRulesDecoded0 = [AmplifyClientTypes.CustomRule]()
            for structure0 in customRulesContainer {
                if let structure0 = structure0 {
                    customRulesDecoded0?.append(structure0)
                }
            }
        }
        customRules = customRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let enableAutoBranchCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoBranchCreation)
        enableAutoBranchCreation = enableAutoBranchCreationDecoded
        let autoBranchCreationPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoBranchCreationPatterns)
        var autoBranchCreationPatternsDecoded0:[Swift.String]? = nil
        if let autoBranchCreationPatternsContainer = autoBranchCreationPatternsContainer {
            autoBranchCreationPatternsDecoded0 = [Swift.String]()
            for string0 in autoBranchCreationPatternsContainer {
                if let string0 = string0 {
                    autoBranchCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoBranchCreationPatterns = autoBranchCreationPatternsDecoded0
        let autoBranchCreationConfigDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.AutoBranchCreationConfig.self, forKey: .autoBranchCreationConfig)
        autoBranchCreationConfig = autoBranchCreationConfigDecoded
    }
}

extension CreateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct CreateAppOutput: Swift.Equatable {
    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct CreateAppOutputBody: Swift.Equatable {
    let app: AmplifyClientTypes.App?
}

extension CreateAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

enum CreateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBackendEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentArtifacts
        case environmentName
        case stackName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentArtifacts = self.deploymentArtifacts {
            try encodeContainer.encode(deploymentArtifacts, forKey: .deploymentArtifacts)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension CreateBackendEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments"
    }
}

/// The request structure for the backend environment create request.
public struct CreateBackendEnvironmentInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of deployment artifacts.
    public var deploymentArtifacts: Swift.String?
    /// The name for the backend environment.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The AWS CloudFormation stack name of a backend environment.
    public var stackName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        deploymentArtifacts: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.deploymentArtifacts = deploymentArtifacts
        self.environmentName = environmentName
        self.stackName = stackName
    }
}

struct CreateBackendEnvironmentInputBody: Swift.Equatable {
    let environmentName: Swift.String?
    let stackName: Swift.String?
    let deploymentArtifacts: Swift.String?
}

extension CreateBackendEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentArtifacts
        case environmentName
        case stackName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let deploymentArtifactsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArtifacts)
        deploymentArtifacts = deploymentArtifactsDecoded
    }
}

extension CreateBackendEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackendEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.backendEnvironment = output.backendEnvironment
        } else {
            self.backendEnvironment = nil
        }
    }
}

/// The result structure for the create backend environment request.
public struct CreateBackendEnvironmentOutput: Swift.Equatable {
    /// Describes the backend environment for an Amplify app.
    /// This member is required.
    public var backendEnvironment: AmplifyClientTypes.BackendEnvironment?

    public init(
        backendEnvironment: AmplifyClientTypes.BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

struct CreateBackendEnvironmentOutputBody: Swift.Equatable {
    let backendEnvironment: AmplifyClientTypes.BackendEnvironment?
}

extension CreateBackendEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.BackendEnvironment.self, forKey: .backendEnvironment)
        backendEnvironment = backendEnvironmentDecoded
    }
}

enum CreateBackendEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBranchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBranchInput(appId: \(Swift.String(describing: appId)), backendEnvironmentArn: \(Swift.String(describing: backendEnvironmentArn)), branchName: \(Swift.String(describing: branchName)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableNotification: \(Swift.String(describing: enableNotification)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), stage: \(Swift.String(describing: stage)), tags: \(Swift.String(describing: tags)), ttl: \(Swift.String(describing: ttl)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

extension CreateBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case branchName
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case tags
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentArn = self.backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let buildSpec = self.buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableAutoBuild = self.enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = self.enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableNotification = self.enableNotification {
            try encodeContainer.encode(enableNotification, forKey: .enableNotification)
        }
        if let enablePerformanceMode = self.enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = self.enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let framework = self.framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = self.pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

extension CreateBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches"
    }
}

/// The request structure for the create branch request.
public struct CreateBranchInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app.
    public var backendEnvironmentArn: Swift.String?
    /// The basic authorization credentials for the branch. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The name for the branch.
    /// This member is required.
    public var branchName: Swift.String?
    /// The build specification (build spec) for the branch.
    public var buildSpec: Swift.String?
    /// The description for the branch.
    public var description: Swift.String?
    /// The display name for a branch. This is used as the default domain prefix.
    public var displayName: Swift.String?
    /// Enables auto building for the branch.
    public var enableAutoBuild: Swift.Bool?
    /// Enables basic authorization for the branch.
    public var enableBasicAuth: Swift.Bool?
    /// Enables notifications for the branch.
    public var enableNotification: Swift.Bool?
    /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
    public var enablePerformanceMode: Swift.Bool?
    /// Enables pull request previews for this branch.
    public var enablePullRequestPreview: Swift.Bool?
    /// The environment variables for the branch.
    public var environmentVariables: [Swift.String:Swift.String]?
    /// The framework for the branch.
    public var framework: Swift.String?
    /// The Amplify environment name for the pull request.
    public var pullRequestEnvironmentName: Swift.String?
    /// Describes the current stage for the branch.
    public var stage: AmplifyClientTypes.Stage?
    /// The tag for the branch.
    public var tags: [Swift.String:Swift.String]?
    /// The content Time To Live (TTL) for the website in seconds.
    public var ttl: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentArn: Swift.String? = nil,
        basicAuthCredentials: Swift.String? = nil,
        branchName: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableAutoBuild: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableNotification: Swift.Bool? = nil,
        enablePerformanceMode: Swift.Bool? = nil,
        enablePullRequestPreview: Swift.Bool? = nil,
        environmentVariables: [Swift.String:Swift.String]? = nil,
        framework: Swift.String? = nil,
        pullRequestEnvironmentName: Swift.String? = nil,
        stage: AmplifyClientTypes.Stage? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentArn = backendEnvironmentArn
        self.basicAuthCredentials = basicAuthCredentials
        self.branchName = branchName
        self.buildSpec = buildSpec
        self.description = description
        self.displayName = displayName
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enableNotification = enableNotification
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.stage = stage
        self.tags = tags
        self.ttl = ttl
    }
}

struct CreateBranchInputBody: Swift.Equatable {
    let branchName: Swift.String?
    let description: Swift.String?
    let stage: AmplifyClientTypes.Stage?
    let framework: Swift.String?
    let enableNotification: Swift.Bool?
    let enableAutoBuild: Swift.Bool?
    let environmentVariables: [Swift.String:Swift.String]?
    let basicAuthCredentials: Swift.String?
    let enableBasicAuth: Swift.Bool?
    let enablePerformanceMode: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let buildSpec: Swift.String?
    let ttl: Swift.String?
    let displayName: Swift.String?
    let enablePullRequestPreview: Swift.Bool?
    let pullRequestEnvironmentName: Swift.String?
    let backendEnvironmentArn: Swift.String?
}

extension CreateBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case branchName
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case tags
        case ttl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stageDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .framework)
        framework = frameworkDecoded
        let enableNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableNotification)
        enableNotification = enableNotificationDecoded
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
    }
}

extension CreateBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBranchOutputBody = try responseDecoder.decode(responseBody: data)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// The result structure for create branch request.
public struct CreateBranchOutput: Swift.Equatable {
    /// Describes the branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct CreateBranchOutputBody: Swift.Equatable {
    let branch: AmplifyClientTypes.Branch?
}

extension CreateBranchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

enum CreateBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileMap = fileMap {
            var fileMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fileMap)
            for (dictKey0, fileMap0) in fileMap {
                try fileMapContainer.encode(fileMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/deployments"
    }
}

/// The request structure for the create a new deployment request.
public struct CreateDeploymentInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the branch, for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// An optional file map that contains the file name as the key and the file content md5 hash as the value. If this argument is provided, the service will generate a unique upload URL per file. Otherwise, the service will only generate a single upload URL for the zipped files.
    public var fileMap: [Swift.String:Swift.String]?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        fileMap: [Swift.String:Swift.String]? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.fileMap = fileMap
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let fileMap: [Swift.String:Swift.String]?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileMap
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .fileMap)
        var fileMapDecoded0: [Swift.String:Swift.String]? = nil
        if let fileMapContainer = fileMapContainer {
            fileMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, md5hash0) in fileMapContainer {
                if let md5hash0 = md5hash0 {
                    fileMapDecoded0?[key0] = md5hash0
                }
            }
        }
        fileMap = fileMapDecoded0
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.fileUploadUrls = output.fileUploadUrls
            self.jobId = output.jobId
            self.zipUploadUrl = output.zipUploadUrl
        } else {
            self.fileUploadUrls = nil
            self.jobId = nil
            self.zipUploadUrl = nil
        }
    }
}

/// The result structure for the create a new deployment request.
public struct CreateDeploymentOutput: Swift.Equatable {
    /// When the fileMap argument is provided in the request, fileUploadUrls will contain a map of file names to upload URLs.
    /// This member is required.
    public var fileUploadUrls: [Swift.String:Swift.String]?
    /// The job ID for this deployment. will supply to start deployment api.
    public var jobId: Swift.String?
    /// When the fileMap argument is not provided in the request, this zipUploadUrl is returned.
    /// This member is required.
    public var zipUploadUrl: Swift.String?

    public init(
        fileUploadUrls: [Swift.String:Swift.String]? = nil,
        jobId: Swift.String? = nil,
        zipUploadUrl: Swift.String? = nil
    )
    {
        self.fileUploadUrls = fileUploadUrls
        self.jobId = jobId
        self.zipUploadUrl = zipUploadUrl
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let fileUploadUrls: [Swift.String:Swift.String]?
    let zipUploadUrl: Swift.String?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileUploadUrls
        case jobId
        case zipUploadUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let fileUploadUrlsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .fileUploadUrls)
        var fileUploadUrlsDecoded0: [Swift.String:Swift.String]? = nil
        if let fileUploadUrlsContainer = fileUploadUrlsContainer {
            fileUploadUrlsDecoded0 = [Swift.String:Swift.String]()
            for (key0, uploadurl0) in fileUploadUrlsContainer {
                if let uploadurl0 = uploadurl0 {
                    fileUploadUrlsDecoded0?[key0] = uploadurl0
                }
            }
        }
        fileUploadUrls = fileUploadUrlsDecoded0
        let zipUploadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zipUploadUrl)
        zipUploadUrl = zipUploadUrlDecoded
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case domainName
        case enableAutoSubDomain
        case subDomainSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoSubDomainCreationPatterns = autoSubDomainCreationPatterns {
            var autoSubDomainCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoSubDomainCreationPatterns)
            for autosubdomaincreationpattern0 in autoSubDomainCreationPatterns {
                try autoSubDomainCreationPatternsContainer.encode(autosubdomaincreationpattern0)
            }
        }
        if let autoSubDomainIAMRole = self.autoSubDomainIAMRole {
            try encodeContainer.encode(autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableAutoSubDomain = self.enableAutoSubDomain {
            try encodeContainer.encode(enableAutoSubDomain, forKey: .enableAutoSubDomain)
        }
        if let subDomainSettings = subDomainSettings {
            var subDomainSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subDomainSettings)
            for subdomainsetting0 in subDomainSettings {
                try subDomainSettingsContainer.encode(subdomainsetting0)
            }
        }
    }
}

extension CreateDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains"
    }
}

/// The request structure for the create domain association request.
public struct CreateDomainAssociationInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// Sets the branch patterns for automatic subdomain creation.
    public var autoSubDomainCreationPatterns: [Swift.String]?
    /// The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
    public var autoSubDomainIAMRole: Swift.String?
    /// The domain name for the domain association.
    /// This member is required.
    public var domainName: Swift.String?
    /// Enables the automated creation of subdomains for branches.
    public var enableAutoSubDomain: Swift.Bool?
    /// The setting for the subdomain.
    /// This member is required.
    public var subDomainSettings: [AmplifyClientTypes.SubDomainSetting]?

    public init(
        appId: Swift.String? = nil,
        autoSubDomainCreationPatterns: [Swift.String]? = nil,
        autoSubDomainIAMRole: Swift.String? = nil,
        domainName: Swift.String? = nil,
        enableAutoSubDomain: Swift.Bool? = nil,
        subDomainSettings: [AmplifyClientTypes.SubDomainSetting]? = nil
    )
    {
        self.appId = appId
        self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
        self.autoSubDomainIAMRole = autoSubDomainIAMRole
        self.domainName = domainName
        self.enableAutoSubDomain = enableAutoSubDomain
        self.subDomainSettings = subDomainSettings
    }
}

struct CreateDomainAssociationInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let enableAutoSubDomain: Swift.Bool?
    let subDomainSettings: [AmplifyClientTypes.SubDomainSetting]?
    let autoSubDomainCreationPatterns: [Swift.String]?
    let autoSubDomainIAMRole: Swift.String?
}

extension CreateDomainAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case domainName
        case enableAutoSubDomain
        case subDomainSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableAutoSubDomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoSubDomain)
        enableAutoSubDomain = enableAutoSubDomainDecoded
        let subDomainSettingsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.SubDomainSetting?].self, forKey: .subDomainSettings)
        var subDomainSettingsDecoded0:[AmplifyClientTypes.SubDomainSetting]? = nil
        if let subDomainSettingsContainer = subDomainSettingsContainer {
            subDomainSettingsDecoded0 = [AmplifyClientTypes.SubDomainSetting]()
            for structure0 in subDomainSettingsContainer {
                if let structure0 = structure0 {
                    subDomainSettingsDecoded0?.append(structure0)
                }
            }
        }
        subDomainSettings = subDomainSettingsDecoded0
        let autoSubDomainCreationPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoSubDomainCreationPatterns)
        var autoSubDomainCreationPatternsDecoded0:[Swift.String]? = nil
        if let autoSubDomainCreationPatternsContainer = autoSubDomainCreationPatternsContainer {
            autoSubDomainCreationPatternsDecoded0 = [Swift.String]()
            for string0 in autoSubDomainCreationPatternsContainer {
                if let string0 = string0 {
                    autoSubDomainCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoSubDomainCreationPatterns = autoSubDomainCreationPatternsDecoded0
        let autoSubDomainIAMRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoSubDomainIAMRole)
        autoSubDomainIAMRole = autoSubDomainIAMRoleDecoded
    }
}

extension CreateDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

/// The result structure for the create domain association request.
public struct CreateDomainAssociationOutput: Swift.Equatable {
    /// Describes the structure of a domain association, which associates a custom domain with an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct CreateDomainAssociationOutputBody: Swift.Equatable {
    let domainAssociation: AmplifyClientTypes.DomainAssociation?
}

extension CreateDomainAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

enum CreateDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWebhookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension CreateWebhookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/webhooks"
    }
}

/// The request structure for the create webhook request.
public struct CreateWebhookInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for a branch that is part of an Amplify app.
    /// This member is required.
    public var branchName: Swift.String?
    /// The description for a webhook.
    public var description: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.description = description
    }
}

struct CreateWebhookInputBody: Swift.Equatable {
    let branchName: Swift.String?
    let description: Swift.String?
}

extension CreateWebhookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateWebhookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWebhookOutputBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// The result structure for the create webhook request.
public struct CreateWebhookOutput: Swift.Equatable {
    /// Describes a webhook that connects repository events to an Amplify app.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct CreateWebhookOutputBody: Swift.Equatable {
    let webhook: AmplifyClientTypes.Webhook?
}

extension CreateWebhookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhook
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

enum CreateWebhookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyClientTypes.CustomRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case source
        case status
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes a custom rewrite or redirect rule.
    public struct CustomRule: Swift.Equatable {
        /// The condition for a URL rewrite or redirect rule, such as a country code.
        public var condition: Swift.String?
        /// The source pattern for a URL rewrite or redirect rule.
        /// This member is required.
        public var source: Swift.String?
        /// The status code for a URL rewrite or redirect rule. 200 Represents a 200 rewrite rule. 301 Represents a 301 (moved pemanently) redirect rule. This and all future requests should be directed to the target URL. 302 Represents a 302 temporary redirect rule. 404 Represents a 404 redirect rule. 404-200 Represents a 404 rewrite rule.
        public var status: Swift.String?
        /// The target pattern for a URL rewrite or redirect rule.
        /// This member is required.
        public var target: Swift.String?

        public init(
            condition: Swift.String? = nil,
            source: Swift.String? = nil,
            status: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.condition = condition
            self.source = source
            self.status = status
            self.target = target
        }
    }

}

extension DeleteAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())"
    }
}

/// Describes the request structure for the delete app request.
public struct DeleteAppInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppInputBody: Swift.Equatable {
}

extension DeleteAppInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

/// The result structure for the delete app request.
public struct DeleteAppOutput: Swift.Equatable {
    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct DeleteAppOutputBody: Swift.Equatable {
    let app: AmplifyClientTypes.App?
}

extension DeleteAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

enum DeleteAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackendEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments/\(environmentName.urlPercentEncoding())"
    }
}

/// The request structure for the delete backend environment request.
public struct DeleteBackendEnvironmentInput: Swift.Equatable {
    /// The unique ID of an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of a backend environment of an Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct DeleteBackendEnvironmentInputBody: Swift.Equatable {
}

extension DeleteBackendEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackendEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBackendEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.backendEnvironment = output.backendEnvironment
        } else {
            self.backendEnvironment = nil
        }
    }
}

/// The result structure of the delete backend environment result.
public struct DeleteBackendEnvironmentOutput: Swift.Equatable {
    /// Describes the backend environment for an Amplify app.
    /// This member is required.
    public var backendEnvironment: AmplifyClientTypes.BackendEnvironment?

    public init(
        backendEnvironment: AmplifyClientTypes.BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

struct DeleteBackendEnvironmentOutputBody: Swift.Equatable {
    let backendEnvironment: AmplifyClientTypes.BackendEnvironment?
}

extension DeleteBackendEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.BackendEnvironment.self, forKey: .backendEnvironment)
        backendEnvironment = backendEnvironmentDecoded
    }
}

enum DeleteBackendEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())"
    }
}

/// The request structure for the delete branch request.
public struct DeleteBranchInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the branch.
    /// This member is required.
    public var branchName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
    }
}

struct DeleteBranchInputBody: Swift.Equatable {
}

extension DeleteBranchInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBranchOutputBody = try responseDecoder.decode(responseBody: data)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// The result structure for the delete branch request.
public struct DeleteBranchOutput: Swift.Equatable {
    /// The branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct DeleteBranchOutputBody: Swift.Equatable {
    let branch: AmplifyClientTypes.Branch?
}

extension DeleteBranchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

enum DeleteBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let domainName = domainName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains/\(domainName.urlPercentEncoding())"
    }
}

/// The request structure for the delete domain association request.
public struct DeleteDomainAssociationInput: Swift.Equatable {
    /// The unique id for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
    }
}

struct DeleteDomainAssociationInputBody: Swift.Equatable {
}

extension DeleteDomainAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDomainAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

public struct DeleteDomainAssociationOutput: Swift.Equatable {
    /// Describes a domain association that associates a custom domain with an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct DeleteDomainAssociationOutputBody: Swift.Equatable {
    let domainAssociation: AmplifyClientTypes.DomainAssociation?
}

extension DeleteDomainAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

enum DeleteDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

/// The request structure for the delete job request.
public struct DeleteJobInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the branch, for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique ID for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

struct DeleteJobInputBody: Swift.Equatable {
}

extension DeleteJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// The result structure for the delete job request.
public struct DeleteJobOutput: Swift.Equatable {
    /// Describes the summary for an execution job for an Amplify app.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct DeleteJobOutputBody: Swift.Equatable {
    let jobSummary: AmplifyClientTypes.JobSummary?
}

extension DeleteJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

enum DeleteJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWebhookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let webhookId = webhookId else {
            return nil
        }
        return "/webhooks/\(webhookId.urlPercentEncoding())"
    }
}

/// The request structure for the delete webhook request.
public struct DeleteWebhookInput: Swift.Equatable {
    /// The unique ID for a webhook.
    /// This member is required.
    public var webhookId: Swift.String?

    public init(
        webhookId: Swift.String? = nil
    )
    {
        self.webhookId = webhookId
    }
}

struct DeleteWebhookInputBody: Swift.Equatable {
}

extension DeleteWebhookInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWebhookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteWebhookOutputBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// The result structure for the delete webhook request.
public struct DeleteWebhookOutput: Swift.Equatable {
    /// Describes a webhook that connects repository events to an Amplify app.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct DeleteWebhookOutputBody: Swift.Equatable {
    let webhook: AmplifyClientTypes.Webhook?
}

extension DeleteWebhookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhook
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

enum DeleteWebhookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DependentServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependentServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An operation failed because a dependent service threw an exception.
public struct DependentServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependentServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DependentServiceFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DependentServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyClientTypes.DomainAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case certificateVerificationDNSRecord
        case domainAssociationArn
        case domainName
        case domainStatus
        case enableAutoSubDomain
        case statusReason
        case subDomains
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoSubDomainCreationPatterns = autoSubDomainCreationPatterns {
            var autoSubDomainCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoSubDomainCreationPatterns)
            for autosubdomaincreationpattern0 in autoSubDomainCreationPatterns {
                try autoSubDomainCreationPatternsContainer.encode(autosubdomaincreationpattern0)
            }
        }
        if let autoSubDomainIAMRole = self.autoSubDomainIAMRole {
            try encodeContainer.encode(autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
        }
        if let certificateVerificationDNSRecord = self.certificateVerificationDNSRecord {
            try encodeContainer.encode(certificateVerificationDNSRecord, forKey: .certificateVerificationDNSRecord)
        }
        if let domainAssociationArn = self.domainAssociationArn {
            try encodeContainer.encode(domainAssociationArn, forKey: .domainAssociationArn)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainStatus = self.domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let enableAutoSubDomain = self.enableAutoSubDomain {
            try encodeContainer.encode(enableAutoSubDomain, forKey: .enableAutoSubDomain)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let subDomains = subDomains {
            var subDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subDomains)
            for subdomain0 in subDomains {
                try subDomainsContainer.encode(subdomain0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainAssociationArn)
        domainAssociationArn = domainAssociationArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableAutoSubDomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoSubDomain)
        enableAutoSubDomain = enableAutoSubDomainDecoded
        let autoSubDomainCreationPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoSubDomainCreationPatterns)
        var autoSubDomainCreationPatternsDecoded0:[Swift.String]? = nil
        if let autoSubDomainCreationPatternsContainer = autoSubDomainCreationPatternsContainer {
            autoSubDomainCreationPatternsDecoded0 = [Swift.String]()
            for string0 in autoSubDomainCreationPatternsContainer {
                if let string0 = string0 {
                    autoSubDomainCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoSubDomainCreationPatterns = autoSubDomainCreationPatternsDecoded0
        let autoSubDomainIAMRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoSubDomainIAMRole)
        autoSubDomainIAMRole = autoSubDomainIAMRoleDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let certificateVerificationDNSRecordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateVerificationDNSRecord)
        certificateVerificationDNSRecord = certificateVerificationDNSRecordDecoded
        let subDomainsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.SubDomain?].self, forKey: .subDomains)
        var subDomainsDecoded0:[AmplifyClientTypes.SubDomain]? = nil
        if let subDomainsContainer = subDomainsContainer {
            subDomainsDecoded0 = [AmplifyClientTypes.SubDomain]()
            for structure0 in subDomainsContainer {
                if let structure0 = structure0 {
                    subDomainsDecoded0?.append(structure0)
                }
            }
        }
        subDomains = subDomainsDecoded0
    }
}

extension AmplifyClientTypes {
    /// Describes a domain association that associates a custom domain with an Amplify app.
    public struct DomainAssociation: Swift.Equatable {
        /// Sets branch patterns for automatic subdomain creation.
        public var autoSubDomainCreationPatterns: [Swift.String]?
        /// The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
        public var autoSubDomainIAMRole: Swift.String?
        /// The DNS record for certificate verification.
        public var certificateVerificationDNSRecord: Swift.String?
        /// The Amazon Resource Name (ARN) for the domain association.
        /// This member is required.
        public var domainAssociationArn: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The current status of the domain association.
        /// This member is required.
        public var domainStatus: AmplifyClientTypes.DomainStatus?
        /// Enables the automated creation of subdomains for branches.
        /// This member is required.
        public var enableAutoSubDomain: Swift.Bool?
        /// The reason for the current status of the domain association.
        /// This member is required.
        public var statusReason: Swift.String?
        /// The subdomains for the domain association.
        /// This member is required.
        public var subDomains: [AmplifyClientTypes.SubDomain]?

        public init(
            autoSubDomainCreationPatterns: [Swift.String]? = nil,
            autoSubDomainIAMRole: Swift.String? = nil,
            certificateVerificationDNSRecord: Swift.String? = nil,
            domainAssociationArn: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainStatus: AmplifyClientTypes.DomainStatus? = nil,
            enableAutoSubDomain: Swift.Bool? = nil,
            statusReason: Swift.String? = nil,
            subDomains: [AmplifyClientTypes.SubDomain]? = nil
        )
        {
            self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
            self.autoSubDomainIAMRole = autoSubDomainIAMRole
            self.certificateVerificationDNSRecord = certificateVerificationDNSRecord
            self.domainAssociationArn = domainAssociationArn
            self.domainName = domainName
            self.domainStatus = domainStatus
            self.enableAutoSubDomain = enableAutoSubDomain
            self.statusReason = statusReason
            self.subDomains = subDomains
        }
    }

}

extension AmplifyClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case failed
        case inProgress
        case pendingDeployment
        case pendingVerification
        case requestingCertificate
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .available,
                .creating,
                .failed,
                .inProgress,
                .pendingDeployment,
                .pendingVerification,
                .requestingCertificate,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pendingDeployment: return "PENDING_DEPLOYMENT"
            case .pendingVerification: return "PENDING_VERIFICATION"
            case .requestingCertificate: return "REQUESTING_CERTIFICATE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension GenerateAccessLogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GenerateAccessLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/accesslogs"
    }
}

/// The request structure for the generate access logs request.
public struct GenerateAccessLogsInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The time at which the logs should end. The time range specified is inclusive of the end time.
    public var endTime: ClientRuntime.Date?
    /// The time at which the logs should start. The time range specified is inclusive of the start time.
    public var startTime: ClientRuntime.Date?

    public init(
        appId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
        self.endTime = endTime
        self.startTime = startTime
    }
}

struct GenerateAccessLogsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let domainName: Swift.String?
}

extension GenerateAccessLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case endTime
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GenerateAccessLogsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateAccessLogsOutputBody = try responseDecoder.decode(responseBody: data)
            self.logUrl = output.logUrl
        } else {
            self.logUrl = nil
        }
    }
}

/// The result structure for the generate access logs request.
public struct GenerateAccessLogsOutput: Swift.Equatable {
    /// The pre-signed URL for the requested access logs.
    public var logUrl: Swift.String?

    public init(
        logUrl: Swift.String? = nil
    )
    {
        self.logUrl = logUrl
    }
}

struct GenerateAccessLogsOutputBody: Swift.Equatable {
    let logUrl: Swift.String?
}

extension GenerateAccessLogsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
    }
}

enum GenerateAccessLogsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())"
    }
}

/// The request structure for the get app request.
public struct GetAppInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppInputBody: Swift.Equatable {
}

extension GetAppInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct GetAppOutput: Swift.Equatable {
    /// Represents the different branches of a repository for building, deploying, and hosting an Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct GetAppOutputBody: Swift.Equatable {
    let app: AmplifyClientTypes.App?
}

extension GetAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

enum GetAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetArtifactUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let artifactId = artifactId else {
            return nil
        }
        return "/artifacts/\(artifactId.urlPercentEncoding())"
    }
}

/// Returns the request structure for the get artifact request.
public struct GetArtifactUrlInput: Swift.Equatable {
    /// The unique ID for an artifact.
    /// This member is required.
    public var artifactId: Swift.String?

    public init(
        artifactId: Swift.String? = nil
    )
    {
        self.artifactId = artifactId
    }
}

struct GetArtifactUrlInputBody: Swift.Equatable {
}

extension GetArtifactUrlInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetArtifactUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetArtifactUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.artifactId = output.artifactId
            self.artifactUrl = output.artifactUrl
        } else {
            self.artifactId = nil
            self.artifactUrl = nil
        }
    }
}

/// Returns the result structure for the get artifact request.
public struct GetArtifactUrlOutput: Swift.Equatable {
    /// The unique ID for an artifact.
    /// This member is required.
    public var artifactId: Swift.String?
    /// The presigned URL for the artifact.
    /// This member is required.
    public var artifactUrl: Swift.String?

    public init(
        artifactId: Swift.String? = nil,
        artifactUrl: Swift.String? = nil
    )
    {
        self.artifactId = artifactId
        self.artifactUrl = artifactUrl
    }
}

struct GetArtifactUrlOutputBody: Swift.Equatable {
    let artifactId: Swift.String?
    let artifactUrl: Swift.String?
}

extension GetArtifactUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactId
        case artifactUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactId)
        artifactId = artifactIdDecoded
        let artifactUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactUrl)
        artifactUrl = artifactUrlDecoded
    }
}

enum GetArtifactUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackendEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments/\(environmentName.urlPercentEncoding())"
    }
}

/// The request structure for the get backend environment request.
public struct GetBackendEnvironmentInput: Swift.Equatable {
    /// The unique id for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the backend environment.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct GetBackendEnvironmentInputBody: Swift.Equatable {
}

extension GetBackendEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBackendEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackendEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.backendEnvironment = output.backendEnvironment
        } else {
            self.backendEnvironment = nil
        }
    }
}

/// The result structure for the get backend environment result.
public struct GetBackendEnvironmentOutput: Swift.Equatable {
    /// Describes the backend environment for an Amplify app.
    /// This member is required.
    public var backendEnvironment: AmplifyClientTypes.BackendEnvironment?

    public init(
        backendEnvironment: AmplifyClientTypes.BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

struct GetBackendEnvironmentOutputBody: Swift.Equatable {
    let backendEnvironment: AmplifyClientTypes.BackendEnvironment?
}

extension GetBackendEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.BackendEnvironment.self, forKey: .backendEnvironment)
        backendEnvironment = backendEnvironmentDecoded
    }
}

enum GetBackendEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())"
    }
}

/// The request structure for the get branch request.
public struct GetBranchInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the branch.
    /// This member is required.
    public var branchName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
    }
}

struct GetBranchInputBody: Swift.Equatable {
}

extension GetBranchInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBranchOutputBody = try responseDecoder.decode(responseBody: data)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

public struct GetBranchOutput: Swift.Equatable {
    /// The branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct GetBranchOutputBody: Swift.Equatable {
    let branch: AmplifyClientTypes.Branch?
}

extension GetBranchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

enum GetBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let domainName = domainName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains/\(domainName.urlPercentEncoding())"
    }
}

/// The request structure for the get domain association request.
public struct GetDomainAssociationInput: Swift.Equatable {
    /// The unique id for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
    }
}

struct GetDomainAssociationInputBody: Swift.Equatable {
}

extension GetDomainAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

/// The result structure for the get domain association request.
public struct GetDomainAssociationOutput: Swift.Equatable {
    /// Describes the structure of a domain association, which associates a custom domain with an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct GetDomainAssociationOutputBody: Swift.Equatable {
    let domainAssociation: AmplifyClientTypes.DomainAssociation?
}

extension GetDomainAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

enum GetDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

/// The request structure for the get job request.
public struct GetJobInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The branch name for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique ID for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

struct GetJobInputBody: Swift.Equatable {
}

extension GetJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct GetJobOutput: Swift.Equatable {
    /// Describes an execution job for an Amplify app.
    /// This member is required.
    public var job: AmplifyClientTypes.Job?

    public init(
        job: AmplifyClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct GetJobOutputBody: Swift.Equatable {
    let job: AmplifyClientTypes.Job?
}

extension GetJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum GetJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWebhookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let webhookId = webhookId else {
            return nil
        }
        return "/webhooks/\(webhookId.urlPercentEncoding())"
    }
}

/// The request structure for the get webhook request.
public struct GetWebhookInput: Swift.Equatable {
    /// The unique ID for a webhook.
    /// This member is required.
    public var webhookId: Swift.String?

    public init(
        webhookId: Swift.String? = nil
    )
    {
        self.webhookId = webhookId
    }
}

struct GetWebhookInputBody: Swift.Equatable {
}

extension GetWebhookInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWebhookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWebhookOutputBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// The result structure for the get webhook request.
public struct GetWebhookOutput: Swift.Equatable {
    /// Describes the structure of a webhook.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct GetWebhookOutputBody: Swift.Equatable {
    let webhook: AmplifyClientTypes.Webhook?
}

extension GetWebhookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhook
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

enum GetWebhookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service failed to perform an operation due to an internal issue.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case steps
        case summary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for step0 in steps {
                try stepsContainer.encode(step0)
            }
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobSummary.self, forKey: .summary)
        summary = summaryDecoded
        let stepsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.Step?].self, forKey: .steps)
        var stepsDecoded0:[AmplifyClientTypes.Step]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [AmplifyClientTypes.Step]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension AmplifyClientTypes {
    /// Describes an execution job for an Amplify app.
    public struct Job: Swift.Equatable {
        /// The execution steps for an execution job, for an Amplify app.
        /// This member is required.
        public var steps: [AmplifyClientTypes.Step]?
        /// Describes the summary for an execution job for an Amplify app.
        /// This member is required.
        public var summary: AmplifyClientTypes.JobSummary?

        public init(
            steps: [AmplifyClientTypes.Step]? = nil,
            summary: AmplifyClientTypes.JobSummary? = nil
        )
        {
            self.steps = steps
            self.summary = summary
        }
    }

}

extension AmplifyClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case pending
        case provisioning
        case running
        case succeed
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .pending,
                .provisioning,
                .running,
                .succeed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .provisioning: return "PROVISIONING"
            case .running: return "RUNNING"
            case .succeed: return "SUCCEED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case commitMessage
        case commitTime
        case endTime
        case jobArn
        case jobId
        case jobType
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let commitTime = self.commitTime {
            try encodeContainer.encodeTimestamp(commitTime, format: .epochSeconds, forKey: .commitTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let commitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .commitTime)
        commitTime = commitTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes the summary for an execution job for an Amplify app.
    public struct JobSummary: Swift.Equatable {
        /// The commit ID from a third-party repository provider for the job.
        /// This member is required.
        public var commitId: Swift.String?
        /// The commit message from a third-party repository provider for the job.
        /// This member is required.
        public var commitMessage: Swift.String?
        /// The commit date and time for the job.
        /// This member is required.
        public var commitTime: ClientRuntime.Date?
        /// The end date and time for the job.
        public var endTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The unique ID for the job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The type for the job. If the value is RELEASE, the job was manually released from its source by using the StartJob API. If the value is RETRY, the job was manually retried using the StartJob API. If the value is WEB_HOOK, the job was automatically triggered by webhooks.
        /// This member is required.
        public var jobType: AmplifyClientTypes.JobType?
        /// The start date and time for the job.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The current status for the job.
        /// This member is required.
        public var status: AmplifyClientTypes.JobStatus?

        public init(
            commitId: Swift.String? = nil,
            commitMessage: Swift.String? = nil,
            commitTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobType: AmplifyClientTypes.JobType? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: AmplifyClientTypes.JobStatus? = nil
        )
        {
            self.commitId = commitId
            self.commitMessage = commitMessage
            self.commitTime = commitTime
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobId = jobId
            self.jobType = jobType
            self.startTime = startTime
            self.status = status
        }
    }

}

extension AmplifyClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manual
        case release
        case retry
        case webHook
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .manual,
                .release,
                .retry,
                .webHook,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manual: return "MANUAL"
            case .release: return "RELEASE"
            case .retry: return "RETRY"
            case .webHook: return "WEB_HOOK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource could not be created because service quotas were exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAppsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAppsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apps"
    }
}

/// The request structure for the list apps request.
public struct ListAppsInput: Swift.Equatable {
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. If non-null, the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppsInputBody: Swift.Equatable {
}

extension ListAppsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppsOutputBody = try responseDecoder.decode(responseBody: data)
            self.apps = output.apps
            self.nextToken = output.nextToken
        } else {
            self.apps = nil
            self.nextToken = nil
        }
    }
}

/// The result structure for an Amplify app list request.
public struct ListAppsOutput: Swift.Equatable {
    /// A list of Amplify apps.
    /// This member is required.
    public var apps: [AmplifyClientTypes.App]?
    /// A pagination token. Set to null to start listing apps from start. If non-null, the pagination token is returned in a result. Pass its value in here to list more projects.
    public var nextToken: Swift.String?

    public init(
        apps: [AmplifyClientTypes.App]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

struct ListAppsOutputBody: Swift.Equatable {
    let apps: [AmplifyClientTypes.App]?
    let nextToken: Swift.String?
}

extension ListAppsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apps
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.App?].self, forKey: .apps)
        var appsDecoded0:[AmplifyClientTypes.App]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [AmplifyClientTypes.App]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListArtifactsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListArtifactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/artifacts"
    }
}

/// Describes the request structure for the list artifacts request.
public struct ListArtifactsInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of a branch that is part of an Amplify app.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique ID for a job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing artifacts from start. If a non-null pagination token is returned in a result, pass its value in here to list more artifacts.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListArtifactsInputBody: Swift.Equatable {
}

extension ListArtifactsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListArtifactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListArtifactsOutputBody = try responseDecoder.decode(responseBody: data)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

/// The result structure for the list artifacts request.
public struct ListArtifactsOutput: Swift.Equatable {
    /// A list of artifacts.
    /// This member is required.
    public var artifacts: [AmplifyClientTypes.Artifact]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        artifacts: [AmplifyClientTypes.Artifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListArtifactsOutputBody: Swift.Equatable {
    let artifacts: [AmplifyClientTypes.Artifact]?
    let nextToken: Swift.String?
}

extension ListArtifactsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.Artifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[AmplifyClientTypes.Artifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [AmplifyClientTypes.Artifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListArtifactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBackendEnvironmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let environmentName = environmentName {
                let environmentNameQueryItem = ClientRuntime.URLQueryItem(name: "environmentName".urlPercentEncoding(), value: Swift.String(environmentName).urlPercentEncoding())
                items.append(environmentNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBackendEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/backendenvironments"
    }
}

/// The request structure for the list backend environments request.
public struct ListBackendEnvironmentsInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment
    public var environmentName: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing backend environments from the start. If a non-null pagination token is returned in a result, pass its value in here to list more backend environments.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackendEnvironmentsInputBody: Swift.Equatable {
}

extension ListBackendEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBackendEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackendEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.backendEnvironments = output.backendEnvironments
            self.nextToken = output.nextToken
        } else {
            self.backendEnvironments = nil
            self.nextToken = nil
        }
    }
}

/// The result structure for the list backend environments result.
public struct ListBackendEnvironmentsOutput: Swift.Equatable {
    /// The list of backend environments for an Amplify app.
    /// This member is required.
    public var backendEnvironments: [AmplifyClientTypes.BackendEnvironment]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        backendEnvironments: [AmplifyClientTypes.BackendEnvironment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backendEnvironments = backendEnvironments
        self.nextToken = nextToken
    }
}

struct ListBackendEnvironmentsOutputBody: Swift.Equatable {
    let backendEnvironments: [AmplifyClientTypes.BackendEnvironment]?
    let nextToken: Swift.String?
}

extension ListBackendEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.BackendEnvironment?].self, forKey: .backendEnvironments)
        var backendEnvironmentsDecoded0:[AmplifyClientTypes.BackendEnvironment]? = nil
        if let backendEnvironmentsContainer = backendEnvironmentsContainer {
            backendEnvironmentsDecoded0 = [AmplifyClientTypes.BackendEnvironment]()
            for structure0 in backendEnvironmentsContainer {
                if let structure0 = structure0 {
                    backendEnvironmentsDecoded0?.append(structure0)
                }
            }
        }
        backendEnvironments = backendEnvironmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBackendEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBranchesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBranchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches"
    }
}

/// The request structure for the list branches request.
public struct ListBranchesInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing branches from the start. If a non-null pagination token is returned in a result, pass its value in here to list more branches.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBranchesInputBody: Swift.Equatable {
}

extension ListBranchesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBranchesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBranchesOutputBody = try responseDecoder.decode(responseBody: data)
            self.branches = output.branches
            self.nextToken = output.nextToken
        } else {
            self.branches = nil
            self.nextToken = nil
        }
    }
}

/// The result structure for the list branches request.
public struct ListBranchesOutput: Swift.Equatable {
    /// A list of branches for an Amplify app.
    /// This member is required.
    public var branches: [AmplifyClientTypes.Branch]?
    /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        branches: [AmplifyClientTypes.Branch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.branches = branches
        self.nextToken = nextToken
    }
}

struct ListBranchesOutputBody: Swift.Equatable {
    let branches: [AmplifyClientTypes.Branch]?
    let nextToken: Swift.String?
}

extension ListBranchesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branches
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchesContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.Branch?].self, forKey: .branches)
        var branchesDecoded0:[AmplifyClientTypes.Branch]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [AmplifyClientTypes.Branch]()
            for structure0 in branchesContainer {
                if let structure0 = structure0 {
                    branchesDecoded0?.append(structure0)
                }
            }
        }
        branches = branchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBranchesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDomainAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDomainAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains"
    }
}

/// The request structure for the list domain associations request.
public struct ListDomainAssociationsInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing apps from the start. If non-null, a pagination token is returned in a result. Pass its value in here to list more projects.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainAssociationsInputBody: Swift.Equatable {
}

extension ListDomainAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainAssociations = output.domainAssociations
            self.nextToken = output.nextToken
        } else {
            self.domainAssociations = nil
            self.nextToken = nil
        }
    }
}

/// The result structure for the list domain association request.
public struct ListDomainAssociationsOutput: Swift.Equatable {
    /// A list of domain associations.
    /// This member is required.
    public var domainAssociations: [AmplifyClientTypes.DomainAssociation]?
    /// A pagination token. If non-null, a pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        domainAssociations: [AmplifyClientTypes.DomainAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainAssociations = domainAssociations
        self.nextToken = nextToken
    }
}

struct ListDomainAssociationsOutputBody: Swift.Equatable {
    let domainAssociations: [AmplifyClientTypes.DomainAssociation]?
    let nextToken: Swift.String?
}

extension ListDomainAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainAssociations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.DomainAssociation?].self, forKey: .domainAssociations)
        var domainAssociationsDecoded0:[AmplifyClientTypes.DomainAssociation]? = nil
        if let domainAssociationsContainer = domainAssociationsContainer {
            domainAssociationsDecoded0 = [AmplifyClientTypes.DomainAssociation]()
            for structure0 in domainAssociationsContainer {
                if let structure0 = structure0 {
                    domainAssociationsDecoded0?.append(structure0)
                }
            }
        }
        domainAssociations = domainAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs"
    }
}

/// The request structure for the list jobs request.
public struct ListJobsInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for a branch.
    /// This member is required.
    public var branchName: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing steps from the start. If a non-null pagination token is returned in a result, pass its value in here to list more steps.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

/// The maximum number of records to list in a single response.
public struct ListJobsOutput: Swift.Equatable {
    /// The result structure for the list job result request.
    /// This member is required.
    public var jobSummaries: [AmplifyClientTypes.JobSummary]?
    /// A pagination token. If non-null the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [AmplifyClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody: Swift.Equatable {
    let jobSummaries: [AmplifyClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.JobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[AmplifyClientTypes.JobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [AmplifyClientTypes.JobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// The request structure to use to list tags for a resource.
public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) to use to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// The response for the list tags for resource request.
public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags for the specified The Amazon Resource Name (ARN).
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWebhooksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWebhooksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/webhooks"
    }
}

/// The request structure for the list webhooks request.
public struct ListWebhooksInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token. Set to null to start listing webhooks from the start. If non-null,the pagination token is returned in a result. Pass its value in here to list more webhooks.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebhooksInputBody: Swift.Equatable {
}

extension ListWebhooksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWebhooksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWebhooksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.webhooks = output.webhooks
        } else {
            self.nextToken = nil
            self.webhooks = nil
        }
    }
}

/// The result structure for the list webhooks request.
public struct ListWebhooksOutput: Swift.Equatable {
    /// A pagination token. If non-null, the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
    public var nextToken: Swift.String?
    /// A list of webhooks.
    /// This member is required.
    public var webhooks: [AmplifyClientTypes.Webhook]?

    public init(
        nextToken: Swift.String? = nil,
        webhooks: [AmplifyClientTypes.Webhook]? = nil
    )
    {
        self.nextToken = nextToken
        self.webhooks = webhooks
    }
}

struct ListWebhooksOutputBody: Swift.Equatable {
    let webhooks: [AmplifyClientTypes.Webhook]?
    let nextToken: Swift.String?
}

extension ListWebhooksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case webhooks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhooksContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.Webhook?].self, forKey: .webhooks)
        var webhooksDecoded0:[AmplifyClientTypes.Webhook]? = nil
        if let webhooksContainer = webhooksContainer {
            webhooksDecoded0 = [AmplifyClientTypes.Webhook]()
            for structure0 in webhooksContainer {
                if let structure0 = structure0 {
                    webhooksDecoded0?.append(structure0)
                }
            }
        }
        webhooks = webhooksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWebhooksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An entity was not found during an operation.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyClientTypes {
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case web
        case webCompute
        case webDynamic
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .web,
                .webCompute,
                .webDynamic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .web: return "WEB"
            case .webCompute: return "WEB_COMPUTE"
            case .webDynamic: return "WEB_DYNAMIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyClientTypes.ProductionBranch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case lastDeployTime
        case status
        case thumbnailUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let lastDeployTime = self.lastDeployTime {
            try encodeContainer.encodeTimestamp(lastDeployTime, format: .epochSeconds, forKey: .lastDeployTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let thumbnailUrl = self.thumbnailUrl {
            try encodeContainer.encode(thumbnailUrl, forKey: .thumbnailUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastDeployTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDeployTime)
        lastDeployTime = lastDeployTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let thumbnailUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbnailUrl)
        thumbnailUrl = thumbnailUrlDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes the information about a production branch for an Amplify app.
    public struct ProductionBranch: Swift.Equatable {
        /// The branch name for the production branch.
        public var branchName: Swift.String?
        /// The last deploy time of the production branch.
        public var lastDeployTime: ClientRuntime.Date?
        /// The status of the production branch.
        public var status: Swift.String?
        /// The thumbnail URL for the production branch.
        public var thumbnailUrl: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            lastDeployTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil,
            thumbnailUrl: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.lastDeployTime = lastDeployTime
            self.status = status
            self.thumbnailUrl = thumbnailUrl
        }
    }

}

extension AmplifyClientTypes {
    public enum RepositoryCloneMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sigv4
        case ssh
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryCloneMethod] {
            return [
                .sigv4,
                .ssh,
                .token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sigv4: return "SIGV4"
            case .ssh: return "SSH"
            case .token: return "TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositoryCloneMethod(rawValue: rawValue) ?? RepositoryCloneMethod.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An operation failed due to a non-existent resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var code: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyClientTypes {
    public enum Stage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beta
        case development
        case experimental
        case production
        case pullRequest
        case sdkUnknown(Swift.String)

        public static var allCases: [Stage] {
            return [
                .beta,
                .development,
                .experimental,
                .production,
                .pullRequest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beta: return "BETA"
            case .development: return "DEVELOPMENT"
            case .experimental: return "EXPERIMENTAL"
            case .production: return "PRODUCTION"
            case .pullRequest: return "PULL_REQUEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Stage(rawValue: rawValue) ?? Stage.sdkUnknown(rawValue)
        }
    }
}

extension StartDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case sourceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
    }
}

extension StartDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/deployments/start"
    }
}

/// The request structure for the start a deployment request.
public struct StartDeploymentInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the branch, for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The job ID for this deployment, generated by the create deployment request.
    public var jobId: Swift.String?
    /// The source URL for this deployment, used when calling start deployment without create deployment. The source URL can be any HTTP GET URL that is publicly accessible and downloads a single .zip file.
    public var sourceUrl: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        sourceUrl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
        self.sourceUrl = sourceUrl
    }
}

struct StartDeploymentInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let sourceUrl: Swift.String?
}

extension StartDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case sourceUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
    }
}

extension StartDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// The result structure for the start a deployment request.
public struct StartDeploymentOutput: Swift.Equatable {
    /// The summary for the job.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct StartDeploymentOutputBody: Swift.Equatable {
    let jobSummary: AmplifyClientTypes.JobSummary?
}

extension StartDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

enum StartDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case commitMessage
        case commitTime
        case jobId
        case jobReason
        case jobType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = self.commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let commitTime = self.commitTime {
            try encodeContainer.encodeTimestamp(commitTime, format: .epochSeconds, forKey: .commitTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobReason = self.jobReason {
            try encodeContainer.encode(jobReason, forKey: .jobReason)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
    }
}

extension StartJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs"
    }
}

/// The request structure for the start job request.
public struct StartJobInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The branch name for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The commit ID from a third-party repository provider for the job.
    public var commitId: Swift.String?
    /// The commit message from a third-party repository provider for the job.
    public var commitMessage: Swift.String?
    /// The commit date and time for the job.
    public var commitTime: ClientRuntime.Date?
    /// The unique ID for an existing job. This is required if the value of jobType is RETRY.
    public var jobId: Swift.String?
    /// A descriptive reason for starting this job.
    public var jobReason: Swift.String?
    /// Describes the type for the job. The job type RELEASE starts a new job with the latest change from the specified branch. This value is available only for apps that are connected to a repository. The job type RETRY retries an existing job. If the job type value is RETRY, the jobId is also required.
    /// This member is required.
    public var jobType: AmplifyClientTypes.JobType?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        commitId: Swift.String? = nil,
        commitMessage: Swift.String? = nil,
        commitTime: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobReason: Swift.String? = nil,
        jobType: AmplifyClientTypes.JobType? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.commitId = commitId
        self.commitMessage = commitMessage
        self.commitTime = commitTime
        self.jobId = jobId
        self.jobReason = jobReason
        self.jobType = jobType
    }
}

struct StartJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobType: AmplifyClientTypes.JobType?
    let jobReason: Swift.String?
    let commitId: Swift.String?
    let commitMessage: Swift.String?
    let commitTime: ClientRuntime.Date?
}

extension StartJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitId
        case commitMessage
        case commitTime
        case jobId
        case jobReason
        case jobType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let jobReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobReason)
        jobReason = jobReasonDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let commitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .commitTime)
        commitTime = commitTimeDecoded
    }
}

extension StartJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// The result structure for the run job request.
public struct StartJobOutput: Swift.Equatable {
    /// The summary for the job.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct StartJobOutputBody: Swift.Equatable {
    let jobSummary: AmplifyClientTypes.JobSummary?
}

extension StartJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

enum StartJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyClientTypes.Step: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsUrl
        case context
        case endTime
        case logUrl
        case screenshots
        case startTime
        case status
        case statusReason
        case stepName
        case testArtifactsUrl
        case testConfigUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsUrl = self.artifactsUrl {
            try encodeContainer.encode(artifactsUrl, forKey: .artifactsUrl)
        }
        if let context = self.context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let logUrl = self.logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let screenshots = screenshots {
            var screenshotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .screenshots)
            for (dictKey0, screenshots0) in screenshots {
                try screenshotsContainer.encode(screenshots0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let stepName = self.stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
        if let testArtifactsUrl = self.testArtifactsUrl {
            try encodeContainer.encode(testArtifactsUrl, forKey: .testArtifactsUrl)
        }
        if let testConfigUrl = self.testConfigUrl {
            try encodeContainer.encode(testConfigUrl, forKey: .testConfigUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepName)
        stepName = stepNameDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let artifactsUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactsUrl)
        artifactsUrl = artifactsUrlDecoded
        let testArtifactsUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testArtifactsUrl)
        testArtifactsUrl = testArtifactsUrlDecoded
        let testConfigUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testConfigUrl)
        testConfigUrl = testConfigUrlDecoded
        let screenshotsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .screenshots)
        var screenshotsDecoded0: [Swift.String:Swift.String]? = nil
        if let screenshotsContainer = screenshotsContainer {
            screenshotsDecoded0 = [Swift.String:Swift.String]()
            for (key0, thumbnailurl0) in screenshotsContainer {
                if let thumbnailurl0 = thumbnailurl0 {
                    screenshotsDecoded0?[key0] = thumbnailurl0
                }
            }
        }
        screenshots = screenshotsDecoded0
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes an execution step, for an execution job, for an Amplify app.
    public struct Step: Swift.Equatable {
        /// The URL to the artifact for the execution step.
        public var artifactsUrl: Swift.String?
        /// The context for the current step. Includes a build image if the step is build.
        public var context: Swift.String?
        /// The end date and time of the execution step.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The URL to the logs for the execution step.
        public var logUrl: Swift.String?
        /// The list of screenshot URLs for the execution step, if relevant.
        public var screenshots: [Swift.String:Swift.String]?
        /// The start date and time of the execution step.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The status of the execution step.
        /// This member is required.
        public var status: AmplifyClientTypes.JobStatus?
        /// The reason for the current step status.
        public var statusReason: Swift.String?
        /// The name of the execution step.
        /// This member is required.
        public var stepName: Swift.String?
        /// The URL to the test artifact for the execution step.
        public var testArtifactsUrl: Swift.String?
        /// The URL to the test configuration for the execution step.
        public var testConfigUrl: Swift.String?

        public init(
            artifactsUrl: Swift.String? = nil,
            context: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            logUrl: Swift.String? = nil,
            screenshots: [Swift.String:Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: AmplifyClientTypes.JobStatus? = nil,
            statusReason: Swift.String? = nil,
            stepName: Swift.String? = nil,
            testArtifactsUrl: Swift.String? = nil,
            testConfigUrl: Swift.String? = nil
        )
        {
            self.artifactsUrl = artifactsUrl
            self.context = context
            self.endTime = endTime
            self.logUrl = logUrl
            self.screenshots = screenshots
            self.startTime = startTime
            self.status = status
            self.statusReason = statusReason
            self.stepName = stepName
            self.testArtifactsUrl = testArtifactsUrl
            self.testConfigUrl = testConfigUrl
        }
    }

}

extension StopJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/stop"
    }
}

/// The request structure for the stop job request.
public struct StopJobInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name for the branch, for the job.
    /// This member is required.
    public var branchName: Swift.String?
    /// The unique id for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        branchName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

struct StopJobInputBody: Swift.Equatable {
}

extension StopJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// The result structure for the stop job request.
public struct StopJobOutput: Swift.Equatable {
    /// The summary for the job.
    /// This member is required.
    public var jobSummary: AmplifyClientTypes.JobSummary?

    public init(
        jobSummary: AmplifyClientTypes.JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct StopJobOutputBody: Swift.Equatable {
    let jobSummary: AmplifyClientTypes.JobSummary?
}

extension StopJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

enum StopJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyClientTypes.SubDomain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsRecord
        case subDomainSetting
        case verified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecord = self.dnsRecord {
            try encodeContainer.encode(dnsRecord, forKey: .dnsRecord)
        }
        if let subDomainSetting = self.subDomainSetting {
            try encodeContainer.encode(subDomainSetting, forKey: .subDomainSetting)
        }
        if let verified = self.verified {
            try encodeContainer.encode(verified, forKey: .verified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subDomainSettingDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.SubDomainSetting.self, forKey: .subDomainSetting)
        subDomainSetting = subDomainSettingDecoded
        let verifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .verified)
        verified = verifiedDecoded
        let dnsRecordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsRecord)
        dnsRecord = dnsRecordDecoded
    }
}

extension AmplifyClientTypes {
    /// The subdomain for the domain association.
    public struct SubDomain: Swift.Equatable {
        /// The DNS record for the subdomain.
        /// This member is required.
        public var dnsRecord: Swift.String?
        /// Describes the settings for the subdomain.
        /// This member is required.
        public var subDomainSetting: AmplifyClientTypes.SubDomainSetting?
        /// The verified status of the subdomain
        /// This member is required.
        public var verified: Swift.Bool?

        public init(
            dnsRecord: Swift.String? = nil,
            subDomainSetting: AmplifyClientTypes.SubDomainSetting? = nil,
            verified: Swift.Bool? = nil
        )
        {
            self.dnsRecord = dnsRecord
            self.subDomainSetting = subDomainSetting
            self.verified = verified
        }
    }

}

extension AmplifyClientTypes.SubDomainSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes the settings for the subdomain.
    public struct SubDomainSetting: Swift.Equatable {
        /// The branch name setting for the subdomain.
        /// This member is required.
        public var branchName: Swift.String?
        /// The prefix setting for the subdomain.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.`prefix` = `prefix`
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// The request structure to tag a resource with a tag key and value.
public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) to use to tag a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to tag the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The response for the tag resource request.
public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An operation failed due to a lack of access.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// The request structure for the untag resource request.
public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) to use to untag a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to use to untag a resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The response for the untag resource request.
public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInput(appId: \(Swift.String(describing: appId)), autoBranchCreationConfig: \(Swift.String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(Swift.String(describing: autoBranchCreationPatterns)), customHeaders: \(Swift.String(describing: customHeaders)), customRules: \(Swift.String(describing: customRules)), description: \(Swift.String(describing: description)), enableAutoBranchCreation: \(Swift.String(describing: enableAutoBranchCreation)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableBranchAutoBuild: \(Swift.String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(Swift.String(describing: enableBranchAutoDeletion)), environmentVariables: \(Swift.String(describing: environmentVariables)), iamServiceRoleArn: \(Swift.String(describing: iamServiceRoleArn)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), repository: \(Swift.String(describing: repository)), accessToken: \"CONTENT_REDACTED\", basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\", oauthToken: \"CONTENT_REDACTED\")"}
}

extension UpdateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let autoBranchCreationConfig = self.autoBranchCreationConfig {
            try encodeContainer.encode(autoBranchCreationConfig, forKey: .autoBranchCreationConfig)
        }
        if let autoBranchCreationPatterns = autoBranchCreationPatterns {
            var autoBranchCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoBranchCreationPatterns)
            for autobranchcreationpattern0 in autoBranchCreationPatterns {
                try autoBranchCreationPatternsContainer.encode(autobranchcreationpattern0)
            }
        }
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = self.buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let customHeaders = self.customHeaders {
            try encodeContainer.encode(customHeaders, forKey: .customHeaders)
        }
        if let customRules = customRules {
            var customRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customRules)
            for customrule0 in customRules {
                try customRulesContainer.encode(customrule0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableAutoBranchCreation = self.enableAutoBranchCreation {
            try encodeContainer.encode(enableAutoBranchCreation, forKey: .enableAutoBranchCreation)
        }
        if let enableBasicAuth = self.enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableBranchAutoBuild = self.enableBranchAutoBuild {
            try encodeContainer.encode(enableBranchAutoBuild, forKey: .enableBranchAutoBuild)
        }
        if let enableBranchAutoDeletion = self.enableBranchAutoDeletion {
            try encodeContainer.encode(enableBranchAutoDeletion, forKey: .enableBranchAutoDeletion)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let iamServiceRoleArn = self.iamServiceRoleArn {
            try encodeContainer.encode(iamServiceRoleArn, forKey: .iamServiceRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let oauthToken = self.oauthToken {
            try encodeContainer.encode(oauthToken, forKey: .oauthToken)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
    }
}

extension UpdateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())"
    }
}

/// The request structure for the update app request.
public struct UpdateAppInput: Swift.Equatable {
    /// The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use accessToken for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use oauthToken. You must specify either accessToken or oauthToken when you update an app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/UserGuide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var accessToken: Swift.String?
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The automated branch creation configuration for an Amplify app.
    public var autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
    /// Describes the automated branch creation glob patterns for an Amplify app.
    public var autoBranchCreationPatterns: [Swift.String]?
    /// The basic authorization credentials for an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The build specification (build spec) for an Amplify app.
    public var buildSpec: Swift.String?
    /// The custom HTTP headers for an Amplify app.
    public var customHeaders: Swift.String?
    /// The custom redirect and rewrite rules for an Amplify app.
    public var customRules: [AmplifyClientTypes.CustomRule]?
    /// The description for an Amplify app.
    public var description: Swift.String?
    /// Enables automated branch creation for an Amplify app.
    public var enableAutoBranchCreation: Swift.Bool?
    /// Enables basic authorization for an Amplify app.
    public var enableBasicAuth: Swift.Bool?
    /// Enables branch auto-building for an Amplify app.
    public var enableBranchAutoBuild: Swift.Bool?
    /// Automatically disconnects a branch in the Amplify Console when you delete a branch from your Git repository.
    public var enableBranchAutoDeletion: Swift.Bool?
    /// The environment variables for an Amplify app.
    public var environmentVariables: [Swift.String:Swift.String]?
    /// The AWS Identity and Access Management (IAM) service role for an Amplify app.
    public var iamServiceRoleArn: Swift.String?
    /// The name for an Amplify app.
    public var name: Swift.String?
    /// The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use oauthToken for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use accessToken. You must specify either oauthToken or accessToken when you update an app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see [Migrating an existing OAuth app to the Amplify GitHub App](https://docs.aws.amazon.com/amplify/latest/UserGuide/setting-up-GitHub-access.html#migrating-to-github-app-auth) in the Amplify User Guide .
    public var oauthToken: Swift.String?
    /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC.
    public var platform: AmplifyClientTypes.Platform?
    /// The name of the repository for an Amplify app
    public var repository: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        appId: Swift.String? = nil,
        autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig? = nil,
        autoBranchCreationPatterns: [Swift.String]? = nil,
        basicAuthCredentials: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        customHeaders: Swift.String? = nil,
        customRules: [AmplifyClientTypes.CustomRule]? = nil,
        description: Swift.String? = nil,
        enableAutoBranchCreation: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableBranchAutoBuild: Swift.Bool? = nil,
        enableBranchAutoDeletion: Swift.Bool? = nil,
        environmentVariables: [Swift.String:Swift.String]? = nil,
        iamServiceRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        oauthToken: Swift.String? = nil,
        platform: AmplifyClientTypes.Platform? = nil,
        repository: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.appId = appId
        self.autoBranchCreationConfig = autoBranchCreationConfig
        self.autoBranchCreationPatterns = autoBranchCreationPatterns
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.customHeaders = customHeaders
        self.customRules = customRules
        self.description = description
        self.enableAutoBranchCreation = enableAutoBranchCreation
        self.enableBasicAuth = enableBasicAuth
        self.enableBranchAutoBuild = enableBranchAutoBuild
        self.enableBranchAutoDeletion = enableBranchAutoDeletion
        self.environmentVariables = environmentVariables
        self.iamServiceRoleArn = iamServiceRoleArn
        self.name = name
        self.oauthToken = oauthToken
        self.platform = platform
        self.repository = repository
    }
}

struct UpdateAppInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let platform: AmplifyClientTypes.Platform?
    let iamServiceRoleArn: Swift.String?
    let environmentVariables: [Swift.String:Swift.String]?
    let enableBranchAutoBuild: Swift.Bool?
    let enableBranchAutoDeletion: Swift.Bool?
    let enableBasicAuth: Swift.Bool?
    let basicAuthCredentials: Swift.String?
    let customRules: [AmplifyClientTypes.CustomRule]?
    let buildSpec: Swift.String?
    let customHeaders: Swift.String?
    let enableAutoBranchCreation: Swift.Bool?
    let autoBranchCreationPatterns: [Swift.String]?
    let autoBranchCreationConfig: AmplifyClientTypes.AutoBranchCreationConfig?
    let repository: Swift.String?
    let oauthToken: Swift.String?
    let accessToken: Swift.String?
}

extension UpdateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let iamServiceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamServiceRoleArn)
        iamServiceRoleArn = iamServiceRoleArnDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let enableBranchAutoBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBranchAutoBuild)
        enableBranchAutoBuild = enableBranchAutoBuildDecoded
        let enableBranchAutoDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBranchAutoDeletion)
        enableBranchAutoDeletion = enableBranchAutoDeletionDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let customRulesContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.CustomRule?].self, forKey: .customRules)
        var customRulesDecoded0:[AmplifyClientTypes.CustomRule]? = nil
        if let customRulesContainer = customRulesContainer {
            customRulesDecoded0 = [AmplifyClientTypes.CustomRule]()
            for structure0 in customRulesContainer {
                if let structure0 = structure0 {
                    customRulesDecoded0?.append(structure0)
                }
            }
        }
        customRules = customRulesDecoded0
        let buildSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let enableAutoBranchCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoBranchCreation)
        enableAutoBranchCreation = enableAutoBranchCreationDecoded
        let autoBranchCreationPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoBranchCreationPatterns)
        var autoBranchCreationPatternsDecoded0:[Swift.String]? = nil
        if let autoBranchCreationPatternsContainer = autoBranchCreationPatternsContainer {
            autoBranchCreationPatternsDecoded0 = [Swift.String]()
            for string0 in autoBranchCreationPatternsContainer {
                if let string0 = string0 {
                    autoBranchCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoBranchCreationPatterns = autoBranchCreationPatternsDecoded0
        let autoBranchCreationConfigDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.AutoBranchCreationConfig.self, forKey: .autoBranchCreationConfig)
        autoBranchCreationConfig = autoBranchCreationConfigDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let oauthTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oauthToken)
        oauthToken = oauthTokenDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension UpdateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

/// The result structure for an Amplify app update request.
public struct UpdateAppOutput: Swift.Equatable {
    /// Represents the updated Amplify app.
    /// This member is required.
    public var app: AmplifyClientTypes.App?

    public init(
        app: AmplifyClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct UpdateAppOutputBody: Swift.Equatable {
    let app: AmplifyClientTypes.App?
}

extension UpdateAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

enum UpdateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBranchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBranchInput(appId: \(Swift.String(describing: appId)), backendEnvironmentArn: \(Swift.String(describing: backendEnvironmentArn)), branchName: \(Swift.String(describing: branchName)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), enableAutoBuild: \(Swift.String(describing: enableAutoBuild)), enableBasicAuth: \(Swift.String(describing: enableBasicAuth)), enableNotification: \(Swift.String(describing: enableNotification)), enablePerformanceMode: \(Swift.String(describing: enablePerformanceMode)), enablePullRequestPreview: \(Swift.String(describing: enablePullRequestPreview)), environmentVariables: \(Swift.String(describing: environmentVariables)), framework: \(Swift.String(describing: framework)), pullRequestEnvironmentName: \(Swift.String(describing: pullRequestEnvironmentName)), stage: \(Swift.String(describing: stage)), ttl: \(Swift.String(describing: ttl)), basicAuthCredentials: \"CONTENT_REDACTED\", buildSpec: \"CONTENT_REDACTED\")"}
}

extension UpdateBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentArn = self.backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = self.buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableAutoBuild = self.enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = self.enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableNotification = self.enableNotification {
            try encodeContainer.encode(enableNotification, forKey: .enableNotification)
        }
        if let enablePerformanceMode = self.enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = self.enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let framework = self.framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = self.pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

extension UpdateBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let branchName = branchName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/branches/\(branchName.urlPercentEncoding())"
    }
}

/// The request structure for the update branch request.
public struct UpdateBranchInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app.
    public var backendEnvironmentArn: Swift.String?
    /// The basic authorization credentials for the branch. You must base64-encode the authorization credentials and provide them in the format user:password.
    public var basicAuthCredentials: Swift.String?
    /// The name for the branch.
    /// This member is required.
    public var branchName: Swift.String?
    /// The build specification (build spec) for the branch.
    public var buildSpec: Swift.String?
    /// The description for the branch.
    public var description: Swift.String?
    /// The display name for a branch. This is used as the default domain prefix.
    public var displayName: Swift.String?
    /// Enables auto building for the branch.
    public var enableAutoBuild: Swift.Bool?
    /// Enables basic authorization for the branch.
    public var enableBasicAuth: Swift.Bool?
    /// Enables notifications for the branch.
    public var enableNotification: Swift.Bool?
    /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
    public var enablePerformanceMode: Swift.Bool?
    /// Enables pull request previews for this branch.
    public var enablePullRequestPreview: Swift.Bool?
    /// The environment variables for the branch.
    public var environmentVariables: [Swift.String:Swift.String]?
    /// The framework for the branch.
    public var framework: Swift.String?
    /// The Amplify environment name for the pull request.
    public var pullRequestEnvironmentName: Swift.String?
    /// Describes the current stage for the branch.
    public var stage: AmplifyClientTypes.Stage?
    /// The content Time to Live (TTL) for the website in seconds.
    public var ttl: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentArn: Swift.String? = nil,
        basicAuthCredentials: Swift.String? = nil,
        branchName: Swift.String? = nil,
        buildSpec: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        enableAutoBuild: Swift.Bool? = nil,
        enableBasicAuth: Swift.Bool? = nil,
        enableNotification: Swift.Bool? = nil,
        enablePerformanceMode: Swift.Bool? = nil,
        enablePullRequestPreview: Swift.Bool? = nil,
        environmentVariables: [Swift.String:Swift.String]? = nil,
        framework: Swift.String? = nil,
        pullRequestEnvironmentName: Swift.String? = nil,
        stage: AmplifyClientTypes.Stage? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentArn = backendEnvironmentArn
        self.basicAuthCredentials = basicAuthCredentials
        self.branchName = branchName
        self.buildSpec = buildSpec
        self.description = description
        self.displayName = displayName
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enableNotification = enableNotification
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.stage = stage
        self.ttl = ttl
    }
}

struct UpdateBranchInputBody: Swift.Equatable {
    let description: Swift.String?
    let framework: Swift.String?
    let stage: AmplifyClientTypes.Stage?
    let enableNotification: Swift.Bool?
    let enableAutoBuild: Swift.Bool?
    let environmentVariables: [Swift.String:Swift.String]?
    let basicAuthCredentials: Swift.String?
    let enableBasicAuth: Swift.Bool?
    let enablePerformanceMode: Swift.Bool?
    let buildSpec: Swift.String?
    let ttl: Swift.String?
    let displayName: Swift.String?
    let enablePullRequestPreview: Swift.Bool?
    let pullRequestEnvironmentName: Swift.String?
    let backendEnvironmentArn: Swift.String?
}

extension UpdateBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case ttl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .framework)
        framework = frameworkDecoded
        let stageDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
        let enableNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableNotification)
        enableNotification = enableNotificationDecoded
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
    }
}

extension UpdateBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBranchOutputBody = try responseDecoder.decode(responseBody: data)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// The result structure for the update branch request.
public struct UpdateBranchOutput: Swift.Equatable {
    /// The branch for an Amplify app, which maps to a third-party repository branch.
    /// This member is required.
    public var branch: AmplifyClientTypes.Branch?

    public init(
        branch: AmplifyClientTypes.Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct UpdateBranchOutputBody: Swift.Equatable {
    let branch: AmplifyClientTypes.Branch?
}

extension UpdateBranchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

enum UpdateBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case enableAutoSubDomain
        case subDomainSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoSubDomainCreationPatterns = autoSubDomainCreationPatterns {
            var autoSubDomainCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoSubDomainCreationPatterns)
            for autosubdomaincreationpattern0 in autoSubDomainCreationPatterns {
                try autoSubDomainCreationPatternsContainer.encode(autosubdomaincreationpattern0)
            }
        }
        if let autoSubDomainIAMRole = self.autoSubDomainIAMRole {
            try encodeContainer.encode(autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
        }
        if let enableAutoSubDomain = self.enableAutoSubDomain {
            try encodeContainer.encode(enableAutoSubDomain, forKey: .enableAutoSubDomain)
        }
        if let subDomainSettings = subDomainSettings {
            var subDomainSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subDomainSettings)
            for subdomainsetting0 in subDomainSettings {
                try subDomainSettingsContainer.encode(subdomainsetting0)
            }
        }
    }
}

extension UpdateDomainAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let domainName = domainName else {
            return nil
        }
        return "/apps/\(appId.urlPercentEncoding())/domains/\(domainName.urlPercentEncoding())"
    }
}

/// The request structure for the update domain association request.
public struct UpdateDomainAssociationInput: Swift.Equatable {
    /// The unique ID for an Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// Sets the branch patterns for automatic subdomain creation.
    public var autoSubDomainCreationPatterns: [Swift.String]?
    /// The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
    public var autoSubDomainIAMRole: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// Enables the automated creation of subdomains for branches.
    public var enableAutoSubDomain: Swift.Bool?
    /// Describes the settings for the subdomain.
    public var subDomainSettings: [AmplifyClientTypes.SubDomainSetting]?

    public init(
        appId: Swift.String? = nil,
        autoSubDomainCreationPatterns: [Swift.String]? = nil,
        autoSubDomainIAMRole: Swift.String? = nil,
        domainName: Swift.String? = nil,
        enableAutoSubDomain: Swift.Bool? = nil,
        subDomainSettings: [AmplifyClientTypes.SubDomainSetting]? = nil
    )
    {
        self.appId = appId
        self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
        self.autoSubDomainIAMRole = autoSubDomainIAMRole
        self.domainName = domainName
        self.enableAutoSubDomain = enableAutoSubDomain
        self.subDomainSettings = subDomainSettings
    }
}

struct UpdateDomainAssociationInputBody: Swift.Equatable {
    let enableAutoSubDomain: Swift.Bool?
    let subDomainSettings: [AmplifyClientTypes.SubDomainSetting]?
    let autoSubDomainCreationPatterns: [Swift.String]?
    let autoSubDomainIAMRole: Swift.String?
}

extension UpdateDomainAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case enableAutoSubDomain
        case subDomainSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAutoSubDomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoSubDomain)
        enableAutoSubDomain = enableAutoSubDomainDecoded
        let subDomainSettingsContainer = try containerValues.decodeIfPresent([AmplifyClientTypes.SubDomainSetting?].self, forKey: .subDomainSettings)
        var subDomainSettingsDecoded0:[AmplifyClientTypes.SubDomainSetting]? = nil
        if let subDomainSettingsContainer = subDomainSettingsContainer {
            subDomainSettingsDecoded0 = [AmplifyClientTypes.SubDomainSetting]()
            for structure0 in subDomainSettingsContainer {
                if let structure0 = structure0 {
                    subDomainSettingsDecoded0?.append(structure0)
                }
            }
        }
        subDomainSettings = subDomainSettingsDecoded0
        let autoSubDomainCreationPatternsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .autoSubDomainCreationPatterns)
        var autoSubDomainCreationPatternsDecoded0:[Swift.String]? = nil
        if let autoSubDomainCreationPatternsContainer = autoSubDomainCreationPatternsContainer {
            autoSubDomainCreationPatternsDecoded0 = [Swift.String]()
            for string0 in autoSubDomainCreationPatternsContainer {
                if let string0 = string0 {
                    autoSubDomainCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoSubDomainCreationPatterns = autoSubDomainCreationPatternsDecoded0
        let autoSubDomainIAMRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoSubDomainIAMRole)
        autoSubDomainIAMRole = autoSubDomainIAMRoleDecoded
    }
}

extension UpdateDomainAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

/// The result structure for the update domain association request.
public struct UpdateDomainAssociationOutput: Swift.Equatable {
    /// Describes a domain association, which associates a custom domain with an Amplify app.
    /// This member is required.
    public var domainAssociation: AmplifyClientTypes.DomainAssociation?

    public init(
        domainAssociation: AmplifyClientTypes.DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct UpdateDomainAssociationOutputBody: Swift.Equatable {
    let domainAssociation: AmplifyClientTypes.DomainAssociation?
}

extension UpdateDomainAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

enum UpdateDomainAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWebhookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateWebhookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let webhookId = webhookId else {
            return nil
        }
        return "/webhooks/\(webhookId.urlPercentEncoding())"
    }
}

/// The request structure for the update webhook request.
public struct UpdateWebhookInput: Swift.Equatable {
    /// The name for a branch that is part of an Amplify app.
    public var branchName: Swift.String?
    /// The description for a webhook.
    public var description: Swift.String?
    /// The unique ID for a webhook.
    /// This member is required.
    public var webhookId: Swift.String?

    public init(
        branchName: Swift.String? = nil,
        description: Swift.String? = nil,
        webhookId: Swift.String? = nil
    )
    {
        self.branchName = branchName
        self.description = description
        self.webhookId = webhookId
    }
}

struct UpdateWebhookInputBody: Swift.Equatable {
    let branchName: Swift.String?
    let description: Swift.String?
}

extension UpdateWebhookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateWebhookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWebhookOutputBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// The result structure for the update webhook request.
public struct UpdateWebhookOutput: Swift.Equatable {
    /// Describes a webhook that connects repository events to an Amplify app.
    /// This member is required.
    public var webhook: AmplifyClientTypes.Webhook?

    public init(
        webhook: AmplifyClientTypes.Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct UpdateWebhookOutputBody: Swift.Equatable {
    let webhook: AmplifyClientTypes.Webhook?
}

extension UpdateWebhookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhook
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(AmplifyClientTypes.Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

enum UpdateWebhookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependentServiceFailureException": return try await DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyClientTypes.Webhook: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case createTime
        case description
        case updateTime
        case webhookArn
        case webhookId
        case webhookUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
        if let webhookArn = self.webhookArn {
            try encodeContainer.encode(webhookArn, forKey: .webhookArn)
        }
        if let webhookId = self.webhookId {
            try encodeContainer.encode(webhookId, forKey: .webhookId)
        }
        if let webhookUrl = self.webhookUrl {
            try encodeContainer.encode(webhookUrl, forKey: .webhookUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookArn)
        webhookArn = webhookArnDecoded
        let webhookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookId)
        webhookId = webhookIdDecoded
        let webhookUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookUrl)
        webhookUrl = webhookUrlDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension AmplifyClientTypes {
    /// Describes a webhook that connects repository events to an Amplify app.
    public struct Webhook: Swift.Equatable {
        /// The name for a branch that is part of an Amplify app.
        /// This member is required.
        public var branchName: Swift.String?
        /// The create date and time for a webhook.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description for a webhook.
        /// This member is required.
        public var description: Swift.String?
        /// Updates the date and time for a webhook.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the webhook.
        /// This member is required.
        public var webhookArn: Swift.String?
        /// The ID of the webhook.
        /// This member is required.
        public var webhookId: Swift.String?
        /// The URL of the webhook.
        /// This member is required.
        public var webhookUrl: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil,
            webhookArn: Swift.String? = nil,
            webhookId: Swift.String? = nil,
            webhookUrl: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.createTime = createTime
            self.description = description
            self.updateTime = updateTime
            self.webhookArn = webhookArn
            self.webhookId = webhookId
            self.webhookUrl = webhookUrl
        }
    }

}
