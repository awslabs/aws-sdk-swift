// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension QuickSightClient {
    /// Paginate over `[ListAnalysesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAnalysesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAnalysesOutputResponse`
    public func listAnalysesPaginated(input: ListAnalysesInput) -> ClientRuntime.PaginatorSequence<ListAnalysesInput, ListAnalysesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAnalysesInput, ListAnalysesOutputResponse>(input: input, inputKey: \ListAnalysesInput.nextToken, outputKey: \ListAnalysesOutputResponse.nextToken, paginationFunction: self.listAnalyses(input:))
    }
}

extension ListAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAnalysesInput {
        return ListAnalysesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAnalysesInput, Output == ListAnalysesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAnalysesPaginated`
    /// to access the nested member `[QuickSightClientTypes.AnalysisSummary]`
    /// - Returns: `[QuickSightClientTypes.AnalysisSummary]`
    public func analysisSummaryList() async throws -> [QuickSightClientTypes.AnalysisSummary] {
        return try await self.asyncCompactMap { item in item.analysisSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDashboardsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDashboardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDashboardsOutputResponse`
    public func listDashboardsPaginated(input: ListDashboardsInput) -> ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutputResponse>(input: input, inputKey: \ListDashboardsInput.nextToken, outputKey: \ListDashboardsOutputResponse.nextToken, paginationFunction: self.listDashboards(input:))
    }
}

extension ListDashboardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDashboardsInput {
        return ListDashboardsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDashboardsInput, Output == ListDashboardsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDashboardsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardSummary]`
    public func dashboardSummaryList() async throws -> [QuickSightClientTypes.DashboardSummary] {
        return try await self.asyncCompactMap { item in item.dashboardSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDashboardVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDashboardVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDashboardVersionsOutputResponse`
    public func listDashboardVersionsPaginated(input: ListDashboardVersionsInput) -> ClientRuntime.PaginatorSequence<ListDashboardVersionsInput, ListDashboardVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDashboardVersionsInput, ListDashboardVersionsOutputResponse>(input: input, inputKey: \ListDashboardVersionsInput.nextToken, outputKey: \ListDashboardVersionsOutputResponse.nextToken, paginationFunction: self.listDashboardVersions(input:))
    }
}

extension ListDashboardVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDashboardVersionsInput {
        return ListDashboardVersionsInput(
            awsAccountId: self.awsAccountId,
            dashboardId: self.dashboardId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDashboardVersionsInput, Output == ListDashboardVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDashboardVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardVersionSummary]`
    public func dashboardVersionSummaryList() async throws -> [QuickSightClientTypes.DashboardVersionSummary] {
        return try await self.asyncCompactMap { item in item.dashboardVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDataSetsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSetsOutputResponse`
    public func listDataSetsPaginated(input: ListDataSetsInput) -> ClientRuntime.PaginatorSequence<ListDataSetsInput, ListDataSetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSetsInput, ListDataSetsOutputResponse>(input: input, inputKey: \ListDataSetsInput.nextToken, outputKey: \ListDataSetsOutputResponse.nextToken, paginationFunction: self.listDataSets(input:))
    }
}

extension ListDataSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSetsInput {
        return ListDataSetsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDataSetsInput, Output == ListDataSetsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSetsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSetSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSetSummary]`
    public func dataSetSummaries() async throws -> [QuickSightClientTypes.DataSetSummary] {
        return try await self.asyncCompactMap { item in item.dataSetSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDataSourcesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSourcesOutputResponse`
    public func listDataSourcesPaginated(input: ListDataSourcesInput) -> ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse>(input: input, inputKey: \ListDataSourcesInput.nextToken, outputKey: \ListDataSourcesOutputResponse.nextToken, paginationFunction: self.listDataSources(input:))
    }
}

extension ListDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourcesInput {
        return ListDataSourcesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDataSourcesInput, Output == ListDataSourcesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSourcesPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSource]`
    /// - Returns: `[QuickSightClientTypes.DataSource]`
    public func dataSources() async throws -> [QuickSightClientTypes.DataSource] {
        return try await self.asyncCompactMap { item in item.dataSources }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListIngestionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionsOutputResponse`
    public func listIngestionsPaginated(input: ListIngestionsInput) -> ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutputResponse>(input: input, inputKey: \ListIngestionsInput.nextToken, outputKey: \ListIngestionsOutputResponse.nextToken, paginationFunction: self.listIngestions(input:))
    }
}

extension ListIngestionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionsInput {
        return ListIngestionsInput(
            awsAccountId: self.awsAccountId,
            dataSetId: self.dataSetId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIngestionsInput, Output == ListIngestionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Ingestion]`
    /// - Returns: `[QuickSightClientTypes.Ingestion]`
    public func ingestions() async throws -> [QuickSightClientTypes.Ingestion] {
        return try await self.asyncCompactMap { item in item.ingestions }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListNamespacesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNamespacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNamespacesOutputResponse`
    public func listNamespacesPaginated(input: ListNamespacesInput) -> ClientRuntime.PaginatorSequence<ListNamespacesInput, ListNamespacesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNamespacesInput, ListNamespacesOutputResponse>(input: input, inputKey: \ListNamespacesInput.nextToken, outputKey: \ListNamespacesOutputResponse.nextToken, paginationFunction: self.listNamespaces(input:))
    }
}

extension ListNamespacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNamespacesInput {
        return ListNamespacesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListNamespacesInput, Output == ListNamespacesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listNamespacesPaginated`
    /// to access the nested member `[QuickSightClientTypes.NamespaceInfoV2]`
    /// - Returns: `[QuickSightClientTypes.NamespaceInfoV2]`
    public func namespaces() async throws -> [QuickSightClientTypes.NamespaceInfoV2] {
        return try await self.asyncCompactMap { item in item.namespaces }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplateAliasesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplateAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplateAliasesOutputResponse`
    public func listTemplateAliasesPaginated(input: ListTemplateAliasesInput) -> ClientRuntime.PaginatorSequence<ListTemplateAliasesInput, ListTemplateAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTemplateAliasesInput, ListTemplateAliasesOutputResponse>(input: input, inputKey: \ListTemplateAliasesInput.nextToken, outputKey: \ListTemplateAliasesOutputResponse.nextToken, paginationFunction: self.listTemplateAliases(input:))
    }
}

extension ListTemplateAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplateAliasesInput {
        return ListTemplateAliasesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            templateId: self.templateId
        )}
}

extension PaginatorSequence where Input == ListTemplateAliasesInput, Output == ListTemplateAliasesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplateAliasesPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateAlias]`
    /// - Returns: `[QuickSightClientTypes.TemplateAlias]`
    public func templateAliasList() async throws -> [QuickSightClientTypes.TemplateAlias] {
        return try await self.asyncCompactMap { item in item.templateAliasList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplatesOutputResponse`
    public func listTemplatesPaginated(input: ListTemplatesInput) -> ClientRuntime.PaginatorSequence<ListTemplatesInput, ListTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTemplatesInput, ListTemplatesOutputResponse>(input: input, inputKey: \ListTemplatesInput.nextToken, outputKey: \ListTemplatesOutputResponse.nextToken, paginationFunction: self.listTemplates(input:))
    }
}

extension ListTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplatesInput {
        return ListTemplatesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListTemplatesInput, Output == ListTemplatesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplatesPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateSummary]`
    /// - Returns: `[QuickSightClientTypes.TemplateSummary]`
    public func templateSummaryList() async throws -> [QuickSightClientTypes.TemplateSummary] {
        return try await self.asyncCompactMap { item in item.templateSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplateVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplateVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplateVersionsOutputResponse`
    public func listTemplateVersionsPaginated(input: ListTemplateVersionsInput) -> ClientRuntime.PaginatorSequence<ListTemplateVersionsInput, ListTemplateVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTemplateVersionsInput, ListTemplateVersionsOutputResponse>(input: input, inputKey: \ListTemplateVersionsInput.nextToken, outputKey: \ListTemplateVersionsOutputResponse.nextToken, paginationFunction: self.listTemplateVersions(input:))
    }
}

extension ListTemplateVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplateVersionsInput {
        return ListTemplateVersionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            templateId: self.templateId
        )}
}

extension PaginatorSequence where Input == ListTemplateVersionsInput, Output == ListTemplateVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplateVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.TemplateVersionSummary]`
    public func templateVersionSummaryList() async throws -> [QuickSightClientTypes.TemplateVersionSummary] {
        return try await self.asyncCompactMap { item in item.templateVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListThemesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThemesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThemesOutputResponse`
    public func listThemesPaginated(input: ListThemesInput) -> ClientRuntime.PaginatorSequence<ListThemesInput, ListThemesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThemesInput, ListThemesOutputResponse>(input: input, inputKey: \ListThemesInput.nextToken, outputKey: \ListThemesOutputResponse.nextToken, paginationFunction: self.listThemes(input:))
    }
}

extension ListThemesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThemesInput {
        return ListThemesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == ListThemesInput, Output == ListThemesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listThemesPaginated`
    /// to access the nested member `[QuickSightClientTypes.ThemeSummary]`
    /// - Returns: `[QuickSightClientTypes.ThemeSummary]`
    public func themeSummaryList() async throws -> [QuickSightClientTypes.ThemeSummary] {
        return try await self.asyncCompactMap { item in item.themeSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListThemeVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThemeVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThemeVersionsOutputResponse`
    public func listThemeVersionsPaginated(input: ListThemeVersionsInput) -> ClientRuntime.PaginatorSequence<ListThemeVersionsInput, ListThemeVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThemeVersionsInput, ListThemeVersionsOutputResponse>(input: input, inputKey: \ListThemeVersionsInput.nextToken, outputKey: \ListThemeVersionsOutputResponse.nextToken, paginationFunction: self.listThemeVersions(input:))
    }
}

extension ListThemeVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThemeVersionsInput {
        return ListThemeVersionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            themeId: self.themeId
        )}
}

extension PaginatorSequence where Input == ListThemeVersionsInput, Output == ListThemeVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listThemeVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.ThemeVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.ThemeVersionSummary]`
    public func themeVersionSummaryList() async throws -> [QuickSightClientTypes.ThemeVersionSummary] {
        return try await self.asyncCompactMap { item in item.themeVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchAnalysesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchAnalysesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchAnalysesOutputResponse`
    public func searchAnalysesPaginated(input: SearchAnalysesInput) -> ClientRuntime.PaginatorSequence<SearchAnalysesInput, SearchAnalysesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchAnalysesInput, SearchAnalysesOutputResponse>(input: input, inputKey: \SearchAnalysesInput.nextToken, outputKey: \SearchAnalysesOutputResponse.nextToken, paginationFunction: self.searchAnalyses(input:))
    }
}

extension SearchAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchAnalysesInput {
        return SearchAnalysesInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchAnalysesInput, Output == SearchAnalysesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchAnalysesPaginated`
    /// to access the nested member `[QuickSightClientTypes.AnalysisSummary]`
    /// - Returns: `[QuickSightClientTypes.AnalysisSummary]`
    public func analysisSummaryList() async throws -> [QuickSightClientTypes.AnalysisSummary] {
        return try await self.asyncCompactMap { item in item.analysisSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDashboardsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDashboardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDashboardsOutputResponse`
    public func searchDashboardsPaginated(input: SearchDashboardsInput) -> ClientRuntime.PaginatorSequence<SearchDashboardsInput, SearchDashboardsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchDashboardsInput, SearchDashboardsOutputResponse>(input: input, inputKey: \SearchDashboardsInput.nextToken, outputKey: \SearchDashboardsOutputResponse.nextToken, paginationFunction: self.searchDashboards(input:))
    }
}

extension SearchDashboardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDashboardsInput {
        return SearchDashboardsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchDashboardsInput, Output == SearchDashboardsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchDashboardsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardSummary]`
    public func dashboardSummaryList() async throws -> [QuickSightClientTypes.DashboardSummary] {
        return try await self.asyncCompactMap { item in item.dashboardSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDataSetsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDataSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDataSetsOutputResponse`
    public func searchDataSetsPaginated(input: SearchDataSetsInput) -> ClientRuntime.PaginatorSequence<SearchDataSetsInput, SearchDataSetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchDataSetsInput, SearchDataSetsOutputResponse>(input: input, inputKey: \SearchDataSetsInput.nextToken, outputKey: \SearchDataSetsOutputResponse.nextToken, paginationFunction: self.searchDataSets(input:))
    }
}

extension SearchDataSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDataSetsInput {
        return SearchDataSetsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchDataSetsInput, Output == SearchDataSetsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchDataSetsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSetSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSetSummary]`
    public func dataSetSummaries() async throws -> [QuickSightClientTypes.DataSetSummary] {
        return try await self.asyncCompactMap { item in item.dataSetSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDataSourcesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDataSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDataSourcesOutputResponse`
    public func searchDataSourcesPaginated(input: SearchDataSourcesInput) -> ClientRuntime.PaginatorSequence<SearchDataSourcesInput, SearchDataSourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchDataSourcesInput, SearchDataSourcesOutputResponse>(input: input, inputKey: \SearchDataSourcesInput.nextToken, outputKey: \SearchDataSourcesOutputResponse.nextToken, paginationFunction: self.searchDataSources(input:))
    }
}

extension SearchDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDataSourcesInput {
        return SearchDataSourcesInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchDataSourcesInput, Output == SearchDataSourcesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchDataSourcesPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSourceSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSourceSummary]`
    public func dataSourceSummaries() async throws -> [QuickSightClientTypes.DataSourceSummary] {
        return try await self.asyncCompactMap { item in item.dataSourceSummaries }
    }
}
