// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension QuickSightClient {
    /// Paginate over `[DescribeFolderPermissionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFolderPermissionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFolderPermissionsOutputResponse`
    public func describeFolderPermissionsPaginated(input: DescribeFolderPermissionsInput) -> ClientRuntime.PaginatorSequence<DescribeFolderPermissionsInput, DescribeFolderPermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFolderPermissionsInput, DescribeFolderPermissionsOutputResponse>(input: input, inputKey: \DescribeFolderPermissionsInput.nextToken, outputKey: \DescribeFolderPermissionsOutputResponse.nextToken, paginationFunction: self.describeFolderPermissions(input:))
    }
}

extension DescribeFolderPermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFolderPermissionsInput {
        return DescribeFolderPermissionsInput(
            awsAccountId: self.awsAccountId,
            folderId: self.folderId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == DescribeFolderPermissionsInput, Output == DescribeFolderPermissionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeFolderPermissionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.ResourcePermission]`
    /// - Returns: `[QuickSightClientTypes.ResourcePermission]`
    public func permissions() async throws -> [QuickSightClientTypes.ResourcePermission] {
        return try await self.asyncCompactMap { item in item.permissions }
    }
}
extension QuickSightClient {
    /// Paginate over `[DescribeFolderResolvedPermissionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFolderResolvedPermissionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFolderResolvedPermissionsOutputResponse`
    public func describeFolderResolvedPermissionsPaginated(input: DescribeFolderResolvedPermissionsInput) -> ClientRuntime.PaginatorSequence<DescribeFolderResolvedPermissionsInput, DescribeFolderResolvedPermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFolderResolvedPermissionsInput, DescribeFolderResolvedPermissionsOutputResponse>(input: input, inputKey: \DescribeFolderResolvedPermissionsInput.nextToken, outputKey: \DescribeFolderResolvedPermissionsOutputResponse.nextToken, paginationFunction: self.describeFolderResolvedPermissions(input:))
    }
}

extension DescribeFolderResolvedPermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFolderResolvedPermissionsInput {
        return DescribeFolderResolvedPermissionsInput(
            awsAccountId: self.awsAccountId,
            folderId: self.folderId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == DescribeFolderResolvedPermissionsInput, Output == DescribeFolderResolvedPermissionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeFolderResolvedPermissionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.ResourcePermission]`
    /// - Returns: `[QuickSightClientTypes.ResourcePermission]`
    public func permissions() async throws -> [QuickSightClientTypes.ResourcePermission] {
        return try await self.asyncCompactMap { item in item.permissions }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListAnalysesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAnalysesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAnalysesOutputResponse`
    public func listAnalysesPaginated(input: ListAnalysesInput) -> ClientRuntime.PaginatorSequence<ListAnalysesInput, ListAnalysesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAnalysesInput, ListAnalysesOutputResponse>(input: input, inputKey: \ListAnalysesInput.nextToken, outputKey: \ListAnalysesOutputResponse.nextToken, paginationFunction: self.listAnalyses(input:))
    }
}

extension ListAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAnalysesInput {
        return ListAnalysesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAnalysesInput, Output == ListAnalysesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAnalysesPaginated`
    /// to access the nested member `[QuickSightClientTypes.AnalysisSummary]`
    /// - Returns: `[QuickSightClientTypes.AnalysisSummary]`
    public func analysisSummaryList() async throws -> [QuickSightClientTypes.AnalysisSummary] {
        return try await self.asyncCompactMap { item in item.analysisSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListAssetBundleExportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetBundleExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetBundleExportJobsOutputResponse`
    public func listAssetBundleExportJobsPaginated(input: ListAssetBundleExportJobsInput) -> ClientRuntime.PaginatorSequence<ListAssetBundleExportJobsInput, ListAssetBundleExportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssetBundleExportJobsInput, ListAssetBundleExportJobsOutputResponse>(input: input, inputKey: \ListAssetBundleExportJobsInput.nextToken, outputKey: \ListAssetBundleExportJobsOutputResponse.nextToken, paginationFunction: self.listAssetBundleExportJobs(input:))
    }
}

extension ListAssetBundleExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetBundleExportJobsInput {
        return ListAssetBundleExportJobsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAssetBundleExportJobsInput, Output == ListAssetBundleExportJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetBundleExportJobsPaginated`
    /// to access the nested member `[QuickSightClientTypes.AssetBundleExportJobSummary]`
    /// - Returns: `[QuickSightClientTypes.AssetBundleExportJobSummary]`
    public func assetBundleExportJobSummaryList() async throws -> [QuickSightClientTypes.AssetBundleExportJobSummary] {
        return try await self.asyncCompactMap { item in item.assetBundleExportJobSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListAssetBundleImportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetBundleImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetBundleImportJobsOutputResponse`
    public func listAssetBundleImportJobsPaginated(input: ListAssetBundleImportJobsInput) -> ClientRuntime.PaginatorSequence<ListAssetBundleImportJobsInput, ListAssetBundleImportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssetBundleImportJobsInput, ListAssetBundleImportJobsOutputResponse>(input: input, inputKey: \ListAssetBundleImportJobsInput.nextToken, outputKey: \ListAssetBundleImportJobsOutputResponse.nextToken, paginationFunction: self.listAssetBundleImportJobs(input:))
    }
}

extension ListAssetBundleImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetBundleImportJobsInput {
        return ListAssetBundleImportJobsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAssetBundleImportJobsInput, Output == ListAssetBundleImportJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetBundleImportJobsPaginated`
    /// to access the nested member `[QuickSightClientTypes.AssetBundleImportJobSummary]`
    /// - Returns: `[QuickSightClientTypes.AssetBundleImportJobSummary]`
    public func assetBundleImportJobSummaryList() async throws -> [QuickSightClientTypes.AssetBundleImportJobSummary] {
        return try await self.asyncCompactMap { item in item.assetBundleImportJobSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDashboardsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDashboardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDashboardsOutputResponse`
    public func listDashboardsPaginated(input: ListDashboardsInput) -> ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutputResponse>(input: input, inputKey: \ListDashboardsInput.nextToken, outputKey: \ListDashboardsOutputResponse.nextToken, paginationFunction: self.listDashboards(input:))
    }
}

extension ListDashboardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDashboardsInput {
        return ListDashboardsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDashboardsInput, Output == ListDashboardsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDashboardsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardSummary]`
    public func dashboardSummaryList() async throws -> [QuickSightClientTypes.DashboardSummary] {
        return try await self.asyncCompactMap { item in item.dashboardSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDashboardVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDashboardVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDashboardVersionsOutputResponse`
    public func listDashboardVersionsPaginated(input: ListDashboardVersionsInput) -> ClientRuntime.PaginatorSequence<ListDashboardVersionsInput, ListDashboardVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDashboardVersionsInput, ListDashboardVersionsOutputResponse>(input: input, inputKey: \ListDashboardVersionsInput.nextToken, outputKey: \ListDashboardVersionsOutputResponse.nextToken, paginationFunction: self.listDashboardVersions(input:))
    }
}

extension ListDashboardVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDashboardVersionsInput {
        return ListDashboardVersionsInput(
            awsAccountId: self.awsAccountId,
            dashboardId: self.dashboardId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDashboardVersionsInput, Output == ListDashboardVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDashboardVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardVersionSummary]`
    public func dashboardVersionSummaryList() async throws -> [QuickSightClientTypes.DashboardVersionSummary] {
        return try await self.asyncCompactMap { item in item.dashboardVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDataSetsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSetsOutputResponse`
    public func listDataSetsPaginated(input: ListDataSetsInput) -> ClientRuntime.PaginatorSequence<ListDataSetsInput, ListDataSetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSetsInput, ListDataSetsOutputResponse>(input: input, inputKey: \ListDataSetsInput.nextToken, outputKey: \ListDataSetsOutputResponse.nextToken, paginationFunction: self.listDataSets(input:))
    }
}

extension ListDataSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSetsInput {
        return ListDataSetsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDataSetsInput, Output == ListDataSetsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSetsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSetSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSetSummary]`
    public func dataSetSummaries() async throws -> [QuickSightClientTypes.DataSetSummary] {
        return try await self.asyncCompactMap { item in item.dataSetSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDataSourcesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSourcesOutputResponse`
    public func listDataSourcesPaginated(input: ListDataSourcesInput) -> ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutputResponse>(input: input, inputKey: \ListDataSourcesInput.nextToken, outputKey: \ListDataSourcesOutputResponse.nextToken, paginationFunction: self.listDataSources(input:))
    }
}

extension ListDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourcesInput {
        return ListDataSourcesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDataSourcesInput, Output == ListDataSourcesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSourcesPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSource]`
    /// - Returns: `[QuickSightClientTypes.DataSource]`
    public func dataSources() async throws -> [QuickSightClientTypes.DataSource] {
        return try await self.asyncCompactMap { item in item.dataSources }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListFolderMembersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFolderMembersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFolderMembersOutputResponse`
    public func listFolderMembersPaginated(input: ListFolderMembersInput) -> ClientRuntime.PaginatorSequence<ListFolderMembersInput, ListFolderMembersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFolderMembersInput, ListFolderMembersOutputResponse>(input: input, inputKey: \ListFolderMembersInput.nextToken, outputKey: \ListFolderMembersOutputResponse.nextToken, paginationFunction: self.listFolderMembers(input:))
    }
}

extension ListFolderMembersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFolderMembersInput {
        return ListFolderMembersInput(
            awsAccountId: self.awsAccountId,
            folderId: self.folderId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFolderMembersInput, Output == ListFolderMembersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFolderMembersPaginated`
    /// to access the nested member `[QuickSightClientTypes.MemberIdArnPair]`
    /// - Returns: `[QuickSightClientTypes.MemberIdArnPair]`
    public func folderMemberList() async throws -> [QuickSightClientTypes.MemberIdArnPair] {
        return try await self.asyncCompactMap { item in item.folderMemberList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListFoldersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFoldersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFoldersOutputResponse`
    public func listFoldersPaginated(input: ListFoldersInput) -> ClientRuntime.PaginatorSequence<ListFoldersInput, ListFoldersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFoldersInput, ListFoldersOutputResponse>(input: input, inputKey: \ListFoldersInput.nextToken, outputKey: \ListFoldersOutputResponse.nextToken, paginationFunction: self.listFolders(input:))
    }
}

extension ListFoldersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFoldersInput {
        return ListFoldersInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFoldersInput, Output == ListFoldersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFoldersPaginated`
    /// to access the nested member `[QuickSightClientTypes.FolderSummary]`
    /// - Returns: `[QuickSightClientTypes.FolderSummary]`
    public func folderSummaryList() async throws -> [QuickSightClientTypes.FolderSummary] {
        return try await self.asyncCompactMap { item in item.folderSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListGroupMembershipsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupMembershipsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupMembershipsOutputResponse`
    public func listGroupMembershipsPaginated(input: ListGroupMembershipsInput) -> ClientRuntime.PaginatorSequence<ListGroupMembershipsInput, ListGroupMembershipsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGroupMembershipsInput, ListGroupMembershipsOutputResponse>(input: input, inputKey: \ListGroupMembershipsInput.nextToken, outputKey: \ListGroupMembershipsOutputResponse.nextToken, paginationFunction: self.listGroupMemberships(input:))
    }
}

extension ListGroupMembershipsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupMembershipsInput {
        return ListGroupMembershipsInput(
            awsAccountId: self.awsAccountId,
            groupName: self.groupName,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListGroupMembershipsInput, Output == ListGroupMembershipsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupMembershipsPaginated`
    /// to access the nested member `[QuickSightClientTypes.GroupMember]`
    /// - Returns: `[QuickSightClientTypes.GroupMember]`
    public func groupMemberList() async throws -> [QuickSightClientTypes.GroupMember] {
        return try await self.asyncCompactMap { item in item.groupMemberList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupsOutputResponse`
    public func listGroupsPaginated(input: ListGroupsInput) -> ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutputResponse>(input: input, inputKey: \ListGroupsInput.nextToken, outputKey: \ListGroupsOutputResponse.nextToken, paginationFunction: self.listGroups(input:))
    }
}

extension ListGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsInput {
        return ListGroupsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListGroupsInput, Output == ListGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Group]`
    /// - Returns: `[QuickSightClientTypes.Group]`
    public func groupList() async throws -> [QuickSightClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groupList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListIAMPolicyAssignmentsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIAMPolicyAssignmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIAMPolicyAssignmentsOutputResponse`
    public func listIAMPolicyAssignmentsPaginated(input: ListIAMPolicyAssignmentsInput) -> ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsInput, ListIAMPolicyAssignmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsInput, ListIAMPolicyAssignmentsOutputResponse>(input: input, inputKey: \ListIAMPolicyAssignmentsInput.nextToken, outputKey: \ListIAMPolicyAssignmentsOutputResponse.nextToken, paginationFunction: self.listIAMPolicyAssignments(input:))
    }
}

extension ListIAMPolicyAssignmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIAMPolicyAssignmentsInput {
        return ListIAMPolicyAssignmentsInput(
            assignmentStatus: self.assignmentStatus,
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIAMPolicyAssignmentsInput, Output == ListIAMPolicyAssignmentsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIAMPolicyAssignmentsPaginated`
    /// to access the nested member `[QuickSightClientTypes.IAMPolicyAssignmentSummary]`
    /// - Returns: `[QuickSightClientTypes.IAMPolicyAssignmentSummary]`
    public func iamPolicyAssignments() async throws -> [QuickSightClientTypes.IAMPolicyAssignmentSummary] {
        return try await self.asyncCompactMap { item in item.iamPolicyAssignments }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListIAMPolicyAssignmentsForUserOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIAMPolicyAssignmentsForUserInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIAMPolicyAssignmentsForUserOutputResponse`
    public func listIAMPolicyAssignmentsForUserPaginated(input: ListIAMPolicyAssignmentsForUserInput) -> ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsForUserInput, ListIAMPolicyAssignmentsForUserOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsForUserInput, ListIAMPolicyAssignmentsForUserOutputResponse>(input: input, inputKey: \ListIAMPolicyAssignmentsForUserInput.nextToken, outputKey: \ListIAMPolicyAssignmentsForUserOutputResponse.nextToken, paginationFunction: self.listIAMPolicyAssignmentsForUser(input:))
    }
}

extension ListIAMPolicyAssignmentsForUserInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIAMPolicyAssignmentsForUserInput {
        return ListIAMPolicyAssignmentsForUserInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            userName: self.userName
        )}
}

extension PaginatorSequence where Input == ListIAMPolicyAssignmentsForUserInput, Output == ListIAMPolicyAssignmentsForUserOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIAMPolicyAssignmentsForUserPaginated`
    /// to access the nested member `[QuickSightClientTypes.ActiveIAMPolicyAssignment]`
    /// - Returns: `[QuickSightClientTypes.ActiveIAMPolicyAssignment]`
    public func activeAssignments() async throws -> [QuickSightClientTypes.ActiveIAMPolicyAssignment] {
        return try await self.asyncCompactMap { item in item.activeAssignments }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListIngestionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionsOutputResponse`
    public func listIngestionsPaginated(input: ListIngestionsInput) -> ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutputResponse>(input: input, inputKey: \ListIngestionsInput.nextToken, outputKey: \ListIngestionsOutputResponse.nextToken, paginationFunction: self.listIngestions(input:))
    }
}

extension ListIngestionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionsInput {
        return ListIngestionsInput(
            awsAccountId: self.awsAccountId,
            dataSetId: self.dataSetId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIngestionsInput, Output == ListIngestionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Ingestion]`
    /// - Returns: `[QuickSightClientTypes.Ingestion]`
    public func ingestions() async throws -> [QuickSightClientTypes.Ingestion] {
        return try await self.asyncCompactMap { item in item.ingestions }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListNamespacesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNamespacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNamespacesOutputResponse`
    public func listNamespacesPaginated(input: ListNamespacesInput) -> ClientRuntime.PaginatorSequence<ListNamespacesInput, ListNamespacesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNamespacesInput, ListNamespacesOutputResponse>(input: input, inputKey: \ListNamespacesInput.nextToken, outputKey: \ListNamespacesOutputResponse.nextToken, paginationFunction: self.listNamespaces(input:))
    }
}

extension ListNamespacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNamespacesInput {
        return ListNamespacesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListNamespacesInput, Output == ListNamespacesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listNamespacesPaginated`
    /// to access the nested member `[QuickSightClientTypes.NamespaceInfoV2]`
    /// - Returns: `[QuickSightClientTypes.NamespaceInfoV2]`
    public func namespaces() async throws -> [QuickSightClientTypes.NamespaceInfoV2] {
        return try await self.asyncCompactMap { item in item.namespaces }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplateAliasesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplateAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplateAliasesOutputResponse`
    public func listTemplateAliasesPaginated(input: ListTemplateAliasesInput) -> ClientRuntime.PaginatorSequence<ListTemplateAliasesInput, ListTemplateAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTemplateAliasesInput, ListTemplateAliasesOutputResponse>(input: input, inputKey: \ListTemplateAliasesInput.nextToken, outputKey: \ListTemplateAliasesOutputResponse.nextToken, paginationFunction: self.listTemplateAliases(input:))
    }
}

extension ListTemplateAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplateAliasesInput {
        return ListTemplateAliasesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            templateId: self.templateId
        )}
}

extension PaginatorSequence where Input == ListTemplateAliasesInput, Output == ListTemplateAliasesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplateAliasesPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateAlias]`
    /// - Returns: `[QuickSightClientTypes.TemplateAlias]`
    public func templateAliasList() async throws -> [QuickSightClientTypes.TemplateAlias] {
        return try await self.asyncCompactMap { item in item.templateAliasList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplatesOutputResponse`
    public func listTemplatesPaginated(input: ListTemplatesInput) -> ClientRuntime.PaginatorSequence<ListTemplatesInput, ListTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTemplatesInput, ListTemplatesOutputResponse>(input: input, inputKey: \ListTemplatesInput.nextToken, outputKey: \ListTemplatesOutputResponse.nextToken, paginationFunction: self.listTemplates(input:))
    }
}

extension ListTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplatesInput {
        return ListTemplatesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListTemplatesInput, Output == ListTemplatesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplatesPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateSummary]`
    /// - Returns: `[QuickSightClientTypes.TemplateSummary]`
    public func templateSummaryList() async throws -> [QuickSightClientTypes.TemplateSummary] {
        return try await self.asyncCompactMap { item in item.templateSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplateVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplateVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplateVersionsOutputResponse`
    public func listTemplateVersionsPaginated(input: ListTemplateVersionsInput) -> ClientRuntime.PaginatorSequence<ListTemplateVersionsInput, ListTemplateVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTemplateVersionsInput, ListTemplateVersionsOutputResponse>(input: input, inputKey: \ListTemplateVersionsInput.nextToken, outputKey: \ListTemplateVersionsOutputResponse.nextToken, paginationFunction: self.listTemplateVersions(input:))
    }
}

extension ListTemplateVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplateVersionsInput {
        return ListTemplateVersionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            templateId: self.templateId
        )}
}

extension PaginatorSequence where Input == ListTemplateVersionsInput, Output == ListTemplateVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplateVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.TemplateVersionSummary]`
    public func templateVersionSummaryList() async throws -> [QuickSightClientTypes.TemplateVersionSummary] {
        return try await self.asyncCompactMap { item in item.templateVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListThemesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThemesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThemesOutputResponse`
    public func listThemesPaginated(input: ListThemesInput) -> ClientRuntime.PaginatorSequence<ListThemesInput, ListThemesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThemesInput, ListThemesOutputResponse>(input: input, inputKey: \ListThemesInput.nextToken, outputKey: \ListThemesOutputResponse.nextToken, paginationFunction: self.listThemes(input:))
    }
}

extension ListThemesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThemesInput {
        return ListThemesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == ListThemesInput, Output == ListThemesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listThemesPaginated`
    /// to access the nested member `[QuickSightClientTypes.ThemeSummary]`
    /// - Returns: `[QuickSightClientTypes.ThemeSummary]`
    public func themeSummaryList() async throws -> [QuickSightClientTypes.ThemeSummary] {
        return try await self.asyncCompactMap { item in item.themeSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListThemeVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThemeVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThemeVersionsOutputResponse`
    public func listThemeVersionsPaginated(input: ListThemeVersionsInput) -> ClientRuntime.PaginatorSequence<ListThemeVersionsInput, ListThemeVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThemeVersionsInput, ListThemeVersionsOutputResponse>(input: input, inputKey: \ListThemeVersionsInput.nextToken, outputKey: \ListThemeVersionsOutputResponse.nextToken, paginationFunction: self.listThemeVersions(input:))
    }
}

extension ListThemeVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThemeVersionsInput {
        return ListThemeVersionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            themeId: self.themeId
        )}
}

extension PaginatorSequence where Input == ListThemeVersionsInput, Output == ListThemeVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listThemeVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.ThemeVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.ThemeVersionSummary]`
    public func themeVersionSummaryList() async throws -> [QuickSightClientTypes.ThemeVersionSummary] {
        return try await self.asyncCompactMap { item in item.themeVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTopicsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTopicsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTopicsOutputResponse`
    public func listTopicsPaginated(input: ListTopicsInput) -> ClientRuntime.PaginatorSequence<ListTopicsInput, ListTopicsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTopicsInput, ListTopicsOutputResponse>(input: input, inputKey: \ListTopicsInput.nextToken, outputKey: \ListTopicsOutputResponse.nextToken, paginationFunction: self.listTopics(input:))
    }
}

extension ListTopicsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTopicsInput {
        return ListTopicsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension QuickSightClient {
    /// Paginate over `[ListUserGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUserGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUserGroupsOutputResponse`
    public func listUserGroupsPaginated(input: ListUserGroupsInput) -> ClientRuntime.PaginatorSequence<ListUserGroupsInput, ListUserGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUserGroupsInput, ListUserGroupsOutputResponse>(input: input, inputKey: \ListUserGroupsInput.nextToken, outputKey: \ListUserGroupsOutputResponse.nextToken, paginationFunction: self.listUserGroups(input:))
    }
}

extension ListUserGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserGroupsInput {
        return ListUserGroupsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            userName: self.userName
        )}
}

extension PaginatorSequence where Input == ListUserGroupsInput, Output == ListUserGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listUserGroupsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Group]`
    /// - Returns: `[QuickSightClientTypes.Group]`
    public func groupList() async throws -> [QuickSightClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groupList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListUsersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutputResponse`
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse>(input: input, inputKey: \ListUsersInput.nextToken, outputKey: \ListUsersOutputResponse.nextToken, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListUsersInput, Output == ListUsersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
    /// to access the nested member `[QuickSightClientTypes.User]`
    /// - Returns: `[QuickSightClientTypes.User]`
    public func userList() async throws -> [QuickSightClientTypes.User] {
        return try await self.asyncCompactMap { item in item.userList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListVPCConnectionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListVPCConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListVPCConnectionsOutputResponse`
    public func listVPCConnectionsPaginated(input: ListVPCConnectionsInput) -> ClientRuntime.PaginatorSequence<ListVPCConnectionsInput, ListVPCConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListVPCConnectionsInput, ListVPCConnectionsOutputResponse>(input: input, inputKey: \ListVPCConnectionsInput.nextToken, outputKey: \ListVPCConnectionsOutputResponse.nextToken, paginationFunction: self.listVPCConnections(input:))
    }
}

extension ListVPCConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVPCConnectionsInput {
        return ListVPCConnectionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension QuickSightClient {
    /// Paginate over `[SearchAnalysesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchAnalysesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchAnalysesOutputResponse`
    public func searchAnalysesPaginated(input: SearchAnalysesInput) -> ClientRuntime.PaginatorSequence<SearchAnalysesInput, SearchAnalysesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchAnalysesInput, SearchAnalysesOutputResponse>(input: input, inputKey: \SearchAnalysesInput.nextToken, outputKey: \SearchAnalysesOutputResponse.nextToken, paginationFunction: self.searchAnalyses(input:))
    }
}

extension SearchAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchAnalysesInput {
        return SearchAnalysesInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchAnalysesInput, Output == SearchAnalysesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchAnalysesPaginated`
    /// to access the nested member `[QuickSightClientTypes.AnalysisSummary]`
    /// - Returns: `[QuickSightClientTypes.AnalysisSummary]`
    public func analysisSummaryList() async throws -> [QuickSightClientTypes.AnalysisSummary] {
        return try await self.asyncCompactMap { item in item.analysisSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDashboardsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDashboardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDashboardsOutputResponse`
    public func searchDashboardsPaginated(input: SearchDashboardsInput) -> ClientRuntime.PaginatorSequence<SearchDashboardsInput, SearchDashboardsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchDashboardsInput, SearchDashboardsOutputResponse>(input: input, inputKey: \SearchDashboardsInput.nextToken, outputKey: \SearchDashboardsOutputResponse.nextToken, paginationFunction: self.searchDashboards(input:))
    }
}

extension SearchDashboardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDashboardsInput {
        return SearchDashboardsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchDashboardsInput, Output == SearchDashboardsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchDashboardsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardSummary]`
    public func dashboardSummaryList() async throws -> [QuickSightClientTypes.DashboardSummary] {
        return try await self.asyncCompactMap { item in item.dashboardSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDataSetsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDataSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDataSetsOutputResponse`
    public func searchDataSetsPaginated(input: SearchDataSetsInput) -> ClientRuntime.PaginatorSequence<SearchDataSetsInput, SearchDataSetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchDataSetsInput, SearchDataSetsOutputResponse>(input: input, inputKey: \SearchDataSetsInput.nextToken, outputKey: \SearchDataSetsOutputResponse.nextToken, paginationFunction: self.searchDataSets(input:))
    }
}

extension SearchDataSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDataSetsInput {
        return SearchDataSetsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchDataSetsInput, Output == SearchDataSetsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchDataSetsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSetSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSetSummary]`
    public func dataSetSummaries() async throws -> [QuickSightClientTypes.DataSetSummary] {
        return try await self.asyncCompactMap { item in item.dataSetSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDataSourcesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDataSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDataSourcesOutputResponse`
    public func searchDataSourcesPaginated(input: SearchDataSourcesInput) -> ClientRuntime.PaginatorSequence<SearchDataSourcesInput, SearchDataSourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchDataSourcesInput, SearchDataSourcesOutputResponse>(input: input, inputKey: \SearchDataSourcesInput.nextToken, outputKey: \SearchDataSourcesOutputResponse.nextToken, paginationFunction: self.searchDataSources(input:))
    }
}

extension SearchDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDataSourcesInput {
        return SearchDataSourcesInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchDataSourcesInput, Output == SearchDataSourcesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchDataSourcesPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSourceSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSourceSummary]`
    public func dataSourceSummaries() async throws -> [QuickSightClientTypes.DataSourceSummary] {
        return try await self.asyncCompactMap { item in item.dataSourceSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchFoldersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchFoldersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchFoldersOutputResponse`
    public func searchFoldersPaginated(input: SearchFoldersInput) -> ClientRuntime.PaginatorSequence<SearchFoldersInput, SearchFoldersOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchFoldersInput, SearchFoldersOutputResponse>(input: input, inputKey: \SearchFoldersInput.nextToken, outputKey: \SearchFoldersOutputResponse.nextToken, paginationFunction: self.searchFolders(input:))
    }
}

extension SearchFoldersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchFoldersInput {
        return SearchFoldersInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchFoldersInput, Output == SearchFoldersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchFoldersPaginated`
    /// to access the nested member `[QuickSightClientTypes.FolderSummary]`
    /// - Returns: `[QuickSightClientTypes.FolderSummary]`
    public func folderSummaryList() async throws -> [QuickSightClientTypes.FolderSummary] {
        return try await self.asyncCompactMap { item in item.folderSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchGroupsOutputResponse`
    public func searchGroupsPaginated(input: SearchGroupsInput) -> ClientRuntime.PaginatorSequence<SearchGroupsInput, SearchGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchGroupsInput, SearchGroupsOutputResponse>(input: input, inputKey: \SearchGroupsInput.nextToken, outputKey: \SearchGroupsOutputResponse.nextToken, paginationFunction: self.searchGroups(input:))
    }
}

extension SearchGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchGroupsInput {
        return SearchGroupsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == SearchGroupsInput, Output == SearchGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `searchGroupsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Group]`
    /// - Returns: `[QuickSightClientTypes.Group]`
    public func groupList() async throws -> [QuickSightClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groupList }
    }
}
