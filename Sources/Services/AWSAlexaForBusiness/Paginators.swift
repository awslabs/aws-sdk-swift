// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AlexaForBusinessClient {
    /// Paginate over `[ListBusinessReportSchedulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBusinessReportSchedulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBusinessReportSchedulesOutput`
    public func listBusinessReportSchedulesPaginated(input: ListBusinessReportSchedulesInput) -> ClientRuntime.PaginatorSequence<ListBusinessReportSchedulesInput, ListBusinessReportSchedulesOutput> {
        return ClientRuntime.PaginatorSequence<ListBusinessReportSchedulesInput, ListBusinessReportSchedulesOutput>(input: input, inputKey: \ListBusinessReportSchedulesInput.nextToken, outputKey: \ListBusinessReportSchedulesOutput.nextToken, paginationFunction: self.listBusinessReportSchedules(input:))
    }
}

extension ListBusinessReportSchedulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBusinessReportSchedulesInput {
        return ListBusinessReportSchedulesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListConferenceProvidersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConferenceProvidersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConferenceProvidersOutput`
    public func listConferenceProvidersPaginated(input: ListConferenceProvidersInput) -> ClientRuntime.PaginatorSequence<ListConferenceProvidersInput, ListConferenceProvidersOutput> {
        return ClientRuntime.PaginatorSequence<ListConferenceProvidersInput, ListConferenceProvidersOutput>(input: input, inputKey: \ListConferenceProvidersInput.nextToken, outputKey: \ListConferenceProvidersOutput.nextToken, paginationFunction: self.listConferenceProviders(input:))
    }
}

extension ListConferenceProvidersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConferenceProvidersInput {
        return ListConferenceProvidersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListDeviceEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDeviceEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDeviceEventsOutput`
    public func listDeviceEventsPaginated(input: ListDeviceEventsInput) -> ClientRuntime.PaginatorSequence<ListDeviceEventsInput, ListDeviceEventsOutput> {
        return ClientRuntime.PaginatorSequence<ListDeviceEventsInput, ListDeviceEventsOutput>(input: input, inputKey: \ListDeviceEventsInput.nextToken, outputKey: \ListDeviceEventsOutput.nextToken, paginationFunction: self.listDeviceEvents(input:))
    }
}

extension ListDeviceEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeviceEventsInput {
        return ListDeviceEventsInput(
            deviceArn: self.deviceArn,
            eventType: self.eventType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListGatewayGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGatewayGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGatewayGroupsOutput`
    public func listGatewayGroupsPaginated(input: ListGatewayGroupsInput) -> ClientRuntime.PaginatorSequence<ListGatewayGroupsInput, ListGatewayGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListGatewayGroupsInput, ListGatewayGroupsOutput>(input: input, inputKey: \ListGatewayGroupsInput.nextToken, outputKey: \ListGatewayGroupsOutput.nextToken, paginationFunction: self.listGatewayGroups(input:))
    }
}

extension ListGatewayGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGatewayGroupsInput {
        return ListGatewayGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListGatewaysOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGatewaysInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGatewaysOutput`
    public func listGatewaysPaginated(input: ListGatewaysInput) -> ClientRuntime.PaginatorSequence<ListGatewaysInput, ListGatewaysOutput> {
        return ClientRuntime.PaginatorSequence<ListGatewaysInput, ListGatewaysOutput>(input: input, inputKey: \ListGatewaysInput.nextToken, outputKey: \ListGatewaysOutput.nextToken, paginationFunction: self.listGateways(input:))
    }
}

extension ListGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGatewaysInput {
        return ListGatewaysInput(
            gatewayGroupArn: self.gatewayGroupArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListSkillsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSkillsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSkillsOutput`
    public func listSkillsPaginated(input: ListSkillsInput) -> ClientRuntime.PaginatorSequence<ListSkillsInput, ListSkillsOutput> {
        return ClientRuntime.PaginatorSequence<ListSkillsInput, ListSkillsOutput>(input: input, inputKey: \ListSkillsInput.nextToken, outputKey: \ListSkillsOutput.nextToken, paginationFunction: self.listSkills(input:))
    }
}

extension ListSkillsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSkillsInput {
        return ListSkillsInput(
            enablementType: self.enablementType,
            maxResults: self.maxResults,
            nextToken: token,
            skillGroupArn: self.skillGroupArn,
            skillType: self.skillType
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListSkillsStoreCategoriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSkillsStoreCategoriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSkillsStoreCategoriesOutput`
    public func listSkillsStoreCategoriesPaginated(input: ListSkillsStoreCategoriesInput) -> ClientRuntime.PaginatorSequence<ListSkillsStoreCategoriesInput, ListSkillsStoreCategoriesOutput> {
        return ClientRuntime.PaginatorSequence<ListSkillsStoreCategoriesInput, ListSkillsStoreCategoriesOutput>(input: input, inputKey: \ListSkillsStoreCategoriesInput.nextToken, outputKey: \ListSkillsStoreCategoriesOutput.nextToken, paginationFunction: self.listSkillsStoreCategories(input:))
    }
}

extension ListSkillsStoreCategoriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSkillsStoreCategoriesInput {
        return ListSkillsStoreCategoriesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListSkillsStoreSkillsByCategoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSkillsStoreSkillsByCategoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSkillsStoreSkillsByCategoryOutput`
    public func listSkillsStoreSkillsByCategoryPaginated(input: ListSkillsStoreSkillsByCategoryInput) -> ClientRuntime.PaginatorSequence<ListSkillsStoreSkillsByCategoryInput, ListSkillsStoreSkillsByCategoryOutput> {
        return ClientRuntime.PaginatorSequence<ListSkillsStoreSkillsByCategoryInput, ListSkillsStoreSkillsByCategoryOutput>(input: input, inputKey: \ListSkillsStoreSkillsByCategoryInput.nextToken, outputKey: \ListSkillsStoreSkillsByCategoryOutput.nextToken, paginationFunction: self.listSkillsStoreSkillsByCategory(input:))
    }
}

extension ListSkillsStoreSkillsByCategoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSkillsStoreSkillsByCategoryInput {
        return ListSkillsStoreSkillsByCategoryInput(
            categoryId: self.categoryId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListSmartHomeAppliancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSmartHomeAppliancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSmartHomeAppliancesOutput`
    public func listSmartHomeAppliancesPaginated(input: ListSmartHomeAppliancesInput) -> ClientRuntime.PaginatorSequence<ListSmartHomeAppliancesInput, ListSmartHomeAppliancesOutput> {
        return ClientRuntime.PaginatorSequence<ListSmartHomeAppliancesInput, ListSmartHomeAppliancesOutput>(input: input, inputKey: \ListSmartHomeAppliancesInput.nextToken, outputKey: \ListSmartHomeAppliancesOutput.nextToken, paginationFunction: self.listSmartHomeAppliances(input:))
    }
}

extension ListSmartHomeAppliancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSmartHomeAppliancesInput {
        return ListSmartHomeAppliancesInput(
            maxResults: self.maxResults,
            nextToken: token,
            roomArn: self.roomArn
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[ListTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutput`
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput>(input: input, inputKey: \ListTagsInput.nextToken, outputKey: \ListTagsOutput.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            arn: self.arn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchAddressBooksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchAddressBooksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchAddressBooksOutput`
    public func searchAddressBooksPaginated(input: SearchAddressBooksInput) -> ClientRuntime.PaginatorSequence<SearchAddressBooksInput, SearchAddressBooksOutput> {
        return ClientRuntime.PaginatorSequence<SearchAddressBooksInput, SearchAddressBooksOutput>(input: input, inputKey: \SearchAddressBooksInput.nextToken, outputKey: \SearchAddressBooksOutput.nextToken, paginationFunction: self.searchAddressBooks(input:))
    }
}

extension SearchAddressBooksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchAddressBooksInput {
        return SearchAddressBooksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchContactsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchContactsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchContactsOutput`
    public func searchContactsPaginated(input: SearchContactsInput) -> ClientRuntime.PaginatorSequence<SearchContactsInput, SearchContactsOutput> {
        return ClientRuntime.PaginatorSequence<SearchContactsInput, SearchContactsOutput>(input: input, inputKey: \SearchContactsInput.nextToken, outputKey: \SearchContactsOutput.nextToken, paginationFunction: self.searchContacts(input:))
    }
}

extension SearchContactsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchContactsInput {
        return SearchContactsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDevicesOutput`
    public func searchDevicesPaginated(input: SearchDevicesInput) -> ClientRuntime.PaginatorSequence<SearchDevicesInput, SearchDevicesOutput> {
        return ClientRuntime.PaginatorSequence<SearchDevicesInput, SearchDevicesOutput>(input: input, inputKey: \SearchDevicesInput.nextToken, outputKey: \SearchDevicesOutput.nextToken, paginationFunction: self.searchDevices(input:))
    }
}

extension SearchDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDevicesInput {
        return SearchDevicesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchNetworkProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchNetworkProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchNetworkProfilesOutput`
    public func searchNetworkProfilesPaginated(input: SearchNetworkProfilesInput) -> ClientRuntime.PaginatorSequence<SearchNetworkProfilesInput, SearchNetworkProfilesOutput> {
        return ClientRuntime.PaginatorSequence<SearchNetworkProfilesInput, SearchNetworkProfilesOutput>(input: input, inputKey: \SearchNetworkProfilesInput.nextToken, outputKey: \SearchNetworkProfilesOutput.nextToken, paginationFunction: self.searchNetworkProfiles(input:))
    }
}

extension SearchNetworkProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchNetworkProfilesInput {
        return SearchNetworkProfilesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchProfilesOutput`
    public func searchProfilesPaginated(input: SearchProfilesInput) -> ClientRuntime.PaginatorSequence<SearchProfilesInput, SearchProfilesOutput> {
        return ClientRuntime.PaginatorSequence<SearchProfilesInput, SearchProfilesOutput>(input: input, inputKey: \SearchProfilesInput.nextToken, outputKey: \SearchProfilesOutput.nextToken, paginationFunction: self.searchProfiles(input:))
    }
}

extension SearchProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchProfilesInput {
        return SearchProfilesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchRoomsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchRoomsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchRoomsOutput`
    public func searchRoomsPaginated(input: SearchRoomsInput) -> ClientRuntime.PaginatorSequence<SearchRoomsInput, SearchRoomsOutput> {
        return ClientRuntime.PaginatorSequence<SearchRoomsInput, SearchRoomsOutput>(input: input, inputKey: \SearchRoomsInput.nextToken, outputKey: \SearchRoomsOutput.nextToken, paginationFunction: self.searchRooms(input:))
    }
}

extension SearchRoomsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchRoomsInput {
        return SearchRoomsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchSkillGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchSkillGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchSkillGroupsOutput`
    public func searchSkillGroupsPaginated(input: SearchSkillGroupsInput) -> ClientRuntime.PaginatorSequence<SearchSkillGroupsInput, SearchSkillGroupsOutput> {
        return ClientRuntime.PaginatorSequence<SearchSkillGroupsInput, SearchSkillGroupsOutput>(input: input, inputKey: \SearchSkillGroupsInput.nextToken, outputKey: \SearchSkillGroupsOutput.nextToken, paginationFunction: self.searchSkillGroups(input:))
    }
}

extension SearchSkillGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchSkillGroupsInput {
        return SearchSkillGroupsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
extension AlexaForBusinessClient {
    /// Paginate over `[SearchUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchUsersOutput`
    public func searchUsersPaginated(input: SearchUsersInput) -> ClientRuntime.PaginatorSequence<SearchUsersInput, SearchUsersOutput> {
        return ClientRuntime.PaginatorSequence<SearchUsersInput, SearchUsersOutput>(input: input, inputKey: \SearchUsersInput.nextToken, outputKey: \SearchUsersOutput.nextToken, paginationFunction: self.searchUsers(input:))
    }
}

extension SearchUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchUsersInput {
        return SearchUsersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}
