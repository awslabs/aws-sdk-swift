// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlexaForBusinessClientTypes.AddressBook: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// An address book with attributes.
    public struct AddressBook: Swift.Equatable {
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// The description of the address book.
        public var description: Swift.String?
        /// The name of the address book.
        public var name: Swift.String?

        public init(
            addressBookArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.AddressBookData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to an address book.
    public struct AddressBookData: Swift.Equatable {
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// The description of the address book.
        public var description: Swift.String?
        /// The name of the address book.
        public var name: Swift.String?

        public init(
            addressBookArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }
    }

}

extension AlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource being created already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApproveSkillInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension ApproveSkillInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ApproveSkillInput: Swift.Equatable {
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct ApproveSkillInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension ApproveSkillInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension ApproveSkillOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ApproveSkillOutput: Swift.Equatable {

    public init() { }
}

enum ApproveSkillOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateContactWithAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension AssociateContactWithAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateContactWithAddressBookInput: Swift.Equatable {
    /// The ARN of the address book with which to associate the contact.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The ARN of the contact to associate with an address book.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil,
        contactArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

struct AssociateContactWithAddressBookInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let addressBookArn: Swift.String?
}

extension AssociateContactWithAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension AssociateContactWithAddressBookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateContactWithAddressBookOutput: Swift.Equatable {

    public init() { }
}

enum AssociateContactWithAddressBookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateDeviceWithNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

extension AssociateDeviceWithNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDeviceWithNetworkProfileInput: Swift.Equatable {
    /// The device ARN.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The ARN of the network profile to associate with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        networkProfileArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.networkProfileArn = networkProfileArn
    }
}

struct AssociateDeviceWithNetworkProfileInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let networkProfileArn: Swift.String?
}

extension AssociateDeviceWithNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case networkProfileArn = "NetworkProfileArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension AssociateDeviceWithNetworkProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDeviceWithNetworkProfileOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDeviceWithNetworkProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceNotRegisteredException": return try await DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateDeviceWithRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension AssociateDeviceWithRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDeviceWithRoomInput: Swift.Equatable {
    /// The ARN of the device to associate to a room. Required.
    public var deviceArn: Swift.String?
    /// The ARN of the room with which to associate the device. Required.
    public var roomArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.roomArn = roomArn
    }
}

struct AssociateDeviceWithRoomInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let roomArn: Swift.String?
}

extension AssociateDeviceWithRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension AssociateDeviceWithRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDeviceWithRoomOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDeviceWithRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceNotRegisteredException": return try await DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateSkillGroupWithRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension AssociateSkillGroupWithRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateSkillGroupWithRoomInput: Swift.Equatable {
    /// The ARN of the room with which to associate the skill group. Required.
    public var roomArn: Swift.String?
    /// The ARN of the skill group to associate with a room. Required.
    public var skillGroupArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

struct AssociateSkillGroupWithRoomInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let roomArn: Swift.String?
}

extension AssociateSkillGroupWithRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension AssociateSkillGroupWithRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateSkillGroupWithRoomOutput: Swift.Equatable {

    public init() { }
}

enum AssociateSkillGroupWithRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateSkillWithSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension AssociateSkillWithSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateSkillWithSkillGroupInput: Swift.Equatable {
    /// The ARN of the skill group to associate the skill to. Required.
    public var skillGroupArn: Swift.String?
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

struct AssociateSkillWithSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let skillId: Swift.String?
}

extension AssociateSkillWithSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension AssociateSkillWithSkillGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateSkillWithSkillGroupOutput: Swift.Equatable {

    public init() { }
}

enum AssociateSkillWithSkillGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SkillNotLinkedException": return try await SkillNotLinkedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateSkillWithUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension AssociateSkillWithUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateSkillWithUsersInput: Swift.Equatable {
    /// The private skill ID you want to make available to enrolled users.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct AssociateSkillWithUsersInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension AssociateSkillWithUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension AssociateSkillWithUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateSkillWithUsersOutput: Swift.Equatable {

    public init() { }
}

enum AssociateSkillWithUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.Audio: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale = "Locale"
        case location = "Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The audio message. There is a 1 MB limit on the audio file input and the only supported format is MP3. To convert your MP3 audio files to an Alexa-friendly, required codec version (MPEG version 2) and bit rate (48 kbps), you might use converter software. One option for this is a command-line tool, FFmpeg. For more information, see [FFmpeg](https://www.ffmpeg.org/). The following command converts the provided to an MP3 file that is played in the announcement: ffmpeg -i -ac 2 -codec:a libmp3lame -b:a 48k -ar 16000
    public struct Audio: Swift.Equatable {
        /// The locale of the audio message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The location of the audio file. Currently, S3 URLs are supported. Only S3 locations comprised of safe characters are valid. For more information, see [Safe Characters](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#Safe%20Characters).
        /// This member is required.
        public var location: Swift.String?

        public init(
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            location: Swift.String? = nil
        )
        {
            self.locale = locale
            self.location = location
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryTime = "DeliveryTime"
        case downloadUrl = "DownloadUrl"
        case failureCode = "FailureCode"
        case s3Location = "S3Location"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryTime = self.deliveryTime {
            try encodeContainer.encodeTimestamp(deliveryTime, format: .epochSeconds, forKey: .deliveryTime)
        }
        if let downloadUrl = self.downloadUrl {
            try encodeContainer.encode(downloadUrl, forKey: .downloadUrl)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportStatus.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportS3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let deliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Usage report with specified parameters.
    public struct BusinessReport: Swift.Equatable {
        /// The time of report delivery.
        public var deliveryTime: ClientRuntime.Date?
        /// The download link where a user can download the report.
        public var downloadUrl: Swift.String?
        /// The failure code.
        public var failureCode: AlexaForBusinessClientTypes.BusinessReportFailureCode?
        /// The S3 location of the output reports.
        public var s3Location: AlexaForBusinessClientTypes.BusinessReportS3Location?
        /// The status of the report generation execution (RUNNING, SUCCEEDED, or FAILED).
        public var status: AlexaForBusinessClientTypes.BusinessReportStatus?

        public init(
            deliveryTime: ClientRuntime.Date? = nil,
            downloadUrl: Swift.String? = nil,
            failureCode: AlexaForBusinessClientTypes.BusinessReportFailureCode? = nil,
            s3Location: AlexaForBusinessClientTypes.BusinessReportS3Location? = nil,
            status: AlexaForBusinessClientTypes.BusinessReportStatus? = nil
        )
        {
            self.deliveryTime = deliveryTime
            self.downloadUrl = downloadUrl
            self.failureCode = failureCode
            self.s3Location = s3Location
            self.status = status
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportContentRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval = "Interval"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = self.interval {
            try encodeContainer.encode(interval.rawValue, forKey: .interval)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportInterval.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The content range of the report.
    public struct BusinessReportContentRange: Swift.Equatable {
        /// The interval of the content range.
        /// This member is required.
        public var interval: AlexaForBusinessClientTypes.BusinessReportInterval?

        public init(
            interval: AlexaForBusinessClientTypes.BusinessReportInterval? = nil
        )
        {
            self.interval = interval
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalFailure
        case noSuchBucket
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportFailureCode] {
            return [
                .accessDenied,
                .internalFailure,
                .noSuchBucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .noSuchBucket: return "NO_SUCH_BUCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportFailureCode(rawValue: rawValue) ?? BusinessReportFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case csvZip
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportFormat] {
            return [
                .csv,
                .csvZip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .csvZip: return "CSV_ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportFormat(rawValue: rawValue) ?? BusinessReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportInterval: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneDay
        case oneWeek
        case thirtyDays
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportInterval] {
            return [
                .oneDay,
                .oneWeek,
                .thirtyDays,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneDay: return "ONE_DAY"
            case .oneWeek: return "ONE_WEEK"
            case .thirtyDays: return "THIRTY_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportInterval(rawValue: rawValue) ?? BusinessReportInterval.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.BusinessReportRecurrence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startDate = self.startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The recurrence of the reports.
    public struct BusinessReportRecurrence: Swift.Equatable {
        /// The start date.
        public var startDate: Swift.String?

        public init(
            startDate: Swift.String? = nil
        )
        {
            self.startDate = startDate
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The S3 location of the output reports.
    public struct BusinessReportS3Location: Swift.Equatable {
        /// The S3 bucket name of the output reports.
        public var bucketName: Swift.String?
        /// The path of the business report.
        public var path: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.path = path
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentRange = "ContentRange"
        case format = "Format"
        case lastBusinessReport = "LastBusinessReport"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentRange = self.contentRange {
            try encodeContainer.encode(contentRange, forKey: .contentRange)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let lastBusinessReport = self.lastBusinessReport {
            try encodeContainer.encode(lastBusinessReport, forKey: .lastBusinessReport)
        }
        if let recurrence = self.recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleArn = self.scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
        if let scheduleName = self.scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
        let scheduleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let contentRangeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportContentRange.self, forKey: .contentRange)
        contentRange = contentRangeDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let lastBusinessReportDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReport.self, forKey: .lastBusinessReport)
        lastBusinessReport = lastBusinessReportDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The schedule of the usage report.
    public struct BusinessReportSchedule: Swift.Equatable {
        /// The content range of the reports.
        public var contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
        /// The format of the generated report (individual CSV files or zipped files of individual files).
        public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
        /// The details of the last business report delivery for a specified time interval.
        public var lastBusinessReport: AlexaForBusinessClientTypes.BusinessReport?
        /// The recurrence of the reports.
        public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
        /// The S3 bucket name of the output reports.
        public var s3BucketName: Swift.String?
        /// The S3 key where the report is delivered.
        public var s3KeyPrefix: Swift.String?
        /// The ARN of the business report schedule.
        public var scheduleArn: Swift.String?
        /// The name identifier of the schedule.
        public var scheduleName: Swift.String?

        public init(
            contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange? = nil,
            format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
            lastBusinessReport: AlexaForBusinessClientTypes.BusinessReport? = nil,
            recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            scheduleArn: Swift.String? = nil,
            scheduleName: Swift.String? = nil
        )
        {
            self.contentRange = contentRange
            self.format = format
            self.lastBusinessReport = lastBusinessReport
            self.recurrence = recurrence
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.scheduleArn = scheduleArn
            self.scheduleName = scheduleName
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportStatus] {
            return [
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportStatus(rawValue: rawValue) ?? BusinessReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Category: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryId = "CategoryId"
        case categoryName = "CategoryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryId = self.categoryId {
            try encodeContainer.encode(categoryId, forKey: .categoryId)
        }
        if let categoryName = self.categoryName {
            try encodeContainer.encode(categoryName, forKey: .categoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .categoryId)
        categoryId = categoryIdDecoded
        let categoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryName)
        categoryName = categoryNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The skill store category that is shown. Alexa skills are assigned a specific skill category during creation, such as News, Social, and Sports.
    public struct Category: Swift.Equatable {
        /// The ID of the skill store category.
        public var categoryId: Swift.Int?
        /// The name of the skill store category.
        public var categoryName: Swift.String?

        public init(
            categoryId: Swift.Int? = nil,
            categoryName: Swift.String? = nil
        )
        {
            self.categoryId = categoryId
            self.categoryName = categoryName
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum CommsProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case h323
        case sip
        case sips
        case sdkUnknown(Swift.String)

        public static var allCases: [CommsProtocol] {
            return [
                .h323,
                .sip,
                .sips,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .h323: return "H323"
            case .sip: return "SIP"
            case .sips: return "SIPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommsProtocol(rawValue: rawValue) ?? CommsProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a concurrent modification of resources.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes.ConferencePreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConferenceProviderArn = "DefaultConferenceProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConferenceProviderArn = self.defaultConferenceProviderArn {
            try encodeContainer.encode(defaultConferenceProviderArn, forKey: .defaultConferenceProviderArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultConferenceProviderArn)
        defaultConferenceProviderArn = defaultConferenceProviderArnDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The default conference provider that is used if no other scheduled meetings are detected.
    public struct ConferencePreference: Swift.Equatable {
        /// The ARN of the default conference provider.
        public var defaultConferenceProviderArn: Swift.String?

        public init(
            defaultConferenceProviderArn: Swift.String? = nil
        )
        {
            self.defaultConferenceProviderArn = defaultConferenceProviderArn
        }
    }

}

extension AlexaForBusinessClientTypes.ConferenceProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case ipDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case name = "Name"
        case pstnDialIn = "PSTNDialIn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let ipDialIn = self.ipDialIn {
            try encodeContainer.encode(ipDialIn, forKey: .ipDialIn)
        }
        if let meetingSetting = self.meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pstnDialIn = self.pstnDialIn {
            try encodeContainer.encode(pstnDialIn, forKey: .pstnDialIn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProviderType.self, forKey: .type)
        type = typeDecoded
        let ipDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.IPDialIn.self, forKey: .ipDialIn)
        ipDialIn = ipDialInDecoded
        let pstnDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PSTNDialIn.self, forKey: .pstnDialIn)
        pstnDialIn = pstnDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// An entity that provides a conferencing solution. Alexa for Business acts as the voice interface and mediator that connects users to their preferred conference provider. Examples of conference providers include Amazon Chime, Zoom, Cisco, and Polycom.
    public struct ConferenceProvider: Swift.Equatable {
        /// The ARN of the newly created conference provider.
        public var arn: Swift.String?
        /// The IP endpoint and protocol for calling.
        public var ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
        /// The meeting settings for the conference provider.
        public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
        /// The name of the conference provider.
        public var name: Swift.String?
        /// The information for PSTN conferencing.
        public var pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
        /// The type of conference providers.
        public var type: AlexaForBusinessClientTypes.ConferenceProviderType?

        public init(
            arn: Swift.String? = nil,
            ipDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
            meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
            name: Swift.String? = nil,
            pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil,
            type: AlexaForBusinessClientTypes.ConferenceProviderType? = nil
        )
        {
            self.arn = arn
            self.ipDialIn = ipDialIn
            self.meetingSetting = meetingSetting
            self.name = name
            self.pstnDialIn = pstnDialIn
            self.type = type
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum ConferenceProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bluejeans
        case chime
        case custom
        case fuze
        case googleHangouts
        case polycom
        case ringcentral
        case skypeForBusiness
        case webex
        case zoom
        case sdkUnknown(Swift.String)

        public static var allCases: [ConferenceProviderType] {
            return [
                .bluejeans,
                .chime,
                .custom,
                .fuze,
                .googleHangouts,
                .polycom,
                .ringcentral,
                .skypeForBusiness,
                .webex,
                .zoom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bluejeans: return "BLUEJEANS"
            case .chime: return "CHIME"
            case .custom: return "CUSTOM"
            case .fuze: return "FUZE"
            case .googleHangouts: return "GOOGLE_HANGOUTS"
            case .polycom: return "POLYCOM"
            case .ringcentral: return "RINGCENTRAL"
            case .skypeForBusiness: return "SKYPE_FOR_BUSINESS"
            case .webex: return "WEBEX"
            case .zoom: return "ZOOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConferenceProviderType(rawValue: rawValue) ?? ConferenceProviderType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .offline,
                .online,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddress0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddress0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension AlexaForBusinessClientTypes.Contact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Contact(contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes {
    /// A contact with attributes.
    public struct Contact: Swift.Equatable {
        /// The ARN of the contact.
        public var contactArn: Swift.String?
        /// The name of the contact to display on the console.
        public var displayName: Swift.String?
        /// The first name of the contact, used to call the contact on the device.
        public var firstName: Swift.String?
        /// The last name of the contact, used to call the contact on the device.
        public var lastName: Swift.String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public var phoneNumber: Swift.String?
        /// The list of phone numbers for the contact.
        public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

        public init(
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
            sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
        )
        {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }
    }

}

extension AlexaForBusinessClientTypes.ContactData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddress0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddress0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension AlexaForBusinessClientTypes.ContactData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContactData(contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes {
    /// Information related to a contact.
    public struct ContactData: Swift.Equatable {
        /// The ARN of the contact.
        public var contactArn: Swift.String?
        /// The name of the contact to display on the console.
        public var displayName: Swift.String?
        /// The first name of the contact, used to call the contact on the device.
        public var firstName: Swift.String?
        /// The last name of the contact, used to call the contact on the device.
        public var lastName: Swift.String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public var phoneNumber: Swift.String?
        /// The list of phone numbers for the contact.
        public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

        public init(
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
            sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
        )
        {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }
    }

}

extension AlexaForBusinessClientTypes.Content: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioList = "AudioList"
        case ssmlList = "SsmlList"
        case textList = "TextList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioList = audioList {
            var audioListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audioList)
            for audio0 in audioList {
                try audioListContainer.encode(audio0)
            }
        }
        if let ssmlList = ssmlList {
            var ssmlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ssmlList)
            for ssml0 in ssmlList {
                try ssmlListContainer.encode(ssml0)
            }
        }
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for text0 in textList {
                try textListContainer.encode(text0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Text?].self, forKey: .textList)
        var textListDecoded0:[AlexaForBusinessClientTypes.Text]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [AlexaForBusinessClientTypes.Text]()
            for structure0 in textListContainer {
                if let structure0 = structure0 {
                    textListDecoded0?.append(structure0)
                }
            }
        }
        textList = textListDecoded0
        let ssmlListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Ssml?].self, forKey: .ssmlList)
        var ssmlListDecoded0:[AlexaForBusinessClientTypes.Ssml]? = nil
        if let ssmlListContainer = ssmlListContainer {
            ssmlListDecoded0 = [AlexaForBusinessClientTypes.Ssml]()
            for structure0 in ssmlListContainer {
                if let structure0 = structure0 {
                    ssmlListDecoded0?.append(structure0)
                }
            }
        }
        ssmlList = ssmlListDecoded0
        let audioListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Audio?].self, forKey: .audioList)
        var audioListDecoded0:[AlexaForBusinessClientTypes.Audio]? = nil
        if let audioListContainer = audioListContainer {
            audioListDecoded0 = [AlexaForBusinessClientTypes.Audio]()
            for structure0 in audioListContainer {
                if let structure0 = structure0 {
                    audioListDecoded0?.append(structure0)
                }
            }
        }
        audioList = audioListDecoded0
    }
}

extension AlexaForBusinessClientTypes {
    /// The content definition. This can contain only one text, SSML, or audio list object.
    public struct Content: Swift.Equatable {
        /// The list of audio messages.
        public var audioList: [AlexaForBusinessClientTypes.Audio]?
        /// The list of SSML messages.
        public var ssmlList: [AlexaForBusinessClientTypes.Ssml]?
        /// The list of text messages.
        public var textList: [AlexaForBusinessClientTypes.Text]?

        public init(
            audioList: [AlexaForBusinessClientTypes.Audio]? = nil,
            ssmlList: [AlexaForBusinessClientTypes.Ssml]? = nil,
            textList: [AlexaForBusinessClientTypes.Text]? = nil
        )
        {
            self.audioList = audioList
            self.ssmlList = ssmlList
            self.textList = textList
        }
    }

}

extension CreateAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAddressBookInput: Swift.Equatable {
    /// A unique, user-specified identifier for the request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description of the address book.
    public var description: Swift.String?
    /// The name of the address book.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAddressBookInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAddressBookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAddressBookOutputBody = try responseDecoder.decode(responseBody: data)
            self.addressBookArn = output.addressBookArn
        } else {
            self.addressBookArn = nil
        }
    }
}

public struct CreateAddressBookOutput: Swift.Equatable {
    /// The ARN of the newly created address book.
    public var addressBookArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct CreateAddressBookOutputBody: Swift.Equatable {
    let addressBookArn: Swift.String?
}

extension CreateAddressBookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

enum CreateAddressBookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBusinessReportScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case contentRange = "ContentRange"
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleName = "ScheduleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let contentRange = self.contentRange {
            try encodeContainer.encode(contentRange, forKey: .contentRange)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let recurrence = self.recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleName = self.scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBusinessReportScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBusinessReportScheduleInput: Swift.Equatable {
    /// The client request token.
    public var clientRequestToken: Swift.String?
    /// The content range of the reports.
    /// This member is required.
    public var contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
    /// The format of the generated report (individual CSV files or zipped files of individual files).
    /// This member is required.
    public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
    /// The recurrence of the reports. If this isn't specified, the report will only be delivered one time when the API is called.
    public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    /// The S3 bucket name of the output reports. If this isn't specified, the report can be retrieved from a download link by calling ListBusinessReportSchedule.
    public var s3BucketName: Swift.String?
    /// The S3 key where the report is delivered.
    public var s3KeyPrefix: Swift.String?
    /// The name identifier of the schedule.
    public var scheduleName: Swift.String?
    /// The tags for the business report schedule.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange? = nil,
        format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
        recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        scheduleName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.contentRange = contentRange
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleName = scheduleName
        self.tags = tags
    }
}

struct CreateBusinessReportScheduleInputBody: Swift.Equatable {
    let scheduleName: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let format: AlexaForBusinessClientTypes.BusinessReportFormat?
    let contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
    let recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateBusinessReportScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case contentRange = "ContentRange"
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleName = "ScheduleName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let contentRangeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportContentRange.self, forKey: .contentRange)
        contentRange = contentRangeDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBusinessReportScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBusinessReportScheduleOutputBody = try responseDecoder.decode(responseBody: data)
            self.scheduleArn = output.scheduleArn
        } else {
            self.scheduleArn = nil
        }
    }
}

public struct CreateBusinessReportScheduleOutput: Swift.Equatable {
    /// The ARN of the business report schedule.
    public var scheduleArn: Swift.String?

    public init(
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct CreateBusinessReportScheduleOutputBody: Swift.Equatable {
    let scheduleArn: Swift.String?
}

extension CreateBusinessReportScheduleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

enum CreateBusinessReportScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case conferenceProviderName = "ConferenceProviderName"
        case conferenceProviderType = "ConferenceProviderType"
        case ipDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pstnDialIn = "PSTNDialIn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let conferenceProviderName = self.conferenceProviderName {
            try encodeContainer.encode(conferenceProviderName, forKey: .conferenceProviderName)
        }
        if let conferenceProviderType = self.conferenceProviderType {
            try encodeContainer.encode(conferenceProviderType.rawValue, forKey: .conferenceProviderType)
        }
        if let ipDialIn = self.ipDialIn {
            try encodeContainer.encode(ipDialIn, forKey: .ipDialIn)
        }
        if let meetingSetting = self.meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let pstnDialIn = self.pstnDialIn {
            try encodeContainer.encode(pstnDialIn, forKey: .pstnDialIn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConferenceProviderInput: Swift.Equatable {
    /// The request token of the client.
    public var clientRequestToken: Swift.String?
    /// The name of the conference provider.
    /// This member is required.
    public var conferenceProviderName: Swift.String?
    /// Represents a type within a list of predefined types.
    /// This member is required.
    public var conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    /// The IP endpoint and protocol for calling.
    public var ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
    /// The meeting settings for the conference provider.
    /// This member is required.
    public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    /// The information for PSTN conferencing.
    public var pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        conferenceProviderName: Swift.String? = nil,
        conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType? = nil,
        ipDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
        meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
        pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.conferenceProviderName = conferenceProviderName
        self.conferenceProviderType = conferenceProviderType
        self.ipDialIn = ipDialIn
        self.meetingSetting = meetingSetting
        self.pstnDialIn = pstnDialIn
        self.tags = tags
    }
}

struct CreateConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderName: Swift.String?
    let conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    let ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
    let pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
    let meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case conferenceProviderName = "ConferenceProviderName"
        case conferenceProviderType = "ConferenceProviderType"
        case ipDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pstnDialIn = "PSTNDialIn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderName)
        conferenceProviderName = conferenceProviderNameDecoded
        let conferenceProviderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProviderType.self, forKey: .conferenceProviderType)
        conferenceProviderType = conferenceProviderTypeDecoded
        let ipDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.IPDialIn.self, forKey: .ipDialIn)
        ipDialIn = ipDialInDecoded
        let pstnDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PSTNDialIn.self, forKey: .pstnDialIn)
        pstnDialIn = pstnDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConferenceProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConferenceProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.conferenceProviderArn = output.conferenceProviderArn
        } else {
            self.conferenceProviderArn = nil
        }
    }
}

public struct CreateConferenceProviderOutput: Swift.Equatable {
    /// The ARN of the newly-created conference provider.
    public var conferenceProviderArn: Swift.String?

    public init(
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct CreateConferenceProviderOutputBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
}

extension CreateConferenceProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

enum CreateConferenceProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContactInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), tags: \(Swift.String(describing: tags)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddress0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddress0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContactInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The name of the contact to display on the console.
    public var displayName: Swift.String?
    /// The first name of the contact that is used to call the contact on the device.
    /// This member is required.
    public var firstName: Swift.String?
    /// The last name of the contact that is used to call the contact on the device.
    public var lastName: Swift.String?
    /// The phone number of the contact in E.164 format. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
    public var phoneNumber: Swift.String?
    /// The list of phone numbers for the contact.
    public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    /// The list of SIP addresses for the contact.
    public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
        sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
        self.tags = tags
    }
}

struct CreateContactInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let phoneNumber: Swift.String?
    let phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    let sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
        } else {
            self.contactArn = nil
        }
    }
}

public struct CreateContactOutput: Swift.Equatable {
    /// The ARN of the newly created address book.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct CreateContactOutputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension CreateContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

enum CreateContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateEndOfMeetingReminder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for minutes0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(minutes0)
            }
        }
        if let reminderType = self.reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Swift.Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Swift.Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct CreateEndOfMeetingReminder: Swift.Equatable {
        /// Whether an end of meeting reminder is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A range of 3 to 15 minutes that determines when the reminder begins.
        /// This member is required.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        /// This member is required.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init(
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension CreateGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGatewayGroupInput: Swift.Equatable {
    /// A unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description of the gateway group.
    public var description: Swift.String?
    /// The name of the gateway group.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateGatewayGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGatewayGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayGroupArn = output.gatewayGroupArn
        } else {
            self.gatewayGroupArn = nil
        }
    }
}

public struct CreateGatewayGroupOutput: Swift.Equatable {
    /// The ARN of the created gateway group.
    public var gatewayGroupArn: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct CreateGatewayGroupOutputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
}

extension CreateGatewayGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

enum CreateGatewayGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateInstantBooking: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = self.durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the instant booking feature that are applied to a room profile. When users start their meeting with Alexa, Alexa automatically books the room for the configured duration if the room is available.
    public struct CreateInstantBooking: Swift.Equatable {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case proactiveJoin = "ProactiveJoin"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = self.endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = self.instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let proactiveJoin = self.proactiveJoin {
            try encodeContainer.encode(proactiveJoin, forKey: .proactiveJoin)
        }
        if let requireCheckIn = self.requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = self.roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateEndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateInstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateRequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
        let proactiveJoinDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateProactiveJoin.self, forKey: .proactiveJoin)
        proactiveJoin = proactiveJoinDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates meeting room settings of a room profile.
    public struct CreateMeetingRoomConfiguration: Swift.Equatable {
        /// Creates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder?
        /// Settings to automatically book a room for a configured duration if it's free when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.CreateInstantBooking?
        public var proactiveJoin: AlexaForBusinessClientTypes.CreateProactiveJoin?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.CreateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init(
            endOfMeetingReminder: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.CreateInstantBooking? = nil,
            proactiveJoin: AlexaForBusinessClientTypes.CreateProactiveJoin? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.CreateRequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.proactiveJoin = proactiveJoin
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension CreateNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkProfileInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), eapMethod: \(Swift.String(describing: eapMethod)), networkProfileName: \(Swift.String(describing: networkProfileName)), securityType: \(Swift.String(describing: securityType)), ssid: \(Swift.String(describing: ssid)), tags: \(Swift.String(describing: tags)), trustAnchors: \(Swift.String(describing: trustAnchors)), currentPassword: \"CONTENT_REDACTED\", nextPassword: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case clientRequestToken = "ClientRequestToken"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case tags = "Tags"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let currentPassword = self.currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = self.eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileName = self.networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = self.nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let securityType = self.securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = self.ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchor0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchor0)
            }
        }
    }
}

extension CreateNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNetworkProfileInput: Swift.Equatable {
    /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
    public var certificateAuthorityArn: Swift.String?
    /// A unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The current password of the Wi-Fi network.
    public var currentPassword: Swift.String?
    /// Detailed information about a device's network profile.
    public var description: Swift.String?
    /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
    public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
    /// The name of the network profile associated with a device.
    /// This member is required.
    public var networkProfileName: Swift.String?
    /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
    public var nextPassword: Swift.String?
    /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
    /// This member is required.
    public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
    /// The SSID of the Wi-Fi network.
    /// This member is required.
    public var ssid: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The root certificates of your authentication server that is installed on your devices and used to trust your authentication server during EAP negotiation.
    public var trustAnchors: [Swift.String]?

    public init(
        certificateAuthorityArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        currentPassword: Swift.String? = nil,
        description: Swift.String? = nil,
        eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
        networkProfileName: Swift.String? = nil,
        nextPassword: Swift.String? = nil,
        securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
        ssid: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        trustAnchors: [Swift.String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.clientRequestToken = clientRequestToken
        self.currentPassword = currentPassword
        self.description = description
        self.eapMethod = eapMethod
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.securityType = securityType
        self.ssid = ssid
        self.tags = tags
        self.trustAnchors = trustAnchors
    }
}

struct CreateNetworkProfileInputBody: Swift.Equatable {
    let networkProfileName: Swift.String?
    let description: Swift.String?
    let ssid: Swift.String?
    let securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
    let eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
    let currentPassword: Swift.String?
    let nextPassword: Swift.String?
    let certificateAuthorityArn: Swift.String?
    let trustAnchors: [Swift.String]?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case clientRequestToken = "ClientRequestToken"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case tags = "Tags"
        case trustAnchors = "TrustAnchors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[Swift.String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [Swift.String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNetworkProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkProfileArn = output.networkProfileArn
        } else {
            self.networkProfileArn = nil
        }
    }
}

public struct CreateNetworkProfileOutput: Swift.Equatable {
    /// The ARN of the network profile associated with a device.
    public var networkProfileArn: Swift.String?

    public init(
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct CreateNetworkProfileOutputBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
}

extension CreateNetworkProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

enum CreateNetworkProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCertificateAuthorityException": return try await InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidServiceLinkedRoleStateException": return try await InvalidServiceLinkedRoleStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateProactiveJoin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledByMotion = "EnabledByMotion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledByMotion = self.enabledByMotion {
            try encodeContainer.encode(enabledByMotion, forKey: .enabledByMotion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledByMotionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledByMotion)
        enabledByMotion = enabledByMotionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public struct CreateProactiveJoin: Swift.Equatable {
        /// This member is required.
        public var enabledByMotion: Swift.Bool?

        public init(
            enabledByMotion: Swift.Bool? = nil
        )
        {
            self.enabledByMotion = enabledByMotion
        }
    }

}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clientRequestToken = "ClientRequestToken"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pstnEnabled = "PSTNEnabled"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case tags = "Tags"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataRetentionOptIn = self.dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = self.maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = self.meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pstnEnabled = self.pstnEnabled {
            try encodeContainer.encode(pstnEnabled, forKey: .pstnEnabled)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = self.setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let temperatureUnit = self.temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = self.wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }
}

extension CreateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// The valid address for the room.
    /// This member is required.
    public var address: Swift.String?
    /// The user-specified token that is used during the creation of a profile.
    public var clientRequestToken: Swift.String?
    /// Whether data retention of the profile is enabled.
    public var dataRetentionOptIn: Swift.Bool?
    /// The distance unit to be used by devices in the profile.
    /// This member is required.
    public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    /// The locale of the room profile. (This is currently only available to a limited preview audience.)
    public var locale: Swift.String?
    /// The maximum volume limit for a room profile.
    public var maxVolumeLimit: Swift.Int?
    /// The meeting room settings of a room profile.
    public var meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration?
    /// The name of a room profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// Whether PSTN calling is enabled.
    public var pstnEnabled: Swift.Bool?
    /// Whether room profile setup is enabled.
    public var setupModeDisabled: Swift.Bool?
    /// The tags for the profile.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The temperature unit to be used by devices in the profile.
    /// This member is required.
    public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    /// The time zone used by a room profile.
    /// This member is required.
    public var timezone: Swift.String?
    /// A wake word for Alexa, Echo, Amazon, or a computer.
    /// This member is required.
    public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

    public init(
        address: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        dataRetentionOptIn: Swift.Bool? = nil,
        distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
        locale: Swift.String? = nil,
        maxVolumeLimit: Swift.Int? = nil,
        meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration? = nil,
        profileName: Swift.String? = nil,
        pstnEnabled: Swift.Bool? = nil,
        setupModeDisabled: Swift.Bool? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
        timezone: Swift.String? = nil,
        wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
    )
    {
        self.address = address
        self.clientRequestToken = clientRequestToken
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.profileName = profileName
        self.pstnEnabled = pstnEnabled
        self.setupModeDisabled = setupModeDisabled
        self.tags = tags
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let profileName: Swift.String?
    let timezone: Swift.String?
    let address: Swift.String?
    let distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    let temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    let wakeWord: AlexaForBusinessClientTypes.WakeWord?
    let locale: Swift.String?
    let clientRequestToken: Swift.String?
    let setupModeDisabled: Swift.Bool?
    let maxVolumeLimit: Swift.Int?
    let pstnEnabled: Swift.Bool?
    let dataRetentionOptIn: Swift.Bool?
    let meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clientRequestToken = "ClientRequestToken"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pstnEnabled = "PSTNEnabled"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case tags = "Tags"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pstnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pstnEnabled)
        pstnEnabled = pstnEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileArn = output.profileArn
        } else {
            self.profileArn = nil
        }
    }
}

public struct CreateProfileOutput: Swift.Equatable {
    /// The ARN of the newly created room profile in the response.
    public var profileArn: Swift.String?

    public init(
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct CreateProfileOutputBody: Swift.Equatable {
    let profileArn: Swift.String?
}

extension CreateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

enum CreateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateRequireCheckIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = self.releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct CreateRequireCheckIn: Swift.Equatable {
        /// Whether require check in is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        /// This member is required.
        public var releaseAfterMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension CreateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomName = "RoomName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = self.providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomName = self.roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRoomInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description for the room.
    public var description: Swift.String?
    /// The profile ARN for the room. This is required.
    public var profileArn: Swift.String?
    /// The calendar ARN for the room.
    public var providerCalendarId: Swift.String?
    /// The name for the room.
    /// This member is required.
    public var roomName: Swift.String?
    /// The tags for the room.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        providerCalendarId: Swift.String? = nil,
        roomName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomName = roomName
        self.tags = tags
    }
}

struct CreateRoomInputBody: Swift.Equatable {
    let roomName: Swift.String?
    let description: Swift.String?
    let profileArn: Swift.String?
    let providerCalendarId: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomName = "RoomName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.roomArn = output.roomArn
        } else {
            self.roomArn = nil
        }
    }
}

public struct CreateRoomOutput: Swift.Equatable {
    /// The ARN of the newly created room in the response.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct CreateRoomOutputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension CreateRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

enum CreateRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case skillGroupName = "SkillGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupName = self.skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSkillGroupInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description for the skill group.
    public var description: Swift.String?
    /// The name for the skill group.
    /// This member is required.
    public var skillGroupName: Swift.String?
    /// The tags for the skill group.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        skillGroupName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.skillGroupName = skillGroupName
        self.tags = tags
    }
}

struct CreateSkillGroupInputBody: Swift.Equatable {
    let skillGroupName: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case skillGroupName = "SkillGroupName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSkillGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSkillGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.skillGroupArn = output.skillGroupArn
        } else {
            self.skillGroupArn = nil
        }
    }
}

public struct CreateSkillGroupOutput: Swift.Equatable {
    /// The ARN of the newly created skill group in the response.
    public var skillGroupArn: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct CreateSkillGroupOutputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
}

extension CreateSkillGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

enum CreateSkillGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
        case tags = "Tags"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The email address for the user.
    public var email: Swift.String?
    /// The first name for the user.
    public var firstName: Swift.String?
    /// The last name for the user.
    public var lastName: Swift.String?
    /// The tags for the user.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The ARN for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        email: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.email = email
        self.firstName = firstName
        self.lastName = lastName
        self.tags = tags
        self.userId = userId
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let userId: Swift.String?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let email: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
        case tags = "Tags"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userArn = output.userArn
        } else {
            self.userArn = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The ARN of the newly created user in the response.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
    }
}

extension DeleteAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAddressBookInput: Swift.Equatable {
    /// The ARN of the address book to delete.
    /// This member is required.
    public var addressBookArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct DeleteAddressBookInputBody: Swift.Equatable {
    let addressBookArn: Swift.String?
}

extension DeleteAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension DeleteAddressBookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAddressBookOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAddressBookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBusinessReportScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleArn = self.scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
    }
}

extension DeleteBusinessReportScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBusinessReportScheduleInput: Swift.Equatable {
    /// The ARN of the business report schedule.
    /// This member is required.
    public var scheduleArn: Swift.String?

    public init(
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct DeleteBusinessReportScheduleInputBody: Swift.Equatable {
    let scheduleArn: Swift.String?
}

extension DeleteBusinessReportScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

extension DeleteBusinessReportScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBusinessReportScheduleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBusinessReportScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = self.conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
    }
}

extension DeleteConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConferenceProviderInput: Swift.Equatable {
    /// The ARN of the conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?

    public init(
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct DeleteConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
}

extension DeleteConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

extension DeleteConferenceProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConferenceProviderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConferenceProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension DeleteContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContactInput: Swift.Equatable {
    /// The ARN of the contact to delete.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct DeleteContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension DeleteContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension DeleteContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContactOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

extension DeleteDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// The ARN of the device for which to request details.
    /// This member is required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension DeleteDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension DeleteDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCertificateAuthorityException": return try await InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeviceUsageDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceUsageType = "DeviceUsageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceUsageType = self.deviceUsageType {
            try encodeContainer.encode(deviceUsageType.rawValue, forKey: .deviceUsageType)
        }
    }
}

extension DeleteDeviceUsageDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDeviceUsageDataInput: Swift.Equatable {
    /// The ARN of the device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The type of usage data to delete.
    /// This member is required.
    public var deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType?

    public init(
        deviceArn: Swift.String? = nil,
        deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceUsageType = deviceUsageType
    }
}

struct DeleteDeviceUsageDataInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType?
}

extension DeleteDeviceUsageDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceUsageType = "DeviceUsageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceUsageTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceUsageType.self, forKey: .deviceUsageType)
        deviceUsageType = deviceUsageTypeDecoded
    }
}

extension DeleteDeviceUsageDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeviceUsageDataOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeviceUsageDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeviceNotRegisteredException": return try await DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = self.gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
    }
}

extension DeleteGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGatewayGroupInput: Swift.Equatable {
    /// The ARN of the gateway group to delete.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct DeleteGatewayGroupInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
}

extension DeleteGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension DeleteGatewayGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGatewayGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGatewayGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceAssociatedException": return try await ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

extension DeleteNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init(
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct DeleteNetworkProfileInputBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
}

extension DeleteNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension DeleteNetworkProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteNetworkProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteNetworkProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

extension DeleteProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// The ARN of the room profile to delete. Required.
    public var profileArn: Swift.String?

    public init(
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
    let profileArn: Swift.String?
}

extension DeleteProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension DeleteProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension DeleteRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRoomInput: Swift.Equatable {
    /// The ARN of the room to delete. Required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct DeleteRoomInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension DeleteRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DeleteRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoomOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRoomSkillParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = self.parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DeleteRoomSkillParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRoomSkillParameterInput: Swift.Equatable {
    /// The room skill parameter key for which to remove details.
    /// This member is required.
    public var parameterKey: Swift.String?
    /// The ARN of the room from which to remove the room skill parameter details.
    public var roomArn: Swift.String?
    /// The ID of the skill from which to remove the room skill parameter details.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        parameterKey: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct DeleteRoomSkillParameterInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let skillId: Swift.String?
    let parameterKey: Swift.String?
}

extension DeleteRoomSkillParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
    }
}

extension DeleteRoomSkillParameterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoomSkillParameterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoomSkillParameterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSkillAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DeleteSkillAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSkillAuthorizationInput: Swift.Equatable {
    /// The room that the skill is authorized for.
    public var roomArn: Swift.String?
    /// The unique identifier of a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct DeleteSkillAuthorizationInputBody: Swift.Equatable {
    let skillId: Swift.String?
    let roomArn: Swift.String?
}

extension DeleteSkillAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DeleteSkillAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSkillAuthorizationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSkillAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension DeleteSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSkillGroupInput: Swift.Equatable {
    /// The ARN of the skill group to delete. Required.
    public var skillGroupArn: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct DeleteSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
}

extension DeleteSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

extension DeleteSkillGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSkillGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSkillGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enrollmentId = self.enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The ARN of the user's enrollment in the organization. Required.
    /// This member is required.
    public var enrollmentId: Swift.String?
    /// The ARN of the user to delete in the organization. Required.
    public var userArn: Swift.String?

    public init(
        enrollmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let enrollmentId: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.DeveloperInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerName = "DeveloperName"
        case email = "Email"
        case privacyPolicy = "PrivacyPolicy"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerName = self.developerName {
            try encodeContainer.encode(developerName, forKey: .developerName)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let privacyPolicy = self.privacyPolicy {
            try encodeContainer.encode(privacyPolicy, forKey: .privacyPolicy)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let developerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerName)
        developerName = developerNameDecoded
        let privacyPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privacyPolicy)
        privacyPolicy = privacyPolicyDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The details about the developer that published the skill.
    public struct DeveloperInfo: Swift.Equatable {
        /// The name of the developer.
        public var developerName: Swift.String?
        /// The email of the developer.
        public var email: Swift.String?
        /// The URL of the privacy policy.
        public var privacyPolicy: Swift.String?
        /// The website of the developer.
        public var url: Swift.String?

        public init(
            developerName: Swift.String? = nil,
            email: Swift.String? = nil,
            privacyPolicy: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.developerName = developerName
            self.email = email
            self.privacyPolicy = privacyPolicy
            self.url = url
        }
    }

}

extension AlexaForBusinessClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
        case deviceSerialNumber = "DeviceSerialNumber"
        case deviceStatus = "DeviceStatus"
        case deviceStatusInfo = "DeviceStatusInfo"
        case deviceType = "DeviceType"
        case macAddress = "MacAddress"
        case networkProfileInfo = "NetworkProfileInfo"
        case roomArn = "RoomArn"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceSerialNumber = self.deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let deviceStatus = self.deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceStatusInfo = self.deviceStatusInfo {
            try encodeContainer.encode(deviceStatusInfo, forKey: .deviceStatusInfo)
        }
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let networkProfileInfo = self.networkProfileInfo {
            try encodeContainer.encode(networkProfileInfo, forKey: .networkProfileInfo)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let softwareVersion = self.softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let deviceStatusInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatusInfo.self, forKey: .deviceStatusInfo)
        deviceStatusInfo = deviceStatusInfoDecoded
        let networkProfileInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceNetworkProfileInfo.self, forKey: .networkProfileInfo)
        networkProfileInfo = networkProfileInfoDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A device with attributes.
    public struct Device: Swift.Equatable {
        /// The ARN of a device.
        public var deviceArn: Swift.String?
        /// The name of a device.
        public var deviceName: Swift.String?
        /// The serial number of a device.
        public var deviceSerialNumber: Swift.String?
        /// The status of a device. If the status is not READY, check the DeviceStatusInfo value for details.
        public var deviceStatus: AlexaForBusinessClientTypes.DeviceStatus?
        /// Detailed information about a device's status.
        public var deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo?
        /// The type of a device.
        public var deviceType: Swift.String?
        /// The MAC address of a device.
        public var macAddress: Swift.String?
        /// Detailed information about a device's network profile.
        public var networkProfileInfo: AlexaForBusinessClientTypes.DeviceNetworkProfileInfo?
        /// The room ARN of a device.
        public var roomArn: Swift.String?
        /// The software version of a device.
        public var softwareVersion: Swift.String?

        public init(
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceSerialNumber: Swift.String? = nil,
            deviceStatus: AlexaForBusinessClientTypes.DeviceStatus? = nil,
            deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo? = nil,
            deviceType: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            networkProfileInfo: AlexaForBusinessClientTypes.DeviceNetworkProfileInfo? = nil,
            roomArn: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileInfo = networkProfileInfo
            self.roomArn = roomArn
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.DeviceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
        case deviceSerialNumber = "DeviceSerialNumber"
        case deviceStatus = "DeviceStatus"
        case deviceStatusInfo = "DeviceStatusInfo"
        case deviceType = "DeviceType"
        case macAddress = "MacAddress"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceSerialNumber = self.deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let deviceStatus = self.deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceStatusInfo = self.deviceStatusInfo {
            try encodeContainer.encode(deviceStatusInfo, forKey: .deviceStatusInfo)
        }
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = self.networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = self.roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
        if let softwareVersion = self.softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let deviceStatusInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatusInfo.self, forKey: .deviceStatusInfo)
        deviceStatusInfo = deviceStatusInfoDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Device attributes.
    public struct DeviceData: Swift.Equatable {
        /// The time (in epoch) when the device data was created.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of a device.
        public var deviceArn: Swift.String?
        /// The name of a device.
        public var deviceName: Swift.String?
        /// The serial number of a device.
        public var deviceSerialNumber: Swift.String?
        /// The status of a device.
        public var deviceStatus: AlexaForBusinessClientTypes.DeviceStatus?
        /// Detailed information about a device's status.
        public var deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo?
        /// The type of a device.
        public var deviceType: Swift.String?
        /// The MAC address of a device.
        public var macAddress: Swift.String?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The room ARN associated with a device.
        public var roomArn: Swift.String?
        /// The name of the room associated with a device.
        public var roomName: Swift.String?
        /// The software version of a device.
        public var softwareVersion: Swift.String?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceSerialNumber: Swift.String? = nil,
            deviceStatus: AlexaForBusinessClientTypes.DeviceStatus? = nil,
            deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo? = nil,
            deviceType: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.roomArn = roomArn
            self.roomName = roomName
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.DeviceEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceEventType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The list of device events.
    public struct DeviceEvent: Swift.Equatable {
        /// The time (in epoch) when the event occurred.
        public var timestamp: ClientRuntime.Date?
        /// The type of device event.
        public var type: AlexaForBusinessClientTypes.DeviceEventType?
        /// The value of the event.
        public var value: Swift.String?

        public init(
            timestamp: ClientRuntime.Date? = nil,
            type: AlexaForBusinessClientTypes.DeviceEventType? = nil,
            value: Swift.String? = nil
        )
        {
            self.timestamp = timestamp
            self.type = type
            self.value = value
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum DeviceEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionStatus
        case deviceStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceEventType] {
            return [
                .connectionStatus,
                .deviceStatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionStatus: return "CONNECTION_STATUS"
            case .deviceStatus: return "DEVICE_STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceEventType(rawValue: rawValue) ?? DeviceEventType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceNetworkProfileInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateExpirationTime = "CertificateExpirationTime"
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateExpirationTime = self.certificateExpirationTime {
            try encodeContainer.encodeTimestamp(certificateExpirationTime, format: .epochSeconds, forKey: .certificateExpirationTime)
        }
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .certificateExpirationTime)
        certificateExpirationTime = certificateExpirationTimeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Detailed information about a device's network profile.
    public struct DeviceNetworkProfileInfo: Swift.Equatable {
        /// The ARN of the certificate associated with a device.
        public var certificateArn: Swift.String?
        /// The time (in epoch) when the certificate expires.
        public var certificateExpirationTime: ClientRuntime.Date?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            certificateExpirationTime: ClientRuntime.Date? = nil,
            networkProfileArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateExpirationTime = certificateExpirationTime
            self.networkProfileArn = networkProfileArn
        }
    }

}

extension DeviceNotRegisteredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeviceNotRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because this device is no longer registered and therefore no longer managed by this account.
public struct DeviceNotRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceNotRegisteredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeviceNotRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceNotRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistered
        case failed
        case pending
        case ready
        case wasOffline
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .deregistered,
                .failed,
                .pending,
                .ready,
                .wasOffline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "DEREGISTERED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .wasOffline: return "WAS_OFFLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceStatusDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case feature = "Feature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let feature = self.feature {
            try encodeContainer.encode(feature.rawValue, forKey: .feature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
        let codeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatusDetailCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Details of a devices status.
    public struct DeviceStatusDetail: Swift.Equatable {
        /// The device status detail code.
        public var code: AlexaForBusinessClientTypes.DeviceStatusDetailCode?
        /// The list of available features on the device.
        public var feature: AlexaForBusinessClientTypes.Feature?

        public init(
            code: AlexaForBusinessClientTypes.DeviceStatusDetailCode? = nil,
            feature: AlexaForBusinessClientTypes.Feature? = nil
        )
        {
            self.code = code
            self.feature = feature
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum DeviceStatusDetailCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associationRejection
        case authenticationFailure
        case certificateAuthorityAccessDenied
        case certificateIssuingLimitExceeded
        case credentialsAccessFailure
        case deviceSoftwareUpdateNeeded
        case deviceWasOffline
        case dhcpFailure
        case dnsFailure
        case internetUnavailable
        case invalidCertificateAuthority
        case invalidPasswordState
        case networkProfileNotFound
        case passwordManagerAccessDenied
        case passwordNotFound
        case tlsVersionMismatch
        case unknownFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatusDetailCode] {
            return [
                .associationRejection,
                .authenticationFailure,
                .certificateAuthorityAccessDenied,
                .certificateIssuingLimitExceeded,
                .credentialsAccessFailure,
                .deviceSoftwareUpdateNeeded,
                .deviceWasOffline,
                .dhcpFailure,
                .dnsFailure,
                .internetUnavailable,
                .invalidCertificateAuthority,
                .invalidPasswordState,
                .networkProfileNotFound,
                .passwordManagerAccessDenied,
                .passwordNotFound,
                .tlsVersionMismatch,
                .unknownFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associationRejection: return "ASSOCIATION_REJECTION"
            case .authenticationFailure: return "AUTHENTICATION_FAILURE"
            case .certificateAuthorityAccessDenied: return "CERTIFICATE_AUTHORITY_ACCESS_DENIED"
            case .certificateIssuingLimitExceeded: return "CERTIFICATE_ISSUING_LIMIT_EXCEEDED"
            case .credentialsAccessFailure: return "CREDENTIALS_ACCESS_FAILURE"
            case .deviceSoftwareUpdateNeeded: return "DEVICE_SOFTWARE_UPDATE_NEEDED"
            case .deviceWasOffline: return "DEVICE_WAS_OFFLINE"
            case .dhcpFailure: return "DHCP_FAILURE"
            case .dnsFailure: return "DNS_FAILURE"
            case .internetUnavailable: return "INTERNET_UNAVAILABLE"
            case .invalidCertificateAuthority: return "INVALID_CERTIFICATE_AUTHORITY"
            case .invalidPasswordState: return "INVALID_PASSWORD_STATE"
            case .networkProfileNotFound: return "NETWORK_PROFILE_NOT_FOUND"
            case .passwordManagerAccessDenied: return "PASSWORD_MANAGER_ACCESS_DENIED"
            case .passwordNotFound: return "PASSWORD_NOT_FOUND"
            case .tlsVersionMismatch: return "TLS_VERSION_MISMATCH"
            case .unknownFailure: return "UNKNOWN_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatusDetailCode(rawValue: rawValue) ?? DeviceStatusDetailCode.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceStatusInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case connectionStatusUpdatedTime = "ConnectionStatusUpdatedTime"
        case deviceStatusDetails = "DeviceStatusDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let connectionStatusUpdatedTime = self.connectionStatusUpdatedTime {
            try encodeContainer.encodeTimestamp(connectionStatusUpdatedTime, format: .epochSeconds, forKey: .connectionStatusUpdatedTime)
        }
        if let deviceStatusDetails = deviceStatusDetails {
            var deviceStatusDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceStatusDetails)
            for devicestatusdetail0 in deviceStatusDetails {
                try deviceStatusDetailsContainer.encode(devicestatusdetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceStatusDetailsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.DeviceStatusDetail?].self, forKey: .deviceStatusDetails)
        var deviceStatusDetailsDecoded0:[AlexaForBusinessClientTypes.DeviceStatusDetail]? = nil
        if let deviceStatusDetailsContainer = deviceStatusDetailsContainer {
            deviceStatusDetailsDecoded0 = [AlexaForBusinessClientTypes.DeviceStatusDetail]()
            for structure0 in deviceStatusDetailsContainer {
                if let structure0 = structure0 {
                    deviceStatusDetailsDecoded0?.append(structure0)
                }
            }
        }
        deviceStatusDetails = deviceStatusDetailsDecoded0
        let connectionStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let connectionStatusUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .connectionStatusUpdatedTime)
        connectionStatusUpdatedTime = connectionStatusUpdatedTimeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Detailed information about a device's status.
    public struct DeviceStatusInfo: Swift.Equatable {
        /// The latest available information about the connection status of a device.
        public var connectionStatus: AlexaForBusinessClientTypes.ConnectionStatus?
        /// The time (in epoch) when the device connection status changed.
        public var connectionStatusUpdatedTime: ClientRuntime.Date?
        /// One or more device status detail descriptions.
        public var deviceStatusDetails: [AlexaForBusinessClientTypes.DeviceStatusDetail]?

        public init(
            connectionStatus: AlexaForBusinessClientTypes.ConnectionStatus? = nil,
            connectionStatusUpdatedTime: ClientRuntime.Date? = nil,
            deviceStatusDetails: [AlexaForBusinessClientTypes.DeviceStatusDetail]? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.connectionStatusUpdatedTime = connectionStatusUpdatedTime
            self.deviceStatusDetails = deviceStatusDetails
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum DeviceUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceUsageType] {
            return [
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceUsageType(rawValue: rawValue) ?? DeviceUsageType.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateContactFromAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension DisassociateContactFromAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateContactFromAddressBookInput: Swift.Equatable {
    /// The ARN of the address from which to disassociate the contact.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The ARN of the contact to disassociate from an address book.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil,
        contactArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

struct DisassociateContactFromAddressBookInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let addressBookArn: Swift.String?
}

extension DisassociateContactFromAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension DisassociateContactFromAddressBookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateContactFromAddressBookOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateContactFromAddressBookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateDeviceFromRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

extension DisassociateDeviceFromRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDeviceFromRoomInput: Swift.Equatable {
    /// The ARN of the device to disassociate from a room. Required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct DisassociateDeviceFromRoomInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension DisassociateDeviceFromRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension DisassociateDeviceFromRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateDeviceFromRoomOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateDeviceFromRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceNotRegisteredException": return try await DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateSkillFromSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DisassociateSkillFromSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateSkillFromSkillGroupInput: Swift.Equatable {
    /// The unique identifier of a skill. Required.
    public var skillGroupArn: Swift.String?
    /// The ARN of a skill group to associate to a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

struct DisassociateSkillFromSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let skillId: Swift.String?
}

extension DisassociateSkillFromSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension DisassociateSkillFromSkillGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateSkillFromSkillGroupOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateSkillFromSkillGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateSkillFromUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DisassociateSkillFromUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateSkillFromUsersInput: Swift.Equatable {
    /// The private skill ID you want to make unavailable for enrolled users.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct DisassociateSkillFromUsersInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension DisassociateSkillFromUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension DisassociateSkillFromUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateSkillFromUsersOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateSkillFromUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateSkillGroupFromRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension DisassociateSkillGroupFromRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateSkillGroupFromRoomInput: Swift.Equatable {
    /// The ARN of the room from which the skill group is to be disassociated. Required.
    public var roomArn: Swift.String?
    /// The ARN of the skill group to disassociate from a room. Required.
    public var skillGroupArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

struct DisassociateSkillGroupFromRoomInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let roomArn: Swift.String?
}

extension DisassociateSkillGroupFromRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DisassociateSkillGroupFromRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateSkillGroupFromRoomOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateSkillGroupFromRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum DistanceUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imperial
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceUnit] {
            return [
                .imperial,
                .metric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imperial: return "IMPERIAL"
            case .metric: return "METRIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DistanceUnit(rawValue: rawValue) ?? DistanceUnit.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum EnablementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementType] {
            return [
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnablementType(rawValue: rawValue) ?? EnablementType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum EnablementTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementTypeFilter] {
            return [
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnablementTypeFilter(rawValue: rawValue) ?? EnablementTypeFilter.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.EndOfMeetingReminder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for minutes0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(minutes0)
            }
        }
        if let reminderType = self.reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Swift.Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Swift.Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct EndOfMeetingReminder: Swift.Equatable {
        /// Whether an end of meeting reminder is enabled or not.
        public var enabled: Swift.Bool?
        /// A range of 3 to 15 minutes that determines when the reminder begins.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init(
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum EndOfMeetingReminderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case announcementTimeCheck
        case announcementVariableTimeLeft
        case chime
        case knock
        case sdkUnknown(Swift.String)

        public static var allCases: [EndOfMeetingReminderType] {
            return [
                .announcementTimeCheck,
                .announcementVariableTimeLeft,
                .chime,
                .knock,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .announcementTimeCheck: return "ANNOUNCEMENT_TIME_CHECK"
            case .announcementVariableTimeLeft: return "ANNOUNCEMENT_VARIABLE_TIME_LEFT"
            case .chime: return "CHIME"
            case .knock: return "KNOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndOfMeetingReminderType(rawValue: rawValue) ?? EndOfMeetingReminderType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum EnrollmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistering
        case disassociating
        case initialized
        case pending
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [EnrollmentStatus] {
            return [
                .deregistering,
                .disassociating,
                .initialized,
                .pending,
                .registered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistering: return "DEREGISTERING"
            case .disassociating: return "DISASSOCIATING"
            case .initialized: return "INITIALIZED"
            case .pending: return "PENDING"
            case .registered: return "REGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnrollmentStatus(rawValue: rawValue) ?? EnrollmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum Feature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case bluetooth
        case lists
        case networkProfile
        case notifications
        case settings
        case skills
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [Feature] {
            return [
                .all,
                .bluetooth,
                .lists,
                .networkProfile,
                .notifications,
                .settings,
                .skills,
                .volume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .bluetooth: return "BLUETOOTH"
            case .lists: return "LISTS"
            case .networkProfile: return "NETWORK_PROFILE"
            case .notifications: return "NOTIFICATIONS"
            case .settings: return "SETTINGS"
            case .skills: return "SKILLS"
            case .volume: return "VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Feature(rawValue: rawValue) ?? Feature.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AlexaForBusinessClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria.
    public struct Filter: Swift.Equatable {
        /// The key of a filter.
        /// This member is required.
        public var key: Swift.String?
        /// The values of a filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension ForgetSmartHomeAppliancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension ForgetSmartHomeAppliancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ForgetSmartHomeAppliancesInput: Swift.Equatable {
    /// The room that the appliances are associated with.
    /// This member is required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct ForgetSmartHomeAppliancesInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension ForgetSmartHomeAppliancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension ForgetSmartHomeAppliancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ForgetSmartHomeAppliancesOutput: Swift.Equatable {

    public init() { }
}

enum ForgetSmartHomeAppliancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.Gateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = self.gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = self.softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The details of the gateway.
    public struct Gateway: Swift.Equatable {
        /// The ARN of the gateway.
        public var arn: Swift.String?
        /// The description of the gateway.
        public var description: Swift.String?
        /// The ARN of the gateway group that the gateway is associated to.
        public var gatewayGroupArn: Swift.String?
        /// The name of the gateway.
        public var name: Swift.String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public var softwareVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            gatewayGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.GatewayGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The details of the gateway group.
    public struct GatewayGroup: Swift.Equatable {
        /// The ARN of the gateway group.
        public var arn: Swift.String?
        /// The description of the gateway group.
        public var description: Swift.String?
        /// The name of the gateway group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.GatewayGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of a gateway group.
    public struct GatewayGroupSummary: Swift.Equatable {
        /// The ARN of the gateway group.
        public var arn: Swift.String?
        /// The description of the gateway group.
        public var description: Swift.String?
        /// The name of the gateway group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.GatewaySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = self.gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = self.softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of a gateway.
    public struct GatewaySummary: Swift.Equatable {
        /// The ARN of the gateway.
        public var arn: Swift.String?
        /// The description of the gateway.
        public var description: Swift.String?
        /// The ARN of the gateway group that the gateway is associated to.
        public var gatewayGroupArn: Swift.String?
        /// The name of the gateway.
        public var name: Swift.String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public var softwareVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            gatewayGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }
    }

}

extension GetAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
    }
}

extension GetAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAddressBookInput: Swift.Equatable {
    /// The ARN of the address book for which to request details.
    /// This member is required.
    public var addressBookArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct GetAddressBookInputBody: Swift.Equatable {
    let addressBookArn: Swift.String?
}

extension GetAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension GetAddressBookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAddressBookOutputBody = try responseDecoder.decode(responseBody: data)
            self.addressBook = output.addressBook
        } else {
            self.addressBook = nil
        }
    }
}

public struct GetAddressBookOutput: Swift.Equatable {
    /// The details of the requested address book.
    public var addressBook: AlexaForBusinessClientTypes.AddressBook?

    public init(
        addressBook: AlexaForBusinessClientTypes.AddressBook? = nil
    )
    {
        self.addressBook = addressBook
    }
}

struct GetAddressBookOutputBody: Swift.Equatable {
    let addressBook: AlexaForBusinessClientTypes.AddressBook?
}

extension GetAddressBookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBook = "AddressBook"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.AddressBook.self, forKey: .addressBook)
        addressBook = addressBookDecoded
    }
}

enum GetAddressBookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConferencePreferenceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetConferencePreferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConferencePreferenceInput: Swift.Equatable {

    public init() { }
}

struct GetConferencePreferenceInputBody: Swift.Equatable {
}

extension GetConferencePreferenceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConferencePreferenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConferencePreferenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.preference = output.preference
        } else {
            self.preference = nil
        }
    }
}

public struct GetConferencePreferenceOutput: Swift.Equatable {
    /// The conference preference.
    public var preference: AlexaForBusinessClientTypes.ConferencePreference?

    public init(
        preference: AlexaForBusinessClientTypes.ConferencePreference? = nil
    )
    {
        self.preference = preference
    }
}

struct GetConferencePreferenceOutputBody: Swift.Equatable {
    let preference: AlexaForBusinessClientTypes.ConferencePreference?
}

extension GetConferencePreferenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preference = "Preference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preferenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferencePreference.self, forKey: .preference)
        preference = preferenceDecoded
    }
}

enum GetConferencePreferenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = self.conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
    }
}

extension GetConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConferenceProviderInput: Swift.Equatable {
    /// The ARN of the newly created conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?

    public init(
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct GetConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
}

extension GetConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

extension GetConferenceProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConferenceProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.conferenceProvider = output.conferenceProvider
        } else {
            self.conferenceProvider = nil
        }
    }
}

public struct GetConferenceProviderOutput: Swift.Equatable {
    /// The conference provider.
    public var conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider?

    public init(
        conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider? = nil
    )
    {
        self.conferenceProvider = conferenceProvider
    }
}

struct GetConferenceProviderOutputBody: Swift.Equatable {
    let conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider?
}

extension GetConferenceProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProvider = "ConferenceProvider"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProvider.self, forKey: .conferenceProvider)
        conferenceProvider = conferenceProviderDecoded
    }
}

enum GetConferenceProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension GetContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactInput: Swift.Equatable {
    /// The ARN of the contact for which to request details.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct GetContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension GetContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension GetContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contact = output.contact
        } else {
            self.contact = nil
        }
    }
}

public struct GetContactOutput: Swift.Equatable {
    /// The details of the requested contact.
    public var contact: AlexaForBusinessClientTypes.Contact?

    public init(
        contact: AlexaForBusinessClientTypes.Contact? = nil
    )
    {
        self.contact = contact
    }
}

struct GetContactOutputBody: Swift.Equatable {
    let contact: AlexaForBusinessClientTypes.Contact?
}

extension GetContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contact = "Contact"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Contact.self, forKey: .contact)
        contact = contactDecoded
    }
}

enum GetContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

extension GetDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDeviceInput: Swift.Equatable {
    /// The ARN of the device for which to request details. Required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct GetDeviceInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension GetDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension GetDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct GetDeviceOutput: Swift.Equatable {
    /// The details of the device requested. Required.
    public var device: AlexaForBusinessClientTypes.Device?

    public init(
        device: AlexaForBusinessClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputBody: Swift.Equatable {
    let device: AlexaForBusinessClientTypes.Device?
}

extension GetDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

enum GetDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = self.gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
    }
}

extension GetGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGatewayGroupInput: Swift.Equatable {
    /// The ARN of the gateway group to get.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct GetGatewayGroupInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
}

extension GetGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension GetGatewayGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGatewayGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayGroup = output.gatewayGroup
        } else {
            self.gatewayGroup = nil
        }
    }
}

public struct GetGatewayGroupOutput: Swift.Equatable {
    /// The details of the gateway group.
    public var gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup?

    public init(
        gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup? = nil
    )
    {
        self.gatewayGroup = gatewayGroup
    }
}

struct GetGatewayGroupOutputBody: Swift.Equatable {
    let gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup?
}

extension GetGatewayGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroup = "GatewayGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.GatewayGroup.self, forKey: .gatewayGroup)
        gatewayGroup = gatewayGroupDecoded
    }
}

enum GetGatewayGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension GetGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGatewayInput: Swift.Equatable {
    /// The ARN of the gateway to get.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct GetGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension GetGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension GetGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gateway = output.gateway
        } else {
            self.gateway = nil
        }
    }
}

public struct GetGatewayOutput: Swift.Equatable {
    /// The details of the gateway.
    public var gateway: AlexaForBusinessClientTypes.Gateway?

    public init(
        gateway: AlexaForBusinessClientTypes.Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

struct GetGatewayOutputBody: Swift.Equatable {
    let gateway: AlexaForBusinessClientTypes.Gateway?
}

extension GetGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateway = "Gateway"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Gateway.self, forKey: .gateway)
        gateway = gatewayDecoded
    }
}

enum GetGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInvitationConfigurationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetInvitationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInvitationConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetInvitationConfigurationInputBody: Swift.Equatable {
}

extension GetInvitationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInvitationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInvitationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactEmail = output.contactEmail
            self.organizationName = output.organizationName
            self.privateSkillIds = output.privateSkillIds
        } else {
            self.contactEmail = nil
            self.organizationName = nil
            self.privateSkillIds = nil
        }
    }
}

public struct GetInvitationConfigurationOutput: Swift.Equatable {
    /// The email ID of the organization or individual contact that the enrolled user can use.
    public var contactEmail: Swift.String?
    /// The name of the organization sending the enrollment invite to a user.
    public var organizationName: Swift.String?
    /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
    public var privateSkillIds: [Swift.String]?

    public init(
        contactEmail: Swift.String? = nil,
        organizationName: Swift.String? = nil,
        privateSkillIds: [Swift.String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

struct GetInvitationConfigurationOutputBody: Swift.Equatable {
    let organizationName: Swift.String?
    let contactEmail: Swift.String?
    let privateSkillIds: [Swift.String]?
}

extension GetInvitationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let contactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactEmail)
        contactEmail = contactEmailDecoded
        let privateSkillIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .privateSkillIds)
        var privateSkillIdsDecoded0:[Swift.String]? = nil
        if let privateSkillIdsContainer = privateSkillIdsContainer {
            privateSkillIdsDecoded0 = [Swift.String]()
            for string0 in privateSkillIdsContainer {
                if let string0 = string0 {
                    privateSkillIdsDecoded0?.append(string0)
                }
            }
        }
        privateSkillIds = privateSkillIdsDecoded0
    }
}

enum GetInvitationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

extension GetNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init(
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct GetNetworkProfileInputBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
}

extension GetNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension GetNetworkProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNetworkProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct GetNetworkProfileOutput: Swift.Equatable {
    /// The network profile associated with a device.
    public var networkProfile: AlexaForBusinessClientTypes.NetworkProfile?

    public init(
        networkProfile: AlexaForBusinessClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct GetNetworkProfileOutputBody: Swift.Equatable {
    let networkProfile: AlexaForBusinessClientTypes.NetworkProfile?
}

extension GetNetworkProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile = "NetworkProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

enum GetNetworkProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidSecretsManagerResourceException": return try await InvalidSecretsManagerResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

extension GetProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProfileInput: Swift.Equatable {
    /// The ARN of the room profile for which to request details. Required.
    public var profileArn: Swift.String?

    public init(
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct GetProfileInputBody: Swift.Equatable {
    let profileArn: Swift.String?
}

extension GetProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension GetProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct GetProfileOutput: Swift.Equatable {
    /// The details of the room profile requested. Required.
    public var profile: AlexaForBusinessClientTypes.Profile?

    public init(
        profile: AlexaForBusinessClientTypes.Profile? = nil
    )
    {
        self.profile = profile
    }
}

struct GetProfileOutputBody: Swift.Equatable {
    let profile: AlexaForBusinessClientTypes.Profile?
}

extension GetProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile = "Profile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Profile.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum GetProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension GetRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoomInput: Swift.Equatable {
    /// The ARN of the room for which to request details. Required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct GetRoomInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension GetRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension GetRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct GetRoomOutput: Swift.Equatable {
    /// The details of the room requested.
    public var room: AlexaForBusinessClientTypes.Room?

    public init(
        room: AlexaForBusinessClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct GetRoomOutputBody: Swift.Equatable {
    let room: AlexaForBusinessClientTypes.Room?
}

extension GetRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

enum GetRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRoomSkillParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = self.parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension GetRoomSkillParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoomSkillParameterInput: Swift.Equatable {
    /// The room skill parameter key for which to get details. Required.
    /// This member is required.
    public var parameterKey: Swift.String?
    /// The ARN of the room from which to get the room skill parameter details.
    public var roomArn: Swift.String?
    /// The ARN of the skill from which to get the room skill parameter details. Required.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        parameterKey: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct GetRoomSkillParameterInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let skillId: Swift.String?
    let parameterKey: Swift.String?
}

extension GetRoomSkillParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
    }
}

extension GetRoomSkillParameterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRoomSkillParameterOutputBody = try responseDecoder.decode(responseBody: data)
            self.roomSkillParameter = output.roomSkillParameter
        } else {
            self.roomSkillParameter = nil
        }
    }
}

public struct GetRoomSkillParameterOutput: Swift.Equatable {
    /// The details of the room skill parameter requested. Required.
    public var roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?

    public init(
        roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter? = nil
    )
    {
        self.roomSkillParameter = roomSkillParameter
    }
}

struct GetRoomSkillParameterOutputBody: Swift.Equatable {
    let roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?
}

extension GetRoomSkillParameterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomSkillParameter = "RoomSkillParameter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomSkillParameterDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RoomSkillParameter.self, forKey: .roomSkillParameter)
        roomSkillParameter = roomSkillParameterDecoded
    }
}

enum GetRoomSkillParameterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension GetSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSkillGroupInput: Swift.Equatable {
    /// The ARN of the skill group for which to get details. Required.
    public var skillGroupArn: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct GetSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
}

extension GetSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

extension GetSkillGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSkillGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.skillGroup = output.skillGroup
        } else {
            self.skillGroup = nil
        }
    }
}

public struct GetSkillGroupOutput: Swift.Equatable {
    /// The details of the skill group requested. Required.
    public var skillGroup: AlexaForBusinessClientTypes.SkillGroup?

    public init(
        skillGroup: AlexaForBusinessClientTypes.SkillGroup? = nil
    )
    {
        self.skillGroup = skillGroup
    }
}

struct GetSkillGroupOutputBody: Swift.Equatable {
    let skillGroup: AlexaForBusinessClientTypes.SkillGroup?
}

extension GetSkillGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroup = "SkillGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillGroup.self, forKey: .skillGroup)
        skillGroup = skillGroupDecoded
    }
}

enum GetSkillGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.IPDialIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commsProtocol = "CommsProtocol"
        case endpoint = "Endpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commsProtocol = self.commsProtocol {
            try encodeContainer.encode(commsProtocol.rawValue, forKey: .commsProtocol)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let commsProtocolDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CommsProtocol.self, forKey: .commsProtocol)
        commsProtocol = commsProtocolDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The IP endpoint and protocol for calling.
    public struct IPDialIn: Swift.Equatable {
        /// The protocol, including SIP, SIPS, and H323.
        /// This member is required.
        public var commsProtocol: AlexaForBusinessClientTypes.CommsProtocol?
        /// The IP address.
        /// This member is required.
        public var endpoint: Swift.String?

        public init(
            commsProtocol: AlexaForBusinessClientTypes.CommsProtocol? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.commsProtocol = commsProtocol
            self.endpoint = endpoint
        }
    }

}

extension AlexaForBusinessClientTypes.InstantBooking: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = self.durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the instant booking feature that are applied to a room profile. When users start their meeting with Alexa, Alexa automatically books the room for the configured duration if the room is available.
    public struct InstantBooking: Swift.Equatable {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension InvalidCertificateAuthorityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCertificateAuthorityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Certificate Authority can't issue or revoke a certificate.
public struct InvalidCertificateAuthorityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificateAuthorityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCertificateAuthorityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCertificateAuthorityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeviceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidDeviceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The device is in an invalid state.
public struct InvalidDeviceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeviceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDeviceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeviceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecretsManagerResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSecretsManagerResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A password in SecretsManager is in an invalid state.
public struct InvalidSecretsManagerResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecretsManagerResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSecretsManagerResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSecretsManagerResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidServiceLinkedRoleStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidServiceLinkedRoleStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service linked role is locked for deletion.
public struct InvalidServiceLinkedRoleStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidServiceLinkedRoleStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidServiceLinkedRoleStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidServiceLinkedRoleStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidUserStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The attempt to update a user is invalid due to the user's current status.
public struct InvalidUserStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUserStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidUserStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUserStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are performing an action that would put you beyond your account's limits.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBusinessReportSchedulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBusinessReportSchedulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBusinessReportSchedulesInput: Swift.Equatable {
    /// The maximum number of schedules listed in the call.
    public var maxResults: Swift.Int?
    /// The token used to list the remaining schedules from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBusinessReportSchedulesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListBusinessReportSchedulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBusinessReportSchedulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBusinessReportSchedulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.businessReportSchedules = output.businessReportSchedules
            self.nextToken = output.nextToken
        } else {
            self.businessReportSchedules = nil
            self.nextToken = nil
        }
    }
}

public struct ListBusinessReportSchedulesOutput: Swift.Equatable {
    /// The schedule of the reports.
    public var businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]?
    /// The token used to list the remaining schedules from the previous API call.
    public var nextToken: Swift.String?

    public init(
        businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.businessReportSchedules = businessReportSchedules
        self.nextToken = nextToken
    }
}

struct ListBusinessReportSchedulesOutputBody: Swift.Equatable {
    let businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]?
    let nextToken: Swift.String?
}

extension ListBusinessReportSchedulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessReportSchedules = "BusinessReportSchedules"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessReportSchedulesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.BusinessReportSchedule?].self, forKey: .businessReportSchedules)
        var businessReportSchedulesDecoded0:[AlexaForBusinessClientTypes.BusinessReportSchedule]? = nil
        if let businessReportSchedulesContainer = businessReportSchedulesContainer {
            businessReportSchedulesDecoded0 = [AlexaForBusinessClientTypes.BusinessReportSchedule]()
            for structure0 in businessReportSchedulesContainer {
                if let structure0 = structure0 {
                    businessReportSchedulesDecoded0?.append(structure0)
                }
            }
        }
        businessReportSchedules = businessReportSchedulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBusinessReportSchedulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConferenceProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConferenceProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConferenceProvidersInput: Swift.Equatable {
    /// The maximum number of conference providers to be returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConferenceProvidersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListConferenceProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListConferenceProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConferenceProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.conferenceProviders = output.conferenceProviders
            self.nextToken = output.nextToken
        } else {
            self.conferenceProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListConferenceProvidersOutput: Swift.Equatable {
    /// The conference providers.
    public var conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conferenceProviders = conferenceProviders
        self.nextToken = nextToken
    }
}

struct ListConferenceProvidersOutputBody: Swift.Equatable {
    let conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]?
    let nextToken: Swift.String?
}

extension ListConferenceProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviders = "ConferenceProviders"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProvidersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.ConferenceProvider?].self, forKey: .conferenceProviders)
        var conferenceProvidersDecoded0:[AlexaForBusinessClientTypes.ConferenceProvider]? = nil
        if let conferenceProvidersContainer = conferenceProvidersContainer {
            conferenceProvidersDecoded0 = [AlexaForBusinessClientTypes.ConferenceProvider]()
            for structure0 in conferenceProvidersContainer {
                if let structure0 = structure0 {
                    conferenceProvidersDecoded0?.append(structure0)
                }
            }
        }
        conferenceProviders = conferenceProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConferenceProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeviceEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case eventType = "EventType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDeviceEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDeviceEventsInput: Swift.Equatable {
    /// The ARN of a device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The event type to filter device events. If EventType isn't specified, this returns a list of all device events in reverse chronological order. If EventType is specified, this returns a list of device events for that EventType in reverse chronological order.
    public var eventType: AlexaForBusinessClientTypes.DeviceEventType?
    /// The maximum number of results to include in the response. The default value is 50. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults. When the end of results is reached, the response has a value of null.
    public var nextToken: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        eventType: AlexaForBusinessClientTypes.DeviceEventType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceEventsInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let eventType: AlexaForBusinessClientTypes.DeviceEventType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDeviceEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case eventType = "EventType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeviceEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeviceEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceEvents = output.deviceEvents
            self.nextToken = output.nextToken
        } else {
            self.deviceEvents = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceEventsOutput: Swift.Equatable {
    /// The device events requested for the device ARN.
    public var deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?

    public init(
        deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceEvents = deviceEvents
        self.nextToken = nextToken
    }
}

struct ListDeviceEventsOutputBody: Swift.Equatable {
    let deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]?
    let nextToken: Swift.String?
}

extension ListDeviceEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceEvents = "DeviceEvents"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceEventsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.DeviceEvent?].self, forKey: .deviceEvents)
        var deviceEventsDecoded0:[AlexaForBusinessClientTypes.DeviceEvent]? = nil
        if let deviceEventsContainer = deviceEventsContainer {
            deviceEventsDecoded0 = [AlexaForBusinessClientTypes.DeviceEvent]()
            for structure0 in deviceEventsContainer {
                if let structure0 = structure0 {
                    deviceEventsDecoded0?.append(structure0)
                }
            }
        }
        deviceEvents = deviceEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeviceEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGatewayGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGatewayGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGatewayGroupsInput: Swift.Equatable {
    /// The maximum number of gateway group summaries to return. The default is 50.
    public var maxResults: Swift.Int?
    /// The token used to paginate though multiple pages of gateway group summaries.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewayGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGatewayGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGatewayGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGatewayGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayGroups = output.gatewayGroups
            self.nextToken = output.nextToken
        } else {
            self.gatewayGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewayGroupsOutput: Swift.Equatable {
    /// The gateway groups in the list.
    public var gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]?
    /// The token used to paginate though multiple pages of gateway group summaries.
    public var nextToken: Swift.String?

    public init(
        gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayGroups = gatewayGroups
        self.nextToken = nextToken
    }
}

struct ListGatewayGroupsOutputBody: Swift.Equatable {
    let gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]?
    let nextToken: Swift.String?
}

extension ListGatewayGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroups = "GatewayGroups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.GatewayGroupSummary?].self, forKey: .gatewayGroups)
        var gatewayGroupsDecoded0:[AlexaForBusinessClientTypes.GatewayGroupSummary]? = nil
        if let gatewayGroupsContainer = gatewayGroupsContainer {
            gatewayGroupsDecoded0 = [AlexaForBusinessClientTypes.GatewayGroupSummary]()
            for structure0 in gatewayGroupsContainer {
                if let structure0 = structure0 {
                    gatewayGroupsDecoded0?.append(structure0)
                }
            }
        }
        gatewayGroups = gatewayGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGatewayGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGatewaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = self.gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The gateway group ARN for which to list gateways.
    public var gatewayGroupArn: Swift.String?
    /// The maximum number of gateway summaries to return. The default is 50.
    public var maxResults: Swift.Int?
    /// The token used to paginate though multiple pages of gateway summaries.
    public var nextToken: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGatewaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGatewaysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGatewaysOutputBody = try responseDecoder.decode(responseBody: data)
            self.gateways = output.gateways
            self.nextToken = output.nextToken
        } else {
            self.gateways = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutput: Swift.Equatable {
    /// The gateways in the list.
    public var gateways: [AlexaForBusinessClientTypes.GatewaySummary]?
    /// The token used to paginate though multiple pages of gateway summaries.
    public var nextToken: Swift.String?

    public init(
        gateways: [AlexaForBusinessClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputBody: Swift.Equatable {
    let gateways: [AlexaForBusinessClientTypes.GatewaySummary]?
    let nextToken: Swift.String?
}

extension ListGatewaysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateways = "Gateways"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.GatewaySummary?].self, forKey: .gateways)
        var gatewaysDecoded0:[AlexaForBusinessClientTypes.GatewaySummary]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [AlexaForBusinessClientTypes.GatewaySummary]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGatewaysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSkillsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enablementType = "EnablementType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case skillGroupArn = "SkillGroupArn"
        case skillType = "SkillType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enablementType = self.enablementType {
            try encodeContainer.encode(enablementType.rawValue, forKey: .enablementType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillType = self.skillType {
            try encodeContainer.encode(skillType.rawValue, forKey: .skillType)
        }
    }
}

extension ListSkillsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSkillsInput: Swift.Equatable {
    /// Whether the skill is enabled under the user's account.
    public var enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The ARN of the skill group for which to list enabled skills.
    public var skillGroupArn: Swift.String?
    /// Whether the skill is publicly available or is a private skill.
    public var skillType: AlexaForBusinessClientTypes.SkillTypeFilter?

    public init(
        enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil,
        skillType: AlexaForBusinessClientTypes.SkillTypeFilter? = nil
    )
    {
        self.enablementType = enablementType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.skillGroupArn = skillGroupArn
        self.skillType = skillType
    }
}

struct ListSkillsInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter?
    let skillType: AlexaForBusinessClientTypes.SkillTypeFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSkillsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enablementType = "EnablementType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case skillGroupArn = "SkillGroupArn"
        case skillType = "SkillType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let enablementTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EnablementTypeFilter.self, forKey: .enablementType)
        enablementType = enablementTypeDecoded
        let skillTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillTypeFilter.self, forKey: .skillType)
        skillType = skillTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSkillsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.skillSummaries = output.skillSummaries
        } else {
            self.nextToken = nil
            self.skillSummaries = nil
        }
    }
}

public struct ListSkillsOutput: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The list of enabled skills requested. Required.
    public var skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]?

    public init(
        nextToken: Swift.String? = nil,
        skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillSummaries = skillSummaries
    }
}

struct ListSkillsOutputBody: Swift.Equatable {
    let skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]?
    let nextToken: Swift.String?
}

extension ListSkillsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case skillSummaries = "SkillSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillSummariesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SkillSummary?].self, forKey: .skillSummaries)
        var skillSummariesDecoded0:[AlexaForBusinessClientTypes.SkillSummary]? = nil
        if let skillSummariesContainer = skillSummariesContainer {
            skillSummariesDecoded0 = [AlexaForBusinessClientTypes.SkillSummary]()
            for structure0 in skillSummariesContainer {
                if let structure0 = structure0 {
                    skillSummariesDecoded0?.append(structure0)
                }
            }
        }
        skillSummaries = skillSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSkillsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSkillsStoreCategoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSkillsStoreCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSkillsStoreCategoriesInput: Swift.Equatable {
    /// The maximum number of categories returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreCategoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSkillsStoreCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsStoreCategoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSkillsStoreCategoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.categoryList = output.categoryList
            self.nextToken = output.nextToken
        } else {
            self.categoryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSkillsStoreCategoriesOutput: Swift.Equatable {
    /// The list of categories.
    public var categoryList: [AlexaForBusinessClientTypes.Category]?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        categoryList: [AlexaForBusinessClientTypes.Category]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categoryList = categoryList
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreCategoriesOutputBody: Swift.Equatable {
    let categoryList: [AlexaForBusinessClientTypes.Category]?
    let nextToken: Swift.String?
}

extension ListSkillsStoreCategoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryList = "CategoryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Category?].self, forKey: .categoryList)
        var categoryListDecoded0:[AlexaForBusinessClientTypes.Category]? = nil
        if let categoryListContainer = categoryListContainer {
            categoryListDecoded0 = [AlexaForBusinessClientTypes.Category]()
            for structure0 in categoryListContainer {
                if let structure0 = structure0 {
                    categoryListDecoded0?.append(structure0)
                }
            }
        }
        categoryList = categoryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSkillsStoreCategoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSkillsStoreSkillsByCategoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryId = "CategoryId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryId = self.categoryId {
            try encodeContainer.encode(categoryId, forKey: .categoryId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSkillsStoreSkillsByCategoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSkillsStoreSkillsByCategoryInput: Swift.Equatable {
    /// The category ID for which the skills are being retrieved from the skill store.
    /// This member is required.
    public var categoryId: Swift.Int?
    /// The maximum number of skills returned per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        categoryId: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categoryId = categoryId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreSkillsByCategoryInputBody: Swift.Equatable {
    let categoryId: Swift.Int?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSkillsStoreSkillsByCategoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryId = "CategoryId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .categoryId)
        categoryId = categoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsStoreSkillsByCategoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSkillsStoreSkillsByCategoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.skillsStoreSkills = output.skillsStoreSkills
        } else {
            self.nextToken = nil
            self.skillsStoreSkills = nil
        }
    }
}

public struct ListSkillsStoreSkillsByCategoryOutput: Swift.Equatable {
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The skill store skills.
    public var skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]?

    public init(
        nextToken: Swift.String? = nil,
        skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillsStoreSkills = skillsStoreSkills
    }
}

struct ListSkillsStoreSkillsByCategoryOutputBody: Swift.Equatable {
    let skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]?
    let nextToken: Swift.String?
}

extension ListSkillsStoreSkillsByCategoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case skillsStoreSkills = "SkillsStoreSkills"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillsStoreSkillsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SkillsStoreSkill?].self, forKey: .skillsStoreSkills)
        var skillsStoreSkillsDecoded0:[AlexaForBusinessClientTypes.SkillsStoreSkill]? = nil
        if let skillsStoreSkillsContainer = skillsStoreSkillsContainer {
            skillsStoreSkillsDecoded0 = [AlexaForBusinessClientTypes.SkillsStoreSkill]()
            for structure0 in skillsStoreSkillsContainer {
                if let structure0 = structure0 {
                    skillsStoreSkillsDecoded0?.append(structure0)
                }
            }
        }
        skillsStoreSkills = skillsStoreSkillsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSkillsStoreSkillsByCategoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSmartHomeAppliancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension ListSmartHomeAppliancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSmartHomeAppliancesInput: Swift.Equatable {
    /// The maximum number of appliances to be returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The room that the appliances are associated with.
    /// This member is required.
    public var roomArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roomArn = roomArn
    }
}

struct ListSmartHomeAppliancesInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSmartHomeAppliancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSmartHomeAppliancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSmartHomeAppliancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.smartHomeAppliances = output.smartHomeAppliances
        } else {
            self.nextToken = nil
            self.smartHomeAppliances = nil
        }
    }
}

public struct ListSmartHomeAppliancesOutput: Swift.Equatable {
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The smart home appliances.
    public var smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]?

    public init(
        nextToken: Swift.String? = nil,
        smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]? = nil
    )
    {
        self.nextToken = nextToken
        self.smartHomeAppliances = smartHomeAppliances
    }
}

struct ListSmartHomeAppliancesOutputBody: Swift.Equatable {
    let smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]?
    let nextToken: Swift.String?
}

extension ListSmartHomeAppliancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case smartHomeAppliances = "SmartHomeAppliances"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smartHomeAppliancesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SmartHomeAppliance?].self, forKey: .smartHomeAppliances)
        var smartHomeAppliancesDecoded0:[AlexaForBusinessClientTypes.SmartHomeAppliance]? = nil
        if let smartHomeAppliancesContainer = smartHomeAppliancesContainer {
            smartHomeAppliancesDecoded0 = [AlexaForBusinessClientTypes.SmartHomeAppliance]()
            for structure0 in smartHomeAppliancesContainer {
                if let structure0 = structure0 {
                    smartHomeAppliancesDecoded0?.append(structure0)
                }
            }
        }
        smartHomeAppliances = smartHomeAppliancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSmartHomeAppliancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The ARN of the specified resource for which to list tags.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutput: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The tags requested for the specified resource.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let tags: [AlexaForBusinessClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.MeetingRoomConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case proactiveJoin = "ProactiveJoin"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = self.endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = self.instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let proactiveJoin = self.proactiveJoin {
            try encodeContainer.encode(proactiveJoin, forKey: .proactiveJoin)
        }
        if let requireCheckIn = self.requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = self.roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.InstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
        let proactiveJoinDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ProactiveJoin.self, forKey: .proactiveJoin)
        proactiveJoin = proactiveJoinDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Meeting room settings of a room profile.
    public struct MeetingRoomConfiguration: Swift.Equatable {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.EndOfMeetingReminder?
        /// Settings to automatically book the room if available for a configured duration when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.InstantBooking?
        public var proactiveJoin: AlexaForBusinessClientTypes.ProactiveJoin?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into. This makes the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.RequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init(
            endOfMeetingReminder: AlexaForBusinessClientTypes.EndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.InstantBooking? = nil,
            proactiveJoin: AlexaForBusinessClientTypes.ProactiveJoin? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.RequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.proactiveJoin = proactiveJoin
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension AlexaForBusinessClientTypes.MeetingSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requirePin = "RequirePin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requirePin = self.requirePin {
            try encodeContainer.encode(requirePin.rawValue, forKey: .requirePin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requirePinDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RequirePin.self, forKey: .requirePin)
        requirePin = requirePinDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The values that indicate whether a pin is always required (YES), never required (NO), or OPTIONAL.
    ///
    /// * If YES, Alexa will always ask for a meeting pin.
    ///
    /// * If NO, Alexa will never ask for a meeting pin.
    ///
    /// * If OPTIONAL, Alexa will ask if you have a meeting pin and if the customer responds with yes, it will ask for the meeting pin.
    public struct MeetingSetting: Swift.Equatable {
        /// The values that indicate whether the pin is always required.
        /// This member is required.
        public var requirePin: AlexaForBusinessClientTypes.RequirePin?

        public init(
            requirePin: AlexaForBusinessClientTypes.RequirePin? = nil
        )
        {
            self.requirePin = requirePin
        }
    }

}

extension NameInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NameInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The name sent in the request is already in use.
public struct NameInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NameInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NameInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NameInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public enum NetworkEapMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eapTls
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkEapMethod] {
            return [
                .eapTls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eapTls: return "EAP_TLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkEapMethod(rawValue: rawValue) ?? NetworkEapMethod.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.NetworkProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let currentPassword = self.currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = self.eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = self.networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = self.nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let securityType = self.securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = self.ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchor0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchor0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[Swift.String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [Swift.String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

extension AlexaForBusinessClientTypes.NetworkProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkProfile(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), description: \(Swift.String(describing: description)), eapMethod: \(Swift.String(describing: eapMethod)), networkProfileArn: \(Swift.String(describing: networkProfileArn)), networkProfileName: \(Swift.String(describing: networkProfileName)), securityType: \(Swift.String(describing: securityType)), ssid: \(Swift.String(describing: ssid)), trustAnchors: \(Swift.String(describing: trustAnchors)), currentPassword: \"CONTENT_REDACTED\", nextPassword: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes {
    /// The network profile associated with a device.
    public struct NetworkProfile: Swift.Equatable {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public var certificateAuthorityArn: Swift.String?
        /// The current password of the Wi-Fi network.
        public var currentPassword: Swift.String?
        /// Detailed information about a device's network profile.
        public var description: Swift.String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
        public var nextPassword: Swift.String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public var ssid: Swift.String?
        /// The root certificates of your authentication server, which is installed on your devices and used to trust your authentication server during EAP negotiation.
        public var trustAnchors: [Swift.String]?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            currentPassword: Swift.String? = nil,
            description: Swift.String? = nil,
            eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            nextPassword: Swift.String? = nil,
            securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
            ssid: Swift.String? = nil,
            trustAnchors: [Swift.String]? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.currentPassword = currentPassword
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.nextPassword = nextPassword
            self.securityType = securityType
            self.ssid = ssid
            self.trustAnchors = trustAnchors
        }
    }

}

extension AlexaForBusinessClientTypes.NetworkProfileData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case securityType = "SecurityType"
        case ssid = "Ssid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = self.eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = self.networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let securityType = self.securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = self.ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The data associated with a network profile.
    public struct NetworkProfileData: Swift.Equatable {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public var certificateAuthorityArn: Swift.String?
        /// Detailed information about a device's network profile.
        public var description: Swift.String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public var ssid: Swift.String?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            description: Swift.String? = nil,
            eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
            ssid: Swift.String? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.securityType = securityType
            self.ssid = ssid
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum NetworkSecurityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `open`
        case wep
        case wpa2Enterprise
        case wpa2Psk
        case wpaPsk
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSecurityType] {
            return [
                .open,
                .wep,
                .wpa2Enterprise,
                .wpa2Psk,
                .wpaPsk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .open: return "OPEN"
            case .wep: return "WEP"
            case .wpa2Enterprise: return "WPA2_ENTERPRISE"
            case .wpa2Psk: return "WPA2_PSK"
            case .wpaPsk: return "WPA_PSK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkSecurityType(rawValue: rawValue) ?? NetworkSecurityType.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is not found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes.PSTNDialIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case oneClickIdDelay = "OneClickIdDelay"
        case oneClickPinDelay = "OneClickPinDelay"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let oneClickIdDelay = self.oneClickIdDelay {
            try encodeContainer.encode(oneClickIdDelay, forKey: .oneClickIdDelay)
        }
        if let oneClickPinDelay = self.oneClickPinDelay {
            try encodeContainer.encode(oneClickPinDelay, forKey: .oneClickPinDelay)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let oneClickIdDelayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oneClickIdDelay)
        oneClickIdDelay = oneClickIdDelayDecoded
        let oneClickPinDelayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oneClickPinDelay)
        oneClickPinDelay = oneClickPinDelayDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The information for public switched telephone network (PSTN) conferencing.
    public struct PSTNDialIn: Swift.Equatable {
        /// The zip code.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The delay duration before Alexa enters the conference ID with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        /// This member is required.
        public var oneClickIdDelay: Swift.String?
        /// The delay duration before Alexa enters the conference pin with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        /// This member is required.
        public var oneClickPinDelay: Swift.String?
        /// The phone number to call to join the conference.
        /// This member is required.
        public var phoneNumber: Swift.String?

        public init(
            countryCode: Swift.String? = nil,
            oneClickIdDelay: Swift.String? = nil,
            oneClickPinDelay: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.oneClickIdDelay = oneClickIdDelay
            self.oneClickPinDelay = oneClickPinDelay
            self.phoneNumber = phoneNumber
        }
    }

}

extension AlexaForBusinessClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case number = "Number"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let number = self.number {
            try encodeContainer.encode(number, forKey: .number)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .number)
        number = numberDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PhoneNumberType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AlexaForBusinessClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(number: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes {
    /// The phone number for the contact containing the raw number and phone number type.
    public struct PhoneNumber: Swift.Equatable {
        /// The raw value of the phone number.
        /// This member is required.
        public var number: Swift.String?
        /// The type of the phone number.
        /// This member is required.
        public var type: AlexaForBusinessClientTypes.PhoneNumberType?

        public init(
            number: Swift.String? = nil,
            type: AlexaForBusinessClientTypes.PhoneNumberType? = nil
        )
        {
            self.number = number
            self.type = type
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case home
        case mobile
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .home,
                .mobile,
                .work,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .home: return "HOME"
            case .mobile: return "MOBILE"
            case .work: return "WORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.ProactiveJoin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledByMotion = "EnabledByMotion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledByMotion = self.enabledByMotion {
            try encodeContainer.encode(enabledByMotion, forKey: .enabledByMotion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledByMotionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledByMotion)
        enabledByMotion = enabledByMotionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public struct ProactiveJoin: Swift.Equatable {
        public var enabledByMotion: Swift.Bool?

        public init(
            enabledByMotion: Swift.Bool? = nil
        )
        {
            self.enabledByMotion = enabledByMotion
        }
    }

}

extension AlexaForBusinessClientTypes.Profile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressBookArn = "AddressBookArn"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pstnEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let dataRetentionOptIn = self.dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = self.isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = self.maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = self.meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pstnEnabled = self.pstnEnabled {
            try encodeContainer.encode(pstnEnabled, forKey: .pstnEnabled)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = self.setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let temperatureUnit = self.temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = self.wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pstnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pstnEnabled)
        pstnEnabled = pstnEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A room profile with attributes.
    public struct Profile: Swift.Equatable {
        /// The address of a room profile.
        public var address: Swift.String?
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// Whether data retention of the profile is enabled.
        public var dataRetentionOptIn: Swift.Bool?
        /// The distance unit of a room profile.
        public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
        /// Retrieves if the profile is default or not.
        public var isDefault: Swift.Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public var locale: Swift.String?
        /// The max volume limit of a room profile.
        public var maxVolumeLimit: Swift.Int?
        /// Meeting room settings of a room profile.
        public var meetingRoomConfiguration: AlexaForBusinessClientTypes.MeetingRoomConfiguration?
        /// The ARN of a room profile.
        public var profileArn: Swift.String?
        /// The name of a room profile.
        public var profileName: Swift.String?
        /// The PSTN setting of a room profile.
        public var pstnEnabled: Swift.Bool?
        /// The setup mode of a room profile.
        public var setupModeDisabled: Swift.Bool?
        /// The temperature unit of a room profile.
        public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
        /// The time zone of a room profile.
        public var timezone: Swift.String?
        /// The wake word of a room profile.
        public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

        public init(
            address: Swift.String? = nil,
            addressBookArn: Swift.String? = nil,
            dataRetentionOptIn: Swift.Bool? = nil,
            distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
            isDefault: Swift.Bool? = nil,
            locale: Swift.String? = nil,
            maxVolumeLimit: Swift.Int? = nil,
            meetingRoomConfiguration: AlexaForBusinessClientTypes.MeetingRoomConfiguration? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            pstnEnabled: Swift.Bool? = nil,
            setupModeDisabled: Swift.Bool? = nil,
            temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
            timezone: Swift.String? = nil,
            wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
        )
        {
            self.address = address
            self.addressBookArn = addressBookArn
            self.dataRetentionOptIn = dataRetentionOptIn
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.maxVolumeLimit = maxVolumeLimit
            self.meetingRoomConfiguration = meetingRoomConfiguration
            self.profileArn = profileArn
            self.profileName = profileName
            self.pstnEnabled = pstnEnabled
            self.setupModeDisabled = setupModeDisabled
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }
    }

}

extension AlexaForBusinessClientTypes.ProfileData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = self.isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let temperatureUnit = self.temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = self.wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The data of a room profile.
    public struct ProfileData: Swift.Equatable {
        /// The address of a room profile.
        public var address: Swift.String?
        /// The distance unit of a room profile.
        public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
        /// Retrieves if the profile data is default or not.
        public var isDefault: Swift.Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public var locale: Swift.String?
        /// The ARN of a room profile.
        public var profileArn: Swift.String?
        /// The name of a room profile.
        public var profileName: Swift.String?
        /// The temperature unit of a room profile.
        public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
        /// The time zone of a room profile.
        public var timezone: Swift.String?
        /// The wake word of a room profile.
        public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

        public init(
            address: Swift.String? = nil,
            distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
            isDefault: Swift.Bool? = nil,
            locale: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
            timezone: Swift.String? = nil,
            wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
        )
        {
            self.address = address
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.profileArn = profileArn
            self.profileName = profileName
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }
    }

}

extension PutConferencePreferenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferencePreference = "ConferencePreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferencePreference = self.conferencePreference {
            try encodeContainer.encode(conferencePreference, forKey: .conferencePreference)
        }
    }
}

extension PutConferencePreferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutConferencePreferenceInput: Swift.Equatable {
    /// The conference preference of a specific conference provider.
    /// This member is required.
    public var conferencePreference: AlexaForBusinessClientTypes.ConferencePreference?

    public init(
        conferencePreference: AlexaForBusinessClientTypes.ConferencePreference? = nil
    )
    {
        self.conferencePreference = conferencePreference
    }
}

struct PutConferencePreferenceInputBody: Swift.Equatable {
    let conferencePreference: AlexaForBusinessClientTypes.ConferencePreference?
}

extension PutConferencePreferenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferencePreference = "ConferencePreference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferencePreferenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferencePreference.self, forKey: .conferencePreference)
        conferencePreference = conferencePreferenceDecoded
    }
}

extension PutConferencePreferenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutConferencePreferenceOutput: Swift.Equatable {

    public init() { }
}

enum PutConferencePreferenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutInvitationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactEmail = self.contactEmail {
            try encodeContainer.encode(contactEmail, forKey: .contactEmail)
        }
        if let organizationName = self.organizationName {
            try encodeContainer.encode(organizationName, forKey: .organizationName)
        }
        if let privateSkillIds = privateSkillIds {
            var privateSkillIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateSkillIds)
            for skillid0 in privateSkillIds {
                try privateSkillIdsContainer.encode(skillid0)
            }
        }
    }
}

extension PutInvitationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInvitationConfigurationInput: Swift.Equatable {
    /// The email ID of the organization or individual contact that the enrolled user can use.
    public var contactEmail: Swift.String?
    /// The name of the organization sending the enrollment invite to a user.
    /// This member is required.
    public var organizationName: Swift.String?
    /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
    public var privateSkillIds: [Swift.String]?

    public init(
        contactEmail: Swift.String? = nil,
        organizationName: Swift.String? = nil,
        privateSkillIds: [Swift.String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

struct PutInvitationConfigurationInputBody: Swift.Equatable {
    let organizationName: Swift.String?
    let contactEmail: Swift.String?
    let privateSkillIds: [Swift.String]?
}

extension PutInvitationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let contactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactEmail)
        contactEmail = contactEmailDecoded
        let privateSkillIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .privateSkillIds)
        var privateSkillIdsDecoded0:[Swift.String]? = nil
        if let privateSkillIdsContainer = privateSkillIdsContainer {
            privateSkillIdsDecoded0 = [Swift.String]()
            for string0 in privateSkillIdsContainer {
                if let string0 = string0 {
                    privateSkillIdsDecoded0?.append(string0)
                }
            }
        }
        privateSkillIds = privateSkillIdsDecoded0
    }
}

extension PutInvitationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutInvitationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutInvitationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRoomSkillParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case roomSkillParameter = "RoomSkillParameter"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomSkillParameter = self.roomSkillParameter {
            try encodeContainer.encode(roomSkillParameter, forKey: .roomSkillParameter)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension PutRoomSkillParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRoomSkillParameterInput: Swift.Equatable {
    /// The ARN of the room associated with the room skill parameter. Required.
    public var roomArn: Swift.String?
    /// The updated room skill parameter. Required.
    /// This member is required.
    public var roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?
    /// The ARN of the skill associated with the room skill parameter. Required.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.roomSkillParameter = roomSkillParameter
        self.skillId = skillId
    }
}

struct PutRoomSkillParameterInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let skillId: Swift.String?
    let roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?
}

extension PutRoomSkillParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case roomSkillParameter = "RoomSkillParameter"
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomSkillParameterDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RoomSkillParameter.self, forKey: .roomSkillParameter)
        roomSkillParameter = roomSkillParameterDecoded
    }
}

extension PutRoomSkillParameterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutRoomSkillParameterOutput: Swift.Equatable {

    public init() { }
}

enum PutRoomSkillParameterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutSkillAuthorizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSkillAuthorizationInput(roomArn: \(Swift.String(describing: roomArn)), skillId: \(Swift.String(describing: skillId)), authorizationResult: \"CONTENT_REDACTED\")"}
}

extension PutSkillAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationResult = "AuthorizationResult"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationResult = authorizationResult {
            var authorizationResultContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .authorizationResult)
            for (dictKey0, authorizationResult0) in authorizationResult {
                try authorizationResultContainer.encode(authorizationResult0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension PutSkillAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutSkillAuthorizationInput: Swift.Equatable {
    /// The authorization result specific to OAUTH code grant output. "Code must be populated in the AuthorizationResult map to establish the authorization.
    /// This member is required.
    public var authorizationResult: [Swift.String:Swift.String]?
    /// The room that the skill is authorized for.
    public var roomArn: Swift.String?
    /// The unique identifier of a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        authorizationResult: [Swift.String:Swift.String]? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.authorizationResult = authorizationResult
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct PutSkillAuthorizationInputBody: Swift.Equatable {
    let authorizationResult: [Swift.String:Swift.String]?
    let skillId: Swift.String?
    let roomArn: Swift.String?
}

extension PutSkillAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationResult = "AuthorizationResult"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationResultContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .authorizationResult)
        var authorizationResultDecoded0: [Swift.String:Swift.String]? = nil
        if let authorizationResultContainer = authorizationResultContainer {
            authorizationResultDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in authorizationResultContainer {
                if let value0 = value0 {
                    authorizationResultDecoded0?[key0] = value0
                }
            }
        }
        authorizationResult = authorizationResultDecoded0
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension PutSkillAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutSkillAuthorizationOutput: Swift.Equatable {

    public init() { }
}

enum PutSkillAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterAVSDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case clientId = "ClientId"
        case deviceSerialNumber = "DeviceSerialNumber"
        case productId = "ProductId"
        case roomArn = "RoomArn"
        case tags = "Tags"
        case userCode = "UserCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = self.amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let deviceSerialNumber = self.deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userCode = self.userCode {
            try encodeContainer.encode(userCode, forKey: .userCode)
        }
    }
}

extension RegisterAVSDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterAVSDeviceInput: Swift.Equatable {
    /// The device type ID for your AVS device generated by Amazon when the OEM creates a new product on Amazon's Developer Console.
    /// This member is required.
    public var amazonId: Swift.String?
    /// The client ID of the OEM used for code-based linking authorization on an AVS device.
    /// This member is required.
    public var clientId: Swift.String?
    /// The key generated by the OEM that uniquely identifies a specified instance of your AVS device.
    public var deviceSerialNumber: Swift.String?
    /// The product ID used to identify your AVS device during authorization.
    /// This member is required.
    public var productId: Swift.String?
    /// The Amazon Resource Name (ARN) of the room with which to associate your AVS device.
    public var roomArn: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The code that is obtained after your AVS device has made a POST request to LWA as a part of the Device Authorization Request component of the OAuth code-based linking specification.
    /// This member is required.
    public var userCode: Swift.String?

    public init(
        amazonId: Swift.String? = nil,
        clientId: Swift.String? = nil,
        deviceSerialNumber: Swift.String? = nil,
        productId: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        userCode: Swift.String? = nil
    )
    {
        self.amazonId = amazonId
        self.clientId = clientId
        self.deviceSerialNumber = deviceSerialNumber
        self.productId = productId
        self.roomArn = roomArn
        self.tags = tags
        self.userCode = userCode
    }
}

struct RegisterAVSDeviceInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let userCode: Swift.String?
    let productId: Swift.String?
    let deviceSerialNumber: Swift.String?
    let amazonId: Swift.String?
    let roomArn: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension RegisterAVSDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case clientId = "ClientId"
        case deviceSerialNumber = "DeviceSerialNumber"
        case productId = "ProductId"
        case roomArn = "RoomArn"
        case tags = "Tags"
        case userCode = "UserCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterAVSDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterAVSDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceArn = output.deviceArn
        } else {
            self.deviceArn = nil
        }
    }
}

public struct RegisterAVSDeviceOutput: Swift.Equatable {
    /// The ARN of the device.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct RegisterAVSDeviceOutputBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension RegisterAVSDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

enum RegisterAVSDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidDeviceException": return try await InvalidDeviceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RejectSkillInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension RejectSkillInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RejectSkillInput: Swift.Equatable {
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct RejectSkillInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension RejectSkillInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension RejectSkillOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RejectSkillOutput: Swift.Equatable {

    public init() { }
}

enum RejectSkillOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.RequireCheckIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = self.releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct RequireCheckIn: Swift.Equatable {
        /// Whether require check in is enabled or not.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public var releaseAfterMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum RequirePin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case `optional`
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [RequirePin] {
            return [
                .no,
                .optional,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .optional: return "OPTIONAL"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequirePin(rawValue: rawValue) ?? RequirePin.sdkUnknown(rawValue)
        }
    }
}

extension ResolveRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension ResolveRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResolveRoomInput: Swift.Equatable {
    /// The ARN of the skill that was requested. Required.
    /// This member is required.
    public var skillId: Swift.String?
    /// The ARN of the user. Required.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        skillId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.skillId = skillId
        self.userId = userId
    }
}

struct ResolveRoomInputBody: Swift.Equatable {
    let userId: Swift.String?
    let skillId: Swift.String?
}

extension ResolveRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension ResolveRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResolveRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.roomArn = output.roomArn
            self.roomName = output.roomName
            self.roomSkillParameters = output.roomSkillParameters
        } else {
            self.roomArn = nil
            self.roomName = nil
            self.roomSkillParameters = nil
        }
    }
}

public struct ResolveRoomOutput: Swift.Equatable {
    /// The ARN of the room from which the skill request was invoked.
    public var roomArn: Swift.String?
    /// The name of the room from which the skill request was invoked.
    public var roomName: Swift.String?
    /// Response to get the room profile request. Required.
    public var roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]?

    public init(
        roomArn: Swift.String? = nil,
        roomName: Swift.String? = nil,
        roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]? = nil
    )
    {
        self.roomArn = roomArn
        self.roomName = roomName
        self.roomSkillParameters = roomSkillParameters
    }
}

struct ResolveRoomOutputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let roomName: Swift.String?
    let roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]?
}

extension ResolveRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case roomName = "RoomName"
        case roomSkillParameters = "RoomSkillParameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let roomSkillParametersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.RoomSkillParameter?].self, forKey: .roomSkillParameters)
        var roomSkillParametersDecoded0:[AlexaForBusinessClientTypes.RoomSkillParameter]? = nil
        if let roomSkillParametersContainer = roomSkillParametersContainer {
            roomSkillParametersDecoded0 = [AlexaForBusinessClientTypes.RoomSkillParameter]()
            for structure0 in roomSkillParametersContainer {
                if let structure0 = structure0 {
                    roomSkillParametersDecoded0?.append(structure0)
                }
            }
        }
        roomSkillParameters = roomSkillParametersDecoded0
    }
}

enum ResolveRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceAssociatedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Another resource is associated with the resource in the request.
public struct ResourceAssociatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAssociatedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAssociatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.clientRequestToken = output.clientRequestToken
            self.properties.message = output.message
        } else {
            self.properties.clientRequestToken = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource in the request is already in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A unique, user-specified identifier for the request that ensures idempotency.
        public internal(set) var clientRequestToken: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.clientRequestToken = clientRequestToken
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let clientRequestToken: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension RevokeInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enrollmentId = self.enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension RevokeInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RevokeInvitationInput: Swift.Equatable {
    /// The ARN of the enrollment invitation to revoke. Required.
    public var enrollmentId: Swift.String?
    /// The ARN of the user for whom to revoke an enrollment invitation. Required.
    public var userArn: Swift.String?

    public init(
        enrollmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

struct RevokeInvitationInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let enrollmentId: Swift.String?
}

extension RevokeInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension RevokeInvitationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RevokeInvitationOutput: Swift.Equatable {

    public init() { }
}

enum RevokeInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.Room: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = self.providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = self.roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A room with attributes.
    public struct Room: Swift.Equatable {
        /// The description of a room.
        public var description: Swift.String?
        /// The profile ARN of a room.
        public var profileArn: Swift.String?
        /// The provider calendar ARN of a room.
        public var providerCalendarId: Swift.String?
        /// The ARN of a room.
        public var roomArn: Swift.String?
        /// The name of a room.
        public var roomName: Swift.String?

        public init(
            description: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            providerCalendarId: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil
        )
        {
            self.description = description
            self.profileArn = profileArn
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }
    }

}

extension AlexaForBusinessClientTypes.RoomData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let providerCalendarId = self.providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = self.roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The data of a room.
    public struct RoomData: Swift.Equatable {
        /// The description of a room.
        public var description: Swift.String?
        /// The profile ARN of a room.
        public var profileArn: Swift.String?
        /// The profile name of a room.
        public var profileName: Swift.String?
        /// The provider calendar ARN of a room.
        public var providerCalendarId: Swift.String?
        /// The ARN of a room.
        public var roomArn: Swift.String?
        /// The name of a room.
        public var roomName: Swift.String?

        public init(
            description: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            providerCalendarId: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil
        )
        {
            self.description = description
            self.profileArn = profileArn
            self.profileName = profileName
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }
    }

}

extension AlexaForBusinessClientTypes.RoomSkillParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = self.parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterValue = self.parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A skill parameter associated with a room.
    public struct RoomSkillParameter: Swift.Equatable {
        /// The parameter key of a room skill parameter. ParameterKey is an enumerated type that only takes DEFAULT or SCOPE as valid values.
        /// This member is required.
        public var parameterKey: Swift.String?
        /// The parameter value of a room skill parameter.
        /// This member is required.
        public var parameterValue: Swift.String?

        public init(
            parameterKey: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }
    }

}

extension SearchAddressBooksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchAddressBooksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchAddressBooksInput: Swift.Equatable {
    /// The filters to use to list a specified set of address books. The supported filter key is AddressBookName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of address books. The supported sort key is AddressBookName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchAddressBooksInputBody: Swift.Equatable {
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchAddressBooksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchAddressBooksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchAddressBooksOutputBody = try responseDecoder.decode(responseBody: data)
            self.addressBooks = output.addressBooks
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.addressBooks = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchAddressBooksOutput: Swift.Equatable {
    /// The address books that meet the specified set of filter criteria, in sort order.
    public var addressBooks: [AlexaForBusinessClientTypes.AddressBookData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of address books returned.
    public var totalCount: Swift.Int?

    public init(
        addressBooks: [AlexaForBusinessClientTypes.AddressBookData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.addressBooks = addressBooks
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchAddressBooksOutputBody: Swift.Equatable {
    let addressBooks: [AlexaForBusinessClientTypes.AddressBookData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchAddressBooksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBooks = "AddressBooks"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBooksContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.AddressBookData?].self, forKey: .addressBooks)
        var addressBooksDecoded0:[AlexaForBusinessClientTypes.AddressBookData]? = nil
        if let addressBooksContainer = addressBooksContainer {
            addressBooksDecoded0 = [AlexaForBusinessClientTypes.AddressBookData]()
            for structure0 in addressBooksContainer {
                if let structure0 = structure0 {
                    addressBooksDecoded0?.append(structure0)
                }
            }
        }
        addressBooks = addressBooksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchAddressBooksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchContactsInput: Swift.Equatable {
    /// The filters to use to list a specified set of address books. The supported filter keys are DisplayName, FirstName, LastName, and AddressBookArns.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of contacts. The supported sort keys are DisplayName, FirstName, and LastName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchContactsInputBody: Swift.Equatable {
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchContactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchContactsOutputBody = try responseDecoder.decode(responseBody: data)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.contacts = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchContactsOutput: Swift.Equatable {
    /// The contacts that meet the specified set of filter criteria, in sort order.
    public var contacts: [AlexaForBusinessClientTypes.ContactData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of contacts returned.
    public var totalCount: Swift.Int?

    public init(
        contacts: [AlexaForBusinessClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchContactsOutputBody: Swift.Equatable {
    let contacts: [AlexaForBusinessClientTypes.ContactData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchContactsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.ContactData?].self, forKey: .contacts)
        var contactsDecoded0:[AlexaForBusinessClientTypes.ContactData]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [AlexaForBusinessClientTypes.ContactData]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchContactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchDevicesInput: Swift.Equatable {
    /// The filters to use to list a specified set of devices. Supported filter keys are DeviceName, DeviceStatus, DeviceStatusDetailCode, RoomName, DeviceType, DeviceSerialNumber, UnassociatedOnly, ConnectionStatus (ONLINE and OFFLINE), NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of devices. Supported sort keys are DeviceName, DeviceStatus, RoomName, DeviceType, DeviceSerialNumber, ConnectionStatus, NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchDevicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.devices = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchDevicesOutput: Swift.Equatable {
    /// The devices that meet the specified set of filter criteria, in sort order.
    public var devices: [AlexaForBusinessClientTypes.DeviceData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of devices returned.
    public var totalCount: Swift.Int?

    public init(
        devices: [AlexaForBusinessClientTypes.DeviceData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchDevicesOutputBody: Swift.Equatable {
    let devices: [AlexaForBusinessClientTypes.DeviceData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.DeviceData?].self, forKey: .devices)
        var devicesDecoded0:[AlexaForBusinessClientTypes.DeviceData]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [AlexaForBusinessClientTypes.DeviceData]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchNetworkProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchNetworkProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchNetworkProfilesInput: Swift.Equatable {
    /// The filters to use to list a specified set of network profiles. Valid filters are NetworkProfileName, Ssid, and SecurityType.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use to list the specified set of network profiles. Valid sort criteria includes NetworkProfileName, Ssid, and SecurityType.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchNetworkProfilesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchNetworkProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchNetworkProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchNetworkProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkProfiles = output.networkProfiles
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.networkProfiles = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchNetworkProfilesOutput: Swift.Equatable {
    /// The network profiles that meet the specified set of filter criteria, in sort order. It is a list of NetworkProfileData objects.
    public var networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The total number of network profiles returned.
    public var totalCount: Swift.Int?

    public init(
        networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchNetworkProfilesOutputBody: Swift.Equatable {
    let networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchNetworkProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfiles = "NetworkProfiles"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfilesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.NetworkProfileData?].self, forKey: .networkProfiles)
        var networkProfilesDecoded0:[AlexaForBusinessClientTypes.NetworkProfileData]? = nil
        if let networkProfilesContainer = networkProfilesContainer {
            networkProfilesDecoded0 = [AlexaForBusinessClientTypes.NetworkProfileData]()
            for structure0 in networkProfilesContainer {
                if let structure0 = structure0 {
                    networkProfilesDecoded0?.append(structure0)
                }
            }
        }
        networkProfiles = networkProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchNetworkProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchProfilesInput: Swift.Equatable {
    /// The filters to use to list a specified set of room profiles. Supported filter keys are ProfileName and Address. Required.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of room profiles. Supported sort keys are ProfileName and Address.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchProfilesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.profiles = nil
            self.totalCount = nil
        }
    }
}

public struct SearchProfilesOutput: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The profiles that meet the specified set of filter criteria, in sort order.
    public var profiles: [AlexaForBusinessClientTypes.ProfileData]?
    /// The total number of room profiles returned.
    public var totalCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [AlexaForBusinessClientTypes.ProfileData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
        self.totalCount = totalCount
    }
}

struct SearchProfilesOutputBody: Swift.Equatable {
    let profiles: [AlexaForBusinessClientTypes.ProfileData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case profiles = "Profiles"
        case totalCount = "TotalCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.ProfileData?].self, forKey: .profiles)
        var profilesDecoded0:[AlexaForBusinessClientTypes.ProfileData]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [AlexaForBusinessClientTypes.ProfileData]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchRoomsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchRoomsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchRoomsInput: Swift.Equatable {
    /// The filters to use to list a specified set of rooms. The supported filter keys are RoomName and ProfileName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of rooms. The supported sort keys are RoomName and ProfileName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchRoomsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchRoomsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchRoomsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchRoomsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.rooms = nil
            self.totalCount = nil
        }
    }
}

public struct SearchRoomsOutput: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The rooms that meet the specified set of filter criteria, in sort order.
    public var rooms: [AlexaForBusinessClientTypes.RoomData]?
    /// The total number of rooms returned.
    public var totalCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        rooms: [AlexaForBusinessClientTypes.RoomData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
        self.totalCount = totalCount
    }
}

struct SearchRoomsOutputBody: Swift.Equatable {
    let rooms: [AlexaForBusinessClientTypes.RoomData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchRoomsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rooms = "Rooms"
        case totalCount = "TotalCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.RoomData?].self, forKey: .rooms)
        var roomsDecoded0:[AlexaForBusinessClientTypes.RoomData]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [AlexaForBusinessClientTypes.RoomData]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchRoomsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchSkillGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchSkillGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchSkillGroupsInput: Swift.Equatable {
    /// The filters to use to list a specified set of skill groups. The supported filter key is SkillGroupName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of skill groups. The supported sort key is SkillGroupName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchSkillGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchSkillGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchSkillGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchSkillGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.skillGroups = output.skillGroups
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.skillGroups = nil
            self.totalCount = nil
        }
    }
}

public struct SearchSkillGroupsOutput: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The skill groups that meet the filter criteria, in sort order.
    public var skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]?
    /// The total number of skill groups returned.
    public var totalCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.skillGroups = skillGroups
        self.totalCount = totalCount
    }
}

struct SearchSkillGroupsOutputBody: Swift.Equatable {
    let skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchSkillGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case skillGroups = "SkillGroups"
        case totalCount = "TotalCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SkillGroupData?].self, forKey: .skillGroups)
        var skillGroupsDecoded0:[AlexaForBusinessClientTypes.SkillGroupData]? = nil
        if let skillGroupsContainer = skillGroupsContainer {
            skillGroupsDecoded0 = [AlexaForBusinessClientTypes.SkillGroupData]()
            for structure0 in skillGroupsContainer {
                if let structure0 = structure0 {
                    skillGroupsDecoded0?.append(structure0)
                }
            }
        }
        skillGroups = skillGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchSkillGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sort0 in sortCriteria {
                try sortCriteriaContainer.encode(sort0)
            }
        }
    }
}

extension SearchUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchUsersInput: Swift.Equatable {
    /// The filters to use for listing a specific set of users. Required. Supported filter keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. Required.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the filtered set of users. Required. Supported sort keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchUsersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
            self.users = output.users
        } else {
            self.nextToken = nil
            self.totalCount = nil
            self.users = nil
        }
    }
}

public struct SearchUsersOutput: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of users returned.
    public var totalCount: Swift.Int?
    /// The users that meet the specified set of filter criteria, in sort order.
    public var users: [AlexaForBusinessClientTypes.UserData]?

    public init(
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil,
        users: [AlexaForBusinessClientTypes.UserData]? = nil
    )
    {
        self.nextToken = nextToken
        self.totalCount = totalCount
        self.users = users
    }
}

struct SearchUsersOutputBody: Swift.Equatable {
    let users: [AlexaForBusinessClientTypes.UserData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.UserData?].self, forKey: .users)
        var usersDecoded0:[AlexaForBusinessClientTypes.UserData]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [AlexaForBusinessClientTypes.UserData]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

enum SearchUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendAnnouncementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case roomFilters = "RoomFilters"
        case timeToLiveInSeconds = "TimeToLiveInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let roomFilters = roomFilters {
            var roomFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roomFilters)
            for filter0 in roomFilters {
                try roomFiltersContainer.encode(filter0)
            }
        }
        if let timeToLiveInSeconds = self.timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
    }
}

extension SendAnnouncementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendAnnouncementInput: Swift.Equatable {
    /// The unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The announcement content. This can contain only one of the three possible announcement types (text, SSML or audio).
    /// This member is required.
    public var content: AlexaForBusinessClientTypes.Content?
    /// The filters to use to send an announcement to a specified list of rooms. The supported filter keys are RoomName, ProfileName, RoomArn, and ProfileArn. To send to all rooms, specify an empty RoomFilters list.
    /// This member is required.
    public var roomFilters: [AlexaForBusinessClientTypes.Filter]?
    /// The time to live for an announcement. Default is 300. If delivery doesn't occur within this time, the announcement is not delivered.
    public var timeToLiveInSeconds: Swift.Int?

    public init(
        clientRequestToken: Swift.String? = nil,
        content: AlexaForBusinessClientTypes.Content? = nil,
        roomFilters: [AlexaForBusinessClientTypes.Filter]? = nil,
        timeToLiveInSeconds: Swift.Int? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.roomFilters = roomFilters
        self.timeToLiveInSeconds = timeToLiveInSeconds
    }
}

struct SendAnnouncementInputBody: Swift.Equatable {
    let roomFilters: [AlexaForBusinessClientTypes.Filter]?
    let content: AlexaForBusinessClientTypes.Content?
    let timeToLiveInSeconds: Swift.Int?
    let clientRequestToken: Swift.String?
}

extension SendAnnouncementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case roomFilters = "RoomFilters"
        case timeToLiveInSeconds = "TimeToLiveInSeconds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomFiltersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .roomFilters)
        var roomFiltersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let roomFiltersContainer = roomFiltersContainer {
            roomFiltersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in roomFiltersContainer {
                if let structure0 = structure0 {
                    roomFiltersDecoded0?.append(structure0)
                }
            }
        }
        roomFilters = roomFiltersDecoded0
        let contentDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Content.self, forKey: .content)
        content = contentDecoded
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SendAnnouncementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendAnnouncementOutputBody = try responseDecoder.decode(responseBody: data)
            self.announcementArn = output.announcementArn
        } else {
            self.announcementArn = nil
        }
    }
}

public struct SendAnnouncementOutput: Swift.Equatable {
    /// The identifier of the announcement.
    public var announcementArn: Swift.String?

    public init(
        announcementArn: Swift.String? = nil
    )
    {
        self.announcementArn = announcementArn
    }
}

struct SendAnnouncementOutputBody: Swift.Equatable {
    let announcementArn: Swift.String?
}

extension SendAnnouncementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case announcementArn = "AnnouncementArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let announcementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .announcementArn)
        announcementArn = announcementArnDecoded
    }
}

enum SendAnnouncementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyExistsException": return try await AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension SendInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendInvitationInput: Swift.Equatable {
    /// The ARN of the user to whom to send an invitation. Required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct SendInvitationInputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension SendInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension SendInvitationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SendInvitationOutput: Swift.Equatable {

    public init() { }
}

enum SendInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidUserStatusException": return try await InvalidUserStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.SipAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AlexaForBusinessClientTypes.SipAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipAddress(type: \"CONTENT_REDACTED\", uri: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes {
    /// The SIP address for the contact containing the URI and SIP address type.
    public struct SipAddress: Swift.Equatable {
        /// The type of the SIP address.
        /// This member is required.
        public var type: AlexaForBusinessClientTypes.SipType?
        /// The URI for the SIP address.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            type: AlexaForBusinessClientTypes.SipType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.type = type
            self.uri = uri
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum SipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [SipType] {
            return [
                .work,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .work: return "WORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SipType(rawValue: rawValue) ?? SipType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.SkillDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulletPoints = "BulletPoints"
        case developerInfo = "DeveloperInfo"
        case endUserLicenseAgreement = "EndUserLicenseAgreement"
        case genericKeywords = "GenericKeywords"
        case invocationPhrase = "InvocationPhrase"
        case newInThisVersionBulletPoints = "NewInThisVersionBulletPoints"
        case productDescription = "ProductDescription"
        case releaseDate = "ReleaseDate"
        case reviews = "Reviews"
        case skillTypes = "SkillTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bulletPoints = bulletPoints {
            var bulletPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bulletPoints)
            for bulletpoint0 in bulletPoints {
                try bulletPointsContainer.encode(bulletpoint0)
            }
        }
        if let developerInfo = self.developerInfo {
            try encodeContainer.encode(developerInfo, forKey: .developerInfo)
        }
        if let endUserLicenseAgreement = self.endUserLicenseAgreement {
            try encodeContainer.encode(endUserLicenseAgreement, forKey: .endUserLicenseAgreement)
        }
        if let genericKeywords = genericKeywords {
            var genericKeywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .genericKeywords)
            for generickeyword0 in genericKeywords {
                try genericKeywordsContainer.encode(generickeyword0)
            }
        }
        if let invocationPhrase = self.invocationPhrase {
            try encodeContainer.encode(invocationPhrase, forKey: .invocationPhrase)
        }
        if let newInThisVersionBulletPoints = newInThisVersionBulletPoints {
            var newInThisVersionBulletPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .newInThisVersionBulletPoints)
            for bulletpoint0 in newInThisVersionBulletPoints {
                try newInThisVersionBulletPointsContainer.encode(bulletpoint0)
            }
        }
        if let productDescription = self.productDescription {
            try encodeContainer.encode(productDescription, forKey: .productDescription)
        }
        if let releaseDate = self.releaseDate {
            try encodeContainer.encode(releaseDate, forKey: .releaseDate)
        }
        if let reviews = reviews {
            var reviewsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reviews)
            for (dictKey0, reviews0) in reviews {
                try reviewsContainer.encode(reviews0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let skillTypes = skillTypes {
            var skillTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skillTypes)
            for skillstoretype0 in skillTypes {
                try skillTypesContainer.encode(skillstoretype0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let invocationPhraseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationPhrase)
        invocationPhrase = invocationPhraseDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let endUserLicenseAgreementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endUserLicenseAgreement)
        endUserLicenseAgreement = endUserLicenseAgreementDecoded
        let genericKeywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .genericKeywords)
        var genericKeywordsDecoded0:[Swift.String]? = nil
        if let genericKeywordsContainer = genericKeywordsContainer {
            genericKeywordsDecoded0 = [Swift.String]()
            for string0 in genericKeywordsContainer {
                if let string0 = string0 {
                    genericKeywordsDecoded0?.append(string0)
                }
            }
        }
        genericKeywords = genericKeywordsDecoded0
        let bulletPointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bulletPoints)
        var bulletPointsDecoded0:[Swift.String]? = nil
        if let bulletPointsContainer = bulletPointsContainer {
            bulletPointsDecoded0 = [Swift.String]()
            for string0 in bulletPointsContainer {
                if let string0 = string0 {
                    bulletPointsDecoded0?.append(string0)
                }
            }
        }
        bulletPoints = bulletPointsDecoded0
        let newInThisVersionBulletPointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .newInThisVersionBulletPoints)
        var newInThisVersionBulletPointsDecoded0:[Swift.String]? = nil
        if let newInThisVersionBulletPointsContainer = newInThisVersionBulletPointsContainer {
            newInThisVersionBulletPointsDecoded0 = [Swift.String]()
            for string0 in newInThisVersionBulletPointsContainer {
                if let string0 = string0 {
                    newInThisVersionBulletPointsDecoded0?.append(string0)
                }
            }
        }
        newInThisVersionBulletPoints = newInThisVersionBulletPointsDecoded0
        let skillTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .skillTypes)
        var skillTypesDecoded0:[Swift.String]? = nil
        if let skillTypesContainer = skillTypesContainer {
            skillTypesDecoded0 = [Swift.String]()
            for string0 in skillTypesContainer {
                if let string0 = string0 {
                    skillTypesDecoded0?.append(string0)
                }
            }
        }
        skillTypes = skillTypesDecoded0
        let reviewsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .reviews)
        var reviewsDecoded0: [Swift.String:Swift.String]? = nil
        if let reviewsContainer = reviewsContainer {
            reviewsDecoded0 = [Swift.String:Swift.String]()
            for (key0, reviewvalue0) in reviewsContainer {
                if let reviewvalue0 = reviewvalue0 {
                    reviewsDecoded0?[key0] = reviewvalue0
                }
            }
        }
        reviews = reviewsDecoded0
        let developerInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeveloperInfo.self, forKey: .developerInfo)
        developerInfo = developerInfoDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Granular information about the skill.
    public struct SkillDetails: Swift.Equatable {
        /// The details about what the skill supports organized as bullet points.
        public var bulletPoints: [Swift.String]?
        /// The details about the developer that published the skill.
        public var developerInfo: AlexaForBusinessClientTypes.DeveloperInfo?
        /// The URL of the end user license agreement.
        public var endUserLicenseAgreement: Swift.String?
        /// The generic keywords associated with the skill that can be used to find a skill.
        public var genericKeywords: [Swift.String]?
        /// The phrase used to trigger the skill.
        public var invocationPhrase: Swift.String?
        /// The updates added in bullet points.
        public var newInThisVersionBulletPoints: [Swift.String]?
        /// The description of the product.
        public var productDescription: Swift.String?
        /// The date when the skill was released.
        public var releaseDate: Swift.String?
        /// This member has been deprecated. The list of reviews for the skill, including Key and Value pair.
        public var reviews: [Swift.String:Swift.String]?
        /// The types of skills.
        public var skillTypes: [Swift.String]?

        public init(
            bulletPoints: [Swift.String]? = nil,
            developerInfo: AlexaForBusinessClientTypes.DeveloperInfo? = nil,
            endUserLicenseAgreement: Swift.String? = nil,
            genericKeywords: [Swift.String]? = nil,
            invocationPhrase: Swift.String? = nil,
            newInThisVersionBulletPoints: [Swift.String]? = nil,
            productDescription: Swift.String? = nil,
            releaseDate: Swift.String? = nil,
            reviews: [Swift.String:Swift.String]? = nil,
            skillTypes: [Swift.String]? = nil
        )
        {
            self.bulletPoints = bulletPoints
            self.developerInfo = developerInfo
            self.endUserLicenseAgreement = endUserLicenseAgreement
            self.genericKeywords = genericKeywords
            self.invocationPhrase = invocationPhrase
            self.newInThisVersionBulletPoints = newInThisVersionBulletPoints
            self.productDescription = productDescription
            self.releaseDate = releaseDate
            self.reviews = reviews
            self.skillTypes = skillTypes
        }
    }

}

extension AlexaForBusinessClientTypes.SkillGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = self.skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A skill group with attributes.
    public struct SkillGroup: Swift.Equatable {
        /// The description of a skill group.
        public var description: Swift.String?
        /// The ARN of a skill group.
        public var skillGroupArn: Swift.String?
        /// The name of a skill group.
        public var skillGroupName: Swift.String?

        public init(
            description: Swift.String? = nil,
            skillGroupArn: Swift.String? = nil,
            skillGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }
    }

}

extension AlexaForBusinessClientTypes.SkillGroupData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = self.skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The attributes of a skill group.
    public struct SkillGroupData: Swift.Equatable {
        /// The description of a skill group.
        public var description: Swift.String?
        /// The skill group ARN of a skill group.
        public var skillGroupArn: Swift.String?
        /// The skill group name of a skill group.
        public var skillGroupName: Swift.String?

        public init(
            description: Swift.String? = nil,
            skillGroupArn: Swift.String? = nil,
            skillGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }
    }

}

extension SkillNotLinkedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SkillNotLinkedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The skill must be linked to a third-party account.
public struct SkillNotLinkedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SkillNotLinkedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SkillNotLinkedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SkillNotLinkedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes.SkillSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enablementType = "EnablementType"
        case skillId = "SkillId"
        case skillName = "SkillName"
        case skillType = "SkillType"
        case supportsLinking = "SupportsLinking"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enablementType = self.enablementType {
            try encodeContainer.encode(enablementType.rawValue, forKey: .enablementType)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let skillName = self.skillName {
            try encodeContainer.encode(skillName, forKey: .skillName)
        }
        if let skillType = self.skillType {
            try encodeContainer.encode(skillType.rawValue, forKey: .skillType)
        }
        if supportsLinking != false {
            try encodeContainer.encode(supportsLinking, forKey: .supportsLinking)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let skillNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillName)
        skillName = skillNameDecoded
        let supportsLinkingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsLinking) ?? false
        supportsLinking = supportsLinkingDecoded
        let enablementTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EnablementType.self, forKey: .enablementType)
        enablementType = enablementTypeDecoded
        let skillTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillType.self, forKey: .skillType)
        skillType = skillTypeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of skills.
    public struct SkillSummary: Swift.Equatable {
        /// Whether the skill is enabled under the user's account, or if it requires linking to be used.
        public var enablementType: AlexaForBusinessClientTypes.EnablementType?
        /// The ARN of the skill summary.
        public var skillId: Swift.String?
        /// The name of the skill.
        public var skillName: Swift.String?
        /// Whether the skill is publicly available or is a private skill.
        public var skillType: AlexaForBusinessClientTypes.SkillType?
        /// Linking support for a skill.
        public var supportsLinking: Swift.Bool

        public init(
            enablementType: AlexaForBusinessClientTypes.EnablementType? = nil,
            skillId: Swift.String? = nil,
            skillName: Swift.String? = nil,
            skillType: AlexaForBusinessClientTypes.SkillType? = nil,
            supportsLinking: Swift.Bool = false
        )
        {
            self.enablementType = enablementType
            self.skillId = skillId
            self.skillName = skillName
            self.skillType = skillType
            self.supportsLinking = supportsLinking
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum SkillType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SkillType] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SkillType(rawValue: rawValue) ?? SkillType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum SkillTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SkillTypeFilter] {
            return [
                .all,
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SkillTypeFilter(rawValue: rawValue) ?? SkillTypeFilter.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.SkillsStoreSkill: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iconUrl = "IconUrl"
        case sampleUtterances = "SampleUtterances"
        case shortDescription = "ShortDescription"
        case skillDetails = "SkillDetails"
        case skillId = "SkillId"
        case skillName = "SkillName"
        case supportsLinking = "SupportsLinking"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iconUrl = self.iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for utterance0 in sampleUtterances {
                try sampleUtterancesContainer.encode(utterance0)
            }
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let skillDetails = self.skillDetails {
            try encodeContainer.encode(skillDetails, forKey: .skillDetails)
        }
        if let skillId = self.skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let skillName = self.skillName {
            try encodeContainer.encode(skillName, forKey: .skillName)
        }
        if supportsLinking != false {
            try encodeContainer.encode(supportsLinking, forKey: .supportsLinking)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let skillNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillName)
        skillName = skillNameDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[Swift.String]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [Swift.String]()
            for string0 in sampleUtterancesContainer {
                if let string0 = string0 {
                    sampleUtterancesDecoded0?.append(string0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let skillDetailsDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillDetails.self, forKey: .skillDetails)
        skillDetails = skillDetailsDecoded
        let supportsLinkingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsLinking) ?? false
        supportsLinking = supportsLinkingDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The detailed information about an Alexa skill.
    public struct SkillsStoreSkill: Swift.Equatable {
        /// The URL where the skill icon resides.
        public var iconUrl: Swift.String?
        /// Sample utterances that interact with the skill.
        public var sampleUtterances: [Swift.String]?
        /// Short description about the skill.
        public var shortDescription: Swift.String?
        /// Information about the skill.
        public var skillDetails: AlexaForBusinessClientTypes.SkillDetails?
        /// The ARN of the skill.
        public var skillId: Swift.String?
        /// The name of the skill.
        public var skillName: Swift.String?
        /// Linking support for a skill.
        public var supportsLinking: Swift.Bool

        public init(
            iconUrl: Swift.String? = nil,
            sampleUtterances: [Swift.String]? = nil,
            shortDescription: Swift.String? = nil,
            skillDetails: AlexaForBusinessClientTypes.SkillDetails? = nil,
            skillId: Swift.String? = nil,
            skillName: Swift.String? = nil,
            supportsLinking: Swift.Bool = false
        )
        {
            self.iconUrl = iconUrl
            self.sampleUtterances = sampleUtterances
            self.shortDescription = shortDescription
            self.skillDetails = skillDetails
            self.skillId = skillId
            self.skillName = skillName
            self.supportsLinking = supportsLinking
        }
    }

}

extension AlexaForBusinessClientTypes.SmartHomeAppliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case friendlyName = "FriendlyName"
        case manufacturerName = "ManufacturerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = self.friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let manufacturerName = self.manufacturerName {
            try encodeContainer.encode(manufacturerName, forKey: .manufacturerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let manufacturerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturerName)
        manufacturerName = manufacturerNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A smart home appliance that can connect to a central system. Any domestic device can be a smart appliance.
    public struct SmartHomeAppliance: Swift.Equatable {
        /// The description of the smart home appliance.
        public var description: Swift.String?
        /// The friendly name of the smart home appliance.
        public var friendlyName: Swift.String?
        /// The name of the manufacturer of the smart home appliance.
        public var manufacturerName: Swift.String?

        public init(
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            manufacturerName: Swift.String? = nil
        )
        {
            self.description = description
            self.friendlyName = friendlyName
            self.manufacturerName = manufacturerName
        }
    }

}

extension AlexaForBusinessClientTypes.Sort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SortValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// An object representing a sort criteria.
    public struct Sort: Swift.Equatable {
        /// The sort key of a sort object.
        /// This member is required.
        public var key: Swift.String?
        /// The sort value of a sort object.
        /// This member is required.
        public var value: AlexaForBusinessClientTypes.SortValue?

        public init(
            key: Swift.String? = nil,
            value: AlexaForBusinessClientTypes.SortValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum SortValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortValue] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortValue(rawValue: rawValue) ?? SortValue.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Ssml: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale = "Locale"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The SSML message. For more information, see [SSML Reference](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html).
    public struct Ssml: Swift.Equatable {
        /// The locale of the SSML message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The value of the SSML message in the correct SSML format. The audio tag is not supported.
        /// This member is required.
        public var value: Swift.String?

        public init(
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            value: Swift.String? = nil
        )
        {
            self.locale = locale
            self.value = value
        }
    }

}

extension StartDeviceSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case features = "Features"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for feature0 in features {
                try featuresContainer.encode(feature0.rawValue)
            }
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension StartDeviceSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDeviceSyncInput: Swift.Equatable {
    /// The ARN of the device to sync. Required.
    public var deviceArn: Swift.String?
    /// Request structure to start the device sync. Required.
    /// This member is required.
    public var features: [AlexaForBusinessClientTypes.Feature]?
    /// The ARN of the room with which the device to sync is associated. Required.
    public var roomArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        features: [AlexaForBusinessClientTypes.Feature]? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.features = features
        self.roomArn = roomArn
    }
}

struct StartDeviceSyncInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let deviceArn: Swift.String?
    let features: [AlexaForBusinessClientTypes.Feature]?
}

extension StartDeviceSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case features = "Features"
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let featuresContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Feature?].self, forKey: .features)
        var featuresDecoded0:[AlexaForBusinessClientTypes.Feature]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [AlexaForBusinessClientTypes.Feature]()
            for enum0 in featuresContainer {
                if let enum0 = enum0 {
                    featuresDecoded0?.append(enum0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension StartDeviceSyncOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartDeviceSyncOutput: Swift.Equatable {

    public init() { }
}

enum StartDeviceSyncOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeviceNotRegisteredException": return try await DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSmartHomeApplianceDiscoveryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension StartSmartHomeApplianceDiscoveryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSmartHomeApplianceDiscoveryInput: Swift.Equatable {
    /// The room where smart home appliance discovery was initiated.
    /// This member is required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct StartSmartHomeApplianceDiscoveryInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension StartSmartHomeApplianceDiscoveryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension StartSmartHomeApplianceDiscoveryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartSmartHomeApplianceDiscoveryOutput: Swift.Equatable {

    public init() { }
}

enum StartSmartHomeApplianceDiscoveryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A key-value pair that can be associated with a resource.
    public struct Tag: Swift.Equatable {
        /// The key of a tag. Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a tag. Tag values are case sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to which to add metadata tags. Required.
    /// This member is required.
    public var arn: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags. Required.
    /// This member is required.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum TemperatureUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case celsius
        case fahrenheit
        case sdkUnknown(Swift.String)

        public static var allCases: [TemperatureUnit] {
            return [
                .celsius,
                .fahrenheit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .celsius: return "CELSIUS"
            case .fahrenheit: return "FAHRENHEIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemperatureUnit(rawValue: rawValue) ?? TemperatureUnit.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Text: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale = "Locale"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The text message.
    public struct Text: Swift.Equatable {
        /// The locale of the text message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The value of the text message.
        /// This member is required.
        public var value: Swift.String?

        public init(
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            value: Swift.String? = nil
        )
        {
            self.locale = locale
            self.value = value
        }
    }

}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The caller has no permissions to operate on the resource involved in the API call.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource from which to remove metadata tags. Required.
    /// This member is required.
    public var arn: Swift.String?
    /// The tags to be removed from the specified resource. Do not provide system tags. Required.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = self.addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAddressBookInput: Swift.Equatable {
    /// The ARN of the room to update.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The updated description of the room.
    public var description: Swift.String?
    /// The updated name of the room.
    public var name: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.description = description
        self.name = name
    }
}

struct UpdateAddressBookInputBody: Swift.Equatable {
    let addressBookArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAddressBookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAddressBookOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAddressBookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameInUseException": return try await NameInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBusinessReportScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let recurrence = self.recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleArn = self.scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
        if let scheduleName = self.scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
    }
}

extension UpdateBusinessReportScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateBusinessReportScheduleInput: Swift.Equatable {
    /// The format of the generated report (individual CSV files or zipped files of individual files).
    public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
    /// The recurrence of the reports.
    public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    /// The S3 location of the output reports.
    public var s3BucketName: Swift.String?
    /// The S3 key where the report is delivered.
    public var s3KeyPrefix: Swift.String?
    /// The ARN of the business report schedule.
    /// This member is required.
    public var scheduleArn: Swift.String?
    /// The name identifier of the schedule.
    public var scheduleName: Swift.String?

    public init(
        format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
        recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        scheduleArn: Swift.String? = nil,
        scheduleName: Swift.String? = nil
    )
    {
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleArn = scheduleArn
        self.scheduleName = scheduleName
    }
}

struct UpdateBusinessReportScheduleInputBody: Swift.Equatable {
    let scheduleArn: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let format: AlexaForBusinessClientTypes.BusinessReportFormat?
    let scheduleName: Swift.String?
    let recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
}

extension UpdateBusinessReportScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let scheduleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
    }
}

extension UpdateBusinessReportScheduleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateBusinessReportScheduleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateBusinessReportScheduleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
        case conferenceProviderType = "ConferenceProviderType"
        case ipDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pstnDialIn = "PSTNDialIn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = self.conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
        if let conferenceProviderType = self.conferenceProviderType {
            try encodeContainer.encode(conferenceProviderType.rawValue, forKey: .conferenceProviderType)
        }
        if let ipDialIn = self.ipDialIn {
            try encodeContainer.encode(ipDialIn, forKey: .ipDialIn)
        }
        if let meetingSetting = self.meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let pstnDialIn = self.pstnDialIn {
            try encodeContainer.encode(pstnDialIn, forKey: .pstnDialIn)
        }
    }
}

extension UpdateConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConferenceProviderInput: Swift.Equatable {
    /// The ARN of the conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?
    /// The type of the conference provider.
    /// This member is required.
    public var conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    /// The IP endpoint and protocol for calling.
    public var ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
    /// The meeting settings for the conference provider.
    /// This member is required.
    public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    /// The information for PSTN conferencing.
    public var pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?

    public init(
        conferenceProviderArn: Swift.String? = nil,
        conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType? = nil,
        ipDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
        meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
        pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
        self.conferenceProviderType = conferenceProviderType
        self.ipDialIn = ipDialIn
        self.meetingSetting = meetingSetting
        self.pstnDialIn = pstnDialIn
    }
}

struct UpdateConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
    let conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    let ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
    let pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
    let meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
}

extension UpdateConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
        case conferenceProviderType = "ConferenceProviderType"
        case ipDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pstnDialIn = "PSTNDialIn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
        let conferenceProviderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProviderType.self, forKey: .conferenceProviderType)
        conferenceProviderType = conferenceProviderTypeDecoded
        let ipDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.IPDialIn.self, forKey: .ipDialIn)
        ipDialIn = ipDialInDecoded
        let pstnDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PSTNDialIn.self, forKey: .pstnDialIn)
        pstnDialIn = pstnDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
    }
}

extension UpdateConferenceProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateConferenceProviderOutput: Swift.Equatable {

    public init() { }
}

enum UpdateConferenceProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContactInput(contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension UpdateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddress0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddress0)
            }
        }
    }
}

extension UpdateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateContactInput: Swift.Equatable {
    /// The ARN of the contact to update.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The updated display name of the contact.
    public var displayName: Swift.String?
    /// The updated first name of the contact.
    public var firstName: Swift.String?
    /// The updated last name of the contact.
    public var lastName: Swift.String?
    /// The updated phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
    public var phoneNumber: Swift.String?
    /// The list of phone numbers for the contact.
    public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    /// The list of SIP addresses for the contact.
    public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

    public init(
        contactArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
        sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
    )
    {
        self.contactArn = contactArn
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
    }
}

struct UpdateContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let displayName: Swift.String?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let phoneNumber: Swift.String?
    let phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    let sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?
}

extension UpdateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension UpdateContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = self.deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }
}

extension UpdateDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDeviceInput: Swift.Equatable {
    /// The ARN of the device to update. Required.
    public var deviceArn: Swift.String?
    /// The updated device name. Required.
    public var deviceName: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        deviceName: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceName = deviceName
    }
}

struct UpdateDeviceInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let deviceName: Swift.String?
}

extension UpdateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
    }
}

extension UpdateDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDeviceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceNotRegisteredException": return try await DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for minutes0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(minutes0)
            }
        }
        if let reminderType = self.reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Swift.Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Swift.Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct UpdateEndOfMeetingReminder: Swift.Equatable {
        /// Whether an end of meeting reminder is enabled or not.
        public var enabled: Swift.Bool?
        /// Updates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init(
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension UpdateGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = self.gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewayGroupInput: Swift.Equatable {
    /// The updated description of the gateway group.
    public var description: Swift.String?
    /// The ARN of the gateway group to update.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?
    /// The updated name of the gateway group.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        gatewayGroupArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.gatewayGroupArn = gatewayGroupArn
        self.name = name
    }
}

struct UpdateGatewayGroupInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGatewayGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGatewayGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGatewayGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NameInUseException": return try await NameInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayArn = "GatewayArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayArn = self.gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = self.softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }
}

extension UpdateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewayInput: Swift.Equatable {
    /// The updated description of the gateway.
    public var description: Swift.String?
    /// The ARN of the gateway to update.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated name of the gateway.
    public var name: Swift.String?
    /// The updated software version of the gateway. The gateway automatically updates its software version during normal operation.
    public var softwareVersion: Swift.String?

    public init(
        description: Swift.String? = nil,
        gatewayArn: Swift.String? = nil,
        name: Swift.String? = nil,
        softwareVersion: Swift.String? = nil
    )
    {
        self.description = description
        self.gatewayArn = gatewayArn
        self.name = name
        self.softwareVersion = softwareVersion
    }
}

struct UpdateGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let softwareVersion: Swift.String?
}

extension UpdateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayArn = "GatewayArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension UpdateGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGatewayOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NameInUseException": return try await NameInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateInstantBooking: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = self.durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates settings for the instant booking feature that are applied to a room profile. If instant booking is enabled, Alexa automatically reserves a room if it is free when a user joins a meeting with Alexa.
    public struct UpdateInstantBooking: Swift.Equatable {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case proactiveJoin = "ProactiveJoin"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = self.endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = self.instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let proactiveJoin = self.proactiveJoin {
            try encodeContainer.encode(proactiveJoin, forKey: .proactiveJoin)
        }
        if let requireCheckIn = self.requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = self.roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateInstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateRequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
        let proactiveJoinDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateProactiveJoin.self, forKey: .proactiveJoin)
        proactiveJoin = proactiveJoinDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates meeting room settings of a room profile.
    public struct UpdateMeetingRoomConfiguration: Swift.Equatable {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder?
        /// Settings to automatically book an available room available for a configured duration when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.UpdateInstantBooking?
        public var proactiveJoin: AlexaForBusinessClientTypes.UpdateProactiveJoin?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.UpdateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init(
            endOfMeetingReminder: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.UpdateInstantBooking? = nil,
            proactiveJoin: AlexaForBusinessClientTypes.UpdateProactiveJoin? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.UpdateRequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.proactiveJoin = proactiveJoin
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension UpdateNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkProfileInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), description: \(Swift.String(describing: description)), networkProfileArn: \(Swift.String(describing: networkProfileArn)), networkProfileName: \(Swift.String(describing: networkProfileName)), trustAnchors: \(Swift.String(describing: trustAnchors)), currentPassword: \"CONTENT_REDACTED\", nextPassword: \"CONTENT_REDACTED\")"}
}

extension UpdateNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let currentPassword = self.currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkProfileArn = self.networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = self.networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = self.nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchor0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchor0)
            }
        }
    }
}

extension UpdateNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNetworkProfileInput: Swift.Equatable {
    /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
    public var certificateAuthorityArn: Swift.String?
    /// The current password of the Wi-Fi network.
    public var currentPassword: Swift.String?
    /// Detailed information about a device's network profile.
    public var description: Swift.String?
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?
    /// The name of the network profile associated with a device.
    public var networkProfileName: Swift.String?
    /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
    public var nextPassword: Swift.String?
    /// The root certificate(s) of your authentication server that will be installed on your devices and used to trust your authentication server during EAP negotiation.
    public var trustAnchors: [Swift.String]?

    public init(
        certificateAuthorityArn: Swift.String? = nil,
        currentPassword: Swift.String? = nil,
        description: Swift.String? = nil,
        networkProfileArn: Swift.String? = nil,
        networkProfileName: Swift.String? = nil,
        nextPassword: Swift.String? = nil,
        trustAnchors: [Swift.String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.currentPassword = currentPassword
        self.description = description
        self.networkProfileArn = networkProfileArn
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.trustAnchors = trustAnchors
    }
}

struct UpdateNetworkProfileInputBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
    let networkProfileName: Swift.String?
    let description: Swift.String?
    let currentPassword: Swift.String?
    let nextPassword: Swift.String?
    let certificateAuthorityArn: Swift.String?
    let trustAnchors: [Swift.String]?
}

extension UpdateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case trustAnchors = "TrustAnchors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[Swift.String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [Swift.String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

extension UpdateNetworkProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateNetworkProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNetworkProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCertificateAuthorityException": return try await InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSecretsManagerResourceException": return try await InvalidSecretsManagerResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameInUseException": return try await NameInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateProactiveJoin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledByMotion = "EnabledByMotion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledByMotion = self.enabledByMotion {
            try encodeContainer.encode(enabledByMotion, forKey: .enabledByMotion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledByMotionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledByMotion)
        enabledByMotion = enabledByMotionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public struct UpdateProactiveJoin: Swift.Equatable {
        /// This member is required.
        public var enabledByMotion: Swift.Bool?

        public init(
            enabledByMotion: Swift.Bool? = nil
        )
        {
            self.enabledByMotion = enabledByMotion
        }
    }

}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pstnEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let dataRetentionOptIn = self.dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = self.distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = self.isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = self.maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = self.meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pstnEnabled = self.pstnEnabled {
            try encodeContainer.encode(pstnEnabled, forKey: .pstnEnabled)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = self.setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let temperatureUnit = self.temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = self.wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }
}

extension UpdateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// The updated address for the room profile.
    public var address: Swift.String?
    /// Whether data retention of the profile is enabled.
    public var dataRetentionOptIn: Swift.Bool?
    /// The updated distance unit for the room profile.
    public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    /// Sets the profile as default if selected. If this is missing, no update is done to the default status.
    public var isDefault: Swift.Bool?
    /// The updated locale for the room profile. (This is currently only available to a limited preview audience.)
    public var locale: Swift.String?
    /// The updated maximum volume limit for the room profile.
    public var maxVolumeLimit: Swift.Int?
    /// The updated meeting room settings of a room profile.
    public var meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration?
    /// The ARN of the room profile to update. Required.
    public var profileArn: Swift.String?
    /// The updated name for the room profile.
    public var profileName: Swift.String?
    /// Whether the PSTN setting of the room profile is enabled.
    public var pstnEnabled: Swift.Bool?
    /// Whether the setup mode of the profile is enabled.
    public var setupModeDisabled: Swift.Bool?
    /// The updated temperature unit for the room profile.
    public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    /// The updated timezone for the room profile.
    public var timezone: Swift.String?
    /// The updated wake word for the room profile.
    public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

    public init(
        address: Swift.String? = nil,
        dataRetentionOptIn: Swift.Bool? = nil,
        distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
        isDefault: Swift.Bool? = nil,
        locale: Swift.String? = nil,
        maxVolumeLimit: Swift.Int? = nil,
        meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration? = nil,
        profileArn: Swift.String? = nil,
        profileName: Swift.String? = nil,
        pstnEnabled: Swift.Bool? = nil,
        setupModeDisabled: Swift.Bool? = nil,
        temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
        timezone: Swift.String? = nil,
        wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
    )
    {
        self.address = address
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.isDefault = isDefault
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.profileArn = profileArn
        self.profileName = profileName
        self.pstnEnabled = pstnEnabled
        self.setupModeDisabled = setupModeDisabled
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let profileArn: Swift.String?
    let profileName: Swift.String?
    let isDefault: Swift.Bool?
    let timezone: Swift.String?
    let address: Swift.String?
    let distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    let temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    let wakeWord: AlexaForBusinessClientTypes.WakeWord?
    let locale: Swift.String?
    let setupModeDisabled: Swift.Bool?
    let maxVolumeLimit: Swift.Int?
    let pstnEnabled: Swift.Bool?
    let dataRetentionOptIn: Swift.Bool?
    let meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pstnEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pstnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pstnEnabled)
        pstnEnabled = pstnEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
    }
}

extension UpdateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameInUseException": return try await NameInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateRequireCheckIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = self.releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct UpdateRequireCheckIn: Swift.Equatable {
        /// Whether require check in is enabled or not.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public var releaseAfterMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension UpdateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = self.providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = self.roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = self.roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }
}

extension UpdateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoomInput: Swift.Equatable {
    /// The updated description for the room.
    public var description: Swift.String?
    /// The updated profile ARN for the room.
    public var profileArn: Swift.String?
    /// The updated provider calendar ARN for the room.
    public var providerCalendarId: Swift.String?
    /// The ARN of the room to update.
    public var roomArn: Swift.String?
    /// The updated name for the room.
    public var roomName: Swift.String?

    public init(
        description: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        providerCalendarId: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        roomName: Swift.String? = nil
    )
    {
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomArn = roomArn
        self.roomName = roomName
    }
}

struct UpdateRoomInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let roomName: Swift.String?
    let description: Swift.String?
    let providerCalendarId: Swift.String?
    let profileArn: Swift.String?
}

extension UpdateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension UpdateRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRoomOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NameInUseException": return try await NameInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = self.skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = self.skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }
}

extension UpdateSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSkillGroupInput: Swift.Equatable {
    /// The updated description for the skill group.
    public var description: Swift.String?
    /// The ARN of the skill group to update.
    public var skillGroupArn: Swift.String?
    /// The updated name for the skill group.
    public var skillGroupName: Swift.String?

    public init(
        description: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil,
        skillGroupName: Swift.String? = nil
    )
    {
        self.description = description
        self.skillGroupArn = skillGroupArn
        self.skillGroupName = skillGroupName
    }
}

struct UpdateSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let skillGroupName: Swift.String?
    let description: Swift.String?
}

extension UpdateSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSkillGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSkillGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSkillGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NameInUseException": return try await NameInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AlexaForBusinessClientTypes.UserData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case enrollmentId = "EnrollmentId"
        case enrollmentStatus = "EnrollmentStatus"
        case firstName = "FirstName"
        case lastName = "LastName"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enrollmentId = self.enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let enrollmentStatus = self.enrollmentStatus {
            try encodeContainer.encode(enrollmentStatus.rawValue, forKey: .enrollmentStatus)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let enrollmentStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EnrollmentStatus.self, forKey: .enrollmentStatus)
        enrollmentStatus = enrollmentStatusDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to a user.
    public struct UserData: Swift.Equatable {
        /// The email of a user.
        public var email: Swift.String?
        /// The enrollment ARN of a user.
        public var enrollmentId: Swift.String?
        /// The enrollment status of a user.
        public var enrollmentStatus: AlexaForBusinessClientTypes.EnrollmentStatus?
        /// The first name of a user.
        public var firstName: Swift.String?
        /// The last name of a user.
        public var lastName: Swift.String?
        /// The ARN of a user.
        public var userArn: Swift.String?

        public init(
            email: Swift.String? = nil,
            enrollmentId: Swift.String? = nil,
            enrollmentStatus: AlexaForBusinessClientTypes.EnrollmentStatus? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.email = email
            self.enrollmentId = enrollmentId
            self.enrollmentStatus = enrollmentStatus
            self.firstName = firstName
            self.lastName = lastName
            self.userArn = userArn
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum WakeWord: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alexa
        case amazon
        case computer
        case echo
        case sdkUnknown(Swift.String)

        public static var allCases: [WakeWord] {
            return [
                .alexa,
                .amazon,
                .computer,
                .echo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alexa: return "ALEXA"
            case .amazon: return "AMAZON"
            case .computer: return "COMPUTER"
            case .echo: return "ECHO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WakeWord(rawValue: rawValue) ?? WakeWord.sdkUnknown(rawValue)
        }
    }
}
