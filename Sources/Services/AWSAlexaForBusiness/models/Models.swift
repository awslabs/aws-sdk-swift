// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AlexaForBusinessClientTypes.AddressBook {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.AddressBook {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.AddressBook()
        value.addressBookArn = try reader["AddressBookArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// An address book with attributes.
    public struct AddressBook {
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// The description of the address book.
        public var description: Swift.String?
        /// The name of the address book.
        public var name: Swift.String?

        public init(
            addressBookArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.AddressBookData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.AddressBookData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.AddressBookData()
        value.addressBookArn = try reader["AddressBookArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to an address book.
    public struct AddressBookData {
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// The description of the address book.
        public var description: Swift.String?
        /// The name of the address book.
        public var name: Swift.String?

        public init(
            addressBookArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }
    }

}

public enum AlexaForBusinessClientTypes {}

extension AlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = AlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The resource being created already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ApproveSkillInput {

    static func urlPathProvider(_ value: ApproveSkillInput) -> Swift.String? {
        return "/"
    }
}

extension ApproveSkillInput {

    static func write(value: ApproveSkillInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillId"].write(value.skillId)
    }
}

public struct ApproveSkillInput {
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

extension ApproveSkillOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ApproveSkillOutput {
        return ApproveSkillOutput()
    }
}

public struct ApproveSkillOutput {

    public init() { }
}

enum ApproveSkillOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateContactWithAddressBookInput {

    static func urlPathProvider(_ value: AssociateContactWithAddressBookInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateContactWithAddressBookInput {

    static func write(value: AssociateContactWithAddressBookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressBookArn"].write(value.addressBookArn)
        try writer["ContactArn"].write(value.contactArn)
    }
}

public struct AssociateContactWithAddressBookInput {
    /// The ARN of the address book with which to associate the contact.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The ARN of the contact to associate with an address book.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil,
        contactArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

extension AssociateContactWithAddressBookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateContactWithAddressBookOutput {
        return AssociateContactWithAddressBookOutput()
    }
}

public struct AssociateContactWithAddressBookOutput {

    public init() { }
}

enum AssociateContactWithAddressBookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateDeviceWithNetworkProfileInput {

    static func urlPathProvider(_ value: AssociateDeviceWithNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateDeviceWithNetworkProfileInput {

    static func write(value: AssociateDeviceWithNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
        try writer["NetworkProfileArn"].write(value.networkProfileArn)
    }
}

public struct AssociateDeviceWithNetworkProfileInput {
    /// The device ARN.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The ARN of the network profile to associate with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        networkProfileArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.networkProfileArn = networkProfileArn
    }
}

extension AssociateDeviceWithNetworkProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateDeviceWithNetworkProfileOutput {
        return AssociateDeviceWithNetworkProfileOutput()
    }
}

public struct AssociateDeviceWithNetworkProfileOutput {

    public init() { }
}

enum AssociateDeviceWithNetworkProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DeviceNotRegisteredException": return try DeviceNotRegisteredException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateDeviceWithRoomInput {

    static func urlPathProvider(_ value: AssociateDeviceWithRoomInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateDeviceWithRoomInput {

    static func write(value: AssociateDeviceWithRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
        try writer["RoomArn"].write(value.roomArn)
    }
}

public struct AssociateDeviceWithRoomInput {
    /// The ARN of the device to associate to a room. Required.
    public var deviceArn: Swift.String?
    /// The ARN of the room with which to associate the device. Required.
    public var roomArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.roomArn = roomArn
    }
}

extension AssociateDeviceWithRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateDeviceWithRoomOutput {
        return AssociateDeviceWithRoomOutput()
    }
}

public struct AssociateDeviceWithRoomOutput {

    public init() { }
}

enum AssociateDeviceWithRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DeviceNotRegisteredException": return try DeviceNotRegisteredException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateSkillGroupWithRoomInput {

    static func urlPathProvider(_ value: AssociateSkillGroupWithRoomInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateSkillGroupWithRoomInput {

    static func write(value: AssociateSkillGroupWithRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
        try writer["SkillGroupArn"].write(value.skillGroupArn)
    }
}

public struct AssociateSkillGroupWithRoomInput {
    /// The ARN of the room with which to associate the skill group. Required.
    public var roomArn: Swift.String?
    /// The ARN of the skill group to associate with a room. Required.
    public var skillGroupArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

extension AssociateSkillGroupWithRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateSkillGroupWithRoomOutput {
        return AssociateSkillGroupWithRoomOutput()
    }
}

public struct AssociateSkillGroupWithRoomOutput {

    public init() { }
}

enum AssociateSkillGroupWithRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateSkillWithSkillGroupInput {

    static func urlPathProvider(_ value: AssociateSkillWithSkillGroupInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateSkillWithSkillGroupInput {

    static func write(value: AssociateSkillWithSkillGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillGroupArn"].write(value.skillGroupArn)
        try writer["SkillId"].write(value.skillId)
    }
}

public struct AssociateSkillWithSkillGroupInput {
    /// The ARN of the skill group to associate the skill to. Required.
    public var skillGroupArn: Swift.String?
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

extension AssociateSkillWithSkillGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateSkillWithSkillGroupOutput {
        return AssociateSkillWithSkillGroupOutput()
    }
}

public struct AssociateSkillWithSkillGroupOutput {

    public init() { }
}

enum AssociateSkillWithSkillGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "SkillNotLinkedException": return try SkillNotLinkedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateSkillWithUsersInput {

    static func urlPathProvider(_ value: AssociateSkillWithUsersInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateSkillWithUsersInput {

    static func write(value: AssociateSkillWithUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillId"].write(value.skillId)
    }
}

public struct AssociateSkillWithUsersInput {
    /// The private skill ID you want to make available to enrolled users.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

extension AssociateSkillWithUsersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateSkillWithUsersOutput {
        return AssociateSkillWithUsersOutput()
    }
}

public struct AssociateSkillWithUsersOutput {

    public init() { }
}

enum AssociateSkillWithUsersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.Audio {

    static func write(value: AlexaForBusinessClientTypes.Audio?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Locale"].write(value.locale)
        try writer["Location"].write(value.location)
    }
}

extension AlexaForBusinessClientTypes {
    /// The audio message. There is a 1 MB limit on the audio file input and the only supported format is MP3. To convert your MP3 audio files to an Alexa-friendly, required codec version (MPEG version 2) and bit rate (48 kbps), you might use converter software. One option for this is a command-line tool, FFmpeg. For more information, see [FFmpeg](https://www.ffmpeg.org/). The following command converts the provided to an MP3 file that is played in the announcement: ffmpeg -i -ac 2 -codec:a libmp3lame -b:a 48k -ar 16000
    public struct Audio {
        /// The locale of the audio message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The location of the audio file. Currently, S3 URLs are supported. Only S3 locations comprised of safe characters are valid. For more information, see [Safe Characters](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#Safe%20Characters).
        /// This member is required.
        public var location: Swift.String?

        public init(
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            location: Swift.String? = nil
        )
        {
            self.locale = locale
            self.location = location
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReport {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.BusinessReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.BusinessReport()
        value.status = try reader["Status"].readIfPresent()
        value.failureCode = try reader["FailureCode"].readIfPresent()
        value.s3Location = try reader["S3Location"].readIfPresent(with: AlexaForBusinessClientTypes.BusinessReportS3Location.read(from:))
        value.deliveryTime = try reader["DeliveryTime"].readTimestampIfPresent(format: .epochSeconds)
        value.downloadUrl = try reader["DownloadUrl"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Usage report with specified parameters.
    public struct BusinessReport {
        /// The time of report delivery.
        public var deliveryTime: ClientRuntime.Date?
        /// The download link where a user can download the report.
        public var downloadUrl: Swift.String?
        /// The failure code.
        public var failureCode: AlexaForBusinessClientTypes.BusinessReportFailureCode?
        /// The S3 location of the output reports.
        public var s3Location: AlexaForBusinessClientTypes.BusinessReportS3Location?
        /// The status of the report generation execution (RUNNING, SUCCEEDED, or FAILED).
        public var status: AlexaForBusinessClientTypes.BusinessReportStatus?

        public init(
            deliveryTime: ClientRuntime.Date? = nil,
            downloadUrl: Swift.String? = nil,
            failureCode: AlexaForBusinessClientTypes.BusinessReportFailureCode? = nil,
            s3Location: AlexaForBusinessClientTypes.BusinessReportS3Location? = nil,
            status: AlexaForBusinessClientTypes.BusinessReportStatus? = nil
        )
        {
            self.deliveryTime = deliveryTime
            self.downloadUrl = downloadUrl
            self.failureCode = failureCode
            self.s3Location = s3Location
            self.status = status
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportContentRange {

    static func write(value: AlexaForBusinessClientTypes.BusinessReportContentRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Interval"].write(value.interval)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.BusinessReportContentRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.BusinessReportContentRange()
        value.interval = try reader["Interval"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The content range of the report.
    public struct BusinessReportContentRange {
        /// The interval of the content range.
        /// This member is required.
        public var interval: AlexaForBusinessClientTypes.BusinessReportInterval?

        public init(
            interval: AlexaForBusinessClientTypes.BusinessReportInterval? = nil
        )
        {
            self.interval = interval
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum BusinessReportFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case internalFailure
        case noSuchBucket
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportFailureCode] {
            return [
                .accessDenied,
                .internalFailure,
                .noSuchBucket,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .noSuchBucket: return "NO_SUCH_BUCKET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum BusinessReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case csvZip
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportFormat] {
            return [
                .csv,
                .csvZip,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .csvZip: return "CSV_ZIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum BusinessReportInterval: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneDay
        case oneWeek
        case thirtyDays
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportInterval] {
            return [
                .oneDay,
                .oneWeek,
                .thirtyDays,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneDay: return "ONE_DAY"
            case .oneWeek: return "ONE_WEEK"
            case .thirtyDays: return "THIRTY_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.BusinessReportRecurrence {

    static func write(value: AlexaForBusinessClientTypes.BusinessReportRecurrence?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StartDate"].write(value.startDate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.BusinessReportRecurrence {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.BusinessReportRecurrence()
        value.startDate = try reader["StartDate"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The recurrence of the reports.
    public struct BusinessReportRecurrence {
        /// The start date.
        public var startDate: Swift.String?

        public init(
            startDate: Swift.String? = nil
        )
        {
            self.startDate = startDate
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportS3Location {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.BusinessReportS3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.BusinessReportS3Location()
        value.path = try reader["Path"].readIfPresent()
        value.bucketName = try reader["BucketName"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The S3 location of the output reports.
    public struct BusinessReportS3Location {
        /// The S3 bucket name of the output reports.
        public var bucketName: Swift.String?
        /// The path of the business report.
        public var path: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.path = path
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportSchedule {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.BusinessReportSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.BusinessReportSchedule()
        value.scheduleArn = try reader["ScheduleArn"].readIfPresent()
        value.scheduleName = try reader["ScheduleName"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        value.format = try reader["Format"].readIfPresent()
        value.contentRange = try reader["ContentRange"].readIfPresent(with: AlexaForBusinessClientTypes.BusinessReportContentRange.read(from:))
        value.recurrence = try reader["Recurrence"].readIfPresent(with: AlexaForBusinessClientTypes.BusinessReportRecurrence.read(from:))
        value.lastBusinessReport = try reader["LastBusinessReport"].readIfPresent(with: AlexaForBusinessClientTypes.BusinessReport.read(from:))
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The schedule of the usage report.
    public struct BusinessReportSchedule {
        /// The content range of the reports.
        public var contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
        /// The format of the generated report (individual CSV files or zipped files of individual files).
        public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
        /// The details of the last business report delivery for a specified time interval.
        public var lastBusinessReport: AlexaForBusinessClientTypes.BusinessReport?
        /// The recurrence of the reports.
        public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
        /// The S3 bucket name of the output reports.
        public var s3BucketName: Swift.String?
        /// The S3 key where the report is delivered.
        public var s3KeyPrefix: Swift.String?
        /// The ARN of the business report schedule.
        public var scheduleArn: Swift.String?
        /// The name identifier of the schedule.
        public var scheduleName: Swift.String?

        public init(
            contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange? = nil,
            format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
            lastBusinessReport: AlexaForBusinessClientTypes.BusinessReport? = nil,
            recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            scheduleArn: Swift.String? = nil,
            scheduleName: Swift.String? = nil
        )
        {
            self.contentRange = contentRange
            self.format = format
            self.lastBusinessReport = lastBusinessReport
            self.recurrence = recurrence
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.scheduleArn = scheduleArn
            self.scheduleName = scheduleName
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum BusinessReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportStatus] {
            return [
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.Category {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.Category {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.Category()
        value.categoryId = try reader["CategoryId"].readIfPresent()
        value.categoryName = try reader["CategoryName"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The skill store category that is shown. Alexa skills are assigned a specific skill category during creation, such as News, Social, and Sports.
    public struct Category {
        /// The ID of the skill store category.
        public var categoryId: Swift.Int?
        /// The name of the skill store category.
        public var categoryName: Swift.String?

        public init(
            categoryId: Swift.Int? = nil,
            categoryName: Swift.String? = nil
        )
        {
            self.categoryId = categoryId
            self.categoryName = categoryName
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum CommsProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case h323
        case sip
        case sips
        case sdkUnknown(Swift.String)

        public static var allCases: [CommsProtocol] {
            return [
                .h323,
                .sip,
                .sips,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .h323: return "H323"
            case .sip: return "SIP"
            case .sips: return "SIPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// There is a concurrent modification of resources.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AlexaForBusinessClientTypes.ConferencePreference {

    static func write(value: AlexaForBusinessClientTypes.ConferencePreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultConferenceProviderArn"].write(value.defaultConferenceProviderArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.ConferencePreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.ConferencePreference()
        value.defaultConferenceProviderArn = try reader["DefaultConferenceProviderArn"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The default conference provider that is used if no other scheduled meetings are detected.
    public struct ConferencePreference {
        /// The ARN of the default conference provider.
        public var defaultConferenceProviderArn: Swift.String?

        public init(
            defaultConferenceProviderArn: Swift.String? = nil
        )
        {
            self.defaultConferenceProviderArn = defaultConferenceProviderArn
        }
    }

}

extension AlexaForBusinessClientTypes.ConferenceProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.ConferenceProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.ConferenceProvider()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.ipDialIn = try reader["IPDialIn"].readIfPresent(with: AlexaForBusinessClientTypes.IPDialIn.read(from:))
        value.pstnDialIn = try reader["PSTNDialIn"].readIfPresent(with: AlexaForBusinessClientTypes.PSTNDialIn.read(from:))
        value.meetingSetting = try reader["MeetingSetting"].readIfPresent(with: AlexaForBusinessClientTypes.MeetingSetting.read(from:))
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// An entity that provides a conferencing solution. Alexa for Business acts as the voice interface and mediator that connects users to their preferred conference provider. Examples of conference providers include Amazon Chime, Zoom, Cisco, and Polycom.
    public struct ConferenceProvider {
        /// The ARN of the newly created conference provider.
        public var arn: Swift.String?
        /// The IP endpoint and protocol for calling.
        public var ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
        /// The meeting settings for the conference provider.
        public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
        /// The name of the conference provider.
        public var name: Swift.String?
        /// The information for PSTN conferencing.
        public var pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
        /// The type of conference providers.
        public var type: AlexaForBusinessClientTypes.ConferenceProviderType?

        public init(
            arn: Swift.String? = nil,
            ipDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
            meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
            name: Swift.String? = nil,
            pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil,
            type: AlexaForBusinessClientTypes.ConferenceProviderType? = nil
        )
        {
            self.arn = arn
            self.ipDialIn = ipDialIn
            self.meetingSetting = meetingSetting
            self.name = name
            self.pstnDialIn = pstnDialIn
            self.type = type
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum ConferenceProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bluejeans
        case chime
        case custom
        case fuze
        case googleHangouts
        case polycom
        case ringcentral
        case skypeForBusiness
        case webex
        case zoom
        case sdkUnknown(Swift.String)

        public static var allCases: [ConferenceProviderType] {
            return [
                .bluejeans,
                .chime,
                .custom,
                .fuze,
                .googleHangouts,
                .polycom,
                .ringcentral,
                .skypeForBusiness,
                .webex,
                .zoom,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bluejeans: return "BLUEJEANS"
            case .chime: return "CHIME"
            case .custom: return "CUSTOM"
            case .fuze: return "FUZE"
            case .googleHangouts: return "GOOGLE_HANGOUTS"
            case .polycom: return "POLYCOM"
            case .ringcentral: return "RINGCENTRAL"
            case .skypeForBusiness: return "SKYPE_FOR_BUSINESS"
            case .webex: return "WEBEX"
            case .zoom: return "ZOOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case offline
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .offline,
                .online,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.Contact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Contact(contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes.Contact {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.Contact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.Contact()
        value.contactArn = try reader["ContactArn"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.PhoneNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sipAddresses = try reader["SipAddresses"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.SipAddress.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A contact with attributes.
    public struct Contact {
        /// The ARN of the contact.
        public var contactArn: Swift.String?
        /// The name of the contact to display on the console.
        public var displayName: Swift.String?
        /// The first name of the contact, used to call the contact on the device.
        public var firstName: Swift.String?
        /// The last name of the contact, used to call the contact on the device.
        public var lastName: Swift.String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public var phoneNumber: Swift.String?
        /// The list of phone numbers for the contact.
        public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

        public init(
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
            sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
        )
        {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }
    }

}

extension AlexaForBusinessClientTypes.ContactData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContactData(contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes.ContactData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.ContactData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.ContactData()
        value.contactArn = try reader["ContactArn"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.PhoneNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sipAddresses = try reader["SipAddresses"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.SipAddress.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to a contact.
    public struct ContactData {
        /// The ARN of the contact.
        public var contactArn: Swift.String?
        /// The name of the contact to display on the console.
        public var displayName: Swift.String?
        /// The first name of the contact, used to call the contact on the device.
        public var firstName: Swift.String?
        /// The last name of the contact, used to call the contact on the device.
        public var lastName: Swift.String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public var phoneNumber: Swift.String?
        /// The list of phone numbers for the contact.
        public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

        public init(
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
            sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
        )
        {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }
    }

}

extension AlexaForBusinessClientTypes.Content {

    static func write(value: AlexaForBusinessClientTypes.Content?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AudioList"].writeList(value.audioList, memberWritingClosure: AlexaForBusinessClientTypes.Audio.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SsmlList"].writeList(value.ssmlList, memberWritingClosure: AlexaForBusinessClientTypes.Ssml.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TextList"].writeList(value.textList, memberWritingClosure: AlexaForBusinessClientTypes.Text.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AlexaForBusinessClientTypes {
    /// The content definition. This can contain only one text, SSML, or audio list object.
    public struct Content {
        /// The list of audio messages.
        public var audioList: [AlexaForBusinessClientTypes.Audio]?
        /// The list of SSML messages.
        public var ssmlList: [AlexaForBusinessClientTypes.Ssml]?
        /// The list of text messages.
        public var textList: [AlexaForBusinessClientTypes.Text]?

        public init(
            audioList: [AlexaForBusinessClientTypes.Audio]? = nil,
            ssmlList: [AlexaForBusinessClientTypes.Ssml]? = nil,
            textList: [AlexaForBusinessClientTypes.Text]? = nil
        )
        {
            self.audioList = audioList
            self.ssmlList = ssmlList
            self.textList = textList
        }
    }

}

extension CreateAddressBookInput {

    static func urlPathProvider(_ value: CreateAddressBookInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAddressBookInput {

    static func write(value: CreateAddressBookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateAddressBookInput {
    /// A unique, user-specified identifier for the request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description of the address book.
    public var description: Swift.String?
    /// The name of the address book.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateAddressBookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAddressBookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAddressBookOutput()
        value.addressBookArn = try reader["AddressBookArn"].readIfPresent()
        return value
    }
}

public struct CreateAddressBookOutput {
    /// The ARN of the newly created address book.
    public var addressBookArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

enum CreateAddressBookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateBusinessReportScheduleInput {

    static func urlPathProvider(_ value: CreateBusinessReportScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBusinessReportScheduleInput {

    static func write(value: CreateBusinessReportScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ContentRange"].write(value.contentRange, with: AlexaForBusinessClientTypes.BusinessReportContentRange.write(value:to:))
        try writer["Format"].write(value.format)
        try writer["Recurrence"].write(value.recurrence, with: AlexaForBusinessClientTypes.BusinessReportRecurrence.write(value:to:))
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
        try writer["ScheduleName"].write(value.scheduleName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateBusinessReportScheduleInput {
    /// The client request token.
    public var clientRequestToken: Swift.String?
    /// The content range of the reports.
    /// This member is required.
    public var contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
    /// The format of the generated report (individual CSV files or zipped files of individual files).
    /// This member is required.
    public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
    /// The recurrence of the reports. If this isn't specified, the report will only be delivered one time when the API is called.
    public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    /// The S3 bucket name of the output reports. If this isn't specified, the report can be retrieved from a download link by calling ListBusinessReportSchedule.
    public var s3BucketName: Swift.String?
    /// The S3 key where the report is delivered.
    public var s3KeyPrefix: Swift.String?
    /// The name identifier of the schedule.
    public var scheduleName: Swift.String?
    /// The tags for the business report schedule.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange? = nil,
        format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
        recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        scheduleName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.contentRange = contentRange
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleName = scheduleName
        self.tags = tags
    }
}

extension CreateBusinessReportScheduleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateBusinessReportScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBusinessReportScheduleOutput()
        value.scheduleArn = try reader["ScheduleArn"].readIfPresent()
        return value
    }
}

public struct CreateBusinessReportScheduleOutput {
    /// The ARN of the business report schedule.
    public var scheduleArn: Swift.String?

    public init(
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

enum CreateBusinessReportScheduleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateConferenceProviderInput {

    static func urlPathProvider(_ value: CreateConferenceProviderInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConferenceProviderInput {

    static func write(value: CreateConferenceProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ConferenceProviderName"].write(value.conferenceProviderName)
        try writer["ConferenceProviderType"].write(value.conferenceProviderType)
        try writer["IPDialIn"].write(value.ipDialIn, with: AlexaForBusinessClientTypes.IPDialIn.write(value:to:))
        try writer["MeetingSetting"].write(value.meetingSetting, with: AlexaForBusinessClientTypes.MeetingSetting.write(value:to:))
        try writer["PSTNDialIn"].write(value.pstnDialIn, with: AlexaForBusinessClientTypes.PSTNDialIn.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateConferenceProviderInput {
    /// The request token of the client.
    public var clientRequestToken: Swift.String?
    /// The name of the conference provider.
    /// This member is required.
    public var conferenceProviderName: Swift.String?
    /// Represents a type within a list of predefined types.
    /// This member is required.
    public var conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    /// The IP endpoint and protocol for calling.
    public var ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
    /// The meeting settings for the conference provider.
    /// This member is required.
    public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    /// The information for PSTN conferencing.
    public var pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        conferenceProviderName: Swift.String? = nil,
        conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType? = nil,
        ipDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
        meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
        pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.conferenceProviderName = conferenceProviderName
        self.conferenceProviderType = conferenceProviderType
        self.ipDialIn = ipDialIn
        self.meetingSetting = meetingSetting
        self.pstnDialIn = pstnDialIn
        self.tags = tags
    }
}

extension CreateConferenceProviderOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateConferenceProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConferenceProviderOutput()
        value.conferenceProviderArn = try reader["ConferenceProviderArn"].readIfPresent()
        return value
    }
}

public struct CreateConferenceProviderOutput {
    /// The ARN of the newly-created conference provider.
    public var conferenceProviderArn: Swift.String?

    public init(
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

enum CreateConferenceProviderOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContactInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), tags: \(Swift.String(describing: tags)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateContactInput {

    static func urlPathProvider(_ value: CreateContactInput) -> Swift.String? {
        return "/"
    }
}

extension CreateContactInput {

    static func write(value: CreateContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["DisplayName"].write(value.displayName)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["PhoneNumbers"].writeList(value.phoneNumbers, memberWritingClosure: AlexaForBusinessClientTypes.PhoneNumber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SipAddresses"].writeList(value.sipAddresses, memberWritingClosure: AlexaForBusinessClientTypes.SipAddress.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateContactInput {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The name of the contact to display on the console.
    public var displayName: Swift.String?
    /// The first name of the contact that is used to call the contact on the device.
    /// This member is required.
    public var firstName: Swift.String?
    /// The last name of the contact that is used to call the contact on the device.
    public var lastName: Swift.String?
    /// The phone number of the contact in E.164 format. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
    public var phoneNumber: Swift.String?
    /// The list of phone numbers for the contact.
    public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    /// The list of SIP addresses for the contact.
    public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
        sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
        self.tags = tags
    }
}

extension CreateContactOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContactOutput()
        value.contactArn = try reader["ContactArn"].readIfPresent()
        return value
    }
}

public struct CreateContactOutput {
    /// The ARN of the newly created address book.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

enum CreateContactOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateEndOfMeetingReminder {

    static func write(value: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["ReminderAtMinutes"].writeList(value.reminderAtMinutes, memberWritingClosure: Swift.Int.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReminderType"].write(value.reminderType)
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct CreateEndOfMeetingReminder {
        /// Whether an end of meeting reminder is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A range of 3 to 15 minutes that determines when the reminder begins.
        /// This member is required.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        /// This member is required.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init(
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension CreateGatewayGroupInput {

    static func urlPathProvider(_ value: CreateGatewayGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateGatewayGroupInput {

    static func write(value: CreateGatewayGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateGatewayGroupInput {
    /// A unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description of the gateway group.
    public var description: Swift.String?
    /// The name of the gateway group.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateGatewayGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGatewayGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayGroupOutput()
        value.gatewayGroupArn = try reader["GatewayGroupArn"].readIfPresent()
        return value
    }
}

public struct CreateGatewayGroupOutput {
    /// The ARN of the created gateway group.
    public var gatewayGroupArn: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

enum CreateGatewayGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateInstantBooking {

    static func write(value: AlexaForBusinessClientTypes.CreateInstantBooking?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationInMinutes"].write(value.durationInMinutes)
        try writer["Enabled"].write(value.enabled)
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the instant booking feature that are applied to a room profile. When users start their meeting with Alexa, Alexa automatically books the room for the configured duration if the room is available.
    public struct CreateInstantBooking {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration {

    static func write(value: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndOfMeetingReminder"].write(value.endOfMeetingReminder, with: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder.write(value:to:))
        try writer["InstantBooking"].write(value.instantBooking, with: AlexaForBusinessClientTypes.CreateInstantBooking.write(value:to:))
        try writer["ProactiveJoin"].write(value.proactiveJoin, with: AlexaForBusinessClientTypes.CreateProactiveJoin.write(value:to:))
        try writer["RequireCheckIn"].write(value.requireCheckIn, with: AlexaForBusinessClientTypes.CreateRequireCheckIn.write(value:to:))
        try writer["RoomUtilizationMetricsEnabled"].write(value.roomUtilizationMetricsEnabled)
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates meeting room settings of a room profile.
    public struct CreateMeetingRoomConfiguration {
        /// Creates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder?
        /// Settings to automatically book a room for a configured duration if it's free when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.CreateInstantBooking?
        public var proactiveJoin: AlexaForBusinessClientTypes.CreateProactiveJoin?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.CreateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init(
            endOfMeetingReminder: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.CreateInstantBooking? = nil,
            proactiveJoin: AlexaForBusinessClientTypes.CreateProactiveJoin? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.CreateRequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.proactiveJoin = proactiveJoin
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension CreateNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkProfileInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), eapMethod: \(Swift.String(describing: eapMethod)), networkProfileName: \(Swift.String(describing: networkProfileName)), securityType: \(Swift.String(describing: securityType)), ssid: \(Swift.String(describing: ssid)), tags: \(Swift.String(describing: tags)), trustAnchors: \(Swift.String(describing: trustAnchors)), currentPassword: \"CONTENT_REDACTED\", nextPassword: \"CONTENT_REDACTED\")"}
}

extension CreateNetworkProfileInput {

    static func urlPathProvider(_ value: CreateNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateNetworkProfileInput {

    static func write(value: CreateNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateAuthorityArn"].write(value.certificateAuthorityArn)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["CurrentPassword"].write(value.currentPassword)
        try writer["Description"].write(value.description)
        try writer["EapMethod"].write(value.eapMethod)
        try writer["NetworkProfileName"].write(value.networkProfileName)
        try writer["NextPassword"].write(value.nextPassword)
        try writer["SecurityType"].write(value.securityType)
        try writer["Ssid"].write(value.ssid)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrustAnchors"].writeList(value.trustAnchors, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateNetworkProfileInput {
    /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
    public var certificateAuthorityArn: Swift.String?
    /// A unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The current password of the Wi-Fi network.
    public var currentPassword: Swift.String?
    /// Detailed information about a device's network profile.
    public var description: Swift.String?
    /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
    public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
    /// The name of the network profile associated with a device.
    /// This member is required.
    public var networkProfileName: Swift.String?
    /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
    public var nextPassword: Swift.String?
    /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
    /// This member is required.
    public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
    /// The SSID of the Wi-Fi network.
    /// This member is required.
    public var ssid: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The root certificates of your authentication server that is installed on your devices and used to trust your authentication server during EAP negotiation.
    public var trustAnchors: [Swift.String]?

    public init(
        certificateAuthorityArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        currentPassword: Swift.String? = nil,
        description: Swift.String? = nil,
        eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
        networkProfileName: Swift.String? = nil,
        nextPassword: Swift.String? = nil,
        securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
        ssid: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        trustAnchors: [Swift.String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.clientRequestToken = clientRequestToken
        self.currentPassword = currentPassword
        self.description = description
        self.eapMethod = eapMethod
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.securityType = securityType
        self.ssid = ssid
        self.tags = tags
        self.trustAnchors = trustAnchors
    }
}

extension CreateNetworkProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateNetworkProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNetworkProfileOutput()
        value.networkProfileArn = try reader["NetworkProfileArn"].readIfPresent()
        return value
    }
}

public struct CreateNetworkProfileOutput {
    /// The ARN of the network profile associated with a device.
    public var networkProfileArn: Swift.String?

    public init(
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

enum CreateNetworkProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidCertificateAuthorityException": return try InvalidCertificateAuthorityException.makeError(baseError: baseError)
            case "InvalidServiceLinkedRoleStateException": return try InvalidServiceLinkedRoleStateException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateProactiveJoin {

    static func write(value: AlexaForBusinessClientTypes.CreateProactiveJoin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnabledByMotion"].write(value.enabledByMotion)
    }
}

extension AlexaForBusinessClientTypes {
    public struct CreateProactiveJoin {
        /// This member is required.
        public var enabledByMotion: Swift.Bool?

        public init(
            enabledByMotion: Swift.Bool? = nil
        )
        {
            self.enabledByMotion = enabledByMotion
        }
    }

}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["DataRetentionOptIn"].write(value.dataRetentionOptIn)
        try writer["DistanceUnit"].write(value.distanceUnit)
        try writer["Locale"].write(value.locale)
        try writer["MaxVolumeLimit"].write(value.maxVolumeLimit)
        try writer["MeetingRoomConfiguration"].write(value.meetingRoomConfiguration, with: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration.write(value:to:))
        try writer["PSTNEnabled"].write(value.pstnEnabled)
        try writer["ProfileName"].write(value.profileName)
        try writer["SetupModeDisabled"].write(value.setupModeDisabled)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TemperatureUnit"].write(value.temperatureUnit)
        try writer["Timezone"].write(value.timezone)
        try writer["WakeWord"].write(value.wakeWord)
    }
}

public struct CreateProfileInput {
    /// The valid address for the room.
    /// This member is required.
    public var address: Swift.String?
    /// The user-specified token that is used during the creation of a profile.
    public var clientRequestToken: Swift.String?
    /// Whether data retention of the profile is enabled.
    public var dataRetentionOptIn: Swift.Bool?
    /// The distance unit to be used by devices in the profile.
    /// This member is required.
    public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    /// The locale of the room profile. (This is currently only available to a limited preview audience.)
    public var locale: Swift.String?
    /// The maximum volume limit for a room profile.
    public var maxVolumeLimit: Swift.Int?
    /// The meeting room settings of a room profile.
    public var meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration?
    /// The name of a room profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// Whether PSTN calling is enabled.
    public var pstnEnabled: Swift.Bool?
    /// Whether room profile setup is enabled.
    public var setupModeDisabled: Swift.Bool?
    /// The tags for the profile.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The temperature unit to be used by devices in the profile.
    /// This member is required.
    public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    /// The time zone used by a room profile.
    /// This member is required.
    public var timezone: Swift.String?
    /// A wake word for Alexa, Echo, Amazon, or a computer.
    /// This member is required.
    public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

    public init(
        address: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        dataRetentionOptIn: Swift.Bool? = nil,
        distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
        locale: Swift.String? = nil,
        maxVolumeLimit: Swift.Int? = nil,
        meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration? = nil,
        profileName: Swift.String? = nil,
        pstnEnabled: Swift.Bool? = nil,
        setupModeDisabled: Swift.Bool? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
        timezone: Swift.String? = nil,
        wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
    )
    {
        self.address = address
        self.clientRequestToken = clientRequestToken
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.profileName = profileName
        self.pstnEnabled = pstnEnabled
        self.setupModeDisabled = setupModeDisabled
        self.tags = tags
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        return value
    }
}

public struct CreateProfileOutput {
    /// The ARN of the newly created room profile in the response.
    public var profileArn: Swift.String?

    public init(
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.CreateRequireCheckIn {

    static func write(value: AlexaForBusinessClientTypes.CreateRequireCheckIn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["ReleaseAfterMinutes"].write(value.releaseAfterMinutes)
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct CreateRequireCheckIn {
        /// Whether require check in is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        /// This member is required.
        public var releaseAfterMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension CreateRoomInput {

    static func urlPathProvider(_ value: CreateRoomInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRoomInput {

    static func write(value: CreateRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["ProfileArn"].write(value.profileArn)
        try writer["ProviderCalendarId"].write(value.providerCalendarId)
        try writer["RoomName"].write(value.roomName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateRoomInput {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description for the room.
    public var description: Swift.String?
    /// The profile ARN for the room. This is required.
    public var profileArn: Swift.String?
    /// The calendar ARN for the room.
    public var providerCalendarId: Swift.String?
    /// The name for the room.
    /// This member is required.
    public var roomName: Swift.String?
    /// The tags for the room.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        providerCalendarId: Swift.String? = nil,
        roomName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomName = roomName
        self.tags = tags
    }
}

extension CreateRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoomOutput()
        value.roomArn = try reader["RoomArn"].readIfPresent()
        return value
    }
}

public struct CreateRoomOutput {
    /// The ARN of the newly created room in the response.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

enum CreateRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSkillGroupInput {

    static func urlPathProvider(_ value: CreateSkillGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSkillGroupInput {

    static func write(value: CreateSkillGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["SkillGroupName"].write(value.skillGroupName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateSkillGroupInput {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description for the skill group.
    public var description: Swift.String?
    /// The name for the skill group.
    /// This member is required.
    public var skillGroupName: Swift.String?
    /// The tags for the skill group.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        skillGroupName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.skillGroupName = skillGroupName
        self.tags = tags
    }
}

extension CreateSkillGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSkillGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSkillGroupOutput()
        value.skillGroupArn = try reader["SkillGroupArn"].readIfPresent()
        return value
    }
}

public struct CreateSkillGroupOutput {
    /// The ARN of the newly created skill group in the response.
    public var skillGroupArn: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

enum CreateSkillGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserId"].write(value.userId)
    }
}

public struct CreateUserInput {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The email address for the user.
    public var email: Swift.String?
    /// The first name for the user.
    public var firstName: Swift.String?
    /// The last name for the user.
    public var lastName: Swift.String?
    /// The tags for the user.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The ARN for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        email: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.email = email
        self.firstName = firstName
        self.lastName = lastName
        self.tags = tags
        self.userId = userId
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserOutput()
        value.userArn = try reader["UserArn"].readIfPresent()
        return value
    }
}

public struct CreateUserOutput {
    /// The ARN of the newly created user in the response.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAddressBookInput {

    static func urlPathProvider(_ value: DeleteAddressBookInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAddressBookInput {

    static func write(value: DeleteAddressBookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressBookArn"].write(value.addressBookArn)
    }
}

public struct DeleteAddressBookInput {
    /// The ARN of the address book to delete.
    /// This member is required.
    public var addressBookArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

extension DeleteAddressBookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAddressBookOutput {
        return DeleteAddressBookOutput()
    }
}

public struct DeleteAddressBookOutput {

    public init() { }
}

enum DeleteAddressBookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteBusinessReportScheduleInput {

    static func urlPathProvider(_ value: DeleteBusinessReportScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBusinessReportScheduleInput {

    static func write(value: DeleteBusinessReportScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScheduleArn"].write(value.scheduleArn)
    }
}

public struct DeleteBusinessReportScheduleInput {
    /// The ARN of the business report schedule.
    /// This member is required.
    public var scheduleArn: Swift.String?

    public init(
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

extension DeleteBusinessReportScheduleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteBusinessReportScheduleOutput {
        return DeleteBusinessReportScheduleOutput()
    }
}

public struct DeleteBusinessReportScheduleOutput {

    public init() { }
}

enum DeleteBusinessReportScheduleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteConferenceProviderInput {

    static func urlPathProvider(_ value: DeleteConferenceProviderInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConferenceProviderInput {

    static func write(value: DeleteConferenceProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConferenceProviderArn"].write(value.conferenceProviderArn)
    }
}

public struct DeleteConferenceProviderInput {
    /// The ARN of the conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?

    public init(
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

extension DeleteConferenceProviderOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteConferenceProviderOutput {
        return DeleteConferenceProviderOutput()
    }
}

public struct DeleteConferenceProviderOutput {

    public init() { }
}

enum DeleteConferenceProviderOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteContactInput {

    static func urlPathProvider(_ value: DeleteContactInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteContactInput {

    static func write(value: DeleteContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactArn"].write(value.contactArn)
    }
}

public struct DeleteContactInput {
    /// The ARN of the contact to delete.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

extension DeleteContactOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteContactOutput {
        return DeleteContactOutput()
    }
}

public struct DeleteContactOutput {

    public init() { }
}

enum DeleteContactOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDeviceInput {

    static func urlPathProvider(_ value: DeleteDeviceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDeviceInput {

    static func write(value: DeleteDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
    }
}

public struct DeleteDeviceInput {
    /// The ARN of the device for which to request details.
    /// This member is required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

extension DeleteDeviceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDeviceOutput {
        return DeleteDeviceOutput()
    }
}

public struct DeleteDeviceOutput {

    public init() { }
}

enum DeleteDeviceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidCertificateAuthorityException": return try InvalidCertificateAuthorityException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDeviceUsageDataInput {

    static func urlPathProvider(_ value: DeleteDeviceUsageDataInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDeviceUsageDataInput {

    static func write(value: DeleteDeviceUsageDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
        try writer["DeviceUsageType"].write(value.deviceUsageType)
    }
}

public struct DeleteDeviceUsageDataInput {
    /// The ARN of the device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The type of usage data to delete.
    /// This member is required.
    public var deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType?

    public init(
        deviceArn: Swift.String? = nil,
        deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceUsageType = deviceUsageType
    }
}

extension DeleteDeviceUsageDataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDeviceUsageDataOutput {
        return DeleteDeviceUsageDataOutput()
    }
}

public struct DeleteDeviceUsageDataOutput {

    public init() { }
}

enum DeleteDeviceUsageDataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeviceNotRegisteredException": return try DeviceNotRegisteredException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteGatewayGroupInput {

    static func urlPathProvider(_ value: DeleteGatewayGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGatewayGroupInput {

    static func write(value: DeleteGatewayGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayGroupArn"].write(value.gatewayGroupArn)
    }
}

public struct DeleteGatewayGroupInput {
    /// The ARN of the gateway group to delete.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

extension DeleteGatewayGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteGatewayGroupOutput {
        return DeleteGatewayGroupOutput()
    }
}

public struct DeleteGatewayGroupOutput {

    public init() { }
}

enum DeleteGatewayGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceAssociatedException": return try ResourceAssociatedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteNetworkProfileInput {

    static func urlPathProvider(_ value: DeleteNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNetworkProfileInput {

    static func write(value: DeleteNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NetworkProfileArn"].write(value.networkProfileArn)
    }
}

public struct DeleteNetworkProfileInput {
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init(
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

extension DeleteNetworkProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteNetworkProfileOutput {
        return DeleteNetworkProfileOutput()
    }
}

public struct DeleteNetworkProfileOutput {

    public init() { }
}

enum DeleteNetworkProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProfileInput {

    static func write(value: DeleteProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileArn"].write(value.profileArn)
    }
}

public struct DeleteProfileInput {
    /// The ARN of the room profile to delete. Required.
    public var profileArn: Swift.String?

    public init(
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteProfileOutput {
        return DeleteProfileOutput()
    }
}

public struct DeleteProfileOutput {

    public init() { }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRoomInput {

    static func urlPathProvider(_ value: DeleteRoomInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRoomInput {

    static func write(value: DeleteRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
    }
}

public struct DeleteRoomInput {
    /// The ARN of the room to delete. Required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

extension DeleteRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRoomOutput {
        return DeleteRoomOutput()
    }
}

public struct DeleteRoomOutput {

    public init() { }
}

enum DeleteRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRoomSkillParameterInput {

    static func urlPathProvider(_ value: DeleteRoomSkillParameterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRoomSkillParameterInput {

    static func write(value: DeleteRoomSkillParameterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterKey"].write(value.parameterKey)
        try writer["RoomArn"].write(value.roomArn)
        try writer["SkillId"].write(value.skillId)
    }
}

public struct DeleteRoomSkillParameterInput {
    /// The room skill parameter key for which to remove details.
    /// This member is required.
    public var parameterKey: Swift.String?
    /// The ARN of the room from which to remove the room skill parameter details.
    public var roomArn: Swift.String?
    /// The ID of the skill from which to remove the room skill parameter details.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        parameterKey: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

extension DeleteRoomSkillParameterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRoomSkillParameterOutput {
        return DeleteRoomSkillParameterOutput()
    }
}

public struct DeleteRoomSkillParameterOutput {

    public init() { }
}

enum DeleteRoomSkillParameterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSkillAuthorizationInput {

    static func urlPathProvider(_ value: DeleteSkillAuthorizationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSkillAuthorizationInput {

    static func write(value: DeleteSkillAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
        try writer["SkillId"].write(value.skillId)
    }
}

public struct DeleteSkillAuthorizationInput {
    /// The room that the skill is authorized for.
    public var roomArn: Swift.String?
    /// The unique identifier of a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

extension DeleteSkillAuthorizationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSkillAuthorizationOutput {
        return DeleteSkillAuthorizationOutput()
    }
}

public struct DeleteSkillAuthorizationOutput {

    public init() { }
}

enum DeleteSkillAuthorizationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSkillGroupInput {

    static func urlPathProvider(_ value: DeleteSkillGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSkillGroupInput {

    static func write(value: DeleteSkillGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillGroupArn"].write(value.skillGroupArn)
    }
}

public struct DeleteSkillGroupInput {
    /// The ARN of the skill group to delete. Required.
    public var skillGroupArn: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

extension DeleteSkillGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSkillGroupOutput {
        return DeleteSkillGroupOutput()
    }
}

public struct DeleteSkillGroupOutput {

    public init() { }
}

enum DeleteSkillGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserInput {

    static func write(value: DeleteUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnrollmentId"].write(value.enrollmentId)
        try writer["UserArn"].write(value.userArn)
    }
}

public struct DeleteUserInput {
    /// The ARN of the user's enrollment in the organization. Required.
    /// This member is required.
    public var enrollmentId: Swift.String?
    /// The ARN of the user to delete in the organization. Required.
    public var userArn: Swift.String?

    public init(
        enrollmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

public struct DeleteUserOutput {

    public init() { }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.DeveloperInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.DeveloperInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.DeveloperInfo()
        value.developerName = try reader["DeveloperName"].readIfPresent()
        value.privacyPolicy = try reader["PrivacyPolicy"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The details about the developer that published the skill.
    public struct DeveloperInfo {
        /// The name of the developer.
        public var developerName: Swift.String?
        /// The email of the developer.
        public var email: Swift.String?
        /// The URL of the privacy policy.
        public var privacyPolicy: Swift.String?
        /// The website of the developer.
        public var url: Swift.String?

        public init(
            developerName: Swift.String? = nil,
            email: Swift.String? = nil,
            privacyPolicy: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.developerName = developerName
            self.email = email
            self.privacyPolicy = privacyPolicy
            self.url = url
        }
    }

}

extension AlexaForBusinessClientTypes.Device {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.Device()
        value.deviceArn = try reader["DeviceArn"].readIfPresent()
        value.deviceSerialNumber = try reader["DeviceSerialNumber"].readIfPresent()
        value.deviceType = try reader["DeviceType"].readIfPresent()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.softwareVersion = try reader["SoftwareVersion"].readIfPresent()
        value.macAddress = try reader["MacAddress"].readIfPresent()
        value.roomArn = try reader["RoomArn"].readIfPresent()
        value.deviceStatus = try reader["DeviceStatus"].readIfPresent()
        value.deviceStatusInfo = try reader["DeviceStatusInfo"].readIfPresent(with: AlexaForBusinessClientTypes.DeviceStatusInfo.read(from:))
        value.networkProfileInfo = try reader["NetworkProfileInfo"].readIfPresent(with: AlexaForBusinessClientTypes.DeviceNetworkProfileInfo.read(from:))
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A device with attributes.
    public struct Device {
        /// The ARN of a device.
        public var deviceArn: Swift.String?
        /// The name of a device.
        public var deviceName: Swift.String?
        /// The serial number of a device.
        public var deviceSerialNumber: Swift.String?
        /// The status of a device. If the status is not READY, check the DeviceStatusInfo value for details.
        public var deviceStatus: AlexaForBusinessClientTypes.DeviceStatus?
        /// Detailed information about a device's status.
        public var deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo?
        /// The type of a device.
        public var deviceType: Swift.String?
        /// The MAC address of a device.
        public var macAddress: Swift.String?
        /// Detailed information about a device's network profile.
        public var networkProfileInfo: AlexaForBusinessClientTypes.DeviceNetworkProfileInfo?
        /// The room ARN of a device.
        public var roomArn: Swift.String?
        /// The software version of a device.
        public var softwareVersion: Swift.String?

        public init(
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceSerialNumber: Swift.String? = nil,
            deviceStatus: AlexaForBusinessClientTypes.DeviceStatus? = nil,
            deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo? = nil,
            deviceType: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            networkProfileInfo: AlexaForBusinessClientTypes.DeviceNetworkProfileInfo? = nil,
            roomArn: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileInfo = networkProfileInfo
            self.roomArn = roomArn
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.DeviceData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.DeviceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.DeviceData()
        value.deviceArn = try reader["DeviceArn"].readIfPresent()
        value.deviceSerialNumber = try reader["DeviceSerialNumber"].readIfPresent()
        value.deviceType = try reader["DeviceType"].readIfPresent()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.softwareVersion = try reader["SoftwareVersion"].readIfPresent()
        value.macAddress = try reader["MacAddress"].readIfPresent()
        value.deviceStatus = try reader["DeviceStatus"].readIfPresent()
        value.networkProfileArn = try reader["NetworkProfileArn"].readIfPresent()
        value.networkProfileName = try reader["NetworkProfileName"].readIfPresent()
        value.roomArn = try reader["RoomArn"].readIfPresent()
        value.roomName = try reader["RoomName"].readIfPresent()
        value.deviceStatusInfo = try reader["DeviceStatusInfo"].readIfPresent(with: AlexaForBusinessClientTypes.DeviceStatusInfo.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Device attributes.
    public struct DeviceData {
        /// The time (in epoch) when the device data was created.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of a device.
        public var deviceArn: Swift.String?
        /// The name of a device.
        public var deviceName: Swift.String?
        /// The serial number of a device.
        public var deviceSerialNumber: Swift.String?
        /// The status of a device.
        public var deviceStatus: AlexaForBusinessClientTypes.DeviceStatus?
        /// Detailed information about a device's status.
        public var deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo?
        /// The type of a device.
        public var deviceType: Swift.String?
        /// The MAC address of a device.
        public var macAddress: Swift.String?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The room ARN associated with a device.
        public var roomArn: Swift.String?
        /// The name of the room associated with a device.
        public var roomName: Swift.String?
        /// The software version of a device.
        public var softwareVersion: Swift.String?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceSerialNumber: Swift.String? = nil,
            deviceStatus: AlexaForBusinessClientTypes.DeviceStatus? = nil,
            deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo? = nil,
            deviceType: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.roomArn = roomArn
            self.roomName = roomName
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.DeviceEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.DeviceEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.DeviceEvent()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The list of device events.
    public struct DeviceEvent {
        /// The time (in epoch) when the event occurred.
        public var timestamp: ClientRuntime.Date?
        /// The type of device event.
        public var type: AlexaForBusinessClientTypes.DeviceEventType?
        /// The value of the event.
        public var value: Swift.String?

        public init(
            timestamp: ClientRuntime.Date? = nil,
            type: AlexaForBusinessClientTypes.DeviceEventType? = nil,
            value: Swift.String? = nil
        )
        {
            self.timestamp = timestamp
            self.type = type
            self.value = value
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum DeviceEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectionStatus
        case deviceStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceEventType] {
            return [
                .connectionStatus,
                .deviceStatus,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectionStatus: return "CONNECTION_STATUS"
            case .deviceStatus: return "DEVICE_STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceNetworkProfileInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.DeviceNetworkProfileInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.DeviceNetworkProfileInfo()
        value.networkProfileArn = try reader["NetworkProfileArn"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.certificateExpirationTime = try reader["CertificateExpirationTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Detailed information about a device's network profile.
    public struct DeviceNetworkProfileInfo {
        /// The ARN of the certificate associated with a device.
        public var certificateArn: Swift.String?
        /// The time (in epoch) when the certificate expires.
        public var certificateExpirationTime: ClientRuntime.Date?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            certificateExpirationTime: ClientRuntime.Date? = nil,
            networkProfileArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateExpirationTime = certificateExpirationTime
            self.networkProfileArn = networkProfileArn
        }
    }

}

extension DeviceNotRegisteredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DeviceNotRegisteredException {
        let reader = baseError.errorBodyReader
        var value = DeviceNotRegisteredException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request failed because this device is no longer registered and therefore no longer managed by this account.
public struct DeviceNotRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceNotRegisteredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AlexaForBusinessClientTypes {

    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deregistered
        case failed
        case pending
        case ready
        case wasOffline
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .deregistered,
                .failed,
                .pending,
                .ready,
                .wasOffline,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "DEREGISTERED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .wasOffline: return "WAS_OFFLINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceStatusDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.DeviceStatusDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.DeviceStatusDetail()
        value.feature = try reader["Feature"].readIfPresent()
        value.code = try reader["Code"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Details of a devices status.
    public struct DeviceStatusDetail {
        /// The device status detail code.
        public var code: AlexaForBusinessClientTypes.DeviceStatusDetailCode?
        /// The list of available features on the device.
        public var feature: AlexaForBusinessClientTypes.Feature?

        public init(
            code: AlexaForBusinessClientTypes.DeviceStatusDetailCode? = nil,
            feature: AlexaForBusinessClientTypes.Feature? = nil
        )
        {
            self.code = code
            self.feature = feature
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum DeviceStatusDetailCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associationRejection
        case authenticationFailure
        case certificateAuthorityAccessDenied
        case certificateIssuingLimitExceeded
        case credentialsAccessFailure
        case deviceSoftwareUpdateNeeded
        case deviceWasOffline
        case dhcpFailure
        case dnsFailure
        case internetUnavailable
        case invalidCertificateAuthority
        case invalidPasswordState
        case networkProfileNotFound
        case passwordManagerAccessDenied
        case passwordNotFound
        case tlsVersionMismatch
        case unknownFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatusDetailCode] {
            return [
                .associationRejection,
                .authenticationFailure,
                .certificateAuthorityAccessDenied,
                .certificateIssuingLimitExceeded,
                .credentialsAccessFailure,
                .deviceSoftwareUpdateNeeded,
                .deviceWasOffline,
                .dhcpFailure,
                .dnsFailure,
                .internetUnavailable,
                .invalidCertificateAuthority,
                .invalidPasswordState,
                .networkProfileNotFound,
                .passwordManagerAccessDenied,
                .passwordNotFound,
                .tlsVersionMismatch,
                .unknownFailure,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associationRejection: return "ASSOCIATION_REJECTION"
            case .authenticationFailure: return "AUTHENTICATION_FAILURE"
            case .certificateAuthorityAccessDenied: return "CERTIFICATE_AUTHORITY_ACCESS_DENIED"
            case .certificateIssuingLimitExceeded: return "CERTIFICATE_ISSUING_LIMIT_EXCEEDED"
            case .credentialsAccessFailure: return "CREDENTIALS_ACCESS_FAILURE"
            case .deviceSoftwareUpdateNeeded: return "DEVICE_SOFTWARE_UPDATE_NEEDED"
            case .deviceWasOffline: return "DEVICE_WAS_OFFLINE"
            case .dhcpFailure: return "DHCP_FAILURE"
            case .dnsFailure: return "DNS_FAILURE"
            case .internetUnavailable: return "INTERNET_UNAVAILABLE"
            case .invalidCertificateAuthority: return "INVALID_CERTIFICATE_AUTHORITY"
            case .invalidPasswordState: return "INVALID_PASSWORD_STATE"
            case .networkProfileNotFound: return "NETWORK_PROFILE_NOT_FOUND"
            case .passwordManagerAccessDenied: return "PASSWORD_MANAGER_ACCESS_DENIED"
            case .passwordNotFound: return "PASSWORD_NOT_FOUND"
            case .tlsVersionMismatch: return "TLS_VERSION_MISMATCH"
            case .unknownFailure: return "UNKNOWN_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceStatusInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.DeviceStatusInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.DeviceStatusInfo()
        value.deviceStatusDetails = try reader["DeviceStatusDetails"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.DeviceStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent()
        value.connectionStatusUpdatedTime = try reader["ConnectionStatusUpdatedTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Detailed information about a device's status.
    public struct DeviceStatusInfo {
        /// The latest available information about the connection status of a device.
        public var connectionStatus: AlexaForBusinessClientTypes.ConnectionStatus?
        /// The time (in epoch) when the device connection status changed.
        public var connectionStatusUpdatedTime: ClientRuntime.Date?
        /// One or more device status detail descriptions.
        public var deviceStatusDetails: [AlexaForBusinessClientTypes.DeviceStatusDetail]?

        public init(
            connectionStatus: AlexaForBusinessClientTypes.ConnectionStatus? = nil,
            connectionStatusUpdatedTime: ClientRuntime.Date? = nil,
            deviceStatusDetails: [AlexaForBusinessClientTypes.DeviceStatusDetail]? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.connectionStatusUpdatedTime = connectionStatusUpdatedTime
            self.deviceStatusDetails = deviceStatusDetails
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum DeviceUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceUsageType] {
            return [
                .voice,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DisassociateContactFromAddressBookInput {

    static func urlPathProvider(_ value: DisassociateContactFromAddressBookInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateContactFromAddressBookInput {

    static func write(value: DisassociateContactFromAddressBookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressBookArn"].write(value.addressBookArn)
        try writer["ContactArn"].write(value.contactArn)
    }
}

public struct DisassociateContactFromAddressBookInput {
    /// The ARN of the address from which to disassociate the contact.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The ARN of the contact to disassociate from an address book.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil,
        contactArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

extension DisassociateContactFromAddressBookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateContactFromAddressBookOutput {
        return DisassociateContactFromAddressBookOutput()
    }
}

public struct DisassociateContactFromAddressBookOutput {

    public init() { }
}

enum DisassociateContactFromAddressBookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateDeviceFromRoomInput {

    static func urlPathProvider(_ value: DisassociateDeviceFromRoomInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateDeviceFromRoomInput {

    static func write(value: DisassociateDeviceFromRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
    }
}

public struct DisassociateDeviceFromRoomInput {
    /// The ARN of the device to disassociate from a room. Required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

extension DisassociateDeviceFromRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateDeviceFromRoomOutput {
        return DisassociateDeviceFromRoomOutput()
    }
}

public struct DisassociateDeviceFromRoomOutput {

    public init() { }
}

enum DisassociateDeviceFromRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DeviceNotRegisteredException": return try DeviceNotRegisteredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateSkillFromSkillGroupInput {

    static func urlPathProvider(_ value: DisassociateSkillFromSkillGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateSkillFromSkillGroupInput {

    static func write(value: DisassociateSkillFromSkillGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillGroupArn"].write(value.skillGroupArn)
        try writer["SkillId"].write(value.skillId)
    }
}

public struct DisassociateSkillFromSkillGroupInput {
    /// The unique identifier of a skill. Required.
    public var skillGroupArn: Swift.String?
    /// The ARN of a skill group to associate to a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

extension DisassociateSkillFromSkillGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateSkillFromSkillGroupOutput {
        return DisassociateSkillFromSkillGroupOutput()
    }
}

public struct DisassociateSkillFromSkillGroupOutput {

    public init() { }
}

enum DisassociateSkillFromSkillGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateSkillFromUsersInput {

    static func urlPathProvider(_ value: DisassociateSkillFromUsersInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateSkillFromUsersInput {

    static func write(value: DisassociateSkillFromUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillId"].write(value.skillId)
    }
}

public struct DisassociateSkillFromUsersInput {
    /// The private skill ID you want to make unavailable for enrolled users.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

extension DisassociateSkillFromUsersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateSkillFromUsersOutput {
        return DisassociateSkillFromUsersOutput()
    }
}

public struct DisassociateSkillFromUsersOutput {

    public init() { }
}

enum DisassociateSkillFromUsersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateSkillGroupFromRoomInput {

    static func urlPathProvider(_ value: DisassociateSkillGroupFromRoomInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateSkillGroupFromRoomInput {

    static func write(value: DisassociateSkillGroupFromRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
        try writer["SkillGroupArn"].write(value.skillGroupArn)
    }
}

public struct DisassociateSkillGroupFromRoomInput {
    /// The ARN of the room from which the skill group is to be disassociated. Required.
    public var roomArn: Swift.String?
    /// The ARN of the skill group to disassociate from a room. Required.
    public var skillGroupArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

extension DisassociateSkillGroupFromRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateSkillGroupFromRoomOutput {
        return DisassociateSkillGroupFromRoomOutput()
    }
}

public struct DisassociateSkillGroupFromRoomOutput {

    public init() { }
}

enum DisassociateSkillGroupFromRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum DistanceUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case imperial
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceUnit] {
            return [
                .imperial,
                .metric,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .imperial: return "IMPERIAL"
            case .metric: return "METRIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum EnablementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementType] {
            return [
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum EnablementTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementTypeFilter] {
            return [
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.EndOfMeetingReminder {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.EndOfMeetingReminder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.EndOfMeetingReminder()
        value.reminderAtMinutes = try reader["ReminderAtMinutes"].readListIfPresent(memberReadingClosure: Swift.Int.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reminderType = try reader["ReminderType"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct EndOfMeetingReminder {
        /// Whether an end of meeting reminder is enabled or not.
        public var enabled: Swift.Bool?
        /// A range of 3 to 15 minutes that determines when the reminder begins.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init(
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum EndOfMeetingReminderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case announcementTimeCheck
        case announcementVariableTimeLeft
        case chime
        case knock
        case sdkUnknown(Swift.String)

        public static var allCases: [EndOfMeetingReminderType] {
            return [
                .announcementTimeCheck,
                .announcementVariableTimeLeft,
                .chime,
                .knock,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .announcementTimeCheck: return "ANNOUNCEMENT_TIME_CHECK"
            case .announcementVariableTimeLeft: return "ANNOUNCEMENT_VARIABLE_TIME_LEFT"
            case .chime: return "CHIME"
            case .knock: return "KNOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum EnrollmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deregistering
        case disassociating
        case initialized
        case pending
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [EnrollmentStatus] {
            return [
                .deregistering,
                .disassociating,
                .initialized,
                .pending,
                .registered,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deregistering: return "DEREGISTERING"
            case .disassociating: return "DISASSOCIATING"
            case .initialized: return "INITIALIZED"
            case .pending: return "PENDING"
            case .registered: return "REGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum Feature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case bluetooth
        case lists
        case networkProfile
        case notifications
        case settings
        case skills
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [Feature] {
            return [
                .all,
                .bluetooth,
                .lists,
                .networkProfile,
                .notifications,
                .settings,
                .skills,
                .volume,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .bluetooth: return "BLUETOOTH"
            case .lists: return "LISTS"
            case .networkProfile: return "NETWORK_PROFILE"
            case .notifications: return "NOTIFICATIONS"
            case .settings: return "SETTINGS"
            case .skills: return "SKILLS"
            case .volume: return "VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.Filter {

    static func write(value: AlexaForBusinessClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AlexaForBusinessClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria.
    public struct Filter {
        /// The key of a filter.
        /// This member is required.
        public var key: Swift.String?
        /// The values of a filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension ForgetSmartHomeAppliancesInput {

    static func urlPathProvider(_ value: ForgetSmartHomeAppliancesInput) -> Swift.String? {
        return "/"
    }
}

extension ForgetSmartHomeAppliancesInput {

    static func write(value: ForgetSmartHomeAppliancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
    }
}

public struct ForgetSmartHomeAppliancesInput {
    /// The room that the appliances are associated with.
    /// This member is required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

extension ForgetSmartHomeAppliancesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ForgetSmartHomeAppliancesOutput {
        return ForgetSmartHomeAppliancesOutput()
    }
}

public struct ForgetSmartHomeAppliancesOutput {

    public init() { }
}

enum ForgetSmartHomeAppliancesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.Gateway {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.Gateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.Gateway()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.gatewayGroupArn = try reader["GatewayGroupArn"].readIfPresent()
        value.softwareVersion = try reader["SoftwareVersion"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The details of the gateway.
    public struct Gateway {
        /// The ARN of the gateway.
        public var arn: Swift.String?
        /// The description of the gateway.
        public var description: Swift.String?
        /// The ARN of the gateway group that the gateway is associated to.
        public var gatewayGroupArn: Swift.String?
        /// The name of the gateway.
        public var name: Swift.String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public var softwareVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            gatewayGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.GatewayGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.GatewayGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.GatewayGroup()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The details of the gateway group.
    public struct GatewayGroup {
        /// The ARN of the gateway group.
        public var arn: Swift.String?
        /// The description of the gateway group.
        public var description: Swift.String?
        /// The name of the gateway group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.GatewayGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.GatewayGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.GatewayGroupSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of a gateway group.
    public struct GatewayGroupSummary {
        /// The ARN of the gateway group.
        public var arn: Swift.String?
        /// The description of the gateway group.
        public var description: Swift.String?
        /// The name of the gateway group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.GatewaySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.GatewaySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.GatewaySummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.gatewayGroupArn = try reader["GatewayGroupArn"].readIfPresent()
        value.softwareVersion = try reader["SoftwareVersion"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of a gateway.
    public struct GatewaySummary {
        /// The ARN of the gateway.
        public var arn: Swift.String?
        /// The description of the gateway.
        public var description: Swift.String?
        /// The ARN of the gateway group that the gateway is associated to.
        public var gatewayGroupArn: Swift.String?
        /// The name of the gateway.
        public var name: Swift.String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public var softwareVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            gatewayGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }
    }

}

extension GetAddressBookInput {

    static func urlPathProvider(_ value: GetAddressBookInput) -> Swift.String? {
        return "/"
    }
}

extension GetAddressBookInput {

    static func write(value: GetAddressBookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressBookArn"].write(value.addressBookArn)
    }
}

public struct GetAddressBookInput {
    /// The ARN of the address book for which to request details.
    /// This member is required.
    public var addressBookArn: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

extension GetAddressBookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAddressBookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAddressBookOutput()
        value.addressBook = try reader["AddressBook"].readIfPresent(with: AlexaForBusinessClientTypes.AddressBook.read(from:))
        return value
    }
}

public struct GetAddressBookOutput {
    /// The details of the requested address book.
    public var addressBook: AlexaForBusinessClientTypes.AddressBook?

    public init(
        addressBook: AlexaForBusinessClientTypes.AddressBook? = nil
    )
    {
        self.addressBook = addressBook
    }
}

enum GetAddressBookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetConferencePreferenceInput {

    static func urlPathProvider(_ value: GetConferencePreferenceInput) -> Swift.String? {
        return "/"
    }
}

extension GetConferencePreferenceInput {

    static func write(value: GetConferencePreferenceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

public struct GetConferencePreferenceInput {

    public init() { }
}

extension GetConferencePreferenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetConferencePreferenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConferencePreferenceOutput()
        value.preference = try reader["Preference"].readIfPresent(with: AlexaForBusinessClientTypes.ConferencePreference.read(from:))
        return value
    }
}

public struct GetConferencePreferenceOutput {
    /// The conference preference.
    public var preference: AlexaForBusinessClientTypes.ConferencePreference?

    public init(
        preference: AlexaForBusinessClientTypes.ConferencePreference? = nil
    )
    {
        self.preference = preference
    }
}

enum GetConferencePreferenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetConferenceProviderInput {

    static func urlPathProvider(_ value: GetConferenceProviderInput) -> Swift.String? {
        return "/"
    }
}

extension GetConferenceProviderInput {

    static func write(value: GetConferenceProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConferenceProviderArn"].write(value.conferenceProviderArn)
    }
}

public struct GetConferenceProviderInput {
    /// The ARN of the newly created conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?

    public init(
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

extension GetConferenceProviderOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetConferenceProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConferenceProviderOutput()
        value.conferenceProvider = try reader["ConferenceProvider"].readIfPresent(with: AlexaForBusinessClientTypes.ConferenceProvider.read(from:))
        return value
    }
}

public struct GetConferenceProviderOutput {
    /// The conference provider.
    public var conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider?

    public init(
        conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider? = nil
    )
    {
        self.conferenceProvider = conferenceProvider
    }
}

enum GetConferenceProviderOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetContactInput {

    static func urlPathProvider(_ value: GetContactInput) -> Swift.String? {
        return "/"
    }
}

extension GetContactInput {

    static func write(value: GetContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactArn"].write(value.contactArn)
    }
}

public struct GetContactInput {
    /// The ARN of the contact for which to request details.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

extension GetContactOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContactOutput()
        value.contact = try reader["Contact"].readIfPresent(with: AlexaForBusinessClientTypes.Contact.read(from:))
        return value
    }
}

public struct GetContactOutput {
    /// The details of the requested contact.
    public var contact: AlexaForBusinessClientTypes.Contact?

    public init(
        contact: AlexaForBusinessClientTypes.Contact? = nil
    )
    {
        self.contact = contact
    }
}

enum GetContactOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDeviceInput {

    static func urlPathProvider(_ value: GetDeviceInput) -> Swift.String? {
        return "/"
    }
}

extension GetDeviceInput {

    static func write(value: GetDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
    }
}

public struct GetDeviceInput {
    /// The ARN of the device for which to request details. Required.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

extension GetDeviceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceOutput()
        value.device = try reader["Device"].readIfPresent(with: AlexaForBusinessClientTypes.Device.read(from:))
        return value
    }
}

public struct GetDeviceOutput {
    /// The details of the device requested. Required.
    public var device: AlexaForBusinessClientTypes.Device?

    public init(
        device: AlexaForBusinessClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

enum GetDeviceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGatewayGroupInput {

    static func urlPathProvider(_ value: GetGatewayGroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetGatewayGroupInput {

    static func write(value: GetGatewayGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayGroupArn"].write(value.gatewayGroupArn)
    }
}

public struct GetGatewayGroupInput {
    /// The ARN of the gateway group to get.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

extension GetGatewayGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGatewayGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayGroupOutput()
        value.gatewayGroup = try reader["GatewayGroup"].readIfPresent(with: AlexaForBusinessClientTypes.GatewayGroup.read(from:))
        return value
    }
}

public struct GetGatewayGroupOutput {
    /// The details of the gateway group.
    public var gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup?

    public init(
        gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup? = nil
    )
    {
        self.gatewayGroup = gatewayGroup
    }
}

enum GetGatewayGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGatewayInput {

    static func urlPathProvider(_ value: GetGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension GetGatewayInput {

    static func write(value: GetGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayArn"].write(value.gatewayArn)
    }
}

public struct GetGatewayInput {
    /// The ARN of the gateway to get.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

extension GetGatewayOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGatewayOutput()
        value.gateway = try reader["Gateway"].readIfPresent(with: AlexaForBusinessClientTypes.Gateway.read(from:))
        return value
    }
}

public struct GetGatewayOutput {
    /// The details of the gateway.
    public var gateway: AlexaForBusinessClientTypes.Gateway?

    public init(
        gateway: AlexaForBusinessClientTypes.Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

enum GetGatewayOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetInvitationConfigurationInput {

    static func urlPathProvider(_ value: GetInvitationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetInvitationConfigurationInput {

    static func write(value: GetInvitationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

public struct GetInvitationConfigurationInput {

    public init() { }
}

extension GetInvitationConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetInvitationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvitationConfigurationOutput()
        value.contactEmail = try reader["ContactEmail"].readIfPresent()
        value.organizationName = try reader["OrganizationName"].readIfPresent()
        value.privateSkillIds = try reader["PrivateSkillIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct GetInvitationConfigurationOutput {
    /// The email ID of the organization or individual contact that the enrolled user can use.
    public var contactEmail: Swift.String?
    /// The name of the organization sending the enrollment invite to a user.
    public var organizationName: Swift.String?
    /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
    public var privateSkillIds: [Swift.String]?

    public init(
        contactEmail: Swift.String? = nil,
        organizationName: Swift.String? = nil,
        privateSkillIds: [Swift.String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

enum GetInvitationConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetNetworkProfileInput {

    static func urlPathProvider(_ value: GetNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetNetworkProfileInput {

    static func write(value: GetNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NetworkProfileArn"].write(value.networkProfileArn)
    }
}

public struct GetNetworkProfileInput {
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init(
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

extension GetNetworkProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetNetworkProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkProfileOutput()
        value.networkProfile = try reader["NetworkProfile"].readIfPresent(with: AlexaForBusinessClientTypes.NetworkProfile.read(from:))
        return value
    }
}

public struct GetNetworkProfileOutput {
    /// The network profile associated with a device.
    public var networkProfile: AlexaForBusinessClientTypes.NetworkProfile?

    public init(
        networkProfile: AlexaForBusinessClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

enum GetNetworkProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidSecretsManagerResourceException": return try InvalidSecretsManagerResourceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetProfileInput {

    static func urlPathProvider(_ value: GetProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetProfileInput {

    static func write(value: GetProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileArn"].write(value.profileArn)
    }
}

public struct GetProfileInput {
    /// The ARN of the room profile for which to request details. Required.
    public var profileArn: Swift.String?

    public init(
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

extension GetProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileOutput()
        value.profile = try reader["Profile"].readIfPresent(with: AlexaForBusinessClientTypes.Profile.read(from:))
        return value
    }
}

public struct GetProfileOutput {
    /// The details of the room profile requested. Required.
    public var profile: AlexaForBusinessClientTypes.Profile?

    public init(
        profile: AlexaForBusinessClientTypes.Profile? = nil
    )
    {
        self.profile = profile
    }
}

enum GetProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRoomInput {

    static func urlPathProvider(_ value: GetRoomInput) -> Swift.String? {
        return "/"
    }
}

extension GetRoomInput {

    static func write(value: GetRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
    }
}

public struct GetRoomInput {
    /// The ARN of the room for which to request details. Required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

extension GetRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRoomOutput()
        value.room = try reader["Room"].readIfPresent(with: AlexaForBusinessClientTypes.Room.read(from:))
        return value
    }
}

public struct GetRoomOutput {
    /// The details of the room requested.
    public var room: AlexaForBusinessClientTypes.Room?

    public init(
        room: AlexaForBusinessClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

enum GetRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRoomSkillParameterInput {

    static func urlPathProvider(_ value: GetRoomSkillParameterInput) -> Swift.String? {
        return "/"
    }
}

extension GetRoomSkillParameterInput {

    static func write(value: GetRoomSkillParameterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterKey"].write(value.parameterKey)
        try writer["RoomArn"].write(value.roomArn)
        try writer["SkillId"].write(value.skillId)
    }
}

public struct GetRoomSkillParameterInput {
    /// The room skill parameter key for which to get details. Required.
    /// This member is required.
    public var parameterKey: Swift.String?
    /// The ARN of the room from which to get the room skill parameter details.
    public var roomArn: Swift.String?
    /// The ARN of the skill from which to get the room skill parameter details. Required.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        parameterKey: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

extension GetRoomSkillParameterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRoomSkillParameterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRoomSkillParameterOutput()
        value.roomSkillParameter = try reader["RoomSkillParameter"].readIfPresent(with: AlexaForBusinessClientTypes.RoomSkillParameter.read(from:))
        return value
    }
}

public struct GetRoomSkillParameterOutput {
    /// The details of the room skill parameter requested. Required.
    public var roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?

    public init(
        roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter? = nil
    )
    {
        self.roomSkillParameter = roomSkillParameter
    }
}

enum GetRoomSkillParameterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSkillGroupInput {

    static func urlPathProvider(_ value: GetSkillGroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetSkillGroupInput {

    static func write(value: GetSkillGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillGroupArn"].write(value.skillGroupArn)
    }
}

public struct GetSkillGroupInput {
    /// The ARN of the skill group for which to get details. Required.
    public var skillGroupArn: Swift.String?

    public init(
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

extension GetSkillGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSkillGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSkillGroupOutput()
        value.skillGroup = try reader["SkillGroup"].readIfPresent(with: AlexaForBusinessClientTypes.SkillGroup.read(from:))
        return value
    }
}

public struct GetSkillGroupOutput {
    /// The details of the skill group requested. Required.
    public var skillGroup: AlexaForBusinessClientTypes.SkillGroup?

    public init(
        skillGroup: AlexaForBusinessClientTypes.SkillGroup? = nil
    )
    {
        self.skillGroup = skillGroup
    }
}

enum GetSkillGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.IPDialIn {

    static func write(value: AlexaForBusinessClientTypes.IPDialIn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommsProtocol"].write(value.commsProtocol)
        try writer["Endpoint"].write(value.endpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.IPDialIn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.IPDialIn()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.commsProtocol = try reader["CommsProtocol"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The IP endpoint and protocol for calling.
    public struct IPDialIn {
        /// The protocol, including SIP, SIPS, and H323.
        /// This member is required.
        public var commsProtocol: AlexaForBusinessClientTypes.CommsProtocol?
        /// The IP address.
        /// This member is required.
        public var endpoint: Swift.String?

        public init(
            commsProtocol: AlexaForBusinessClientTypes.CommsProtocol? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.commsProtocol = commsProtocol
            self.endpoint = endpoint
        }
    }

}

extension AlexaForBusinessClientTypes.InstantBooking {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.InstantBooking {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.InstantBooking()
        value.durationInMinutes = try reader["DurationInMinutes"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the instant booking feature that are applied to a room profile. When users start their meeting with Alexa, Alexa automatically books the room for the configured duration if the room is available.
    public struct InstantBooking {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension InvalidCertificateAuthorityException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCertificateAuthorityException {
        let reader = baseError.errorBodyReader
        var value = InvalidCertificateAuthorityException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The Certificate Authority can't issue or revoke a certificate.
public struct InvalidCertificateAuthorityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificateAuthorityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidDeviceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDeviceException {
        let reader = baseError.errorBodyReader
        var value = InvalidDeviceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The device is in an invalid state.
public struct InvalidDeviceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeviceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSecretsManagerResourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSecretsManagerResourceException {
        let reader = baseError.errorBodyReader
        var value = InvalidSecretsManagerResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A password in SecretsManager is in an invalid state.
public struct InvalidSecretsManagerResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecretsManagerResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidServiceLinkedRoleStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidServiceLinkedRoleStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidServiceLinkedRoleStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The service linked role is locked for deletion.
public struct InvalidServiceLinkedRoleStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidServiceLinkedRoleStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidUserStatusException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidUserStatusException {
        let reader = baseError.errorBodyReader
        var value = InvalidUserStatusException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The attempt to update a user is invalid due to the user's current status.
public struct InvalidUserStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUserStatusException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You are performing an action that would put you beyond your account's limits.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListBusinessReportSchedulesInput {

    static func urlPathProvider(_ value: ListBusinessReportSchedulesInput) -> Swift.String? {
        return "/"
    }
}

extension ListBusinessReportSchedulesInput {

    static func write(value: ListBusinessReportSchedulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListBusinessReportSchedulesInput {
    /// The maximum number of schedules listed in the call.
    public var maxResults: Swift.Int?
    /// The token used to list the remaining schedules from the previous API call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListBusinessReportSchedulesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListBusinessReportSchedulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBusinessReportSchedulesOutput()
        value.businessReportSchedules = try reader["BusinessReportSchedules"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.BusinessReportSchedule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListBusinessReportSchedulesOutput {
    /// The schedule of the reports.
    public var businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]?
    /// The token used to list the remaining schedules from the previous API call.
    public var nextToken: Swift.String?

    public init(
        businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.businessReportSchedules = businessReportSchedules
        self.nextToken = nextToken
    }
}

enum ListBusinessReportSchedulesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListConferenceProvidersInput {

    static func urlPathProvider(_ value: ListConferenceProvidersInput) -> Swift.String? {
        return "/"
    }
}

extension ListConferenceProvidersInput {

    static func write(value: ListConferenceProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListConferenceProvidersInput {
    /// The maximum number of conference providers to be returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListConferenceProvidersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListConferenceProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConferenceProvidersOutput()
        value.conferenceProviders = try reader["ConferenceProviders"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.ConferenceProvider.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListConferenceProvidersOutput {
    /// The conference providers.
    public var conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conferenceProviders = conferenceProviders
        self.nextToken = nextToken
    }
}

enum ListConferenceProvidersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDeviceEventsInput {

    static func urlPathProvider(_ value: ListDeviceEventsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDeviceEventsInput {

    static func write(value: ListDeviceEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
        try writer["EventType"].write(value.eventType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListDeviceEventsInput {
    /// The ARN of a device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The event type to filter device events. If EventType isn't specified, this returns a list of all device events in reverse chronological order. If EventType is specified, this returns a list of device events for that EventType in reverse chronological order.
    public var eventType: AlexaForBusinessClientTypes.DeviceEventType?
    /// The maximum number of results to include in the response. The default value is 50. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults. When the end of results is reached, the response has a value of null.
    public var nextToken: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        eventType: AlexaForBusinessClientTypes.DeviceEventType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDeviceEventsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDeviceEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceEventsOutput()
        value.deviceEvents = try reader["DeviceEvents"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.DeviceEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDeviceEventsOutput {
    /// The device events requested for the device ARN.
    public var deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?

    public init(
        deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceEvents = deviceEvents
        self.nextToken = nextToken
    }
}

enum ListDeviceEventsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListGatewayGroupsInput {

    static func urlPathProvider(_ value: ListGatewayGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListGatewayGroupsInput {

    static func write(value: ListGatewayGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListGatewayGroupsInput {
    /// The maximum number of gateway group summaries to return. The default is 50.
    public var maxResults: Swift.Int?
    /// The token used to paginate though multiple pages of gateway group summaries.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGatewayGroupsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGatewayGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewayGroupsOutput()
        value.gatewayGroups = try reader["GatewayGroups"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.GatewayGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListGatewayGroupsOutput {
    /// The gateway groups in the list.
    public var gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]?
    /// The token used to paginate though multiple pages of gateway group summaries.
    public var nextToken: Swift.String?

    public init(
        gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayGroups = gatewayGroups
        self.nextToken = nextToken
    }
}

enum ListGatewayGroupsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/"
    }
}

extension ListGatewaysInput {

    static func write(value: ListGatewaysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayGroupArn"].write(value.gatewayGroupArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListGatewaysInput {
    /// The gateway group ARN for which to list gateways.
    public var gatewayGroupArn: Swift.String?
    /// The maximum number of gateway summaries to return. The default is 50.
    public var maxResults: Swift.Int?
    /// The token used to paginate though multiple pages of gateway summaries.
    public var nextToken: Swift.String?

    public init(
        gatewayGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.gateways = try reader["Gateways"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.GatewaySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListGatewaysOutput {
    /// The gateways in the list.
    public var gateways: [AlexaForBusinessClientTypes.GatewaySummary]?
    /// The token used to paginate though multiple pages of gateway summaries.
    public var nextToken: Swift.String?

    public init(
        gateways: [AlexaForBusinessClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSkillsInput {

    static func urlPathProvider(_ value: ListSkillsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSkillsInput {

    static func write(value: ListSkillsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnablementType"].write(value.enablementType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SkillGroupArn"].write(value.skillGroupArn)
        try writer["SkillType"].write(value.skillType)
    }
}

public struct ListSkillsInput {
    /// Whether the skill is enabled under the user's account.
    public var enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The ARN of the skill group for which to list enabled skills.
    public var skillGroupArn: Swift.String?
    /// Whether the skill is publicly available or is a private skill.
    public var skillType: AlexaForBusinessClientTypes.SkillTypeFilter?

    public init(
        enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil,
        skillType: AlexaForBusinessClientTypes.SkillTypeFilter? = nil
    )
    {
        self.enablementType = enablementType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.skillGroupArn = skillGroupArn
        self.skillType = skillType
    }
}

extension ListSkillsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSkillsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSkillsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.skillSummaries = try reader["SkillSummaries"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.SkillSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSkillsOutput {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The list of enabled skills requested. Required.
    public var skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]?

    public init(
        nextToken: Swift.String? = nil,
        skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillSummaries = skillSummaries
    }
}

enum ListSkillsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSkillsStoreCategoriesInput {

    static func urlPathProvider(_ value: ListSkillsStoreCategoriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSkillsStoreCategoriesInput {

    static func write(value: ListSkillsStoreCategoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListSkillsStoreCategoriesInput {
    /// The maximum number of categories returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSkillsStoreCategoriesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSkillsStoreCategoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSkillsStoreCategoriesOutput()
        value.categoryList = try reader["CategoryList"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListSkillsStoreCategoriesOutput {
    /// The list of categories.
    public var categoryList: [AlexaForBusinessClientTypes.Category]?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        categoryList: [AlexaForBusinessClientTypes.Category]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categoryList = categoryList
        self.nextToken = nextToken
    }
}

enum ListSkillsStoreCategoriesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSkillsStoreSkillsByCategoryInput {

    static func urlPathProvider(_ value: ListSkillsStoreSkillsByCategoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListSkillsStoreSkillsByCategoryInput {

    static func write(value: ListSkillsStoreSkillsByCategoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryId"].write(value.categoryId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListSkillsStoreSkillsByCategoryInput {
    /// The category ID for which the skills are being retrieved from the skill store.
    /// This member is required.
    public var categoryId: Swift.Int?
    /// The maximum number of skills returned per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init(
        categoryId: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categoryId = categoryId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSkillsStoreSkillsByCategoryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSkillsStoreSkillsByCategoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSkillsStoreSkillsByCategoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.skillsStoreSkills = try reader["SkillsStoreSkills"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.SkillsStoreSkill.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSkillsStoreSkillsByCategoryOutput {
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The skill store skills.
    public var skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]?

    public init(
        nextToken: Swift.String? = nil,
        skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillsStoreSkills = skillsStoreSkills
    }
}

enum ListSkillsStoreSkillsByCategoryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSmartHomeAppliancesInput {

    static func urlPathProvider(_ value: ListSmartHomeAppliancesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSmartHomeAppliancesInput {

    static func write(value: ListSmartHomeAppliancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RoomArn"].write(value.roomArn)
    }
}

public struct ListSmartHomeAppliancesInput {
    /// The maximum number of appliances to be returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The room that the appliances are associated with.
    /// This member is required.
    public var roomArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roomArn = roomArn
    }
}

extension ListSmartHomeAppliancesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSmartHomeAppliancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSmartHomeAppliancesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.smartHomeAppliances = try reader["SmartHomeAppliances"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.SmartHomeAppliance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSmartHomeAppliancesOutput {
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The smart home appliances.
    public var smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]?

    public init(
        nextToken: Swift.String? = nil,
        smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]? = nil
    )
    {
        self.nextToken = nextToken
        self.smartHomeAppliances = smartHomeAppliances
    }
}

enum ListSmartHomeAppliancesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsInput {

    static func write(value: ListTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListTagsInput {
    /// The ARN of the specified resource for which to list tags.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTagsOutput {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The tags requested for the specified resource.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.MeetingRoomConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.MeetingRoomConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.MeetingRoomConfiguration()
        value.roomUtilizationMetricsEnabled = try reader["RoomUtilizationMetricsEnabled"].readIfPresent()
        value.endOfMeetingReminder = try reader["EndOfMeetingReminder"].readIfPresent(with: AlexaForBusinessClientTypes.EndOfMeetingReminder.read(from:))
        value.instantBooking = try reader["InstantBooking"].readIfPresent(with: AlexaForBusinessClientTypes.InstantBooking.read(from:))
        value.requireCheckIn = try reader["RequireCheckIn"].readIfPresent(with: AlexaForBusinessClientTypes.RequireCheckIn.read(from:))
        value.proactiveJoin = try reader["ProactiveJoin"].readIfPresent(with: AlexaForBusinessClientTypes.ProactiveJoin.read(from:))
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Meeting room settings of a room profile.
    public struct MeetingRoomConfiguration {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.EndOfMeetingReminder?
        /// Settings to automatically book the room if available for a configured duration when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.InstantBooking?
        public var proactiveJoin: AlexaForBusinessClientTypes.ProactiveJoin?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into. This makes the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.RequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init(
            endOfMeetingReminder: AlexaForBusinessClientTypes.EndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.InstantBooking? = nil,
            proactiveJoin: AlexaForBusinessClientTypes.ProactiveJoin? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.RequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.proactiveJoin = proactiveJoin
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension AlexaForBusinessClientTypes.MeetingSetting {

    static func write(value: AlexaForBusinessClientTypes.MeetingSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RequirePin"].write(value.requirePin)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.MeetingSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.MeetingSetting()
        value.requirePin = try reader["RequirePin"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The values that indicate whether a pin is always required (YES), never required (NO), or OPTIONAL.
    ///
    /// * If YES, Alexa will always ask for a meeting pin.
    ///
    /// * If NO, Alexa will never ask for a meeting pin.
    ///
    /// * If OPTIONAL, Alexa will ask if you have a meeting pin and if the customer responds with yes, it will ask for the meeting pin.
    public struct MeetingSetting {
        /// The values that indicate whether the pin is always required.
        /// This member is required.
        public var requirePin: AlexaForBusinessClientTypes.RequirePin?

        public init(
            requirePin: AlexaForBusinessClientTypes.RequirePin? = nil
        )
        {
            self.requirePin = requirePin
        }
    }

}

extension NameInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NameInUseException {
        let reader = baseError.errorBodyReader
        var value = NameInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The name sent in the request is already in use.
public struct NameInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NameInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AlexaForBusinessClientTypes {

    public enum NetworkEapMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eapTls
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkEapMethod] {
            return [
                .eapTls,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eapTls: return "EAP_TLS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.NetworkProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkProfile(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), description: \(Swift.String(describing: description)), eapMethod: \(Swift.String(describing: eapMethod)), networkProfileArn: \(Swift.String(describing: networkProfileArn)), networkProfileName: \(Swift.String(describing: networkProfileName)), securityType: \(Swift.String(describing: securityType)), ssid: \(Swift.String(describing: ssid)), trustAnchors: \(Swift.String(describing: trustAnchors)), currentPassword: \"CONTENT_REDACTED\", nextPassword: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes.NetworkProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.NetworkProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.NetworkProfile()
        value.networkProfileArn = try reader["NetworkProfileArn"].readIfPresent()
        value.networkProfileName = try reader["NetworkProfileName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.ssid = try reader["Ssid"].readIfPresent()
        value.securityType = try reader["SecurityType"].readIfPresent()
        value.eapMethod = try reader["EapMethod"].readIfPresent()
        value.currentPassword = try reader["CurrentPassword"].readIfPresent()
        value.nextPassword = try reader["NextPassword"].readIfPresent()
        value.certificateAuthorityArn = try reader["CertificateAuthorityArn"].readIfPresent()
        value.trustAnchors = try reader["TrustAnchors"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The network profile associated with a device.
    public struct NetworkProfile {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public var certificateAuthorityArn: Swift.String?
        /// The current password of the Wi-Fi network.
        public var currentPassword: Swift.String?
        /// Detailed information about a device's network profile.
        public var description: Swift.String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
        public var nextPassword: Swift.String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public var ssid: Swift.String?
        /// The root certificates of your authentication server, which is installed on your devices and used to trust your authentication server during EAP negotiation.
        public var trustAnchors: [Swift.String]?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            currentPassword: Swift.String? = nil,
            description: Swift.String? = nil,
            eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            nextPassword: Swift.String? = nil,
            securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
            ssid: Swift.String? = nil,
            trustAnchors: [Swift.String]? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.currentPassword = currentPassword
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.nextPassword = nextPassword
            self.securityType = securityType
            self.ssid = ssid
            self.trustAnchors = trustAnchors
        }
    }

}

extension AlexaForBusinessClientTypes.NetworkProfileData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.NetworkProfileData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.NetworkProfileData()
        value.networkProfileArn = try reader["NetworkProfileArn"].readIfPresent()
        value.networkProfileName = try reader["NetworkProfileName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.ssid = try reader["Ssid"].readIfPresent()
        value.securityType = try reader["SecurityType"].readIfPresent()
        value.eapMethod = try reader["EapMethod"].readIfPresent()
        value.certificateAuthorityArn = try reader["CertificateAuthorityArn"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The data associated with a network profile.
    public struct NetworkProfileData {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public var certificateAuthorityArn: Swift.String?
        /// Detailed information about a device's network profile.
        public var description: Swift.String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public var ssid: Swift.String?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            description: Swift.String? = nil,
            eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
            ssid: Swift.String? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.securityType = securityType
            self.ssid = ssid
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum NetworkSecurityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `open`
        case wep
        case wpa2Enterprise
        case wpa2Psk
        case wpaPsk
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSecurityType] {
            return [
                .open,
                .wep,
                .wpa2Enterprise,
                .wpa2Psk,
                .wpaPsk,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .open: return "OPEN"
            case .wep: return "WEP"
            case .wpa2Enterprise: return "WPA2_ENTERPRISE"
            case .wpa2Psk: return "WPA2_PSK"
            case .wpaPsk: return "WPA_PSK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The resource is not found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AlexaForBusinessClientTypes.PSTNDialIn {

    static func write(value: AlexaForBusinessClientTypes.PSTNDialIn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CountryCode"].write(value.countryCode)
        try writer["OneClickIdDelay"].write(value.oneClickIdDelay)
        try writer["OneClickPinDelay"].write(value.oneClickPinDelay)
        try writer["PhoneNumber"].write(value.phoneNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.PSTNDialIn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.PSTNDialIn()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.oneClickIdDelay = try reader["OneClickIdDelay"].readIfPresent()
        value.oneClickPinDelay = try reader["OneClickPinDelay"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The information for public switched telephone network (PSTN) conferencing.
    public struct PSTNDialIn {
        /// The zip code.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The delay duration before Alexa enters the conference ID with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        /// This member is required.
        public var oneClickIdDelay: Swift.String?
        /// The delay duration before Alexa enters the conference pin with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        /// This member is required.
        public var oneClickPinDelay: Swift.String?
        /// The phone number to call to join the conference.
        /// This member is required.
        public var phoneNumber: Swift.String?

        public init(
            countryCode: Swift.String? = nil,
            oneClickIdDelay: Swift.String? = nil,
            oneClickPinDelay: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.oneClickIdDelay = oneClickIdDelay
            self.oneClickPinDelay = oneClickPinDelay
            self.phoneNumber = phoneNumber
        }
    }

}

extension AlexaForBusinessClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(number: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes.PhoneNumber {

    static func write(value: AlexaForBusinessClientTypes.PhoneNumber?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Number"].write(value.number)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.PhoneNumber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.PhoneNumber()
        value.number = try reader["Number"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The phone number for the contact containing the raw number and phone number type.
    public struct PhoneNumber {
        /// The raw value of the phone number.
        /// This member is required.
        public var number: Swift.String?
        /// The type of the phone number.
        /// This member is required.
        public var type: AlexaForBusinessClientTypes.PhoneNumberType?

        public init(
            number: Swift.String? = nil,
            type: AlexaForBusinessClientTypes.PhoneNumberType? = nil
        )
        {
            self.number = number
            self.type = type
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case home
        case mobile
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .home,
                .mobile,
                .work,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .home: return "HOME"
            case .mobile: return "MOBILE"
            case .work: return "WORK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.ProactiveJoin {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.ProactiveJoin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.ProactiveJoin()
        value.enabledByMotion = try reader["EnabledByMotion"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    public struct ProactiveJoin {
        public var enabledByMotion: Swift.Bool?

        public init(
            enabledByMotion: Swift.Bool? = nil
        )
        {
            self.enabledByMotion = enabledByMotion
        }
    }

}

extension AlexaForBusinessClientTypes.Profile {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.Profile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.Profile()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent()
        value.address = try reader["Address"].readIfPresent()
        value.timezone = try reader["Timezone"].readIfPresent()
        value.distanceUnit = try reader["DistanceUnit"].readIfPresent()
        value.temperatureUnit = try reader["TemperatureUnit"].readIfPresent()
        value.wakeWord = try reader["WakeWord"].readIfPresent()
        value.locale = try reader["Locale"].readIfPresent()
        value.setupModeDisabled = try reader["SetupModeDisabled"].readIfPresent()
        value.maxVolumeLimit = try reader["MaxVolumeLimit"].readIfPresent()
        value.pstnEnabled = try reader["PSTNEnabled"].readIfPresent()
        value.dataRetentionOptIn = try reader["DataRetentionOptIn"].readIfPresent()
        value.addressBookArn = try reader["AddressBookArn"].readIfPresent()
        value.meetingRoomConfiguration = try reader["MeetingRoomConfiguration"].readIfPresent(with: AlexaForBusinessClientTypes.MeetingRoomConfiguration.read(from:))
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A room profile with attributes.
    public struct Profile {
        /// The address of a room profile.
        public var address: Swift.String?
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// Whether data retention of the profile is enabled.
        public var dataRetentionOptIn: Swift.Bool?
        /// The distance unit of a room profile.
        public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
        /// Retrieves if the profile is default or not.
        public var isDefault: Swift.Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public var locale: Swift.String?
        /// The max volume limit of a room profile.
        public var maxVolumeLimit: Swift.Int?
        /// Meeting room settings of a room profile.
        public var meetingRoomConfiguration: AlexaForBusinessClientTypes.MeetingRoomConfiguration?
        /// The ARN of a room profile.
        public var profileArn: Swift.String?
        /// The name of a room profile.
        public var profileName: Swift.String?
        /// The PSTN setting of a room profile.
        public var pstnEnabled: Swift.Bool?
        /// The setup mode of a room profile.
        public var setupModeDisabled: Swift.Bool?
        /// The temperature unit of a room profile.
        public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
        /// The time zone of a room profile.
        public var timezone: Swift.String?
        /// The wake word of a room profile.
        public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

        public init(
            address: Swift.String? = nil,
            addressBookArn: Swift.String? = nil,
            dataRetentionOptIn: Swift.Bool? = nil,
            distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
            isDefault: Swift.Bool? = nil,
            locale: Swift.String? = nil,
            maxVolumeLimit: Swift.Int? = nil,
            meetingRoomConfiguration: AlexaForBusinessClientTypes.MeetingRoomConfiguration? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            pstnEnabled: Swift.Bool? = nil,
            setupModeDisabled: Swift.Bool? = nil,
            temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
            timezone: Swift.String? = nil,
            wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
        )
        {
            self.address = address
            self.addressBookArn = addressBookArn
            self.dataRetentionOptIn = dataRetentionOptIn
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.maxVolumeLimit = maxVolumeLimit
            self.meetingRoomConfiguration = meetingRoomConfiguration
            self.profileArn = profileArn
            self.profileName = profileName
            self.pstnEnabled = pstnEnabled
            self.setupModeDisabled = setupModeDisabled
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }
    }

}

extension AlexaForBusinessClientTypes.ProfileData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.ProfileData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.ProfileData()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent()
        value.address = try reader["Address"].readIfPresent()
        value.timezone = try reader["Timezone"].readIfPresent()
        value.distanceUnit = try reader["DistanceUnit"].readIfPresent()
        value.temperatureUnit = try reader["TemperatureUnit"].readIfPresent()
        value.wakeWord = try reader["WakeWord"].readIfPresent()
        value.locale = try reader["Locale"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The data of a room profile.
    public struct ProfileData {
        /// The address of a room profile.
        public var address: Swift.String?
        /// The distance unit of a room profile.
        public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
        /// Retrieves if the profile data is default or not.
        public var isDefault: Swift.Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public var locale: Swift.String?
        /// The ARN of a room profile.
        public var profileArn: Swift.String?
        /// The name of a room profile.
        public var profileName: Swift.String?
        /// The temperature unit of a room profile.
        public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
        /// The time zone of a room profile.
        public var timezone: Swift.String?
        /// The wake word of a room profile.
        public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

        public init(
            address: Swift.String? = nil,
            distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
            isDefault: Swift.Bool? = nil,
            locale: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
            timezone: Swift.String? = nil,
            wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
        )
        {
            self.address = address
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.profileArn = profileArn
            self.profileName = profileName
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }
    }

}

extension PutConferencePreferenceInput {

    static func urlPathProvider(_ value: PutConferencePreferenceInput) -> Swift.String? {
        return "/"
    }
}

extension PutConferencePreferenceInput {

    static func write(value: PutConferencePreferenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConferencePreference"].write(value.conferencePreference, with: AlexaForBusinessClientTypes.ConferencePreference.write(value:to:))
    }
}

public struct PutConferencePreferenceInput {
    /// The conference preference of a specific conference provider.
    /// This member is required.
    public var conferencePreference: AlexaForBusinessClientTypes.ConferencePreference?

    public init(
        conferencePreference: AlexaForBusinessClientTypes.ConferencePreference? = nil
    )
    {
        self.conferencePreference = conferencePreference
    }
}

extension PutConferencePreferenceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutConferencePreferenceOutput {
        return PutConferencePreferenceOutput()
    }
}

public struct PutConferencePreferenceOutput {

    public init() { }
}

enum PutConferencePreferenceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutInvitationConfigurationInput {

    static func urlPathProvider(_ value: PutInvitationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutInvitationConfigurationInput {

    static func write(value: PutInvitationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactEmail"].write(value.contactEmail)
        try writer["OrganizationName"].write(value.organizationName)
        try writer["PrivateSkillIds"].writeList(value.privateSkillIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct PutInvitationConfigurationInput {
    /// The email ID of the organization or individual contact that the enrolled user can use.
    public var contactEmail: Swift.String?
    /// The name of the organization sending the enrollment invite to a user.
    /// This member is required.
    public var organizationName: Swift.String?
    /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
    public var privateSkillIds: [Swift.String]?

    public init(
        contactEmail: Swift.String? = nil,
        organizationName: Swift.String? = nil,
        privateSkillIds: [Swift.String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

extension PutInvitationConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutInvitationConfigurationOutput {
        return PutInvitationConfigurationOutput()
    }
}

public struct PutInvitationConfigurationOutput {

    public init() { }
}

enum PutInvitationConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutRoomSkillParameterInput {

    static func urlPathProvider(_ value: PutRoomSkillParameterInput) -> Swift.String? {
        return "/"
    }
}

extension PutRoomSkillParameterInput {

    static func write(value: PutRoomSkillParameterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
        try writer["RoomSkillParameter"].write(value.roomSkillParameter, with: AlexaForBusinessClientTypes.RoomSkillParameter.write(value:to:))
        try writer["SkillId"].write(value.skillId)
    }
}

public struct PutRoomSkillParameterInput {
    /// The ARN of the room associated with the room skill parameter. Required.
    public var roomArn: Swift.String?
    /// The updated room skill parameter. Required.
    /// This member is required.
    public var roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?
    /// The ARN of the skill associated with the room skill parameter. Required.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        roomArn: Swift.String? = nil,
        roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.roomSkillParameter = roomSkillParameter
        self.skillId = skillId
    }
}

extension PutRoomSkillParameterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutRoomSkillParameterOutput {
        return PutRoomSkillParameterOutput()
    }
}

public struct PutRoomSkillParameterOutput {

    public init() { }
}

enum PutRoomSkillParameterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutSkillAuthorizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSkillAuthorizationInput(roomArn: \(Swift.String(describing: roomArn)), skillId: \(Swift.String(describing: skillId)), authorizationResult: \"CONTENT_REDACTED\")"}
}

extension PutSkillAuthorizationInput {

    static func urlPathProvider(_ value: PutSkillAuthorizationInput) -> Swift.String? {
        return "/"
    }
}

extension PutSkillAuthorizationInput {

    static func write(value: PutSkillAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationResult"].writeMap(value.authorizationResult, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RoomArn"].write(value.roomArn)
        try writer["SkillId"].write(value.skillId)
    }
}

public struct PutSkillAuthorizationInput {
    /// The authorization result specific to OAUTH code grant output. "Code must be populated in the AuthorizationResult map to establish the authorization.
    /// This member is required.
    public var authorizationResult: [Swift.String:Swift.String]?
    /// The room that the skill is authorized for.
    public var roomArn: Swift.String?
    /// The unique identifier of a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        authorizationResult: [Swift.String:Swift.String]? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.authorizationResult = authorizationResult
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

extension PutSkillAuthorizationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutSkillAuthorizationOutput {
        return PutSkillAuthorizationOutput()
    }
}

public struct PutSkillAuthorizationOutput {

    public init() { }
}

enum PutSkillAuthorizationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RegisterAVSDeviceInput {

    static func urlPathProvider(_ value: RegisterAVSDeviceInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterAVSDeviceInput {

    static func write(value: RegisterAVSDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonId"].write(value.amazonId)
        try writer["ClientId"].write(value.clientId)
        try writer["DeviceSerialNumber"].write(value.deviceSerialNumber)
        try writer["ProductId"].write(value.productId)
        try writer["RoomArn"].write(value.roomArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserCode"].write(value.userCode)
    }
}

public struct RegisterAVSDeviceInput {
    /// The device type ID for your AVS device generated by Amazon when the OEM creates a new product on Amazon's Developer Console.
    /// This member is required.
    public var amazonId: Swift.String?
    /// The client ID of the OEM used for code-based linking authorization on an AVS device.
    /// This member is required.
    public var clientId: Swift.String?
    /// The key generated by the OEM that uniquely identifies a specified instance of your AVS device.
    public var deviceSerialNumber: Swift.String?
    /// The product ID used to identify your AVS device during authorization.
    /// This member is required.
    public var productId: Swift.String?
    /// The Amazon Resource Name (ARN) of the room with which to associate your AVS device.
    public var roomArn: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The code that is obtained after your AVS device has made a POST request to LWA as a part of the Device Authorization Request component of the OAuth code-based linking specification.
    /// This member is required.
    public var userCode: Swift.String?

    public init(
        amazonId: Swift.String? = nil,
        clientId: Swift.String? = nil,
        deviceSerialNumber: Swift.String? = nil,
        productId: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        userCode: Swift.String? = nil
    )
    {
        self.amazonId = amazonId
        self.clientId = clientId
        self.deviceSerialNumber = deviceSerialNumber
        self.productId = productId
        self.roomArn = roomArn
        self.tags = tags
        self.userCode = userCode
    }
}

extension RegisterAVSDeviceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RegisterAVSDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterAVSDeviceOutput()
        value.deviceArn = try reader["DeviceArn"].readIfPresent()
        return value
    }
}

public struct RegisterAVSDeviceOutput {
    /// The ARN of the device.
    public var deviceArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

enum RegisterAVSDeviceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidDeviceException": return try InvalidDeviceException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RejectSkillInput {

    static func urlPathProvider(_ value: RejectSkillInput) -> Swift.String? {
        return "/"
    }
}

extension RejectSkillInput {

    static func write(value: RejectSkillInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillId"].write(value.skillId)
    }
}

public struct RejectSkillInput {
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init(
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

extension RejectSkillOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RejectSkillOutput {
        return RejectSkillOutput()
    }
}

public struct RejectSkillOutput {

    public init() { }
}

enum RejectSkillOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.RequireCheckIn {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.RequireCheckIn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.RequireCheckIn()
        value.releaseAfterMinutes = try reader["ReleaseAfterMinutes"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct RequireCheckIn {
        /// Whether require check in is enabled or not.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public var releaseAfterMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum RequirePin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case `optional`
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [RequirePin] {
            return [
                .no,
                .optional,
                .yes,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .optional: return "OPTIONAL"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ResolveRoomInput {

    static func urlPathProvider(_ value: ResolveRoomInput) -> Swift.String? {
        return "/"
    }
}

extension ResolveRoomInput {

    static func write(value: ResolveRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkillId"].write(value.skillId)
        try writer["UserId"].write(value.userId)
    }
}

public struct ResolveRoomInput {
    /// The ARN of the skill that was requested. Required.
    /// This member is required.
    public var skillId: Swift.String?
    /// The ARN of the user. Required.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        skillId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.skillId = skillId
        self.userId = userId
    }
}

extension ResolveRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ResolveRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResolveRoomOutput()
        value.roomArn = try reader["RoomArn"].readIfPresent()
        value.roomName = try reader["RoomName"].readIfPresent()
        value.roomSkillParameters = try reader["RoomSkillParameters"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.RoomSkillParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ResolveRoomOutput {
    /// The ARN of the room from which the skill request was invoked.
    public var roomArn: Swift.String?
    /// The name of the room from which the skill request was invoked.
    public var roomName: Swift.String?
    /// Response to get the room profile request. Required.
    public var roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]?

    public init(
        roomArn: Swift.String? = nil,
        roomName: Swift.String? = nil,
        roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]? = nil
    )
    {
        self.roomArn = roomArn
        self.roomName = roomName
        self.roomSkillParameters = roomSkillParameters
    }
}

enum ResolveRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceAssociatedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAssociatedException {
        let reader = baseError.errorBodyReader
        var value = ResourceAssociatedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Another resource is associated with the resource in the request.
public struct ResourceAssociatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAssociatedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.clientRequestToken = try reader["ClientRequestToken"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The resource in the request is already in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A unique, user-specified identifier for the request that ensures idempotency.
        public internal(set) var clientRequestToken: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.clientRequestToken = clientRequestToken
        self.properties.message = message
    }
}

extension RevokeInvitationInput {

    static func urlPathProvider(_ value: RevokeInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension RevokeInvitationInput {

    static func write(value: RevokeInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnrollmentId"].write(value.enrollmentId)
        try writer["UserArn"].write(value.userArn)
    }
}

public struct RevokeInvitationInput {
    /// The ARN of the enrollment invitation to revoke. Required.
    public var enrollmentId: Swift.String?
    /// The ARN of the user for whom to revoke an enrollment invitation. Required.
    public var userArn: Swift.String?

    public init(
        enrollmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

extension RevokeInvitationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RevokeInvitationOutput {
        return RevokeInvitationOutput()
    }
}

public struct RevokeInvitationOutput {

    public init() { }
}

enum RevokeInvitationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.Room {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.Room {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.Room()
        value.roomArn = try reader["RoomArn"].readIfPresent()
        value.roomName = try reader["RoomName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.providerCalendarId = try reader["ProviderCalendarId"].readIfPresent()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A room with attributes.
    public struct Room {
        /// The description of a room.
        public var description: Swift.String?
        /// The profile ARN of a room.
        public var profileArn: Swift.String?
        /// The provider calendar ARN of a room.
        public var providerCalendarId: Swift.String?
        /// The ARN of a room.
        public var roomArn: Swift.String?
        /// The name of a room.
        public var roomName: Swift.String?

        public init(
            description: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            providerCalendarId: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil
        )
        {
            self.description = description
            self.profileArn = profileArn
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }
    }

}

extension AlexaForBusinessClientTypes.RoomData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.RoomData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.RoomData()
        value.roomArn = try reader["RoomArn"].readIfPresent()
        value.roomName = try reader["RoomName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.providerCalendarId = try reader["ProviderCalendarId"].readIfPresent()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The data of a room.
    public struct RoomData {
        /// The description of a room.
        public var description: Swift.String?
        /// The profile ARN of a room.
        public var profileArn: Swift.String?
        /// The profile name of a room.
        public var profileName: Swift.String?
        /// The provider calendar ARN of a room.
        public var providerCalendarId: Swift.String?
        /// The ARN of a room.
        public var roomArn: Swift.String?
        /// The name of a room.
        public var roomName: Swift.String?

        public init(
            description: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            providerCalendarId: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil
        )
        {
            self.description = description
            self.profileArn = profileArn
            self.profileName = profileName
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }
    }

}

extension AlexaForBusinessClientTypes.RoomSkillParameter {

    static func write(value: AlexaForBusinessClientTypes.RoomSkillParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterKey"].write(value.parameterKey)
        try writer["ParameterValue"].write(value.parameterValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.RoomSkillParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.RoomSkillParameter()
        value.parameterKey = try reader["ParameterKey"].readIfPresent()
        value.parameterValue = try reader["ParameterValue"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A skill parameter associated with a room.
    public struct RoomSkillParameter {
        /// The parameter key of a room skill parameter. ParameterKey is an enumerated type that only takes DEFAULT or SCOPE as valid values.
        /// This member is required.
        public var parameterKey: Swift.String?
        /// The parameter value of a room skill parameter.
        /// This member is required.
        public var parameterValue: Swift.String?

        public init(
            parameterKey: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }
    }

}

extension SearchAddressBooksInput {

    static func urlPathProvider(_ value: SearchAddressBooksInput) -> Swift.String? {
        return "/"
    }
}

extension SearchAddressBooksInput {

    static func write(value: SearchAddressBooksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchAddressBooksInput {
    /// The filters to use to list a specified set of address books. The supported filter key is AddressBookName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of address books. The supported sort key is AddressBookName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchAddressBooksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchAddressBooksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchAddressBooksOutput()
        value.addressBooks = try reader["AddressBooks"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.AddressBookData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

public struct SearchAddressBooksOutput {
    /// The address books that meet the specified set of filter criteria, in sort order.
    public var addressBooks: [AlexaForBusinessClientTypes.AddressBookData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of address books returned.
    public var totalCount: Swift.Int?

    public init(
        addressBooks: [AlexaForBusinessClientTypes.AddressBookData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.addressBooks = addressBooks
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

enum SearchAddressBooksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchContactsInput {

    static func urlPathProvider(_ value: SearchContactsInput) -> Swift.String? {
        return "/"
    }
}

extension SearchContactsInput {

    static func write(value: SearchContactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchContactsInput {
    /// The filters to use to list a specified set of address books. The supported filter keys are DisplayName, FirstName, LastName, and AddressBookArns.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of contacts. The supported sort keys are DisplayName, FirstName, and LastName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchContactsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchContactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchContactsOutput()
        value.contacts = try reader["Contacts"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.ContactData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

public struct SearchContactsOutput {
    /// The contacts that meet the specified set of filter criteria, in sort order.
    public var contacts: [AlexaForBusinessClientTypes.ContactData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of contacts returned.
    public var totalCount: Swift.Int?

    public init(
        contacts: [AlexaForBusinessClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

enum SearchContactsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchDevicesInput {

    static func urlPathProvider(_ value: SearchDevicesInput) -> Swift.String? {
        return "/"
    }
}

extension SearchDevicesInput {

    static func write(value: SearchDevicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchDevicesInput {
    /// The filters to use to list a specified set of devices. Supported filter keys are DeviceName, DeviceStatus, DeviceStatusDetailCode, RoomName, DeviceType, DeviceSerialNumber, UnassociatedOnly, ConnectionStatus (ONLINE and OFFLINE), NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of devices. Supported sort keys are DeviceName, DeviceStatus, RoomName, DeviceType, DeviceSerialNumber, ConnectionStatus, NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchDevicesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchDevicesOutput()
        value.devices = try reader["Devices"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.DeviceData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

public struct SearchDevicesOutput {
    /// The devices that meet the specified set of filter criteria, in sort order.
    public var devices: [AlexaForBusinessClientTypes.DeviceData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of devices returned.
    public var totalCount: Swift.Int?

    public init(
        devices: [AlexaForBusinessClientTypes.DeviceData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

enum SearchDevicesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchNetworkProfilesInput {

    static func urlPathProvider(_ value: SearchNetworkProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension SearchNetworkProfilesInput {

    static func write(value: SearchNetworkProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchNetworkProfilesInput {
    /// The filters to use to list a specified set of network profiles. Valid filters are NetworkProfileName, Ssid, and SecurityType.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use to list the specified set of network profiles. Valid sort criteria includes NetworkProfileName, Ssid, and SecurityType.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchNetworkProfilesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchNetworkProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchNetworkProfilesOutput()
        value.networkProfiles = try reader["NetworkProfiles"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.NetworkProfileData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

public struct SearchNetworkProfilesOutput {
    /// The network profiles that meet the specified set of filter criteria, in sort order. It is a list of NetworkProfileData objects.
    public var networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The total number of network profiles returned.
    public var totalCount: Swift.Int?

    public init(
        networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

enum SearchNetworkProfilesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchProfilesInput {

    static func urlPathProvider(_ value: SearchProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension SearchProfilesInput {

    static func write(value: SearchProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchProfilesInput {
    /// The filters to use to list a specified set of room profiles. Supported filter keys are ProfileName and Address. Required.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of room profiles. Supported sort keys are ProfileName and Address.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchProfilesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchProfilesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.ProfileData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

public struct SearchProfilesOutput {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The profiles that meet the specified set of filter criteria, in sort order.
    public var profiles: [AlexaForBusinessClientTypes.ProfileData]?
    /// The total number of room profiles returned.
    public var totalCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [AlexaForBusinessClientTypes.ProfileData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
        self.totalCount = totalCount
    }
}

enum SearchProfilesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchRoomsInput {

    static func urlPathProvider(_ value: SearchRoomsInput) -> Swift.String? {
        return "/"
    }
}

extension SearchRoomsInput {

    static func write(value: SearchRoomsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchRoomsInput {
    /// The filters to use to list a specified set of rooms. The supported filter keys are RoomName and ProfileName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of rooms. The supported sort keys are RoomName and ProfileName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchRoomsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchRoomsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchRoomsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rooms = try reader["Rooms"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.RoomData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

public struct SearchRoomsOutput {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The rooms that meet the specified set of filter criteria, in sort order.
    public var rooms: [AlexaForBusinessClientTypes.RoomData]?
    /// The total number of rooms returned.
    public var totalCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        rooms: [AlexaForBusinessClientTypes.RoomData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
        self.totalCount = totalCount
    }
}

enum SearchRoomsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchSkillGroupsInput {

    static func urlPathProvider(_ value: SearchSkillGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension SearchSkillGroupsInput {

    static func write(value: SearchSkillGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchSkillGroupsInput {
    /// The filters to use to list a specified set of skill groups. The supported filter key is SkillGroupName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of skill groups. The supported sort key is SkillGroupName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchSkillGroupsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchSkillGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSkillGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.skillGroups = try reader["SkillGroups"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.SkillGroupData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

public struct SearchSkillGroupsOutput {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The skill groups that meet the filter criteria, in sort order.
    public var skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]?
    /// The total number of skill groups returned.
    public var totalCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.skillGroups = skillGroups
        self.totalCount = totalCount
    }
}

enum SearchSkillGroupsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SearchUsersInput {

    static func urlPathProvider(_ value: SearchUsersInput) -> Swift.String? {
        return "/"
    }
}

extension SearchUsersInput {

    static func write(value: SearchUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: AlexaForBusinessClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct SearchUsersInput {
    /// The filters to use for listing a specific set of users. Required. Supported filter keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. Required.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the filtered set of users. Required. Supported sort keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init(
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

extension SearchUsersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SearchUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: AlexaForBusinessClientTypes.UserData.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct SearchUsersOutput {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of users returned.
    public var totalCount: Swift.Int?
    /// The users that meet the specified set of filter criteria, in sort order.
    public var users: [AlexaForBusinessClientTypes.UserData]?

    public init(
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil,
        users: [AlexaForBusinessClientTypes.UserData]? = nil
    )
    {
        self.nextToken = nextToken
        self.totalCount = totalCount
        self.users = users
    }
}

enum SearchUsersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SendAnnouncementInput {

    static func urlPathProvider(_ value: SendAnnouncementInput) -> Swift.String? {
        return "/"
    }
}

extension SendAnnouncementInput {

    static func write(value: SendAnnouncementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Content"].write(value.content, with: AlexaForBusinessClientTypes.Content.write(value:to:))
        try writer["RoomFilters"].writeList(value.roomFilters, memberWritingClosure: AlexaForBusinessClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeToLiveInSeconds"].write(value.timeToLiveInSeconds)
    }
}

public struct SendAnnouncementInput {
    /// The unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The announcement content. This can contain only one of the three possible announcement types (text, SSML or audio).
    /// This member is required.
    public var content: AlexaForBusinessClientTypes.Content?
    /// The filters to use to send an announcement to a specified list of rooms. The supported filter keys are RoomName, ProfileName, RoomArn, and ProfileArn. To send to all rooms, specify an empty RoomFilters list.
    /// This member is required.
    public var roomFilters: [AlexaForBusinessClientTypes.Filter]?
    /// The time to live for an announcement. Default is 300. If delivery doesn't occur within this time, the announcement is not delivered.
    public var timeToLiveInSeconds: Swift.Int?

    public init(
        clientRequestToken: Swift.String? = nil,
        content: AlexaForBusinessClientTypes.Content? = nil,
        roomFilters: [AlexaForBusinessClientTypes.Filter]? = nil,
        timeToLiveInSeconds: Swift.Int? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.roomFilters = roomFilters
        self.timeToLiveInSeconds = timeToLiveInSeconds
    }
}

extension SendAnnouncementOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SendAnnouncementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendAnnouncementOutput()
        value.announcementArn = try reader["AnnouncementArn"].readIfPresent()
        return value
    }
}

public struct SendAnnouncementOutput {
    /// The identifier of the announcement.
    public var announcementArn: Swift.String?

    public init(
        announcementArn: Swift.String? = nil
    )
    {
        self.announcementArn = announcementArn
    }
}

enum SendAnnouncementOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension SendInvitationInput {

    static func urlPathProvider(_ value: SendInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension SendInvitationInput {

    static func write(value: SendInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserArn"].write(value.userArn)
    }
}

public struct SendInvitationInput {
    /// The ARN of the user to whom to send an invitation. Required.
    public var userArn: Swift.String?

    public init(
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

extension SendInvitationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> SendInvitationOutput {
        return SendInvitationOutput()
    }
}

public struct SendInvitationOutput {

    public init() { }
}

enum SendInvitationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidUserStatusException": return try InvalidUserStatusException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.SipAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipAddress(type: \"CONTENT_REDACTED\", uri: \"CONTENT_REDACTED\")"}
}

extension AlexaForBusinessClientTypes.SipAddress {

    static func write(value: AlexaForBusinessClientTypes.SipAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.SipAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.SipAddress()
        value.uri = try reader["Uri"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The SIP address for the contact containing the URI and SIP address type.
    public struct SipAddress {
        /// The type of the SIP address.
        /// This member is required.
        public var type: AlexaForBusinessClientTypes.SipType?
        /// The URI for the SIP address.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            type: AlexaForBusinessClientTypes.SipType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.type = type
            self.uri = uri
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum SipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [SipType] {
            return [
                .work,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .work: return "WORK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.SkillDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.SkillDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.SkillDetails()
        value.productDescription = try reader["ProductDescription"].readIfPresent()
        value.invocationPhrase = try reader["InvocationPhrase"].readIfPresent()
        value.releaseDate = try reader["ReleaseDate"].readIfPresent()
        value.endUserLicenseAgreement = try reader["EndUserLicenseAgreement"].readIfPresent()
        value.genericKeywords = try reader["GenericKeywords"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.bulletPoints = try reader["BulletPoints"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.newInThisVersionBulletPoints = try reader["NewInThisVersionBulletPoints"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.skillTypes = try reader["SkillTypes"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reviews = try reader["Reviews"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.developerInfo = try reader["DeveloperInfo"].readIfPresent(with: AlexaForBusinessClientTypes.DeveloperInfo.read(from:))
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Granular information about the skill.
    public struct SkillDetails {
        /// The details about what the skill supports organized as bullet points.
        public var bulletPoints: [Swift.String]?
        /// The details about the developer that published the skill.
        public var developerInfo: AlexaForBusinessClientTypes.DeveloperInfo?
        /// The URL of the end user license agreement.
        public var endUserLicenseAgreement: Swift.String?
        /// The generic keywords associated with the skill that can be used to find a skill.
        public var genericKeywords: [Swift.String]?
        /// The phrase used to trigger the skill.
        public var invocationPhrase: Swift.String?
        /// The updates added in bullet points.
        public var newInThisVersionBulletPoints: [Swift.String]?
        /// The description of the product.
        public var productDescription: Swift.String?
        /// The date when the skill was released.
        public var releaseDate: Swift.String?
        /// This member has been deprecated. The list of reviews for the skill, including Key and Value pair.
        public var reviews: [Swift.String:Swift.String]?
        /// The types of skills.
        public var skillTypes: [Swift.String]?

        public init(
            bulletPoints: [Swift.String]? = nil,
            developerInfo: AlexaForBusinessClientTypes.DeveloperInfo? = nil,
            endUserLicenseAgreement: Swift.String? = nil,
            genericKeywords: [Swift.String]? = nil,
            invocationPhrase: Swift.String? = nil,
            newInThisVersionBulletPoints: [Swift.String]? = nil,
            productDescription: Swift.String? = nil,
            releaseDate: Swift.String? = nil,
            reviews: [Swift.String:Swift.String]? = nil,
            skillTypes: [Swift.String]? = nil
        )
        {
            self.bulletPoints = bulletPoints
            self.developerInfo = developerInfo
            self.endUserLicenseAgreement = endUserLicenseAgreement
            self.genericKeywords = genericKeywords
            self.invocationPhrase = invocationPhrase
            self.newInThisVersionBulletPoints = newInThisVersionBulletPoints
            self.productDescription = productDescription
            self.releaseDate = releaseDate
            self.reviews = reviews
            self.skillTypes = skillTypes
        }
    }

}

extension AlexaForBusinessClientTypes.SkillGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.SkillGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.SkillGroup()
        value.skillGroupArn = try reader["SkillGroupArn"].readIfPresent()
        value.skillGroupName = try reader["SkillGroupName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A skill group with attributes.
    public struct SkillGroup {
        /// The description of a skill group.
        public var description: Swift.String?
        /// The ARN of a skill group.
        public var skillGroupArn: Swift.String?
        /// The name of a skill group.
        public var skillGroupName: Swift.String?

        public init(
            description: Swift.String? = nil,
            skillGroupArn: Swift.String? = nil,
            skillGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }
    }

}

extension AlexaForBusinessClientTypes.SkillGroupData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.SkillGroupData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.SkillGroupData()
        value.skillGroupArn = try reader["SkillGroupArn"].readIfPresent()
        value.skillGroupName = try reader["SkillGroupName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The attributes of a skill group.
    public struct SkillGroupData {
        /// The description of a skill group.
        public var description: Swift.String?
        /// The skill group ARN of a skill group.
        public var skillGroupArn: Swift.String?
        /// The skill group name of a skill group.
        public var skillGroupName: Swift.String?

        public init(
            description: Swift.String? = nil,
            skillGroupArn: Swift.String? = nil,
            skillGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }
    }

}

extension SkillNotLinkedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SkillNotLinkedException {
        let reader = baseError.errorBodyReader
        var value = SkillNotLinkedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The skill must be linked to a third-party account.
public struct SkillNotLinkedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SkillNotLinkedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AlexaForBusinessClientTypes.SkillSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.SkillSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.SkillSummary()
        value.skillId = try reader["SkillId"].readIfPresent()
        value.skillName = try reader["SkillName"].readIfPresent()
        value.supportsLinking = try reader["SupportsLinking"].readIfPresent() ?? false
        value.enablementType = try reader["EnablementType"].readIfPresent()
        value.skillType = try reader["SkillType"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of skills.
    public struct SkillSummary {
        /// Whether the skill is enabled under the user's account, or if it requires linking to be used.
        public var enablementType: AlexaForBusinessClientTypes.EnablementType?
        /// The ARN of the skill summary.
        public var skillId: Swift.String?
        /// The name of the skill.
        public var skillName: Swift.String?
        /// Whether the skill is publicly available or is a private skill.
        public var skillType: AlexaForBusinessClientTypes.SkillType?
        /// Linking support for a skill.
        public var supportsLinking: Swift.Bool

        public init(
            enablementType: AlexaForBusinessClientTypes.EnablementType? = nil,
            skillId: Swift.String? = nil,
            skillName: Swift.String? = nil,
            skillType: AlexaForBusinessClientTypes.SkillType? = nil,
            supportsLinking: Swift.Bool = false
        )
        {
            self.enablementType = enablementType
            self.skillId = skillId
            self.skillName = skillName
            self.skillType = skillType
            self.supportsLinking = supportsLinking
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum SkillType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SkillType] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum SkillTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SkillTypeFilter] {
            return [
                .all,
                .private,
                .public,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.SkillsStoreSkill {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.SkillsStoreSkill {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.SkillsStoreSkill()
        value.skillId = try reader["SkillId"].readIfPresent()
        value.skillName = try reader["SkillName"].readIfPresent()
        value.shortDescription = try reader["ShortDescription"].readIfPresent()
        value.iconUrl = try reader["IconUrl"].readIfPresent()
        value.sampleUtterances = try reader["SampleUtterances"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.skillDetails = try reader["SkillDetails"].readIfPresent(with: AlexaForBusinessClientTypes.SkillDetails.read(from:))
        value.supportsLinking = try reader["SupportsLinking"].readIfPresent() ?? false
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// The detailed information about an Alexa skill.
    public struct SkillsStoreSkill {
        /// The URL where the skill icon resides.
        public var iconUrl: Swift.String?
        /// Sample utterances that interact with the skill.
        public var sampleUtterances: [Swift.String]?
        /// Short description about the skill.
        public var shortDescription: Swift.String?
        /// Information about the skill.
        public var skillDetails: AlexaForBusinessClientTypes.SkillDetails?
        /// The ARN of the skill.
        public var skillId: Swift.String?
        /// The name of the skill.
        public var skillName: Swift.String?
        /// Linking support for a skill.
        public var supportsLinking: Swift.Bool

        public init(
            iconUrl: Swift.String? = nil,
            sampleUtterances: [Swift.String]? = nil,
            shortDescription: Swift.String? = nil,
            skillDetails: AlexaForBusinessClientTypes.SkillDetails? = nil,
            skillId: Swift.String? = nil,
            skillName: Swift.String? = nil,
            supportsLinking: Swift.Bool = false
        )
        {
            self.iconUrl = iconUrl
            self.sampleUtterances = sampleUtterances
            self.shortDescription = shortDescription
            self.skillDetails = skillDetails
            self.skillId = skillId
            self.skillName = skillName
            self.supportsLinking = supportsLinking
        }
    }

}

extension AlexaForBusinessClientTypes.SmartHomeAppliance {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.SmartHomeAppliance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.SmartHomeAppliance()
        value.friendlyName = try reader["FriendlyName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.manufacturerName = try reader["ManufacturerName"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A smart home appliance that can connect to a central system. Any domestic device can be a smart appliance.
    public struct SmartHomeAppliance {
        /// The description of the smart home appliance.
        public var description: Swift.String?
        /// The friendly name of the smart home appliance.
        public var friendlyName: Swift.String?
        /// The name of the manufacturer of the smart home appliance.
        public var manufacturerName: Swift.String?

        public init(
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            manufacturerName: Swift.String? = nil
        )
        {
            self.description = description
            self.friendlyName = friendlyName
            self.manufacturerName = manufacturerName
        }
    }

}

extension AlexaForBusinessClientTypes.Sort {

    static func write(value: AlexaForBusinessClientTypes.Sort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension AlexaForBusinessClientTypes {
    /// An object representing a sort criteria.
    public struct Sort {
        /// The sort key of a sort object.
        /// This member is required.
        public var key: Swift.String?
        /// The sort value of a sort object.
        /// This member is required.
        public var value: AlexaForBusinessClientTypes.SortValue?

        public init(
            key: Swift.String? = nil,
            value: AlexaForBusinessClientTypes.SortValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum SortValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortValue] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.Ssml {

    static func write(value: AlexaForBusinessClientTypes.Ssml?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Locale"].write(value.locale)
        try writer["Value"].write(value.value)
    }
}

extension AlexaForBusinessClientTypes {
    /// The SSML message. For more information, see [SSML Reference](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html).
    public struct Ssml {
        /// The locale of the SSML message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The value of the SSML message in the correct SSML format. The audio tag is not supported.
        /// This member is required.
        public var value: Swift.String?

        public init(
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            value: Swift.String? = nil
        )
        {
            self.locale = locale
            self.value = value
        }
    }

}

extension StartDeviceSyncInput {

    static func urlPathProvider(_ value: StartDeviceSyncInput) -> Swift.String? {
        return "/"
    }
}

extension StartDeviceSyncInput {

    static func write(value: StartDeviceSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
        try writer["Features"].writeList(value.features, memberWritingClosure: AlexaForBusinessClientTypes.Feature.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoomArn"].write(value.roomArn)
    }
}

public struct StartDeviceSyncInput {
    /// The ARN of the device to sync. Required.
    public var deviceArn: Swift.String?
    /// Request structure to start the device sync. Required.
    /// This member is required.
    public var features: [AlexaForBusinessClientTypes.Feature]?
    /// The ARN of the room with which the device to sync is associated. Required.
    public var roomArn: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        features: [AlexaForBusinessClientTypes.Feature]? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.features = features
        self.roomArn = roomArn
    }
}

extension StartDeviceSyncOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartDeviceSyncOutput {
        return StartDeviceSyncOutput()
    }
}

public struct StartDeviceSyncOutput {

    public init() { }
}

enum StartDeviceSyncOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeviceNotRegisteredException": return try DeviceNotRegisteredException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartSmartHomeApplianceDiscoveryInput {

    static func urlPathProvider(_ value: StartSmartHomeApplianceDiscoveryInput) -> Swift.String? {
        return "/"
    }
}

extension StartSmartHomeApplianceDiscoveryInput {

    static func write(value: StartSmartHomeApplianceDiscoveryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoomArn"].write(value.roomArn)
    }
}

public struct StartSmartHomeApplianceDiscoveryInput {
    /// The room where smart home appliance discovery was initiated.
    /// This member is required.
    public var roomArn: Swift.String?

    public init(
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

extension StartSmartHomeApplianceDiscoveryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartSmartHomeApplianceDiscoveryOutput {
        return StartSmartHomeApplianceDiscoveryOutput()
    }
}

public struct StartSmartHomeApplianceDiscoveryOutput {

    public init() { }
}

enum StartSmartHomeApplianceDiscoveryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.Tag {

    static func write(value: AlexaForBusinessClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// A key-value pair that can be associated with a resource.
    public struct Tag {
        /// The key of a tag. Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a tag. Tag values are case sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AlexaForBusinessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The ARN of the resource to which to add metadata tags. Required.
    /// This member is required.
    public var arn: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags. Required.
    /// This member is required.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes {

    public enum TemperatureUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case celsius
        case fahrenheit
        case sdkUnknown(Swift.String)

        public static var allCases: [TemperatureUnit] {
            return [
                .celsius,
                .fahrenheit,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .celsius: return "CELSIUS"
            case .fahrenheit: return "FAHRENHEIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AlexaForBusinessClientTypes.Text {

    static func write(value: AlexaForBusinessClientTypes.Text?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Locale"].write(value.locale)
        try writer["Value"].write(value.value)
    }
}

extension AlexaForBusinessClientTypes {
    /// The text message.
    public struct Text {
        /// The locale of the text message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The value of the text message.
        /// This member is required.
        public var value: Swift.String?

        public init(
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            value: Swift.String? = nil
        )
        {
            self.locale = locale
            self.value = value
        }
    }

}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The caller has no permissions to operate on the resource involved in the API call.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource from which to remove metadata tags. Required.
    /// This member is required.
    public var arn: Swift.String?
    /// The tags to be removed from the specified resource. Do not provide system tags. Required.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAddressBookInput {

    static func urlPathProvider(_ value: UpdateAddressBookInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAddressBookInput {

    static func write(value: UpdateAddressBookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressBookArn"].write(value.addressBookArn)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

public struct UpdateAddressBookInput {
    /// The ARN of the room to update.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The updated description of the room.
    public var description: Swift.String?
    /// The updated name of the room.
    public var name: Swift.String?

    public init(
        addressBookArn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.description = description
        self.name = name
    }
}

extension UpdateAddressBookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAddressBookOutput {
        return UpdateAddressBookOutput()
    }
}

public struct UpdateAddressBookOutput {

    public init() { }
}

enum UpdateAddressBookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NameInUseException": return try NameInUseException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateBusinessReportScheduleInput {

    static func urlPathProvider(_ value: UpdateBusinessReportScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBusinessReportScheduleInput {

    static func write(value: UpdateBusinessReportScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Format"].write(value.format)
        try writer["Recurrence"].write(value.recurrence, with: AlexaForBusinessClientTypes.BusinessReportRecurrence.write(value:to:))
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
        try writer["ScheduleArn"].write(value.scheduleArn)
        try writer["ScheduleName"].write(value.scheduleName)
    }
}

public struct UpdateBusinessReportScheduleInput {
    /// The format of the generated report (individual CSV files or zipped files of individual files).
    public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
    /// The recurrence of the reports.
    public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    /// The S3 location of the output reports.
    public var s3BucketName: Swift.String?
    /// The S3 key where the report is delivered.
    public var s3KeyPrefix: Swift.String?
    /// The ARN of the business report schedule.
    /// This member is required.
    public var scheduleArn: Swift.String?
    /// The name identifier of the schedule.
    public var scheduleName: Swift.String?

    public init(
        format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
        recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        scheduleArn: Swift.String? = nil,
        scheduleName: Swift.String? = nil
    )
    {
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleArn = scheduleArn
        self.scheduleName = scheduleName
    }
}

extension UpdateBusinessReportScheduleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateBusinessReportScheduleOutput {
        return UpdateBusinessReportScheduleOutput()
    }
}

public struct UpdateBusinessReportScheduleOutput {

    public init() { }
}

enum UpdateBusinessReportScheduleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateConferenceProviderInput {

    static func urlPathProvider(_ value: UpdateConferenceProviderInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConferenceProviderInput {

    static func write(value: UpdateConferenceProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConferenceProviderArn"].write(value.conferenceProviderArn)
        try writer["ConferenceProviderType"].write(value.conferenceProviderType)
        try writer["IPDialIn"].write(value.ipDialIn, with: AlexaForBusinessClientTypes.IPDialIn.write(value:to:))
        try writer["MeetingSetting"].write(value.meetingSetting, with: AlexaForBusinessClientTypes.MeetingSetting.write(value:to:))
        try writer["PSTNDialIn"].write(value.pstnDialIn, with: AlexaForBusinessClientTypes.PSTNDialIn.write(value:to:))
    }
}

public struct UpdateConferenceProviderInput {
    /// The ARN of the conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?
    /// The type of the conference provider.
    /// This member is required.
    public var conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    /// The IP endpoint and protocol for calling.
    public var ipDialIn: AlexaForBusinessClientTypes.IPDialIn?
    /// The meeting settings for the conference provider.
    /// This member is required.
    public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    /// The information for PSTN conferencing.
    public var pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn?

    public init(
        conferenceProviderArn: Swift.String? = nil,
        conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType? = nil,
        ipDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
        meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
        pstnDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
        self.conferenceProviderType = conferenceProviderType
        self.ipDialIn = ipDialIn
        self.meetingSetting = meetingSetting
        self.pstnDialIn = pstnDialIn
    }
}

extension UpdateConferenceProviderOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateConferenceProviderOutput {
        return UpdateConferenceProviderOutput()
    }
}

public struct UpdateConferenceProviderOutput {

    public init() { }
}

enum UpdateConferenceProviderOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContactInput(contactArn: \(Swift.String(describing: contactArn)), displayName: \(Swift.String(describing: displayName)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), sipAddresses: \(Swift.String(describing: sipAddresses)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension UpdateContactInput {

    static func urlPathProvider(_ value: UpdateContactInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateContactInput {

    static func write(value: UpdateContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactArn"].write(value.contactArn)
        try writer["DisplayName"].write(value.displayName)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["PhoneNumbers"].writeList(value.phoneNumbers, memberWritingClosure: AlexaForBusinessClientTypes.PhoneNumber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SipAddresses"].writeList(value.sipAddresses, memberWritingClosure: AlexaForBusinessClientTypes.SipAddress.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateContactInput {
    /// The ARN of the contact to update.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The updated display name of the contact.
    public var displayName: Swift.String?
    /// The updated first name of the contact.
    public var firstName: Swift.String?
    /// The updated last name of the contact.
    public var lastName: Swift.String?
    /// The updated phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
    public var phoneNumber: Swift.String?
    /// The list of phone numbers for the contact.
    public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    /// The list of SIP addresses for the contact.
    public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

    public init(
        contactArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
        sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
    )
    {
        self.contactArn = contactArn
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
    }
}

extension UpdateContactOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateContactOutput {
        return UpdateContactOutput()
    }
}

public struct UpdateContactOutput {

    public init() { }
}

enum UpdateContactOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDeviceInput {

    static func urlPathProvider(_ value: UpdateDeviceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDeviceInput {

    static func write(value: UpdateDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceArn"].write(value.deviceArn)
        try writer["DeviceName"].write(value.deviceName)
    }
}

public struct UpdateDeviceInput {
    /// The ARN of the device to update. Required.
    public var deviceArn: Swift.String?
    /// The updated device name. Required.
    public var deviceName: Swift.String?

    public init(
        deviceArn: Swift.String? = nil,
        deviceName: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceName = deviceName
    }
}

extension UpdateDeviceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDeviceOutput {
        return UpdateDeviceOutput()
    }
}

public struct UpdateDeviceOutput {

    public init() { }
}

enum UpdateDeviceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "DeviceNotRegisteredException": return try DeviceNotRegisteredException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder {

    static func write(value: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["ReminderAtMinutes"].writeList(value.reminderAtMinutes, memberWritingClosure: Swift.Int.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReminderType"].write(value.reminderType)
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct UpdateEndOfMeetingReminder {
        /// Whether an end of meeting reminder is enabled or not.
        public var enabled: Swift.Bool?
        /// Updates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init(
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension UpdateGatewayGroupInput {

    static func urlPathProvider(_ value: UpdateGatewayGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewayGroupInput {

    static func write(value: UpdateGatewayGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["GatewayGroupArn"].write(value.gatewayGroupArn)
        try writer["Name"].write(value.name)
    }
}

public struct UpdateGatewayGroupInput {
    /// The updated description of the gateway group.
    public var description: Swift.String?
    /// The ARN of the gateway group to update.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?
    /// The updated name of the gateway group.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        gatewayGroupArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.gatewayGroupArn = gatewayGroupArn
        self.name = name
    }
}

extension UpdateGatewayGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGatewayGroupOutput {
        return UpdateGatewayGroupOutput()
    }
}

public struct UpdateGatewayGroupOutput {

    public init() { }
}

enum UpdateGatewayGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NameInUseException": return try NameInUseException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGatewayInput {

    static func urlPathProvider(_ value: UpdateGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGatewayInput {

    static func write(value: UpdateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["GatewayArn"].write(value.gatewayArn)
        try writer["Name"].write(value.name)
        try writer["SoftwareVersion"].write(value.softwareVersion)
    }
}

public struct UpdateGatewayInput {
    /// The updated description of the gateway.
    public var description: Swift.String?
    /// The ARN of the gateway to update.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated name of the gateway.
    public var name: Swift.String?
    /// The updated software version of the gateway. The gateway automatically updates its software version during normal operation.
    public var softwareVersion: Swift.String?

    public init(
        description: Swift.String? = nil,
        gatewayArn: Swift.String? = nil,
        name: Swift.String? = nil,
        softwareVersion: Swift.String? = nil
    )
    {
        self.description = description
        self.gatewayArn = gatewayArn
        self.name = name
        self.softwareVersion = softwareVersion
    }
}

extension UpdateGatewayOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGatewayOutput {
        return UpdateGatewayOutput()
    }
}

public struct UpdateGatewayOutput {

    public init() { }
}

enum UpdateGatewayOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NameInUseException": return try NameInUseException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateInstantBooking {

    static func write(value: AlexaForBusinessClientTypes.UpdateInstantBooking?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationInMinutes"].write(value.durationInMinutes)
        try writer["Enabled"].write(value.enabled)
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates settings for the instant booking feature that are applied to a room profile. If instant booking is enabled, Alexa automatically reserves a room if it is free when a user joins a meeting with Alexa.
    public struct UpdateInstantBooking {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration {

    static func write(value: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndOfMeetingReminder"].write(value.endOfMeetingReminder, with: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder.write(value:to:))
        try writer["InstantBooking"].write(value.instantBooking, with: AlexaForBusinessClientTypes.UpdateInstantBooking.write(value:to:))
        try writer["ProactiveJoin"].write(value.proactiveJoin, with: AlexaForBusinessClientTypes.UpdateProactiveJoin.write(value:to:))
        try writer["RequireCheckIn"].write(value.requireCheckIn, with: AlexaForBusinessClientTypes.UpdateRequireCheckIn.write(value:to:))
        try writer["RoomUtilizationMetricsEnabled"].write(value.roomUtilizationMetricsEnabled)
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates meeting room settings of a room profile.
    public struct UpdateMeetingRoomConfiguration {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder?
        /// Settings to automatically book an available room available for a configured duration when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.UpdateInstantBooking?
        public var proactiveJoin: AlexaForBusinessClientTypes.UpdateProactiveJoin?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.UpdateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init(
            endOfMeetingReminder: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.UpdateInstantBooking? = nil,
            proactiveJoin: AlexaForBusinessClientTypes.UpdateProactiveJoin? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.UpdateRequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.proactiveJoin = proactiveJoin
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension UpdateNetworkProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkProfileInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), description: \(Swift.String(describing: description)), networkProfileArn: \(Swift.String(describing: networkProfileArn)), networkProfileName: \(Swift.String(describing: networkProfileName)), trustAnchors: \(Swift.String(describing: trustAnchors)), currentPassword: \"CONTENT_REDACTED\", nextPassword: \"CONTENT_REDACTED\")"}
}

extension UpdateNetworkProfileInput {

    static func urlPathProvider(_ value: UpdateNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNetworkProfileInput {

    static func write(value: UpdateNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateAuthorityArn"].write(value.certificateAuthorityArn)
        try writer["CurrentPassword"].write(value.currentPassword)
        try writer["Description"].write(value.description)
        try writer["NetworkProfileArn"].write(value.networkProfileArn)
        try writer["NetworkProfileName"].write(value.networkProfileName)
        try writer["NextPassword"].write(value.nextPassword)
        try writer["TrustAnchors"].writeList(value.trustAnchors, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateNetworkProfileInput {
    /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
    public var certificateAuthorityArn: Swift.String?
    /// The current password of the Wi-Fi network.
    public var currentPassword: Swift.String?
    /// Detailed information about a device's network profile.
    public var description: Swift.String?
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?
    /// The name of the network profile associated with a device.
    public var networkProfileName: Swift.String?
    /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
    public var nextPassword: Swift.String?
    /// The root certificate(s) of your authentication server that will be installed on your devices and used to trust your authentication server during EAP negotiation.
    public var trustAnchors: [Swift.String]?

    public init(
        certificateAuthorityArn: Swift.String? = nil,
        currentPassword: Swift.String? = nil,
        description: Swift.String? = nil,
        networkProfileArn: Swift.String? = nil,
        networkProfileName: Swift.String? = nil,
        nextPassword: Swift.String? = nil,
        trustAnchors: [Swift.String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.currentPassword = currentPassword
        self.description = description
        self.networkProfileArn = networkProfileArn
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.trustAnchors = trustAnchors
    }
}

extension UpdateNetworkProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateNetworkProfileOutput {
        return UpdateNetworkProfileOutput()
    }
}

public struct UpdateNetworkProfileOutput {

    public init() { }
}

enum UpdateNetworkProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidCertificateAuthorityException": return try InvalidCertificateAuthorityException.makeError(baseError: baseError)
            case "InvalidSecretsManagerResourceException": return try InvalidSecretsManagerResourceException.makeError(baseError: baseError)
            case "NameInUseException": return try NameInUseException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateProactiveJoin {

    static func write(value: AlexaForBusinessClientTypes.UpdateProactiveJoin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnabledByMotion"].write(value.enabledByMotion)
    }
}

extension AlexaForBusinessClientTypes {
    public struct UpdateProactiveJoin {
        /// This member is required.
        public var enabledByMotion: Swift.Bool?

        public init(
            enabledByMotion: Swift.Bool? = nil
        )
        {
            self.enabledByMotion = enabledByMotion
        }
    }

}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["DataRetentionOptIn"].write(value.dataRetentionOptIn)
        try writer["DistanceUnit"].write(value.distanceUnit)
        try writer["IsDefault"].write(value.isDefault)
        try writer["Locale"].write(value.locale)
        try writer["MaxVolumeLimit"].write(value.maxVolumeLimit)
        try writer["MeetingRoomConfiguration"].write(value.meetingRoomConfiguration, with: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration.write(value:to:))
        try writer["PSTNEnabled"].write(value.pstnEnabled)
        try writer["ProfileArn"].write(value.profileArn)
        try writer["ProfileName"].write(value.profileName)
        try writer["SetupModeDisabled"].write(value.setupModeDisabled)
        try writer["TemperatureUnit"].write(value.temperatureUnit)
        try writer["Timezone"].write(value.timezone)
        try writer["WakeWord"].write(value.wakeWord)
    }
}

public struct UpdateProfileInput {
    /// The updated address for the room profile.
    public var address: Swift.String?
    /// Whether data retention of the profile is enabled.
    public var dataRetentionOptIn: Swift.Bool?
    /// The updated distance unit for the room profile.
    public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    /// Sets the profile as default if selected. If this is missing, no update is done to the default status.
    public var isDefault: Swift.Bool?
    /// The updated locale for the room profile. (This is currently only available to a limited preview audience.)
    public var locale: Swift.String?
    /// The updated maximum volume limit for the room profile.
    public var maxVolumeLimit: Swift.Int?
    /// The updated meeting room settings of a room profile.
    public var meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration?
    /// The ARN of the room profile to update. Required.
    public var profileArn: Swift.String?
    /// The updated name for the room profile.
    public var profileName: Swift.String?
    /// Whether the PSTN setting of the room profile is enabled.
    public var pstnEnabled: Swift.Bool?
    /// Whether the setup mode of the profile is enabled.
    public var setupModeDisabled: Swift.Bool?
    /// The updated temperature unit for the room profile.
    public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    /// The updated timezone for the room profile.
    public var timezone: Swift.String?
    /// The updated wake word for the room profile.
    public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

    public init(
        address: Swift.String? = nil,
        dataRetentionOptIn: Swift.Bool? = nil,
        distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
        isDefault: Swift.Bool? = nil,
        locale: Swift.String? = nil,
        maxVolumeLimit: Swift.Int? = nil,
        meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration? = nil,
        profileArn: Swift.String? = nil,
        profileName: Swift.String? = nil,
        pstnEnabled: Swift.Bool? = nil,
        setupModeDisabled: Swift.Bool? = nil,
        temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
        timezone: Swift.String? = nil,
        wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
    )
    {
        self.address = address
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.isDefault = isDefault
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.profileArn = profileArn
        self.profileName = profileName
        self.pstnEnabled = pstnEnabled
        self.setupModeDisabled = setupModeDisabled
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateProfileOutput {
        return UpdateProfileOutput()
    }
}

public struct UpdateProfileOutput {

    public init() { }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NameInUseException": return try NameInUseException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.UpdateRequireCheckIn {

    static func write(value: AlexaForBusinessClientTypes.UpdateRequireCheckIn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["ReleaseAfterMinutes"].write(value.releaseAfterMinutes)
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct UpdateRequireCheckIn {
        /// Whether require check in is enabled or not.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public var releaseAfterMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension UpdateRoomInput {

    static func urlPathProvider(_ value: UpdateRoomInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRoomInput {

    static func write(value: UpdateRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["ProfileArn"].write(value.profileArn)
        try writer["ProviderCalendarId"].write(value.providerCalendarId)
        try writer["RoomArn"].write(value.roomArn)
        try writer["RoomName"].write(value.roomName)
    }
}

public struct UpdateRoomInput {
    /// The updated description for the room.
    public var description: Swift.String?
    /// The updated profile ARN for the room.
    public var profileArn: Swift.String?
    /// The updated provider calendar ARN for the room.
    public var providerCalendarId: Swift.String?
    /// The ARN of the room to update.
    public var roomArn: Swift.String?
    /// The updated name for the room.
    public var roomName: Swift.String?

    public init(
        description: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        providerCalendarId: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        roomName: Swift.String? = nil
    )
    {
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomArn = roomArn
        self.roomName = roomName
    }
}

extension UpdateRoomOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateRoomOutput {
        return UpdateRoomOutput()
    }
}

public struct UpdateRoomOutput {

    public init() { }
}

enum UpdateRoomOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NameInUseException": return try NameInUseException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSkillGroupInput {

    static func urlPathProvider(_ value: UpdateSkillGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSkillGroupInput {

    static func write(value: UpdateSkillGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["SkillGroupArn"].write(value.skillGroupArn)
        try writer["SkillGroupName"].write(value.skillGroupName)
    }
}

public struct UpdateSkillGroupInput {
    /// The updated description for the skill group.
    public var description: Swift.String?
    /// The ARN of the skill group to update.
    public var skillGroupArn: Swift.String?
    /// The updated name for the skill group.
    public var skillGroupName: Swift.String?

    public init(
        description: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil,
        skillGroupName: Swift.String? = nil
    )
    {
        self.description = description
        self.skillGroupArn = skillGroupArn
        self.skillGroupName = skillGroupName
    }
}

extension UpdateSkillGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSkillGroupOutput {
        return UpdateSkillGroupOutput()
    }
}

public struct UpdateSkillGroupOutput {

    public init() { }
}

enum UpdateSkillGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "NameInUseException": return try NameInUseException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AlexaForBusinessClientTypes.UserData {

    static func read(from reader: SmithyJSON.Reader) throws -> AlexaForBusinessClientTypes.UserData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AlexaForBusinessClientTypes.UserData()
        value.userArn = try reader["UserArn"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.enrollmentStatus = try reader["EnrollmentStatus"].readIfPresent()
        value.enrollmentId = try reader["EnrollmentId"].readIfPresent()
        return value
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to a user.
    public struct UserData {
        /// The email of a user.
        public var email: Swift.String?
        /// The enrollment ARN of a user.
        public var enrollmentId: Swift.String?
        /// The enrollment status of a user.
        public var enrollmentStatus: AlexaForBusinessClientTypes.EnrollmentStatus?
        /// The first name of a user.
        public var firstName: Swift.String?
        /// The last name of a user.
        public var lastName: Swift.String?
        /// The ARN of a user.
        public var userArn: Swift.String?

        public init(
            email: Swift.String? = nil,
            enrollmentId: Swift.String? = nil,
            enrollmentStatus: AlexaForBusinessClientTypes.EnrollmentStatus? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.email = email
            self.enrollmentId = enrollmentId
            self.enrollmentStatus = enrollmentStatus
            self.firstName = firstName
            self.lastName = lastName
            self.userArn = userArn
        }
    }

}

extension AlexaForBusinessClientTypes {

    public enum WakeWord: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alexa
        case amazon
        case computer
        case echo
        case sdkUnknown(Swift.String)

        public static var allCases: [WakeWord] {
            return [
                .alexa,
                .amazon,
                .computer,
                .echo,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alexa: return "ALEXA"
            case .amazon: return "AMAZON"
            case .computer: return "COMPUTER"
            case .echo: return "ECHO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}
