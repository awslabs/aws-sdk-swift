// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyReadWrite
import SmithyXML

extension CloudSearchClientTypes.AccessPoliciesStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.AccessPoliciesStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.AccessPoliciesStatus()
            value.options = try reader["Options"].readIfPresent()
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The configured access rules for the domain's document and search endpoints, and the current status of those rules.
    public struct AccessPoliciesStatus: Swift.Equatable {
        /// Access rules for a domain's document or search service endpoints. For more information, see [Configuring Access for a Search Domain](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-access.html) in the Amazon CloudSearch Developer Guide. The maximum size of a policy document is 100 KB.
        /// This member is required.
        public var options: Swift.String?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: Swift.String? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    public enum AlgorithmicStemming: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case light
        case minimal
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmicStemming] {
            return [
                .full,
                .light,
                .minimal,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "full"
            case .light: return "light"
            case .minimal: return "minimal"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmicStemming(rawValue: rawValue) ?? AlgorithmicStemming.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.AnalysisOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmicStemming = "AlgorithmicStemming"
        case japaneseTokenizationDictionary = "JapaneseTokenizationDictionary"
        case stemmingDictionary = "StemmingDictionary"
        case stopwords = "Stopwords"
        case synonyms = "Synonyms"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let algorithmicStemming = algorithmicStemming {
            try container.encode(algorithmicStemming, forKey: ClientRuntime.Key("AlgorithmicStemming"))
        }
        if let japaneseTokenizationDictionary = japaneseTokenizationDictionary {
            try container.encode(japaneseTokenizationDictionary, forKey: ClientRuntime.Key("JapaneseTokenizationDictionary"))
        }
        if let stemmingDictionary = stemmingDictionary {
            try container.encode(stemmingDictionary, forKey: ClientRuntime.Key("StemmingDictionary"))
        }
        if let stopwords = stopwords {
            try container.encode(stopwords, forKey: ClientRuntime.Key("Stopwords"))
        }
        if let synonyms = synonyms {
            try container.encode(synonyms, forKey: ClientRuntime.Key("Synonyms"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.AnalysisOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.AnalysisOptions()
            value.synonyms = try reader["Synonyms"].readIfPresent()
            value.stopwords = try reader["Stopwords"].readIfPresent()
            value.stemmingDictionary = try reader["StemmingDictionary"].readIfPresent()
            value.japaneseTokenizationDictionary = try reader["JapaneseTokenizationDictionary"].readIfPresent()
            value.algorithmicStemming = try reader["AlgorithmicStemming"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
    public struct AnalysisOptions: Swift.Equatable {
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see [Language Specific Text Processing Settings](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/text-processing.html#text-processing-settings) in the Amazon CloudSearch Developer Guide
        public var algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming?
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        public var japaneseTokenizationDictionary: Swift.String?
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        public var stemmingDictionary: Swift.String?
        /// A JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported.
        public var stopwords: Swift.String?
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see [Synonyms](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-analysis-schemes.html#synonyms) in the Amazon CloudSearch Developer Guide.
        public var synonyms: Swift.String?

        public init(
            algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming? = nil,
            japaneseTokenizationDictionary: Swift.String? = nil,
            stemmingDictionary: Swift.String? = nil,
            stopwords: Swift.String? = nil,
            synonyms: Swift.String? = nil
        )
        {
            self.algorithmicStemming = algorithmicStemming
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stemmingDictionary = stemmingDictionary
            self.stopwords = stopwords
            self.synonyms = synonyms
        }
    }

}

extension CloudSearchClientTypes.AnalysisScheme: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisOptions = "AnalysisOptions"
        case analysisSchemeLanguage = "AnalysisSchemeLanguage"
        case analysisSchemeName = "AnalysisSchemeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisOptions = analysisOptions {
            try container.encode(analysisOptions, forKey: ClientRuntime.Key("AnalysisOptions"))
        }
        if let analysisSchemeLanguage = analysisSchemeLanguage {
            try container.encode(analysisSchemeLanguage, forKey: ClientRuntime.Key("AnalysisSchemeLanguage"))
        }
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: ClientRuntime.Key("AnalysisSchemeName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.AnalysisScheme, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.AnalysisScheme()
            value.analysisSchemeName = try reader["AnalysisSchemeName"].readIfPresent()
            value.analysisSchemeLanguage = try reader["AnalysisSchemeLanguage"].readIfPresent()
            value.analysisOptions = try reader["AnalysisOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.AnalysisOptions.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    public struct AnalysisScheme: Swift.Equatable {
        /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
        public var analysisOptions: CloudSearchClientTypes.AnalysisOptions?
        /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
        /// This member is required.
        public var analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var analysisSchemeName: Swift.String?

        public init(
            analysisOptions: CloudSearchClientTypes.AnalysisOptions? = nil,
            analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage? = nil,
            analysisSchemeName: Swift.String? = nil
        )
        {
            self.analysisOptions = analysisOptions
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
        }
    }

}

extension CloudSearchClientTypes {
    /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
    public enum AnalysisSchemeLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ar
        case bg
        case ca
        case cs
        case da
        case de
        case el
        case en
        case es
        case eu
        case fa
        case fi
        case fr
        case ga
        case gl
        case he
        case hi
        case hu
        case hy
        case id
        case it
        case ja
        case ko
        case lv
        case mul
        case nl
        case no
        case pt
        case ro
        case ru
        case sv
        case th
        case tr
        case zhHans
        case zhHant
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisSchemeLanguage] {
            return [
                .ar,
                .bg,
                .ca,
                .cs,
                .da,
                .de,
                .el,
                .en,
                .es,
                .eu,
                .fa,
                .fi,
                .fr,
                .ga,
                .gl,
                .he,
                .hi,
                .hu,
                .hy,
                .id,
                .it,
                .ja,
                .ko,
                .lv,
                .mul,
                .nl,
                .no,
                .pt,
                .ro,
                .ru,
                .sv,
                .th,
                .tr,
                .zhHans,
                .zhHant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ar: return "ar"
            case .bg: return "bg"
            case .ca: return "ca"
            case .cs: return "cs"
            case .da: return "da"
            case .de: return "de"
            case .el: return "el"
            case .en: return "en"
            case .es: return "es"
            case .eu: return "eu"
            case .fa: return "fa"
            case .fi: return "fi"
            case .fr: return "fr"
            case .ga: return "ga"
            case .gl: return "gl"
            case .he: return "he"
            case .hi: return "hi"
            case .hu: return "hu"
            case .hy: return "hy"
            case .id: return "id"
            case .it: return "it"
            case .ja: return "ja"
            case .ko: return "ko"
            case .lv: return "lv"
            case .mul: return "mul"
            case .nl: return "nl"
            case .no: return "no"
            case .pt: return "pt"
            case .ro: return "ro"
            case .ru: return "ru"
            case .sv: return "sv"
            case .th: return "th"
            case .tr: return "tr"
            case .zhHans: return "zh-Hans"
            case .zhHant: return "zh-Hant"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisSchemeLanguage(rawValue: rawValue) ?? AnalysisSchemeLanguage.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.AnalysisSchemeStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.AnalysisSchemeStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.AnalysisSchemeStatus()
            value.options = try reader["Options"].readIfPresent(readingClosure: CloudSearchClientTypes.AnalysisScheme.readingClosure)
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The status and configuration of an AnalysisScheme.
    public struct AnalysisSchemeStatus: Swift.Equatable {
        /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
        /// This member is required.
        public var options: CloudSearchClientTypes.AnalysisScheme?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.AnalysisScheme? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.AvailabilityOptionsStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if options != false {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.AvailabilityOptionsStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.AvailabilityOptionsStatus()
            value.options = try reader["Options"].readIfPresent() ?? false
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The status and configuration of the domain's availability options.
    public struct AvailabilityOptionsStatus: Swift.Equatable {
        /// The availability options configured for the domain.
        /// This member is required.
        public var options: Swift.Bool
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: Swift.Bool = false,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension BaseException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = BaseException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An error occurred while processing the request.
public struct BaseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BaseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension BuildSuggestersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("BuildSuggesters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension BuildSuggestersInput {

    static func urlPathProvider(_ value: BuildSuggestersInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [BuildSuggester] operation. Specifies the name of the domain you want to update.
public struct BuildSuggestersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension BuildSuggestersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<BuildSuggestersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["BuildSuggestersResult"]
            var value = BuildSuggestersOutput()
            value.fieldNames = try reader["FieldNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The result of a BuildSuggester request. Contains a list of the fields used for suggestions.
public struct BuildSuggestersOutput: Swift.Equatable {
    /// A list of field names.
    public var fieldNames: [Swift.String]?

    public init(
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

enum BuildSuggestersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("CreateDomain", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [CreateDomain] operation. Specifies a name for the new search domain.
public struct CreateDomainInput: Swift.Equatable {
    /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension CreateDomainOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateDomainOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateDomainResult"]
            var value = CreateDomainOutput()
            value.domainStatus = try reader["DomainStatus"].readIfPresent(readingClosure: CloudSearchClientTypes.DomainStatus.readingClosure)
            return value
        }
    }
}

/// The result of a CreateDomainRequest. Contains the status of a newly created domain.
public struct CreateDomainOutput: Swift.Equatable {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init(
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

enum CreateDomainOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceAlreadyExists": return try await ResourceAlreadyExistsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CloudSearchClientTypes.DateArrayOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DateArrayOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DateArrayOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceFields = try reader["SourceFields"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
    public struct DateArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.DateOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DateOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DateOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceField = try reader["SourceField"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            value.sortEnabled = try reader["SortEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
    public struct DateOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension DefineAnalysisSchemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DefineAnalysisScheme", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineAnalysisSchemeInput {

    static func urlPathProvider(_ value: DefineAnalysisSchemeInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme configuration.
public struct DefineAnalysisSchemeInput: Swift.Equatable {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisScheme?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        analysisScheme: CloudSearchClientTypes.AnalysisScheme? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisScheme = analysisScheme
        self.domainName = domainName
    }
}

extension DefineAnalysisSchemeOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DefineAnalysisSchemeOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DefineAnalysisSchemeResult"]
            var value = DefineAnalysisSchemeOutput()
            value.analysisScheme = try reader["AnalysisScheme"].readIfPresent(readingClosure: CloudSearchClientTypes.AnalysisSchemeStatus.readingClosure)
            return value
        }
    }
}

/// The result of a [DefineAnalysisScheme] request. Contains the status of the newly-configured analysis scheme.
public struct DefineAnalysisSchemeOutput: Swift.Equatable {
    /// The status and configuration of an AnalysisScheme.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init(
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

enum DefineAnalysisSchemeOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DefineExpressionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: ClientRuntime.Key("Expression"))
        }
        try container.encode("DefineExpression", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineExpressionInput {

    static func urlPathProvider(_ value: DefineExpressionInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineExpression] operation. Specifies the name of the domain you want to update and the expression you want to configure.
public struct DefineExpressionInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    /// This member is required.
    public var expression: CloudSearchClientTypes.Expression?

    public init(
        domainName: Swift.String? = nil,
        expression: CloudSearchClientTypes.Expression? = nil
    )
    {
        self.domainName = domainName
        self.expression = expression
    }
}

extension DefineExpressionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DefineExpressionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DefineExpressionResult"]
            var value = DefineExpressionOutput()
            value.expression = try reader["Expression"].readIfPresent(readingClosure: CloudSearchClientTypes.ExpressionStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DefineExpression request. Contains the status of the newly-configured expression.
public struct DefineExpressionOutput: Swift.Equatable {
    /// The value of an Expression and its current status.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init(
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

enum DefineExpressionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DefineIndexFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case indexField = "IndexField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let indexField = indexField {
            try container.encode(indexField, forKey: ClientRuntime.Key("IndexField"))
        }
        try container.encode("DefineIndexField", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineIndexFieldInput {

    static func urlPathProvider(_ value: DefineIndexFieldInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineIndexField] operation. Specifies the name of the domain you want to update and the index field configuration.
public struct DefineIndexFieldInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The index field and field options you want to configure.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexField?

    public init(
        domainName: Swift.String? = nil,
        indexField: CloudSearchClientTypes.IndexField? = nil
    )
    {
        self.domainName = domainName
        self.indexField = indexField
    }
}

extension DefineIndexFieldOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DefineIndexFieldOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DefineIndexFieldResult"]
            var value = DefineIndexFieldOutput()
            value.indexField = try reader["IndexField"].readIfPresent(readingClosure: CloudSearchClientTypes.IndexFieldStatus.readingClosure)
            return value
        }
    }
}

/// The result of a [DefineIndexField] request. Contains the status of the newly-configured index field.
public struct DefineIndexFieldOutput: Swift.Equatable {
    /// The value of an IndexField and its current status.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init(
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

enum DefineIndexFieldOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DefineSuggesterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case suggester = "Suggester"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggester = suggester {
            try container.encode(suggester, forKey: ClientRuntime.Key("Suggester"))
        }
        try container.encode("DefineSuggester", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineSuggesterInput {

    static func urlPathProvider(_ value: DefineSuggesterInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineSuggester] operation. Specifies the name of the domain you want to update and the suggester configuration.
public struct DefineSuggesterInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.Suggester?

    public init(
        domainName: Swift.String? = nil,
        suggester: CloudSearchClientTypes.Suggester? = nil
    )
    {
        self.domainName = domainName
        self.suggester = suggester
    }
}

extension DefineSuggesterOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DefineSuggesterOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DefineSuggesterResult"]
            var value = DefineSuggesterOutput()
            value.suggester = try reader["Suggester"].readIfPresent(readingClosure: CloudSearchClientTypes.SuggesterStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DefineSuggester request. Contains the status of the newly-configured suggester.
public struct DefineSuggesterOutput: Swift.Equatable {
    /// The value of a Suggester and its current status.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init(
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

enum DefineSuggesterOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteAnalysisSchemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSchemeName = "AnalysisSchemeName"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: ClientRuntime.Key("AnalysisSchemeName"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DeleteAnalysisScheme", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAnalysisSchemeInput {

    static func urlPathProvider(_ value: DeleteAnalysisSchemeInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme you want to delete.
public struct DeleteAnalysisSchemeInput: Swift.Equatable {
    /// The name of the analysis scheme you want to delete.
    /// This member is required.
    public var analysisSchemeName: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        analysisSchemeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeName = analysisSchemeName
        self.domainName = domainName
    }
}

extension DeleteAnalysisSchemeOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteAnalysisSchemeOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DeleteAnalysisSchemeResult"]
            var value = DeleteAnalysisSchemeOutput()
            value.analysisScheme = try reader["AnalysisScheme"].readIfPresent(readingClosure: CloudSearchClientTypes.AnalysisSchemeStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DeleteAnalysisScheme request. Contains the status of the deleted analysis scheme.
public struct DeleteAnalysisSchemeOutput: Swift.Equatable {
    /// The status of the analysis scheme being deleted.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init(
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

enum DeleteAnalysisSchemeOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DeleteDomain", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteDomain] operation. Specifies the name of the domain you want to delete.
public struct DeleteDomainInput: Swift.Equatable {
    /// The name of the domain you want to permanently delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension DeleteDomainOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteDomainOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DeleteDomainResult"]
            var value = DeleteDomainOutput()
            value.domainStatus = try reader["DomainStatus"].readIfPresent(readingClosure: CloudSearchClientTypes.DomainStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DeleteDomain request. Contains the status of a newly deleted domain, or no status if the domain has already been completely deleted.
public struct DeleteDomainOutput: Swift.Equatable {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init(
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

enum DeleteDomainOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteExpressionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case expressionName = "ExpressionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: ClientRuntime.Key("ExpressionName"))
        }
        try container.encode("DeleteExpression", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteExpressionInput {

    static func urlPathProvider(_ value: DeleteExpressionInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteExpression] operation. Specifies the name of the domain you want to update and the name of the expression you want to delete.
public struct DeleteExpressionInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the [Expression] to delete.
    /// This member is required.
    public var expressionName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        expressionName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.expressionName = expressionName
    }
}

extension DeleteExpressionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteExpressionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DeleteExpressionResult"]
            var value = DeleteExpressionOutput()
            value.expression = try reader["Expression"].readIfPresent(readingClosure: CloudSearchClientTypes.ExpressionStatus.readingClosure)
            return value
        }
    }
}

/// The result of a [DeleteExpression] request. Specifies the expression being deleted.
public struct DeleteExpressionOutput: Swift.Equatable {
    /// The status of the expression being deleted.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init(
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

enum DeleteExpressionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteIndexFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case indexFieldName = "IndexFieldName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: ClientRuntime.Key("IndexFieldName"))
        }
        try container.encode("DeleteIndexField", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteIndexFieldInput {

    static func urlPathProvider(_ value: DeleteIndexFieldInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteIndexField] operation. Specifies the name of the domain you want to update and the name of the index field you want to delete.
public struct DeleteIndexFieldInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the index field your want to remove from the domain's indexing options.
    /// This member is required.
    public var indexFieldName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        indexFieldName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.indexFieldName = indexFieldName
    }
}

extension DeleteIndexFieldOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteIndexFieldOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DeleteIndexFieldResult"]
            var value = DeleteIndexFieldOutput()
            value.indexField = try reader["IndexField"].readIfPresent(readingClosure: CloudSearchClientTypes.IndexFieldStatus.readingClosure)
            return value
        }
    }
}

/// The result of a [DeleteIndexField] request.
public struct DeleteIndexFieldOutput: Swift.Equatable {
    /// The status of the index field being deleted.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init(
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

enum DeleteIndexFieldOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteSuggesterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case suggesterName = "SuggesterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: ClientRuntime.Key("SuggesterName"))
        }
        try container.encode("DeleteSuggester", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSuggesterInput {

    static func urlPathProvider(_ value: DeleteSuggesterInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteSuggester] operation. Specifies the name of the domain you want to update and name of the suggester you want to delete.
public struct DeleteSuggesterInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Specifies the name of the suggester you want to delete.
    /// This member is required.
    public var suggesterName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        suggesterName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.suggesterName = suggesterName
    }
}

extension DeleteSuggesterOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteSuggesterOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DeleteSuggesterResult"]
            var value = DeleteSuggesterOutput()
            value.suggester = try reader["Suggester"].readIfPresent(readingClosure: CloudSearchClientTypes.SuggesterStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DeleteSuggester request. Contains the status of the deleted suggester.
public struct DeleteSuggesterOutput: Swift.Equatable {
    /// The status of the suggester being deleted.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init(
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

enum DeleteSuggesterOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeAnalysisSchemesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSchemeNames = "AnalysisSchemeNames"
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisSchemeNames = analysisSchemeNames {
            if !analysisSchemeNames.isEmpty {
                var analysisSchemeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AnalysisSchemeNames"))
                for (index0, standardname0) in analysisSchemeNames.enumerated() {
                    try analysisSchemeNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var analysisSchemeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AnalysisSchemeNames"))
                try analysisSchemeNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeAnalysisSchemes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeAnalysisSchemesInput {

    static func urlPathProvider(_ value: DescribeAnalysisSchemesInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeAnalysisSchemes] operation. Specifies the name of the domain you want to describe. To limit the response to particular analysis schemes, specify the names of the analysis schemes you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAnalysisSchemesInput: Swift.Equatable {
    /// The analysis schemes you want to describe.
    public var analysisSchemeNames: [Swift.String]?
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        analysisSchemeNames: [Swift.String]? = nil,
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeNames = analysisSchemeNames
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeAnalysisSchemesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeAnalysisSchemesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeAnalysisSchemesResult"]
            var value = DescribeAnalysisSchemesOutput()
            value.analysisSchemes = try reader["AnalysisSchemes"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.AnalysisSchemeStatus.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The result of a DescribeAnalysisSchemes request. Contains the analysis schemes configured for the domain specified in the request.
public struct DescribeAnalysisSchemesOutput: Swift.Equatable {
    /// The analysis scheme descriptions.
    /// This member is required.
    public var analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]?

    public init(
        analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]? = nil
    )
    {
        self.analysisSchemes = analysisSchemes
    }
}

enum DescribeAnalysisSchemesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeAvailabilityOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeAvailabilityOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeAvailabilityOptionsInput {

    static func urlPathProvider(_ value: DescribeAvailabilityOptionsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeAvailabilityOptions] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAvailabilityOptionsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeAvailabilityOptionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeAvailabilityOptionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeAvailabilityOptionsResult"]
            var value = DescribeAvailabilityOptionsOutput()
            value.availabilityOptions = try reader["AvailabilityOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.AvailabilityOptionsStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DescribeAvailabilityOptions request. Indicates whether or not the Multi-AZ option is enabled for the domain specified in the request.
public struct DescribeAvailabilityOptionsOutput: Swift.Equatable {
    /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init(
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

enum DescribeAvailabilityOptionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DisabledAction": return try await DisabledOperationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeDomainEndpointOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeDomainEndpointOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDomainEndpointOptionsInput {

    static func urlPathProvider(_ value: DescribeDomainEndpointOptionsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeDomainEndpointOptions] operation. Specify the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeDomainEndpointOptionsInput: Swift.Equatable {
    /// Whether to retrieve the latest configuration (which might be in a Processing state) or the current, active configuration. Defaults to false.
    public var deployed: Swift.Bool?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeDomainEndpointOptionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeDomainEndpointOptionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeDomainEndpointOptionsResult"]
            var value = DescribeDomainEndpointOptionsOutput()
            value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.DomainEndpointOptionsStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DescribeDomainEndpointOptions request. Contains the status and configuration of a search domain's endpoint options.
public struct DescribeDomainEndpointOptionsOutput: Swift.Equatable {
    /// The status and configuration of a search domain's endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init(
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

enum DescribeDomainEndpointOptionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DisabledAction": return try await DisabledOperationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNames = "DomainNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainNames = domainNames {
            if !domainNames.isEmpty {
                var domainNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainNames"))
                for (index0, domainname0) in domainNames.enumerated() {
                    try domainNamesContainer.encode(domainname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var domainNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainNames"))
                try domainNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeDomains", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDomainsInput {

    static func urlPathProvider(_ value: DescribeDomainsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeDomains] operation. By default shows the status of all domains. To restrict the response to particular domains, specify the names of the domains you want to describe.
public struct DescribeDomainsInput: Swift.Equatable {
    /// The names of the domains you want to include in the response.
    public var domainNames: [Swift.String]?

    public init(
        domainNames: [Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

extension DescribeDomainsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeDomainsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeDomainsResult"]
            var value = DescribeDomainsOutput()
            value.domainStatusList = try reader["DomainStatusList"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.DomainStatus.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The result of a DescribeDomains request. Contains the status of the domains specified in the request or all domains owned by the account.
public struct DescribeDomainsOutput: Swift.Equatable {
    /// A list that contains the status of each requested domain.
    /// This member is required.
    public var domainStatusList: [CloudSearchClientTypes.DomainStatus]?

    public init(
        domainStatusList: [CloudSearchClientTypes.DomainStatus]? = nil
    )
    {
        self.domainStatusList = domainStatusList
    }
}

enum DescribeDomainsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeExpressionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
        case expressionNames = "ExpressionNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expressionNames = expressionNames {
            if !expressionNames.isEmpty {
                var expressionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExpressionNames"))
                for (index0, standardname0) in expressionNames.enumerated() {
                    try expressionNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var expressionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExpressionNames"))
                try expressionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeExpressions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeExpressionsInput {

    static func urlPathProvider(_ value: DescribeExpressionsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeDomains] operation. Specifies the name of the domain you want to describe. To restrict the response to particular expressions, specify the names of the expressions you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeExpressionsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// Limits the [DescribeExpressions] response to the specified expressions. If not specified, all expressions are shown.
    public var expressionNames: [Swift.String]?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        expressionNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.expressionNames = expressionNames
    }
}

extension DescribeExpressionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeExpressionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeExpressionsResult"]
            var value = DescribeExpressionsOutput()
            value.expressions = try reader["Expressions"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.ExpressionStatus.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The result of a DescribeExpressions request. Contains the expressions configured for the domain specified in the request.
public struct DescribeExpressionsOutput: Swift.Equatable {
    /// The expressions configured for the domain.
    /// This member is required.
    public var expressions: [CloudSearchClientTypes.ExpressionStatus]?

    public init(
        expressions: [CloudSearchClientTypes.ExpressionStatus]? = nil
    )
    {
        self.expressions = expressions
    }
}

enum DescribeExpressionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeIndexFieldsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
        case fieldNames = "FieldNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let fieldNames = fieldNames {
            if !fieldNames.isEmpty {
                var fieldNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FieldNames"))
                for (index0, dynamicfieldname0) in fieldNames.enumerated() {
                    try fieldNamesContainer.encode(dynamicfieldname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var fieldNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FieldNames"))
                try fieldNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeIndexFields", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeIndexFieldsInput {

    static func urlPathProvider(_ value: DescribeIndexFieldsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeIndexFields] operation. Specifies the name of the domain you want to describe. To restrict the response to particular index fields, specify the names of the index fields you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeIndexFieldsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
    public var fieldNames: [Swift.String]?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        fieldNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.fieldNames = fieldNames
    }
}

extension DescribeIndexFieldsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeIndexFieldsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeIndexFieldsResult"]
            var value = DescribeIndexFieldsOutput()
            value.indexFields = try reader["IndexFields"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.IndexFieldStatus.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The result of a DescribeIndexFields request. Contains the index fields configured for the domain specified in the request.
public struct DescribeIndexFieldsOutput: Swift.Equatable {
    /// The index fields configured for the domain.
    /// This member is required.
    public var indexFields: [CloudSearchClientTypes.IndexFieldStatus]?

    public init(
        indexFields: [CloudSearchClientTypes.IndexFieldStatus]? = nil
    )
    {
        self.indexFields = indexFields
    }
}

enum DescribeIndexFieldsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeScalingParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeScalingParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeScalingParametersInput {

    static func urlPathProvider(_ value: DescribeScalingParametersInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeScalingParameters] operation. Specifies the name of the domain you want to describe.
public struct DescribeScalingParametersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension DescribeScalingParametersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeScalingParametersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeScalingParametersResult"]
            var value = DescribeScalingParametersOutput()
            value.scalingParameters = try reader["ScalingParameters"].readIfPresent(readingClosure: CloudSearchClientTypes.ScalingParametersStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DescribeScalingParameters request. Contains the scaling parameters configured for the domain specified in the request.
public struct DescribeScalingParametersOutput: Swift.Equatable {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init(
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

enum DescribeScalingParametersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeServiceAccessPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeServiceAccessPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeServiceAccessPoliciesInput {

    static func urlPathProvider(_ value: DescribeServiceAccessPoliciesInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeServiceAccessPolicies] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeServiceAccessPoliciesInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension DescribeServiceAccessPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeServiceAccessPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeServiceAccessPoliciesResult"]
            var value = DescribeServiceAccessPoliciesOutput()
            value.accessPolicies = try reader["AccessPolicies"].readIfPresent(readingClosure: CloudSearchClientTypes.AccessPoliciesStatus.readingClosure)
            return value
        }
    }
}

/// The result of a DescribeServiceAccessPolicies request.
public struct DescribeServiceAccessPoliciesOutput: Swift.Equatable {
    /// The access rules configured for the domain specified in the request.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init(
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

enum DescribeServiceAccessPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeSuggestersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
        case suggesterNames = "SuggesterNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggesterNames = suggesterNames {
            if !suggesterNames.isEmpty {
                var suggesterNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SuggesterNames"))
                for (index0, standardname0) in suggesterNames.enumerated() {
                    try suggesterNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var suggesterNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SuggesterNames"))
                try suggesterNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeSuggesters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeSuggestersInput {

    static func urlPathProvider(_ value: DescribeSuggestersInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeSuggester] operation. Specifies the name of the domain you want to describe. To restrict the response to particular suggesters, specify the names of the suggesters you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeSuggestersInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// The suggesters you want to describe.
    public var suggesterNames: [Swift.String]?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        suggesterNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.suggesterNames = suggesterNames
    }
}

extension DescribeSuggestersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeSuggestersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeSuggestersResult"]
            var value = DescribeSuggestersOutput()
            value.suggesters = try reader["Suggesters"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.SuggesterStatus.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The result of a DescribeSuggesters request.
public struct DescribeSuggestersOutput: Swift.Equatable {
    /// The suggesters configured for the domain specified in the request.
    /// This member is required.
    public var suggesters: [CloudSearchClientTypes.SuggesterStatus]?

    public init(
        suggesters: [CloudSearchClientTypes.SuggesterStatus]? = nil
    )
    {
        self.suggesters = suggesters
    }
}

enum DescribeSuggestersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DisabledOperationException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DisabledOperationException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it attempted an operation which is not enabled.
public struct DisabledOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DisabledAction" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension CloudSearchClientTypes.DocumentSuggesterOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fuzzyMatching = "FuzzyMatching"
        case sortExpression = "SortExpression"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fuzzyMatching = fuzzyMatching {
            try container.encode(fuzzyMatching, forKey: ClientRuntime.Key("FuzzyMatching"))
        }
        if let sortExpression = sortExpression {
            try container.encode(sortExpression, forKey: ClientRuntime.Key("SortExpression"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DocumentSuggesterOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DocumentSuggesterOptions()
            value.sourceField = try reader["SourceField"].readIfPresent()
            value.fuzzyMatching = try reader["FuzzyMatching"].readIfPresent()
            value.sortExpression = try reader["SortExpression"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a search suggester.
    public struct DocumentSuggesterOptions: Swift.Equatable {
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none.
        public var fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching?
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        public var sortExpression: Swift.String?
        /// The name of the index field you want to use for suggestions.
        /// This member is required.
        public var sourceField: Swift.String?

        public init(
            fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching? = nil,
            sortExpression: Swift.String? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.fuzzyMatching = fuzzyMatching
            self.sortExpression = sortExpression
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes.DomainEndpointOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforceHTTPS = "EnforceHTTPS"
        case tlsSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enforceHTTPS = enforceHTTPS {
            try container.encode(enforceHTTPS, forKey: ClientRuntime.Key("EnforceHTTPS"))
        }
        if let tlsSecurityPolicy = tlsSecurityPolicy {
            try container.encode(tlsSecurityPolicy, forKey: ClientRuntime.Key("TLSSecurityPolicy"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DomainEndpointOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DomainEndpointOptions()
            value.enforceHTTPS = try reader["EnforceHTTPS"].readIfPresent()
            value.tlsSecurityPolicy = try reader["TLSSecurityPolicy"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The domain's endpoint options.
    public struct DomainEndpointOptions: Swift.Equatable {
        /// Whether the domain is HTTPS only enabled.
        public var enforceHTTPS: Swift.Bool?
        /// The minimum required TLS version
        public var tlsSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy?

        public init(
            enforceHTTPS: Swift.Bool? = nil,
            tlsSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy? = nil
        )
        {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension CloudSearchClientTypes.DomainEndpointOptionsStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DomainEndpointOptionsStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DomainEndpointOptionsStatus()
            value.options = try reader["Options"].readIfPresent(readingClosure: CloudSearchClientTypes.DomainEndpointOptions.readingClosure)
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The configuration and status of the domain's endpoint options.
    public struct DomainEndpointOptionsStatus: Swift.Equatable {
        /// The domain endpoint options configured for the domain.
        /// This member is required.
        public var options: CloudSearchClientTypes.DomainEndpointOptions?
        /// The status of the configured domain endpoint options.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.DomainEndpointOptions? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.DomainStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case created = "Created"
        case deleted = "Deleted"
        case docService = "DocService"
        case domainId = "DomainId"
        case domainName = "DomainName"
        case limits = "Limits"
        case processing = "Processing"
        case requiresIndexDocuments = "RequiresIndexDocuments"
        case searchInstanceCount = "SearchInstanceCount"
        case searchInstanceType = "SearchInstanceType"
        case searchPartitionCount = "SearchPartitionCount"
        case searchService = "SearchService"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let created = created {
            try container.encode(created, forKey: ClientRuntime.Key("Created"))
        }
        if let deleted = deleted {
            try container.encode(deleted, forKey: ClientRuntime.Key("Deleted"))
        }
        if let docService = docService {
            try container.encode(docService, forKey: ClientRuntime.Key("DocService"))
        }
        if let domainId = domainId {
            try container.encode(domainId, forKey: ClientRuntime.Key("DomainId"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let limits = limits {
            try container.encode(limits, forKey: ClientRuntime.Key("Limits"))
        }
        if let processing = processing {
            try container.encode(processing, forKey: ClientRuntime.Key("Processing"))
        }
        if let requiresIndexDocuments = requiresIndexDocuments {
            try container.encode(requiresIndexDocuments, forKey: ClientRuntime.Key("RequiresIndexDocuments"))
        }
        if let searchInstanceCount = searchInstanceCount {
            try container.encode(searchInstanceCount, forKey: ClientRuntime.Key("SearchInstanceCount"))
        }
        if let searchInstanceType = searchInstanceType {
            try container.encode(searchInstanceType, forKey: ClientRuntime.Key("SearchInstanceType"))
        }
        if let searchPartitionCount = searchPartitionCount {
            try container.encode(searchPartitionCount, forKey: ClientRuntime.Key("SearchPartitionCount"))
        }
        if let searchService = searchService {
            try container.encode(searchService, forKey: ClientRuntime.Key("SearchService"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DomainStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DomainStatus()
            value.domainId = try reader["DomainId"].readIfPresent()
            value.domainName = try reader["DomainName"].readIfPresent()
            value.arn = try reader["ARN"].readIfPresent()
            value.created = try reader["Created"].readIfPresent()
            value.deleted = try reader["Deleted"].readIfPresent()
            value.docService = try reader["DocService"].readIfPresent(readingClosure: CloudSearchClientTypes.ServiceEndpoint.readingClosure)
            value.searchService = try reader["SearchService"].readIfPresent(readingClosure: CloudSearchClientTypes.ServiceEndpoint.readingClosure)
            value.requiresIndexDocuments = try reader["RequiresIndexDocuments"].readIfPresent()
            value.processing = try reader["Processing"].readIfPresent()
            value.searchInstanceType = try reader["SearchInstanceType"].readIfPresent()
            value.searchPartitionCount = try reader["SearchPartitionCount"].readIfPresent()
            value.searchInstanceCount = try reader["SearchInstanceCount"].readIfPresent()
            value.limits = try reader["Limits"].readIfPresent(readingClosure: CloudSearchClientTypes.Limits.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The current status of the search domain.
    public struct DomainStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the search domain. See [Identifiers for IAM Entities](http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html) in Using AWS Identity and Access Management for more information.
        public var arn: Swift.String?
        /// True if the search domain is created. It can take several minutes to initialize a domain when [CreateDomain] is called. Newly created search domains are returned from [DescribeDomains] with a false value for Created until domain creation is complete.
        public var created: Swift.Bool?
        /// True if the search domain has been deleted. The system must clean up resources dedicated to the search domain when [DeleteDomain] is called. Newly deleted search domains are returned from [DescribeDomains] with a true value for IsDeleted for several minutes until resource cleanup is complete.
        public var deleted: Swift.Bool?
        /// The service endpoint for updating documents in a search domain.
        public var docService: CloudSearchClientTypes.ServiceEndpoint?
        /// An internally generated unique identifier for a domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        /// This member is required.
        public var domainName: Swift.String?
        public var limits: CloudSearchClientTypes.Limits?
        /// True if processing is being done to activate the current domain configuration.
        public var processing: Swift.Bool?
        /// True if [IndexDocuments] needs to be called to activate the current domain configuration.
        /// This member is required.
        public var requiresIndexDocuments: Swift.Bool?
        /// The number of search instances that are available to process search requests.
        public var searchInstanceCount: Swift.Int?
        /// The instance type that is being used to process search requests.
        public var searchInstanceType: Swift.String?
        /// The number of partitions across which the search index is spread.
        public var searchPartitionCount: Swift.Int?
        /// The service endpoint for requesting search results from a search domain.
        public var searchService: CloudSearchClientTypes.ServiceEndpoint?

        public init(
            arn: Swift.String? = nil,
            created: Swift.Bool? = nil,
            deleted: Swift.Bool? = nil,
            docService: CloudSearchClientTypes.ServiceEndpoint? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            limits: CloudSearchClientTypes.Limits? = nil,
            processing: Swift.Bool? = nil,
            requiresIndexDocuments: Swift.Bool? = nil,
            searchInstanceCount: Swift.Int? = nil,
            searchInstanceType: Swift.String? = nil,
            searchPartitionCount: Swift.Int? = nil,
            searchService: CloudSearchClientTypes.ServiceEndpoint? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.deleted = deleted
            self.docService = docService
            self.domainId = domainId
            self.domainName = domainName
            self.limits = limits
            self.processing = processing
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchInstanceCount = searchInstanceCount
            self.searchInstanceType = searchInstanceType
            self.searchPartitionCount = searchPartitionCount
            self.searchService = searchService
        }
    }

}

extension CloudSearchClientTypes.DoubleArrayOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DoubleArrayOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DoubleArrayOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceFields = try reader["SourceFields"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
    public struct DoubleArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.DoubleOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.DoubleOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.DoubleOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceField = try reader["SourceField"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            value.sortEnabled = try reader["SortEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
    public struct DoubleOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes.Expression: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expressionName = "ExpressionName"
        case expressionValue = "ExpressionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: ClientRuntime.Key("ExpressionName"))
        }
        if let expressionValue = expressionValue {
            try container.encode(expressionValue, forKey: ClientRuntime.Key("ExpressionValue"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.Expression, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.Expression()
            value.expressionName = try reader["ExpressionName"].readIfPresent()
            value.expressionValue = try reader["ExpressionValue"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    public struct Expression: Swift.Equatable {
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var expressionName: Swift.String?
        /// The expression to evaluate for sorting while processing a search request. The Expression syntax is based on JavaScript expressions. For more information, see [Configuring Expressions](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-expressions.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var expressionValue: Swift.String?

        public init(
            expressionName: Swift.String? = nil,
            expressionValue: Swift.String? = nil
        )
        {
            self.expressionName = expressionName
            self.expressionValue = expressionValue
        }
    }

}

extension CloudSearchClientTypes.ExpressionStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.ExpressionStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.ExpressionStatus()
            value.options = try reader["Options"].readIfPresent(readingClosure: CloudSearchClientTypes.Expression.readingClosure)
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The value of an Expression and its current status.
    public struct ExpressionStatus: Swift.Equatable {
        /// The expression that is evaluated for sorting while processing a search request.
        /// This member is required.
        public var options: CloudSearchClientTypes.Expression?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.Expression? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension IndexDocumentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("IndexDocuments", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension IndexDocumentsInput {

    static func urlPathProvider(_ value: IndexDocumentsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [IndexDocuments] operation. Specifies the name of the domain you want to re-index.
public struct IndexDocumentsInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension IndexDocumentsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<IndexDocumentsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["IndexDocumentsResult"]
            var value = IndexDocumentsOutput()
            value.fieldNames = try reader["FieldNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The result of an IndexDocuments request. Contains the status of the indexing operation, including the fields being indexed.
public struct IndexDocumentsOutput: Swift.Equatable {
    /// The names of the fields that are currently being indexed.
    public var fieldNames: [Swift.String]?

    public init(
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

enum IndexDocumentsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CloudSearchClientTypes.IndexField: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateArrayOptions = "DateArrayOptions"
        case dateOptions = "DateOptions"
        case doubleArrayOptions = "DoubleArrayOptions"
        case doubleOptions = "DoubleOptions"
        case indexFieldName = "IndexFieldName"
        case indexFieldType = "IndexFieldType"
        case intArrayOptions = "IntArrayOptions"
        case intOptions = "IntOptions"
        case latLonOptions = "LatLonOptions"
        case literalArrayOptions = "LiteralArrayOptions"
        case literalOptions = "LiteralOptions"
        case textArrayOptions = "TextArrayOptions"
        case textOptions = "TextOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dateArrayOptions = dateArrayOptions {
            try container.encode(dateArrayOptions, forKey: ClientRuntime.Key("DateArrayOptions"))
        }
        if let dateOptions = dateOptions {
            try container.encode(dateOptions, forKey: ClientRuntime.Key("DateOptions"))
        }
        if let doubleArrayOptions = doubleArrayOptions {
            try container.encode(doubleArrayOptions, forKey: ClientRuntime.Key("DoubleArrayOptions"))
        }
        if let doubleOptions = doubleOptions {
            try container.encode(doubleOptions, forKey: ClientRuntime.Key("DoubleOptions"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: ClientRuntime.Key("IndexFieldName"))
        }
        if let indexFieldType = indexFieldType {
            try container.encode(indexFieldType, forKey: ClientRuntime.Key("IndexFieldType"))
        }
        if let intArrayOptions = intArrayOptions {
            try container.encode(intArrayOptions, forKey: ClientRuntime.Key("IntArrayOptions"))
        }
        if let intOptions = intOptions {
            try container.encode(intOptions, forKey: ClientRuntime.Key("IntOptions"))
        }
        if let latLonOptions = latLonOptions {
            try container.encode(latLonOptions, forKey: ClientRuntime.Key("LatLonOptions"))
        }
        if let literalArrayOptions = literalArrayOptions {
            try container.encode(literalArrayOptions, forKey: ClientRuntime.Key("LiteralArrayOptions"))
        }
        if let literalOptions = literalOptions {
            try container.encode(literalOptions, forKey: ClientRuntime.Key("LiteralOptions"))
        }
        if let textArrayOptions = textArrayOptions {
            try container.encode(textArrayOptions, forKey: ClientRuntime.Key("TextArrayOptions"))
        }
        if let textOptions = textOptions {
            try container.encode(textOptions, forKey: ClientRuntime.Key("TextOptions"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.IndexField, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.IndexField()
            value.indexFieldName = try reader["IndexFieldName"].readIfPresent()
            value.indexFieldType = try reader["IndexFieldType"].readIfPresent()
            value.intOptions = try reader["IntOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.IntOptions.readingClosure)
            value.doubleOptions = try reader["DoubleOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.DoubleOptions.readingClosure)
            value.literalOptions = try reader["LiteralOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.LiteralOptions.readingClosure)
            value.textOptions = try reader["TextOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.TextOptions.readingClosure)
            value.dateOptions = try reader["DateOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.DateOptions.readingClosure)
            value.latLonOptions = try reader["LatLonOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.LatLonOptions.readingClosure)
            value.intArrayOptions = try reader["IntArrayOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.IntArrayOptions.readingClosure)
            value.doubleArrayOptions = try reader["DoubleArrayOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.DoubleArrayOptions.readingClosure)
            value.literalArrayOptions = try reader["LiteralArrayOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.LiteralArrayOptions.readingClosure)
            value.textArrayOptions = try reader["TextArrayOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.TextArrayOptions.readingClosure)
            value.dateArrayOptions = try reader["DateArrayOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.DateArrayOptions.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
    public struct IndexField: Swift.Equatable {
        /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
        public var dateArrayOptions: CloudSearchClientTypes.DateArrayOptions?
        /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
        public var dateOptions: CloudSearchClientTypes.DateOptions?
        /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
        public var doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions?
        /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
        public var doubleOptions: CloudSearchClientTypes.DoubleOptions?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        /// This member is required.
        public var indexFieldName: Swift.String?
        /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var indexFieldType: CloudSearchClientTypes.IndexFieldType?
        /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
        public var intArrayOptions: CloudSearchClientTypes.IntArrayOptions?
        /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
        public var intOptions: CloudSearchClientTypes.IntOptions?
        /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
        public var latLonOptions: CloudSearchClientTypes.LatLonOptions?
        /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
        public var literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions?
        /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
        public var literalOptions: CloudSearchClientTypes.LiteralOptions?
        /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
        public var textArrayOptions: CloudSearchClientTypes.TextArrayOptions?
        /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
        public var textOptions: CloudSearchClientTypes.TextOptions?

        public init(
            dateArrayOptions: CloudSearchClientTypes.DateArrayOptions? = nil,
            dateOptions: CloudSearchClientTypes.DateOptions? = nil,
            doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions? = nil,
            doubleOptions: CloudSearchClientTypes.DoubleOptions? = nil,
            indexFieldName: Swift.String? = nil,
            indexFieldType: CloudSearchClientTypes.IndexFieldType? = nil,
            intArrayOptions: CloudSearchClientTypes.IntArrayOptions? = nil,
            intOptions: CloudSearchClientTypes.IntOptions? = nil,
            latLonOptions: CloudSearchClientTypes.LatLonOptions? = nil,
            literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions? = nil,
            literalOptions: CloudSearchClientTypes.LiteralOptions? = nil,
            textArrayOptions: CloudSearchClientTypes.TextArrayOptions? = nil,
            textOptions: CloudSearchClientTypes.TextOptions? = nil
        )
        {
            self.dateArrayOptions = dateArrayOptions
            self.dateOptions = dateOptions
            self.doubleArrayOptions = doubleArrayOptions
            self.doubleOptions = doubleOptions
            self.indexFieldName = indexFieldName
            self.indexFieldType = indexFieldType
            self.intArrayOptions = intArrayOptions
            self.intOptions = intOptions
            self.latLonOptions = latLonOptions
            self.literalArrayOptions = literalArrayOptions
            self.literalOptions = literalOptions
            self.textArrayOptions = textArrayOptions
            self.textOptions = textOptions
        }
    }

}

extension CloudSearchClientTypes.IndexFieldStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.IndexFieldStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.IndexFieldStatus()
            value.options = try reader["Options"].readIfPresent(readingClosure: CloudSearchClientTypes.IndexField.readingClosure)
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The value of an IndexField and its current status.
    public struct IndexFieldStatus: Swift.Equatable {
        /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
        /// This member is required.
        public var options: CloudSearchClientTypes.IndexField?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.IndexField? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
    public enum IndexFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case dateArray
        case double
        case doubleArray
        case int
        case intArray
        case latlon
        case literal
        case literalArray
        case text
        case textArray
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexFieldType] {
            return [
                .date,
                .dateArray,
                .double,
                .doubleArray,
                .int,
                .intArray,
                .latlon,
                .literal,
                .literalArray,
                .text,
                .textArray,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "date"
            case .dateArray: return "date-array"
            case .double: return "double"
            case .doubleArray: return "double-array"
            case .int: return "int"
            case .intArray: return "int-array"
            case .latlon: return "latlon"
            case .literal: return "literal"
            case .literalArray: return "literal-array"
            case .text: return "text"
            case .textArray: return "text-array"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IndexFieldType(rawValue: rawValue) ?? IndexFieldType.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.IntArrayOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.IntArrayOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.IntArrayOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceFields = try reader["SourceFields"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
    public struct IntArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.IntOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.IntOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.IntOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceField = try reader["SourceField"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            value.sortEnabled = try reader["SortEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
    public struct IntOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension InternalException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InternalException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// An internal error occurred while processing the request. If this problem persists, report an issue from the [Service Health Dashboard](http://status.aws.amazon.com/).
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension InvalidTypeException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidTypeException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it specified an invalid type definition.
public struct InvalidTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidType" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension CloudSearchClientTypes.LatLonOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.LatLonOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.LatLonOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceField = try reader["SourceField"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            value.sortEnabled = try reader["SortEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
    public struct LatLonOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension LimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = LimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because a resource limit has already been met.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension CloudSearchClientTypes.Limits: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumPartitionCount = "MaximumPartitionCount"
        case maximumReplicationCount = "MaximumReplicationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maximumPartitionCount = maximumPartitionCount {
            try container.encode(maximumPartitionCount, forKey: ClientRuntime.Key("MaximumPartitionCount"))
        }
        if let maximumReplicationCount = maximumReplicationCount {
            try container.encode(maximumReplicationCount, forKey: ClientRuntime.Key("MaximumReplicationCount"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.Limits, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.Limits()
            value.maximumReplicationCount = try reader["MaximumReplicationCount"].readIfPresent()
            value.maximumPartitionCount = try reader["MaximumPartitionCount"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    public struct Limits: Swift.Equatable {
        /// This member is required.
        public var maximumPartitionCount: Swift.Int?
        /// This member is required.
        public var maximumReplicationCount: Swift.Int?

        public init(
            maximumPartitionCount: Swift.Int? = nil,
            maximumReplicationCount: Swift.Int? = nil
        )
        {
            self.maximumPartitionCount = maximumPartitionCount
            self.maximumReplicationCount = maximumReplicationCount
        }
    }

}

extension ListDomainNamesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListDomainNames", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListDomainNamesInput {

    static func urlPathProvider(_ value: ListDomainNamesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListDomainNamesInput: Swift.Equatable {

    public init() { }
}

extension ListDomainNamesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListDomainNamesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListDomainNamesResult"]
            var value = ListDomainNamesOutput()
            value.domainNames = try reader["DomainNames"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

/// The result of a ListDomainNames request. Contains a list of the domains owned by an account.
public struct ListDomainNamesOutput: Swift.Equatable {
    /// The names of the search domains owned by an account.
    public var domainNames: [Swift.String:Swift.String]?

    public init(
        domainNames: [Swift.String:Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

enum ListDomainNamesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CloudSearchClientTypes.LiteralArrayOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.LiteralArrayOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.LiteralArrayOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceFields = try reader["SourceFields"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
    public struct LiteralArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.LiteralOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.LiteralOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.LiteralOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceField = try reader["SourceField"].readIfPresent()
            value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
            value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            value.sortEnabled = try reader["SortEnabled"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
    public struct LiteralOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// The state of processing a change to an option. One of:
    ///
    /// * RequiresIndexDocuments: The option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
    ///
    /// * Processing: The option's latest value is in the process of being activated.
    ///
    /// * Active: The option's latest value is fully deployed.
    ///
    /// * FailedToValidate: The option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
    public enum OptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failedtovalidate
        case processing
        case requiresindexdocuments
        case sdkUnknown(Swift.String)

        public static var allCases: [OptionState] {
            return [
                .active,
                .failedtovalidate,
                .processing,
                .requiresindexdocuments,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failedtovalidate: return "FailedToValidate"
            case .processing: return "Processing"
            case .requiresindexdocuments: return "RequiresIndexDocuments"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptionState(rawValue: rawValue) ?? OptionState.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.OptionStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case pendingDeletion = "PendingDeletion"
        case state = "State"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let creationDate = creationDate {
            try container.encodeTimestamp(creationDate, format: .dateTime, forKey: ClientRuntime.Key("CreationDate"))
        }
        if let pendingDeletion = pendingDeletion {
            try container.encode(pendingDeletion, forKey: ClientRuntime.Key("PendingDeletion"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("UpdateDate"))
        }
        if updateVersion != 0 {
            try container.encode(updateVersion, forKey: ClientRuntime.Key("UpdateVersion"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.OptionStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.OptionStatus()
            value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: .dateTime)
            value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: .dateTime)
            value.updateVersion = try reader["UpdateVersion"].readIfPresent() ?? 0
            value.state = try reader["State"].readIfPresent()
            value.pendingDeletion = try reader["PendingDeletion"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The status of domain configuration option.
    public struct OptionStatus: Swift.Equatable {
        /// A timestamp for when this option was created.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// Indicates that the option will be deleted once processing is complete.
        public var pendingDeletion: Swift.Bool?
        /// The state of processing a change to an option. Possible values:
        ///
        /// * RequiresIndexDocuments: the option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
        ///
        /// * Processing: the option's latest value is in the process of being activated.
        ///
        /// * Active: the option's latest value is completely deployed.
        ///
        /// * FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
        /// This member is required.
        public var state: CloudSearchClientTypes.OptionState?
        /// A timestamp for when this option was last updated.
        /// This member is required.
        public var updateDate: ClientRuntime.Date?
        /// A unique integer that indicates when this option was last updated.
        public var updateVersion: Swift.Int

        public init(
            creationDate: ClientRuntime.Date? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: CloudSearchClientTypes.OptionState? = nil,
            updateDate: ClientRuntime.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension CloudSearchClientTypes {
    /// The instance type (such as search.m1.small) on which an index partition is hosted.
    public enum PartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case search2xlarge
        case searchLarge
        case searchM1Large
        case searchM1Small
        case searchM22xlarge
        case searchM2Xlarge
        case searchM32xlarge
        case searchM3Large
        case searchM3Medium
        case searchM3Xlarge
        case searchMedium
        case searchPreviousgeneration2xlarge
        case searchPreviousgenerationLarge
        case searchPreviousgenerationSmall
        case searchPreviousgenerationXlarge
        case searchSmall
        case searchXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [PartitionInstanceType] {
            return [
                .search2xlarge,
                .searchLarge,
                .searchM1Large,
                .searchM1Small,
                .searchM22xlarge,
                .searchM2Xlarge,
                .searchM32xlarge,
                .searchM3Large,
                .searchM3Medium,
                .searchM3Xlarge,
                .searchMedium,
                .searchPreviousgeneration2xlarge,
                .searchPreviousgenerationLarge,
                .searchPreviousgenerationSmall,
                .searchPreviousgenerationXlarge,
                .searchSmall,
                .searchXlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .search2xlarge: return "search.2xlarge"
            case .searchLarge: return "search.large"
            case .searchM1Large: return "search.m1.large"
            case .searchM1Small: return "search.m1.small"
            case .searchM22xlarge: return "search.m2.2xlarge"
            case .searchM2Xlarge: return "search.m2.xlarge"
            case .searchM32xlarge: return "search.m3.2xlarge"
            case .searchM3Large: return "search.m3.large"
            case .searchM3Medium: return "search.m3.medium"
            case .searchM3Xlarge: return "search.m3.xlarge"
            case .searchMedium: return "search.medium"
            case .searchPreviousgeneration2xlarge: return "search.previousgeneration.2xlarge"
            case .searchPreviousgenerationLarge: return "search.previousgeneration.large"
            case .searchPreviousgenerationSmall: return "search.previousgeneration.small"
            case .searchPreviousgenerationXlarge: return "search.previousgeneration.xlarge"
            case .searchSmall: return "search.small"
            case .searchXlarge: return "search.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartitionInstanceType(rawValue: rawValue) ?? PartitionInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ResourceAlreadyExistsException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension ResourceNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ResourceNotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it attempted to reference a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension CloudSearchClientTypes.ScalingParameters: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredInstanceType = "DesiredInstanceType"
        case desiredPartitionCount = "DesiredPartitionCount"
        case desiredReplicationCount = "DesiredReplicationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let desiredInstanceType = desiredInstanceType {
            try container.encode(desiredInstanceType, forKey: ClientRuntime.Key("DesiredInstanceType"))
        }
        if desiredPartitionCount != 0 {
            try container.encode(desiredPartitionCount, forKey: ClientRuntime.Key("DesiredPartitionCount"))
        }
        if desiredReplicationCount != 0 {
            try container.encode(desiredReplicationCount, forKey: ClientRuntime.Key("DesiredReplicationCount"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.ScalingParameters, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.ScalingParameters()
            value.desiredInstanceType = try reader["DesiredInstanceType"].readIfPresent()
            value.desiredReplicationCount = try reader["DesiredReplicationCount"].readIfPresent() ?? 0
            value.desiredPartitionCount = try reader["DesiredPartitionCount"].readIfPresent() ?? 0
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The desired instance type and desired number of replicas of each index partition.
    public struct ScalingParameters: Swift.Equatable {
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        public var desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType?
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        public var desiredPartitionCount: Swift.Int
        /// The number of replicas you want to preconfigure for each index partition.
        public var desiredReplicationCount: Swift.Int

        public init(
            desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType? = nil,
            desiredPartitionCount: Swift.Int = 0,
            desiredReplicationCount: Swift.Int = 0
        )
        {
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
            self.desiredReplicationCount = desiredReplicationCount
        }
    }

}

extension CloudSearchClientTypes.ScalingParametersStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.ScalingParametersStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.ScalingParametersStatus()
            value.options = try reader["Options"].readIfPresent(readingClosure: CloudSearchClientTypes.ScalingParameters.readingClosure)
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The status and configuration of a search domain's scaling parameters.
    public struct ScalingParametersStatus: Swift.Equatable {
        /// The desired instance type and desired number of replicas of each index partition.
        /// This member is required.
        public var options: CloudSearchClientTypes.ScalingParameters?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.ScalingParameters? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.ServiceEndpoint: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.ServiceEndpoint, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.ServiceEndpoint()
            value.endpoint = try reader["Endpoint"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The endpoint to which service requests can be submitted.
    public struct ServiceEndpoint: Swift.Equatable {
        /// The endpoint to which service requests can be submitted. For example, search-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com or doc-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com.
        public var endpoint: Swift.String?

        public init(
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension CloudSearchClientTypes.Suggester: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentSuggesterOptions = "DocumentSuggesterOptions"
        case suggesterName = "SuggesterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let documentSuggesterOptions = documentSuggesterOptions {
            try container.encode(documentSuggesterOptions, forKey: ClientRuntime.Key("DocumentSuggesterOptions"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: ClientRuntime.Key("SuggesterName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.Suggester, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.Suggester()
            value.suggesterName = try reader["SuggesterName"].readIfPresent()
            value.documentSuggesterOptions = try reader["DocumentSuggesterOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.DocumentSuggesterOptions.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    public struct Suggester: Swift.Equatable {
        /// Options for a search suggester.
        /// This member is required.
        public var documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var suggesterName: Swift.String?

        public init(
            documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions? = nil,
            suggesterName: Swift.String? = nil
        )
        {
            self.documentSuggesterOptions = documentSuggesterOptions
            self.suggesterName = suggesterName
        }
    }

}

extension CloudSearchClientTypes {
    public enum SuggesterFuzzyMatching: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggesterFuzzyMatching] {
            return [
                .high,
                .low,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SuggesterFuzzyMatching(rawValue: rawValue) ?? SuggesterFuzzyMatching.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.SuggesterStatus: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.SuggesterStatus, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.SuggesterStatus()
            value.options = try reader["Options"].readIfPresent(readingClosure: CloudSearchClientTypes.Suggester.readingClosure)
            value.status = try reader["Status"].readIfPresent(readingClosure: CloudSearchClientTypes.OptionStatus.readingClosure)
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// The value of a Suggester and its current status.
    public struct SuggesterStatus: Swift.Equatable {
        /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
        /// This member is required.
        public var options: CloudSearchClientTypes.Suggester?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.Suggester? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    /// The minimum required TLS version.
    public enum TLSSecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyMinTls10201907
        case policyMinTls12201907
        case sdkUnknown(Swift.String)

        public static var allCases: [TLSSecurityPolicy] {
            return [
                .policyMinTls10201907,
                .policyMinTls12201907,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyMinTls10201907: return "Policy-Min-TLS-1-0-2019-07"
            case .policyMinTls12201907: return "Policy-Min-TLS-1-2-2019-07"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TLSSecurityPolicy(rawValue: rawValue) ?? TLSSecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.TextArrayOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: ClientRuntime.Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.TextArrayOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.TextArrayOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceFields = try reader["SourceFields"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            value.highlightEnabled = try reader["HighlightEnabled"].readIfPresent()
            value.analysisScheme = try reader["AnalysisScheme"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
    public struct TextArrayOptions: Swift.Equatable {
        /// The name of an analysis scheme for a text-array field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.TextOptions: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: ClientRuntime.Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<CloudSearchClientTypes.TextOptions, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = CloudSearchClientTypes.TextOptions()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.sourceField = try reader["SourceField"].readIfPresent()
            value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
            value.sortEnabled = try reader["SortEnabled"].readIfPresent()
            value.highlightEnabled = try reader["HighlightEnabled"].readIfPresent()
            value.analysisScheme = try reader["AnalysisScheme"].readIfPresent()
            return value
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
    public struct TextOptions: Swift.Equatable {
        /// The name of an analysis scheme for a text field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension UpdateAvailabilityOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case multiAZ = "MultiAZ"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        try container.encode("UpdateAvailabilityOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAvailabilityOptionsInput {

    static func urlPathProvider(_ value: UpdateAvailabilityOptionsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateAvailabilityOptions] operation. Specifies the name of the domain you want to update and the Multi-AZ availability option.
public struct UpdateAvailabilityOptionsInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false.
    /// This member is required.
    public var multiAZ: Swift.Bool?

    public init(
        domainName: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.multiAZ = multiAZ
    }
}

extension UpdateAvailabilityOptionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateAvailabilityOptionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UpdateAvailabilityOptionsResult"]
            var value = UpdateAvailabilityOptionsOutput()
            value.availabilityOptions = try reader["AvailabilityOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.AvailabilityOptionsStatus.readingClosure)
            return value
        }
    }
}

/// The result of a UpdateAvailabilityOptions request. Contains the status of the domain's availability options.
public struct UpdateAvailabilityOptionsOutput: Swift.Equatable {
    /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init(
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

enum UpdateAvailabilityOptionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DisabledAction": return try await DisabledOperationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateDomainEndpointOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainEndpointOptions = domainEndpointOptions {
            try container.encode(domainEndpointOptions, forKey: ClientRuntime.Key("DomainEndpointOptions"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("UpdateDomainEndpointOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateDomainEndpointOptionsInput {

    static func urlPathProvider(_ value: UpdateDomainEndpointOptionsInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateDomainEndpointOptions] operation. Specifies the name of the domain you want to update and the domain endpoint options.
public struct UpdateDomainEndpointOptionsInput: Swift.Equatable {
    /// Whether to require that all requests to the domain arrive over HTTPS. We recommend Policy-Min-TLS-1-2-2019-07 for TLSSecurityPolicy. For compatibility with older clients, the default is Policy-Min-TLS-1-0-2019-07.
    /// This member is required.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
    }
}

extension UpdateDomainEndpointOptionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateDomainEndpointOptionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UpdateDomainEndpointOptionsResult"]
            var value = UpdateDomainEndpointOptionsOutput()
            value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(readingClosure: CloudSearchClientTypes.DomainEndpointOptionsStatus.readingClosure)
            return value
        }
    }
}

/// The result of a UpdateDomainEndpointOptions request. Contains the configuration and status of the domain's endpoint options.
public struct UpdateDomainEndpointOptionsOutput: Swift.Equatable {
    /// The newly-configured domain endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init(
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

enum UpdateDomainEndpointOptionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DisabledAction": return try await DisabledOperationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateScalingParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case scalingParameters = "ScalingParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let scalingParameters = scalingParameters {
            try container.encode(scalingParameters, forKey: ClientRuntime.Key("ScalingParameters"))
        }
        try container.encode("UpdateScalingParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateScalingParametersInput {

    static func urlPathProvider(_ value: UpdateScalingParametersInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateScalingParameters] operation. Specifies the name of the domain you want to update and the scaling parameters you want to configure.
public struct UpdateScalingParametersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The desired instance type and desired number of replicas of each index partition.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParameters?

    public init(
        domainName: Swift.String? = nil,
        scalingParameters: CloudSearchClientTypes.ScalingParameters? = nil
    )
    {
        self.domainName = domainName
        self.scalingParameters = scalingParameters
    }
}

extension UpdateScalingParametersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateScalingParametersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UpdateScalingParametersResult"]
            var value = UpdateScalingParametersOutput()
            value.scalingParameters = try reader["ScalingParameters"].readIfPresent(readingClosure: CloudSearchClientTypes.ScalingParametersStatus.readingClosure)
            return value
        }
    }
}

/// The result of a UpdateScalingParameters request. Contains the status of the newly-configured scaling parameters.
public struct UpdateScalingParametersOutput: Swift.Equatable {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init(
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

enum UpdateScalingParametersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UpdateServiceAccessPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessPolicies = accessPolicies {
            try container.encode(accessPolicies, forKey: ClientRuntime.Key("AccessPolicies"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("UpdateServiceAccessPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServiceAccessPoliciesInput {

    static func urlPathProvider(_ value: UpdateServiceAccessPoliciesInput) -> Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateServiceAccessPolicies] operation. Specifies the name of the domain you want to update and the access rules you want to configure.
public struct UpdateServiceAccessPoliciesInput: Swift.Equatable {
    /// The access rules you want to configure. These rules replace any existing rules.
    /// This member is required.
    public var accessPolicies: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        accessPolicies: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.domainName = domainName
    }
}

extension UpdateServiceAccessPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UpdateServiceAccessPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["UpdateServiceAccessPoliciesResult"]
            var value = UpdateServiceAccessPoliciesOutput()
            value.accessPolicies = try reader["AccessPolicies"].readIfPresent(readingClosure: CloudSearchClientTypes.AccessPoliciesStatus.readingClosure)
            return value
        }
    }
}

/// The result of an UpdateServiceAccessPolicies request. Contains the new access policies.
public struct UpdateServiceAccessPoliciesOutput: Swift.Equatable {
    /// The access rules configured for the domain.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init(
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

enum UpdateServiceAccessPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "BaseException": return try await BaseException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalException": return try await InternalException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidType": return try await InvalidTypeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LimitExceeded": return try await LimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ValidationException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ValidationException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because it has invalid parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}
