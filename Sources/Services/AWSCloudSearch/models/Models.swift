// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CloudSearchClientTypes.AccessPoliciesStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The configured access rules for the domain's document and search endpoints, and the current status of those rules.
    public struct AccessPoliciesStatus: Swift.Equatable {
        /// Access rules for a domain's document or search service endpoints. For more information, see [Configuring Access for a Search Domain](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-access.html) in the Amazon CloudSearch Developer Guide. The maximum size of a policy document is 100 KB.
        /// This member is required.
        public var options: Swift.String?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: Swift.String? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    public enum AlgorithmicStemming: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case light
        case minimal
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmicStemming] {
            return [
                .full,
                .light,
                .minimal,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "full"
            case .light: return "light"
            case .minimal: return "minimal"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlgorithmicStemming(rawValue: rawValue) ?? AlgorithmicStemming.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.AnalysisOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmicStemming = "AlgorithmicStemming"
        case japaneseTokenizationDictionary = "JapaneseTokenizationDictionary"
        case stemmingDictionary = "StemmingDictionary"
        case stopwords = "Stopwords"
        case synonyms = "Synonyms"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let algorithmicStemming = algorithmicStemming {
            try container.encode(algorithmicStemming, forKey: ClientRuntime.Key("AlgorithmicStemming"))
        }
        if let japaneseTokenizationDictionary = japaneseTokenizationDictionary {
            try container.encode(japaneseTokenizationDictionary, forKey: ClientRuntime.Key("JapaneseTokenizationDictionary"))
        }
        if let stemmingDictionary = stemmingDictionary {
            try container.encode(stemmingDictionary, forKey: ClientRuntime.Key("StemmingDictionary"))
        }
        if let stopwords = stopwords {
            try container.encode(stopwords, forKey: ClientRuntime.Key("Stopwords"))
        }
        if let synonyms = synonyms {
            try container.encode(synonyms, forKey: ClientRuntime.Key("Synonyms"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let synonymsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .synonyms)
        synonyms = synonymsDecoded
        let stopwordsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stopwords)
        stopwords = stopwordsDecoded
        let stemmingDictionaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stemmingDictionary)
        stemmingDictionary = stemmingDictionaryDecoded
        let japaneseTokenizationDictionaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .japaneseTokenizationDictionary)
        japaneseTokenizationDictionary = japaneseTokenizationDictionaryDecoded
        let algorithmicStemmingDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AlgorithmicStemming.self, forKey: .algorithmicStemming)
        algorithmicStemming = algorithmicStemmingDecoded
    }
}

extension CloudSearchClientTypes {
    /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
    public struct AnalysisOptions: Swift.Equatable {
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see [Language Specific Text Processing Settings](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/text-processing.html#text-processing-settings) in the Amazon CloudSearch Developer Guide
        public var algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming?
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        public var japaneseTokenizationDictionary: Swift.String?
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        public var stemmingDictionary: Swift.String?
        /// A JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported.
        public var stopwords: Swift.String?
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see [Synonyms](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-analysis-schemes.html#synonyms) in the Amazon CloudSearch Developer Guide.
        public var synonyms: Swift.String?

        public init (
            algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming? = nil,
            japaneseTokenizationDictionary: Swift.String? = nil,
            stemmingDictionary: Swift.String? = nil,
            stopwords: Swift.String? = nil,
            synonyms: Swift.String? = nil
        )
        {
            self.algorithmicStemming = algorithmicStemming
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stemmingDictionary = stemmingDictionary
            self.stopwords = stopwords
            self.synonyms = synonyms
        }
    }

}

extension CloudSearchClientTypes.AnalysisScheme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisOptions = "AnalysisOptions"
        case analysisSchemeLanguage = "AnalysisSchemeLanguage"
        case analysisSchemeName = "AnalysisSchemeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisOptions = analysisOptions {
            try container.encode(analysisOptions, forKey: ClientRuntime.Key("AnalysisOptions"))
        }
        if let analysisSchemeLanguage = analysisSchemeLanguage {
            try container.encode(analysisSchemeLanguage, forKey: ClientRuntime.Key("AnalysisSchemeLanguage"))
        }
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: ClientRuntime.Key("AnalysisSchemeName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSchemeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisSchemeName)
        analysisSchemeName = analysisSchemeNameDecoded
        let analysisSchemeLanguageDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisSchemeLanguage.self, forKey: .analysisSchemeLanguage)
        analysisSchemeLanguage = analysisSchemeLanguageDecoded
        let analysisOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisOptions.self, forKey: .analysisOptions)
        analysisOptions = analysisOptionsDecoded
    }
}

extension CloudSearchClientTypes {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    public struct AnalysisScheme: Swift.Equatable {
        /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
        public var analysisOptions: CloudSearchClientTypes.AnalysisOptions?
        /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
        /// This member is required.
        public var analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var analysisSchemeName: Swift.String?

        public init (
            analysisOptions: CloudSearchClientTypes.AnalysisOptions? = nil,
            analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage? = nil,
            analysisSchemeName: Swift.String? = nil
        )
        {
            self.analysisOptions = analysisOptions
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
        }
    }

}

extension CloudSearchClientTypes {
    /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
    public enum AnalysisSchemeLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ar
        case bg
        case ca
        case cs
        case da
        case de
        case el
        case en
        case es
        case eu
        case fa
        case fi
        case fr
        case ga
        case gl
        case he
        case hi
        case hu
        case hy
        case id
        case it
        case ja
        case ko
        case lv
        case mul
        case nl
        case no
        case pt
        case ro
        case ru
        case sv
        case th
        case tr
        case zhHans
        case zhHant
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisSchemeLanguage] {
            return [
                .ar,
                .bg,
                .ca,
                .cs,
                .da,
                .de,
                .el,
                .en,
                .es,
                .eu,
                .fa,
                .fi,
                .fr,
                .ga,
                .gl,
                .he,
                .hi,
                .hu,
                .hy,
                .id,
                .it,
                .ja,
                .ko,
                .lv,
                .mul,
                .nl,
                .no,
                .pt,
                .ro,
                .ru,
                .sv,
                .th,
                .tr,
                .zhHans,
                .zhHant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ar: return "ar"
            case .bg: return "bg"
            case .ca: return "ca"
            case .cs: return "cs"
            case .da: return "da"
            case .de: return "de"
            case .el: return "el"
            case .en: return "en"
            case .es: return "es"
            case .eu: return "eu"
            case .fa: return "fa"
            case .fi: return "fi"
            case .fr: return "fr"
            case .ga: return "ga"
            case .gl: return "gl"
            case .he: return "he"
            case .hi: return "hi"
            case .hu: return "hu"
            case .hy: return "hy"
            case .id: return "id"
            case .it: return "it"
            case .ja: return "ja"
            case .ko: return "ko"
            case .lv: return "lv"
            case .mul: return "mul"
            case .nl: return "nl"
            case .no: return "no"
            case .pt: return "pt"
            case .ro: return "ro"
            case .ru: return "ru"
            case .sv: return "sv"
            case .th: return "th"
            case .tr: return "tr"
            case .zhHans: return "zh-Hans"
            case .zhHant: return "zh-Hant"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisSchemeLanguage(rawValue: rawValue) ?? AnalysisSchemeLanguage.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.AnalysisSchemeStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisScheme.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The status and configuration of an AnalysisScheme.
    public struct AnalysisSchemeStatus: Swift.Equatable {
        /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
        /// This member is required.
        public var options: CloudSearchClientTypes.AnalysisScheme?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.AnalysisScheme? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.AvailabilityOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if options != false {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The status and configuration of the domain's availability options.
    public struct AvailabilityOptionsStatus: Swift.Equatable {
        /// The availability options configured for the domain.
        /// This member is required.
        public var options: Swift.Bool
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: Swift.Bool = false,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension BaseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<BaseExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred while processing the request.
public struct BaseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BaseExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension BaseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BuildSuggestersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("BuildSuggesters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension BuildSuggestersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [BuildSuggester] operation. Specifies the name of the domain you want to update.
public struct BuildSuggestersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct BuildSuggestersInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension BuildSuggestersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension BuildSuggestersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BuildSuggestersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BuildSuggestersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BuildSuggestersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BuildSuggestersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fieldNames = output.fieldNames
        } else {
            self.fieldNames = nil
        }
    }
}

/// The result of a BuildSuggester request. Contains a list of the fields used for suggestions.
public struct BuildSuggestersOutputResponse: Swift.Equatable {
    /// A list of field names.
    public var fieldNames: [Swift.String]?

    public init (
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

struct BuildSuggestersOutputResponseBody: Swift.Equatable {
    let fieldNames: [Swift.String]?
}

extension BuildSuggestersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldNames = "FieldNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("BuildSuggestersResult"))
        if containerValues.contains(.fieldNames) {
            struct KeyVal0{struct member{}}
            let fieldNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fieldNames)
            if let fieldNamesWrappedContainer = fieldNamesWrappedContainer {
                let fieldNamesContainer = try fieldNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldNamesBuffer:[Swift.String]? = nil
                if let fieldNamesContainer = fieldNamesContainer {
                    fieldNamesBuffer = [Swift.String]()
                    for stringContainer0 in fieldNamesContainer {
                        fieldNamesBuffer?.append(stringContainer0)
                    }
                }
                fieldNames = fieldNamesBuffer
            } else {
                fieldNames = []
            }
        } else {
            fieldNames = nil
        }
    }
}

extension CreateDomainInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("CreateDomain", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [CreateDomain] operation. Specifies a name for the new search domain.
public struct CreateDomainInput: Swift.Equatable {
    /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExists" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// The result of a CreateDomainRequest. Contains the status of a newly created domain.
public struct CreateDomainOutputResponse: Swift.Equatable {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init (
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    let domainStatus: CloudSearchClientTypes.DomainStatus?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDomainResult"))
        let domainStatusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension CloudSearchClientTypes.DateArrayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
    public struct DateArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.DateOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
    public struct DateOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension DefineAnalysisSchemeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DefineAnalysisScheme", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineAnalysisSchemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme configuration.
public struct DefineAnalysisSchemeInput: Swift.Equatable {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisScheme?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        analysisScheme: CloudSearchClientTypes.AnalysisScheme? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisScheme = analysisScheme
        self.domainName = domainName
    }
}

struct DefineAnalysisSchemeInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let analysisScheme: CloudSearchClientTypes.AnalysisScheme?
}

extension DefineAnalysisSchemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisScheme.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension DefineAnalysisSchemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineAnalysisSchemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DefineAnalysisSchemeOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineAnalysisSchemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DefineAnalysisSchemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisScheme = output.analysisScheme
        } else {
            self.analysisScheme = nil
        }
    }
}

/// The result of a [DefineAnalysisScheme] request. Contains the status of the newly-configured analysis scheme.
public struct DefineAnalysisSchemeOutputResponse: Swift.Equatable {
    /// The status and configuration of an AnalysisScheme.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init (
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

struct DefineAnalysisSchemeOutputResponseBody: Swift.Equatable {
    let analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?
}

extension DefineAnalysisSchemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineAnalysisSchemeResult"))
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisSchemeStatus.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension DefineExpressionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expression = expression {
            try container.encode(expression, forKey: ClientRuntime.Key("Expression"))
        }
        try container.encode("DefineExpression", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineExpressionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineExpression] operation. Specifies the name of the domain you want to update and the expression you want to configure.
public struct DefineExpressionInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    /// This member is required.
    public var expression: CloudSearchClientTypes.Expression?

    public init (
        domainName: Swift.String? = nil,
        expression: CloudSearchClientTypes.Expression? = nil
    )
    {
        self.domainName = domainName
        self.expression = expression
    }
}

struct DefineExpressionInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let expression: CloudSearchClientTypes.Expression?
}

extension DefineExpressionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case expression = "Expression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Expression.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension DefineExpressionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineExpressionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DefineExpressionOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineExpressionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DefineExpressionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expression = output.expression
        } else {
            self.expression = nil
        }
    }
}

/// The result of a DefineExpression request. Contains the status of the newly-configured expression.
public struct DefineExpressionOutputResponse: Swift.Equatable {
    /// The value of an Expression and its current status.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init (
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

struct DefineExpressionOutputResponseBody: Swift.Equatable {
    let expression: CloudSearchClientTypes.ExpressionStatus?
}

extension DefineExpressionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineExpressionResult"))
        let expressionDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ExpressionStatus.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension DefineIndexFieldInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let indexField = indexField {
            try container.encode(indexField, forKey: ClientRuntime.Key("IndexField"))
        }
        try container.encode("DefineIndexField", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineIndexFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineIndexField] operation. Specifies the name of the domain you want to update and the index field configuration.
public struct DefineIndexFieldInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The index field and field options you want to configure.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexField?

    public init (
        domainName: Swift.String? = nil,
        indexField: CloudSearchClientTypes.IndexField? = nil
    )
    {
        self.domainName = domainName
        self.indexField = indexField
    }
}

struct DefineIndexFieldInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let indexField: CloudSearchClientTypes.IndexField?
}

extension DefineIndexFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case indexField = "IndexField"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let indexFieldDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexField.self, forKey: .indexField)
        indexField = indexFieldDecoded
    }
}

extension DefineIndexFieldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineIndexFieldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DefineIndexFieldOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineIndexFieldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DefineIndexFieldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexField = output.indexField
        } else {
            self.indexField = nil
        }
    }
}

/// The result of a [DefineIndexField] request. Contains the status of the newly-configured index field.
public struct DefineIndexFieldOutputResponse: Swift.Equatable {
    /// The value of an IndexField and its current status.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init (
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

struct DefineIndexFieldOutputResponseBody: Swift.Equatable {
    let indexField: CloudSearchClientTypes.IndexFieldStatus?
}

extension DefineIndexFieldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexField = "IndexField"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineIndexFieldResult"))
        let indexFieldDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexFieldStatus.self, forKey: .indexField)
        indexField = indexFieldDecoded
    }
}

extension DefineSuggesterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggester = suggester {
            try container.encode(suggester, forKey: ClientRuntime.Key("Suggester"))
        }
        try container.encode("DefineSuggester", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DefineSuggesterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DefineSuggester] operation. Specifies the name of the domain you want to update and the suggester configuration.
public struct DefineSuggesterInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.Suggester?

    public init (
        domainName: Swift.String? = nil,
        suggester: CloudSearchClientTypes.Suggester? = nil
    )
    {
        self.domainName = domainName
        self.suggester = suggester
    }
}

struct DefineSuggesterInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let suggester: CloudSearchClientTypes.Suggester?
}

extension DefineSuggesterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case suggester = "Suggester"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let suggesterDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Suggester.self, forKey: .suggester)
        suggester = suggesterDecoded
    }
}

extension DefineSuggesterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DefineSuggesterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DefineSuggesterOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DefineSuggesterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DefineSuggesterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suggester = output.suggester
        } else {
            self.suggester = nil
        }
    }
}

/// The result of a DefineSuggester request. Contains the status of the newly-configured suggester.
public struct DefineSuggesterOutputResponse: Swift.Equatable {
    /// The value of a Suggester and its current status.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init (
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

struct DefineSuggesterOutputResponseBody: Swift.Equatable {
    let suggester: CloudSearchClientTypes.SuggesterStatus?
}

extension DefineSuggesterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suggester = "Suggester"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DefineSuggesterResult"))
        let suggesterDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.SuggesterStatus.self, forKey: .suggester)
        suggester = suggesterDecoded
    }
}

extension DeleteAnalysisSchemeInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisSchemeName = analysisSchemeName {
            try container.encode(analysisSchemeName, forKey: ClientRuntime.Key("AnalysisSchemeName"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DeleteAnalysisScheme", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteAnalysisSchemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme you want to delete.
public struct DeleteAnalysisSchemeInput: Swift.Equatable {
    /// The name of the analysis scheme you want to delete.
    /// This member is required.
    public var analysisSchemeName: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        analysisSchemeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeName = analysisSchemeName
        self.domainName = domainName
    }
}

struct DeleteAnalysisSchemeInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let analysisSchemeName: Swift.String?
}

extension DeleteAnalysisSchemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSchemeName = "AnalysisSchemeName"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let analysisSchemeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisSchemeName)
        analysisSchemeName = analysisSchemeNameDecoded
    }
}

extension DeleteAnalysisSchemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteAnalysisSchemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAnalysisSchemeOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalysisSchemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAnalysisSchemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisScheme = output.analysisScheme
        } else {
            self.analysisScheme = nil
        }
    }
}

/// The result of a DeleteAnalysisScheme request. Contains the status of the deleted analysis scheme.
public struct DeleteAnalysisSchemeOutputResponse: Swift.Equatable {
    /// The status of the analysis scheme being deleted.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init (
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

struct DeleteAnalysisSchemeOutputResponseBody: Swift.Equatable {
    let analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?
}

extension DeleteAnalysisSchemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteAnalysisSchemeResult"))
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AnalysisSchemeStatus.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension DeleteDomainInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DeleteDomain", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteDomain] operation. Specifies the name of the domain you want to delete.
public struct DeleteDomainInput: Swift.Equatable {
    /// The name of the domain you want to permanently delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension DeleteDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// The result of a DeleteDomain request. Contains the status of a newly deleted domain, or no status if the domain has already been completely deleted.
public struct DeleteDomainOutputResponse: Swift.Equatable {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init (
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct DeleteDomainOutputResponseBody: Swift.Equatable {
    let domainStatus: CloudSearchClientTypes.DomainStatus?
}

extension DeleteDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDomainResult"))
        let domainStatusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension DeleteExpressionInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: ClientRuntime.Key("ExpressionName"))
        }
        try container.encode("DeleteExpression", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteExpressionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteExpression] operation. Specifies the name of the domain you want to update and the name of the expression you want to delete.
public struct DeleteExpressionInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the [Expression] to delete.
    /// This member is required.
    public var expressionName: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        expressionName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.expressionName = expressionName
    }
}

struct DeleteExpressionInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let expressionName: Swift.String?
}

extension DeleteExpressionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case expressionName = "ExpressionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let expressionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expressionName)
        expressionName = expressionNameDecoded
    }
}

extension DeleteExpressionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteExpressionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteExpressionOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExpressionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteExpressionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expression = output.expression
        } else {
            self.expression = nil
        }
    }
}

/// The result of a [DeleteExpression] request. Specifies the expression being deleted.
public struct DeleteExpressionOutputResponse: Swift.Equatable {
    /// The status of the expression being deleted.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init (
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

struct DeleteExpressionOutputResponseBody: Swift.Equatable {
    let expression: CloudSearchClientTypes.ExpressionStatus?
}

extension DeleteExpressionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteExpressionResult"))
        let expressionDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ExpressionStatus.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension DeleteIndexFieldInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: ClientRuntime.Key("IndexFieldName"))
        }
        try container.encode("DeleteIndexField", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteIndexFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteIndexField] operation. Specifies the name of the domain you want to update and the name of the index field you want to delete.
public struct DeleteIndexFieldInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the index field your want to remove from the domain's indexing options.
    /// This member is required.
    public var indexFieldName: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        indexFieldName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.indexFieldName = indexFieldName
    }
}

struct DeleteIndexFieldInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let indexFieldName: Swift.String?
}

extension DeleteIndexFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case indexFieldName = "IndexFieldName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
    }
}

extension DeleteIndexFieldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteIndexFieldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteIndexFieldOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIndexFieldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteIndexFieldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexField = output.indexField
        } else {
            self.indexField = nil
        }
    }
}

/// The result of a [DeleteIndexField] request.
public struct DeleteIndexFieldOutputResponse: Swift.Equatable {
    /// The status of the index field being deleted.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init (
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

struct DeleteIndexFieldOutputResponseBody: Swift.Equatable {
    let indexField: CloudSearchClientTypes.IndexFieldStatus?
}

extension DeleteIndexFieldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexField = "IndexField"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteIndexFieldResult"))
        let indexFieldDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexFieldStatus.self, forKey: .indexField)
        indexField = indexFieldDecoded
    }
}

extension DeleteSuggesterInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: ClientRuntime.Key("SuggesterName"))
        }
        try container.encode("DeleteSuggester", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSuggesterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DeleteSuggester] operation. Specifies the name of the domain you want to update and name of the suggester you want to delete.
public struct DeleteSuggesterInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Specifies the name of the suggester you want to delete.
    /// This member is required.
    public var suggesterName: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        suggesterName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.suggesterName = suggesterName
    }
}

struct DeleteSuggesterInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let suggesterName: Swift.String?
}

extension DeleteSuggesterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case suggesterName = "SuggesterName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let suggesterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suggesterName)
        suggesterName = suggesterNameDecoded
    }
}

extension DeleteSuggesterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteSuggesterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSuggesterOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSuggesterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSuggesterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suggester = output.suggester
        } else {
            self.suggester = nil
        }
    }
}

/// The result of a DeleteSuggester request. Contains the status of the deleted suggester.
public struct DeleteSuggesterOutputResponse: Swift.Equatable {
    /// The status of the suggester being deleted.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init (
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

struct DeleteSuggesterOutputResponseBody: Swift.Equatable {
    let suggester: CloudSearchClientTypes.SuggesterStatus?
}

extension DeleteSuggesterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suggester = "Suggester"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteSuggesterResult"))
        let suggesterDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.SuggesterStatus.self, forKey: .suggester)
        suggester = suggesterDecoded
    }
}

extension DescribeAnalysisSchemesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisSchemeNames = analysisSchemeNames {
            if !analysisSchemeNames.isEmpty {
                var analysisSchemeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AnalysisSchemeNames"))
                for (index0, standardname0) in analysisSchemeNames.enumerated() {
                    try analysisSchemeNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var analysisSchemeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AnalysisSchemeNames"))
                try analysisSchemeNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeAnalysisSchemes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeAnalysisSchemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeAnalysisSchemes] operation. Specifies the name of the domain you want to describe. To limit the response to particular analysis schemes, specify the names of the analysis schemes you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAnalysisSchemesInput: Swift.Equatable {
    /// The analysis schemes you want to describe.
    public var analysisSchemeNames: [Swift.String]?
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        analysisSchemeNames: [Swift.String]? = nil,
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeNames = analysisSchemeNames
        self.deployed = deployed
        self.domainName = domainName
    }
}

struct DescribeAnalysisSchemesInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let analysisSchemeNames: [Swift.String]?
    let deployed: Swift.Bool?
}

extension DescribeAnalysisSchemesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSchemeNames = "AnalysisSchemeNames"
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        if containerValues.contains(.analysisSchemeNames) {
            struct KeyVal0{struct member{}}
            let analysisSchemeNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .analysisSchemeNames)
            if let analysisSchemeNamesWrappedContainer = analysisSchemeNamesWrappedContainer {
                let analysisSchemeNamesContainer = try analysisSchemeNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var analysisSchemeNamesBuffer:[Swift.String]? = nil
                if let analysisSchemeNamesContainer = analysisSchemeNamesContainer {
                    analysisSchemeNamesBuffer = [Swift.String]()
                    for stringContainer0 in analysisSchemeNamesContainer {
                        analysisSchemeNamesBuffer?.append(stringContainer0)
                    }
                }
                analysisSchemeNames = analysisSchemeNamesBuffer
            } else {
                analysisSchemeNames = []
            }
        } else {
            analysisSchemeNames = nil
        }
        let deployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployed)
        deployed = deployedDecoded
    }
}

extension DescribeAnalysisSchemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAnalysisSchemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAnalysisSchemesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisSchemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAnalysisSchemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisSchemes = output.analysisSchemes
        } else {
            self.analysisSchemes = nil
        }
    }
}

/// The result of a DescribeAnalysisSchemes request. Contains the analysis schemes configured for the domain specified in the request.
public struct DescribeAnalysisSchemesOutputResponse: Swift.Equatable {
    /// The analysis scheme descriptions.
    /// This member is required.
    public var analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]?

    public init (
        analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]? = nil
    )
    {
        self.analysisSchemes = analysisSchemes
    }
}

struct DescribeAnalysisSchemesOutputResponseBody: Swift.Equatable {
    let analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]?
}

extension DescribeAnalysisSchemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSchemes = "AnalysisSchemes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAnalysisSchemesResult"))
        if containerValues.contains(.analysisSchemes) {
            struct KeyVal0{struct member{}}
            let analysisSchemesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .analysisSchemes)
            if let analysisSchemesWrappedContainer = analysisSchemesWrappedContainer {
                let analysisSchemesContainer = try analysisSchemesWrappedContainer.decodeIfPresent([CloudSearchClientTypes.AnalysisSchemeStatus].self, forKey: .member)
                var analysisSchemesBuffer:[CloudSearchClientTypes.AnalysisSchemeStatus]? = nil
                if let analysisSchemesContainer = analysisSchemesContainer {
                    analysisSchemesBuffer = [CloudSearchClientTypes.AnalysisSchemeStatus]()
                    for structureContainer0 in analysisSchemesContainer {
                        analysisSchemesBuffer?.append(structureContainer0)
                    }
                }
                analysisSchemes = analysisSchemesBuffer
            } else {
                analysisSchemes = []
            }
        } else {
            analysisSchemes = nil
        }
    }
}

extension DescribeAvailabilityOptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeAvailabilityOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeAvailabilityOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeAvailabilityOptions] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAvailabilityOptionsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

struct DescribeAvailabilityOptionsInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let deployed: Swift.Bool?
}

extension DescribeAvailabilityOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let deployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployed)
        deployed = deployedDecoded
    }
}

extension DescribeAvailabilityOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAvailabilityOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAvailabilityOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailabilityOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAvailabilityOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityOptions = output.availabilityOptions
        } else {
            self.availabilityOptions = nil
        }
    }
}

/// The result of a DescribeAvailabilityOptions request. Indicates whether or not the Multi-AZ option is enabled for the domain specified in the request.
public struct DescribeAvailabilityOptionsOutputResponse: Swift.Equatable {
    /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init (
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

struct DescribeAvailabilityOptionsOutputResponseBody: Swift.Equatable {
    let availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?
}

extension DescribeAvailabilityOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityOptions = "AvailabilityOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAvailabilityOptionsResult"))
        let availabilityOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AvailabilityOptionsStatus.self, forKey: .availabilityOptions)
        availabilityOptions = availabilityOptionsDecoded
    }
}

extension DescribeDomainEndpointOptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeDomainEndpointOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDomainEndpointOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeDomainEndpointOptions] operation. Specify the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeDomainEndpointOptionsInput: Swift.Equatable {
    /// Whether to retrieve the latest configuration (which might be in a Processing state) or the current, active configuration. Defaults to false.
    public var deployed: Swift.Bool?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

struct DescribeDomainEndpointOptionsInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let deployed: Swift.Bool?
}

extension DescribeDomainEndpointOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let deployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployed)
        deployed = deployedDecoded
    }
}

extension DescribeDomainEndpointOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDomainEndpointOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDomainEndpointOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainEndpointOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDomainEndpointOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainEndpointOptions = output.domainEndpointOptions
        } else {
            self.domainEndpointOptions = nil
        }
    }
}

/// The result of a DescribeDomainEndpointOptions request. Contains the status and configuration of a search domain's endpoint options.
public struct DescribeDomainEndpointOptionsOutputResponse: Swift.Equatable {
    /// The status and configuration of a search domain's endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init (
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

struct DescribeDomainEndpointOptionsOutputResponseBody: Swift.Equatable {
    let domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?
}

extension DescribeDomainEndpointOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDomainEndpointOptionsResult"))
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainEndpointOptionsStatus.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
    }
}

extension DescribeDomainsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainNames = domainNames {
            if !domainNames.isEmpty {
                var domainNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainNames"))
                for (index0, domainname0) in domainNames.enumerated() {
                    try domainNamesContainer.encode(domainname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var domainNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainNames"))
                try domainNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeDomains", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeDomains] operation. By default shows the status of all domains. To restrict the response to particular domains, specify the names of the domains you want to describe.
public struct DescribeDomainsInput: Swift.Equatable {
    /// The names of the domains you want to include in the response.
    public var domainNames: [Swift.String]?

    public init (
        domainNames: [Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

struct DescribeDomainsInputBody: Swift.Equatable {
    let domainNames: [Swift.String]?
}

extension DescribeDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNames = "DomainNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.domainNames) {
            struct KeyVal0{struct member{}}
            let domainNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .domainNames)
            if let domainNamesWrappedContainer = domainNamesWrappedContainer {
                let domainNamesContainer = try domainNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var domainNamesBuffer:[Swift.String]? = nil
                if let domainNamesContainer = domainNamesContainer {
                    domainNamesBuffer = [Swift.String]()
                    for stringContainer0 in domainNamesContainer {
                        domainNamesBuffer?.append(stringContainer0)
                    }
                }
                domainNames = domainNamesBuffer
            } else {
                domainNames = []
            }
        } else {
            domainNames = nil
        }
    }
}

extension DescribeDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDomainsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatusList = output.domainStatusList
        } else {
            self.domainStatusList = nil
        }
    }
}

/// The result of a DescribeDomains request. Contains the status of the domains specified in the request or all domains owned by the account.
public struct DescribeDomainsOutputResponse: Swift.Equatable {
    /// A list that contains the status of each requested domain.
    /// This member is required.
    public var domainStatusList: [CloudSearchClientTypes.DomainStatus]?

    public init (
        domainStatusList: [CloudSearchClientTypes.DomainStatus]? = nil
    )
    {
        self.domainStatusList = domainStatusList
    }
}

struct DescribeDomainsOutputResponseBody: Swift.Equatable {
    let domainStatusList: [CloudSearchClientTypes.DomainStatus]?
}

extension DescribeDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatusList = "DomainStatusList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDomainsResult"))
        if containerValues.contains(.domainStatusList) {
            struct KeyVal0{struct member{}}
            let domainStatusListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .domainStatusList)
            if let domainStatusListWrappedContainer = domainStatusListWrappedContainer {
                let domainStatusListContainer = try domainStatusListWrappedContainer.decodeIfPresent([CloudSearchClientTypes.DomainStatus].self, forKey: .member)
                var domainStatusListBuffer:[CloudSearchClientTypes.DomainStatus]? = nil
                if let domainStatusListContainer = domainStatusListContainer {
                    domainStatusListBuffer = [CloudSearchClientTypes.DomainStatus]()
                    for structureContainer0 in domainStatusListContainer {
                        domainStatusListBuffer?.append(structureContainer0)
                    }
                }
                domainStatusList = domainStatusListBuffer
            } else {
                domainStatusList = []
            }
        } else {
            domainStatusList = nil
        }
    }
}

extension DescribeExpressionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let expressionNames = expressionNames {
            if !expressionNames.isEmpty {
                var expressionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExpressionNames"))
                for (index0, standardname0) in expressionNames.enumerated() {
                    try expressionNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var expressionNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExpressionNames"))
                try expressionNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeExpressions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeExpressionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeDomains] operation. Specifies the name of the domain you want to describe. To restrict the response to particular expressions, specify the names of the expressions you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeExpressionsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// Limits the [DescribeExpressions] response to the specified expressions. If not specified, all expressions are shown.
    public var expressionNames: [Swift.String]?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        expressionNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.expressionNames = expressionNames
    }
}

struct DescribeExpressionsInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let expressionNames: [Swift.String]?
    let deployed: Swift.Bool?
}

extension DescribeExpressionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
        case expressionNames = "ExpressionNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        if containerValues.contains(.expressionNames) {
            struct KeyVal0{struct member{}}
            let expressionNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .expressionNames)
            if let expressionNamesWrappedContainer = expressionNamesWrappedContainer {
                let expressionNamesContainer = try expressionNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var expressionNamesBuffer:[Swift.String]? = nil
                if let expressionNamesContainer = expressionNamesContainer {
                    expressionNamesBuffer = [Swift.String]()
                    for stringContainer0 in expressionNamesContainer {
                        expressionNamesBuffer?.append(stringContainer0)
                    }
                }
                expressionNames = expressionNamesBuffer
            } else {
                expressionNames = []
            }
        } else {
            expressionNames = nil
        }
        let deployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployed)
        deployed = deployedDecoded
    }
}

extension DescribeExpressionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeExpressionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeExpressionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExpressionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeExpressionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expressions = output.expressions
        } else {
            self.expressions = nil
        }
    }
}

/// The result of a DescribeExpressions request. Contains the expressions configured for the domain specified in the request.
public struct DescribeExpressionsOutputResponse: Swift.Equatable {
    /// The expressions configured for the domain.
    /// This member is required.
    public var expressions: [CloudSearchClientTypes.ExpressionStatus]?

    public init (
        expressions: [CloudSearchClientTypes.ExpressionStatus]? = nil
    )
    {
        self.expressions = expressions
    }
}

struct DescribeExpressionsOutputResponseBody: Swift.Equatable {
    let expressions: [CloudSearchClientTypes.ExpressionStatus]?
}

extension DescribeExpressionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expressions = "Expressions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeExpressionsResult"))
        if containerValues.contains(.expressions) {
            struct KeyVal0{struct member{}}
            let expressionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .expressions)
            if let expressionsWrappedContainer = expressionsWrappedContainer {
                let expressionsContainer = try expressionsWrappedContainer.decodeIfPresent([CloudSearchClientTypes.ExpressionStatus].self, forKey: .member)
                var expressionsBuffer:[CloudSearchClientTypes.ExpressionStatus]? = nil
                if let expressionsContainer = expressionsContainer {
                    expressionsBuffer = [CloudSearchClientTypes.ExpressionStatus]()
                    for structureContainer0 in expressionsContainer {
                        expressionsBuffer?.append(structureContainer0)
                    }
                }
                expressions = expressionsBuffer
            } else {
                expressions = []
            }
        } else {
            expressions = nil
        }
    }
}

extension DescribeIndexFieldsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let fieldNames = fieldNames {
            if !fieldNames.isEmpty {
                var fieldNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FieldNames"))
                for (index0, dynamicfieldname0) in fieldNames.enumerated() {
                    try fieldNamesContainer.encode(dynamicfieldname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var fieldNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FieldNames"))
                try fieldNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeIndexFields", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeIndexFieldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeIndexFields] operation. Specifies the name of the domain you want to describe. To restrict the response to particular index fields, specify the names of the index fields you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeIndexFieldsInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
    public var fieldNames: [Swift.String]?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        fieldNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.fieldNames = fieldNames
    }
}

struct DescribeIndexFieldsInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let fieldNames: [Swift.String]?
    let deployed: Swift.Bool?
}

extension DescribeIndexFieldsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
        case fieldNames = "FieldNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        if containerValues.contains(.fieldNames) {
            struct KeyVal0{struct member{}}
            let fieldNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fieldNames)
            if let fieldNamesWrappedContainer = fieldNamesWrappedContainer {
                let fieldNamesContainer = try fieldNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldNamesBuffer:[Swift.String]? = nil
                if let fieldNamesContainer = fieldNamesContainer {
                    fieldNamesBuffer = [Swift.String]()
                    for stringContainer0 in fieldNamesContainer {
                        fieldNamesBuffer?.append(stringContainer0)
                    }
                }
                fieldNames = fieldNamesBuffer
            } else {
                fieldNames = []
            }
        } else {
            fieldNames = nil
        }
        let deployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployed)
        deployed = deployedDecoded
    }
}

extension DescribeIndexFieldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeIndexFieldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeIndexFieldsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIndexFieldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeIndexFieldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.indexFields = output.indexFields
        } else {
            self.indexFields = nil
        }
    }
}

/// The result of a DescribeIndexFields request. Contains the index fields configured for the domain specified in the request.
public struct DescribeIndexFieldsOutputResponse: Swift.Equatable {
    /// The index fields configured for the domain.
    /// This member is required.
    public var indexFields: [CloudSearchClientTypes.IndexFieldStatus]?

    public init (
        indexFields: [CloudSearchClientTypes.IndexFieldStatus]? = nil
    )
    {
        self.indexFields = indexFields
    }
}

struct DescribeIndexFieldsOutputResponseBody: Swift.Equatable {
    let indexFields: [CloudSearchClientTypes.IndexFieldStatus]?
}

extension DescribeIndexFieldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexFields = "IndexFields"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeIndexFieldsResult"))
        if containerValues.contains(.indexFields) {
            struct KeyVal0{struct member{}}
            let indexFieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .indexFields)
            if let indexFieldsWrappedContainer = indexFieldsWrappedContainer {
                let indexFieldsContainer = try indexFieldsWrappedContainer.decodeIfPresent([CloudSearchClientTypes.IndexFieldStatus].self, forKey: .member)
                var indexFieldsBuffer:[CloudSearchClientTypes.IndexFieldStatus]? = nil
                if let indexFieldsContainer = indexFieldsContainer {
                    indexFieldsBuffer = [CloudSearchClientTypes.IndexFieldStatus]()
                    for structureContainer0 in indexFieldsContainer {
                        indexFieldsBuffer?.append(structureContainer0)
                    }
                }
                indexFields = indexFieldsBuffer
            } else {
                indexFields = []
            }
        } else {
            indexFields = nil
        }
    }
}

extension DescribeScalingParametersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeScalingParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeScalingParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeScalingParameters] operation. Specifies the name of the domain you want to describe.
public struct DescribeScalingParametersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DescribeScalingParametersInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension DescribeScalingParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DescribeScalingParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeScalingParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeScalingParametersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScalingParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeScalingParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scalingParameters = output.scalingParameters
        } else {
            self.scalingParameters = nil
        }
    }
}

/// The result of a DescribeScalingParameters request. Contains the scaling parameters configured for the domain specified in the request.
public struct DescribeScalingParametersOutputResponse: Swift.Equatable {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init (
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

struct DescribeScalingParametersOutputResponseBody: Swift.Equatable {
    let scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?
}

extension DescribeScalingParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scalingParameters = "ScalingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeScalingParametersResult"))
        let scalingParametersDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ScalingParametersStatus.self, forKey: .scalingParameters)
        scalingParameters = scalingParametersDecoded
    }
}

extension DescribeServiceAccessPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("DescribeServiceAccessPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeServiceAccessPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeServiceAccessPolicies] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeServiceAccessPoliciesInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

struct DescribeServiceAccessPoliciesInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let deployed: Swift.Bool?
}

extension DescribeServiceAccessPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let deployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployed)
        deployed = deployedDecoded
    }
}

extension DescribeServiceAccessPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeServiceAccessPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeServiceAccessPoliciesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceAccessPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeServiceAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicies = output.accessPolicies
        } else {
            self.accessPolicies = nil
        }
    }
}

/// The result of a DescribeServiceAccessPolicies request.
public struct DescribeServiceAccessPoliciesOutputResponse: Swift.Equatable {
    /// The access rules configured for the domain specified in the request.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init (
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

struct DescribeServiceAccessPoliciesOutputResponseBody: Swift.Equatable {
    let accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?
}

extension DescribeServiceAccessPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeServiceAccessPoliciesResult"))
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AccessPoliciesStatus.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
    }
}

extension DescribeSuggestersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let deployed = deployed {
            try container.encode(deployed, forKey: ClientRuntime.Key("Deployed"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let suggesterNames = suggesterNames {
            if !suggesterNames.isEmpty {
                var suggesterNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SuggesterNames"))
                for (index0, standardname0) in suggesterNames.enumerated() {
                    try suggesterNamesContainer.encode(standardname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var suggesterNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SuggesterNames"))
                try suggesterNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeSuggesters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeSuggestersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [DescribeSuggester] operation. Specifies the name of the domain you want to describe. To restrict the response to particular suggesters, specify the names of the suggesters you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeSuggestersInput: Swift.Equatable {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// The suggesters you want to describe.
    public var suggesterNames: [Swift.String]?

    public init (
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        suggesterNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.suggesterNames = suggesterNames
    }
}

struct DescribeSuggestersInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let suggesterNames: [Swift.String]?
    let deployed: Swift.Bool?
}

extension DescribeSuggestersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployed = "Deployed"
        case domainName = "DomainName"
        case suggesterNames = "SuggesterNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        if containerValues.contains(.suggesterNames) {
            struct KeyVal0{struct member{}}
            let suggesterNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .suggesterNames)
            if let suggesterNamesWrappedContainer = suggesterNamesWrappedContainer {
                let suggesterNamesContainer = try suggesterNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var suggesterNamesBuffer:[Swift.String]? = nil
                if let suggesterNamesContainer = suggesterNamesContainer {
                    suggesterNamesBuffer = [Swift.String]()
                    for stringContainer0 in suggesterNamesContainer {
                        suggesterNamesBuffer?.append(stringContainer0)
                    }
                }
                suggesterNames = suggesterNamesBuffer
            } else {
                suggesterNames = []
            }
        } else {
            suggesterNames = nil
        }
        let deployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployed)
        deployed = deployedDecoded
    }
}

extension DescribeSuggestersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSuggestersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSuggestersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSuggestersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSuggestersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.suggesters = output.suggesters
        } else {
            self.suggesters = nil
        }
    }
}

/// The result of a DescribeSuggesters request.
public struct DescribeSuggestersOutputResponse: Swift.Equatable {
    /// The suggesters configured for the domain specified in the request.
    /// This member is required.
    public var suggesters: [CloudSearchClientTypes.SuggesterStatus]?

    public init (
        suggesters: [CloudSearchClientTypes.SuggesterStatus]? = nil
    )
    {
        self.suggesters = suggesters
    }
}

struct DescribeSuggestersOutputResponseBody: Swift.Equatable {
    let suggesters: [CloudSearchClientTypes.SuggesterStatus]?
}

extension DescribeSuggestersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suggesters = "Suggesters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeSuggestersResult"))
        if containerValues.contains(.suggesters) {
            struct KeyVal0{struct member{}}
            let suggestersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .suggesters)
            if let suggestersWrappedContainer = suggestersWrappedContainer {
                let suggestersContainer = try suggestersWrappedContainer.decodeIfPresent([CloudSearchClientTypes.SuggesterStatus].self, forKey: .member)
                var suggestersBuffer:[CloudSearchClientTypes.SuggesterStatus]? = nil
                if let suggestersContainer = suggestersContainer {
                    suggestersBuffer = [CloudSearchClientTypes.SuggesterStatus]()
                    for structureContainer0 in suggestersContainer {
                        suggestersBuffer?.append(structureContainer0)
                    }
                }
                suggesters = suggestersBuffer
            } else {
                suggesters = []
            }
        } else {
            suggesters = nil
        }
    }
}

extension DisabledOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DisabledOperationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted an operation which is not enabled.
public struct DisabledOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct DisabledOperationExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension DisabledOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.DocumentSuggesterOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fuzzyMatching = "FuzzyMatching"
        case sortExpression = "SortExpression"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fuzzyMatching = fuzzyMatching {
            try container.encode(fuzzyMatching, forKey: ClientRuntime.Key("FuzzyMatching"))
        }
        if let sortExpression = sortExpression {
            try container.encode(sortExpression, forKey: ClientRuntime.Key("SortExpression"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let fuzzyMatchingDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.SuggesterFuzzyMatching.self, forKey: .fuzzyMatching)
        fuzzyMatching = fuzzyMatchingDecoded
        let sortExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortExpression)
        sortExpression = sortExpressionDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a search suggester.
    public struct DocumentSuggesterOptions: Swift.Equatable {
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none.
        public var fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching?
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        public var sortExpression: Swift.String?
        /// The name of the index field you want to use for suggestions.
        /// This member is required.
        public var sourceField: Swift.String?

        public init (
            fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching? = nil,
            sortExpression: Swift.String? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.fuzzyMatching = fuzzyMatching
            self.sortExpression = sortExpression
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes.DomainEndpointOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforceHTTPS = "EnforceHTTPS"
        case tlsSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enforceHTTPS = enforceHTTPS {
            try container.encode(enforceHTTPS, forKey: ClientRuntime.Key("EnforceHTTPS"))
        }
        if let tlsSecurityPolicy = tlsSecurityPolicy {
            try container.encode(tlsSecurityPolicy, forKey: ClientRuntime.Key("TLSSecurityPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceHTTPSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceHTTPS)
        enforceHTTPS = enforceHTTPSDecoded
        let tlsSecurityPolicyDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.TLSSecurityPolicy.self, forKey: .tlsSecurityPolicy)
        tlsSecurityPolicy = tlsSecurityPolicyDecoded
    }
}

extension CloudSearchClientTypes {
    /// The domain's endpoint options.
    public struct DomainEndpointOptions: Swift.Equatable {
        /// Whether the domain is HTTPS only enabled.
        public var enforceHTTPS: Swift.Bool?
        /// The minimum required TLS version
        public var tlsSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy?

        public init (
            enforceHTTPS: Swift.Bool? = nil,
            tlsSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy? = nil
        )
        {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension CloudSearchClientTypes.DomainEndpointOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainEndpointOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The configuration and status of the domain's endpoint options.
    public struct DomainEndpointOptionsStatus: Swift.Equatable {
        /// The domain endpoint options configured for the domain.
        /// This member is required.
        public var options: CloudSearchClientTypes.DomainEndpointOptions?
        /// The status of the configured domain endpoint options.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.DomainEndpointOptions? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.DomainStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case created = "Created"
        case deleted = "Deleted"
        case docService = "DocService"
        case domainId = "DomainId"
        case domainName = "DomainName"
        case limits = "Limits"
        case processing = "Processing"
        case requiresIndexDocuments = "RequiresIndexDocuments"
        case searchInstanceCount = "SearchInstanceCount"
        case searchInstanceType = "SearchInstanceType"
        case searchPartitionCount = "SearchPartitionCount"
        case searchService = "SearchService"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("ARN"))
        }
        if let created = created {
            try container.encode(created, forKey: ClientRuntime.Key("Created"))
        }
        if let deleted = deleted {
            try container.encode(deleted, forKey: ClientRuntime.Key("Deleted"))
        }
        if let docService = docService {
            try container.encode(docService, forKey: ClientRuntime.Key("DocService"))
        }
        if let domainId = domainId {
            try container.encode(domainId, forKey: ClientRuntime.Key("DomainId"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let limits = limits {
            try container.encode(limits, forKey: ClientRuntime.Key("Limits"))
        }
        if let processing = processing {
            try container.encode(processing, forKey: ClientRuntime.Key("Processing"))
        }
        if let requiresIndexDocuments = requiresIndexDocuments {
            try container.encode(requiresIndexDocuments, forKey: ClientRuntime.Key("RequiresIndexDocuments"))
        }
        if searchInstanceCount != 0 {
            try container.encode(searchInstanceCount, forKey: ClientRuntime.Key("SearchInstanceCount"))
        }
        if let searchInstanceType = searchInstanceType {
            try container.encode(searchInstanceType, forKey: ClientRuntime.Key("SearchInstanceType"))
        }
        if searchPartitionCount != 0 {
            try container.encode(searchPartitionCount, forKey: ClientRuntime.Key("SearchPartitionCount"))
        }
        if let searchService = searchService {
            try container.encode(searchService, forKey: ClientRuntime.Key("SearchService"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .created)
        created = createdDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let docServiceDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ServiceEndpoint.self, forKey: .docService)
        docService = docServiceDecoded
        let searchServiceDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ServiceEndpoint.self, forKey: .searchService)
        searchService = searchServiceDecoded
        let requiresIndexDocumentsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requiresIndexDocuments)
        requiresIndexDocuments = requiresIndexDocumentsDecoded
        let processingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .processing)
        processing = processingDecoded
        let searchInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchInstanceType)
        searchInstanceType = searchInstanceTypeDecoded
        let searchPartitionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .searchPartitionCount)
        searchPartitionCount = searchPartitionCountDecoded
        let searchInstanceCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .searchInstanceCount)
        searchInstanceCount = searchInstanceCountDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Limits.self, forKey: .limits)
        limits = limitsDecoded
    }
}

extension CloudSearchClientTypes {
    /// The current status of the search domain.
    public struct DomainStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the search domain. See [Identifiers for IAM Entities](http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html) in Using AWS Identity and Access Management for more information.
        public var arn: Swift.String?
        /// True if the search domain is created. It can take several minutes to initialize a domain when [CreateDomain] is called. Newly created search domains are returned from [DescribeDomains] with a false value for Created until domain creation is complete.
        public var created: Swift.Bool?
        /// True if the search domain has been deleted. The system must clean up resources dedicated to the search domain when [DeleteDomain] is called. Newly deleted search domains are returned from [DescribeDomains] with a true value for IsDeleted for several minutes until resource cleanup is complete.
        public var deleted: Swift.Bool?
        /// The service endpoint for updating documents in a search domain.
        public var docService: CloudSearchClientTypes.ServiceEndpoint?
        /// An internally generated unique identifier for a domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        /// This member is required.
        public var domainName: Swift.String?
        public var limits: CloudSearchClientTypes.Limits?
        /// True if processing is being done to activate the current domain configuration.
        public var processing: Swift.Bool?
        /// True if [IndexDocuments] needs to be called to activate the current domain configuration.
        /// This member is required.
        public var requiresIndexDocuments: Swift.Bool?
        /// The number of search instances that are available to process search requests.
        public var searchInstanceCount: Swift.Int
        /// The instance type that is being used to process search requests.
        public var searchInstanceType: Swift.String?
        /// The number of partitions across which the search index is spread.
        public var searchPartitionCount: Swift.Int
        /// The service endpoint for requesting search results from a search domain.
        public var searchService: CloudSearchClientTypes.ServiceEndpoint?

        public init (
            arn: Swift.String? = nil,
            created: Swift.Bool? = nil,
            deleted: Swift.Bool? = nil,
            docService: CloudSearchClientTypes.ServiceEndpoint? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            limits: CloudSearchClientTypes.Limits? = nil,
            processing: Swift.Bool? = nil,
            requiresIndexDocuments: Swift.Bool? = nil,
            searchInstanceCount: Swift.Int = 0,
            searchInstanceType: Swift.String? = nil,
            searchPartitionCount: Swift.Int = 0,
            searchService: CloudSearchClientTypes.ServiceEndpoint? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.deleted = deleted
            self.docService = docService
            self.domainId = domainId
            self.domainName = domainName
            self.limits = limits
            self.processing = processing
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchInstanceCount = searchInstanceCount
            self.searchInstanceType = searchInstanceType
            self.searchPartitionCount = searchPartitionCount
            self.searchService = searchService
        }
    }

}

extension CloudSearchClientTypes.DoubleArrayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
    public struct DoubleArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.DoubleOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
    public struct DoubleOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes.Expression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expressionName = "ExpressionName"
        case expressionValue = "ExpressionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let expressionName = expressionName {
            try container.encode(expressionName, forKey: ClientRuntime.Key("ExpressionName"))
        }
        if let expressionValue = expressionValue {
            try container.encode(expressionValue, forKey: ClientRuntime.Key("ExpressionValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expressionName)
        expressionName = expressionNameDecoded
        let expressionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expressionValue)
        expressionValue = expressionValueDecoded
    }
}

extension CloudSearchClientTypes {
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    public struct Expression: Swift.Equatable {
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var expressionName: Swift.String?
        /// The expression to evaluate for sorting while processing a search request. The Expression syntax is based on JavaScript expressions. For more information, see [Configuring Expressions](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-expressions.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var expressionValue: Swift.String?

        public init (
            expressionName: Swift.String? = nil,
            expressionValue: Swift.String? = nil
        )
        {
            self.expressionName = expressionName
            self.expressionValue = expressionValue
        }
    }

}

extension CloudSearchClientTypes.ExpressionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Expression.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The value of an Expression and its current status.
    public struct ExpressionStatus: Swift.Equatable {
        /// The expression that is evaluated for sorting while processing a search request.
        /// This member is required.
        public var options: CloudSearchClientTypes.Expression?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.Expression? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension IndexDocumentsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("IndexDocuments", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension IndexDocumentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [IndexDocuments] operation. Specifies the name of the domain you want to re-index.
public struct IndexDocumentsInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct IndexDocumentsInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension IndexDocumentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension IndexDocumentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension IndexDocumentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum IndexDocumentsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IndexDocumentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IndexDocumentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fieldNames = output.fieldNames
        } else {
            self.fieldNames = nil
        }
    }
}

/// The result of an IndexDocuments request. Contains the status of the indexing operation, including the fields being indexed.
public struct IndexDocumentsOutputResponse: Swift.Equatable {
    /// The names of the fields that are currently being indexed.
    public var fieldNames: [Swift.String]?

    public init (
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

struct IndexDocumentsOutputResponseBody: Swift.Equatable {
    let fieldNames: [Swift.String]?
}

extension IndexDocumentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldNames = "FieldNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("IndexDocumentsResult"))
        if containerValues.contains(.fieldNames) {
            struct KeyVal0{struct member{}}
            let fieldNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .fieldNames)
            if let fieldNamesWrappedContainer = fieldNamesWrappedContainer {
                let fieldNamesContainer = try fieldNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldNamesBuffer:[Swift.String]? = nil
                if let fieldNamesContainer = fieldNamesContainer {
                    fieldNamesBuffer = [Swift.String]()
                    for stringContainer0 in fieldNamesContainer {
                        fieldNamesBuffer?.append(stringContainer0)
                    }
                }
                fieldNames = fieldNamesBuffer
            } else {
                fieldNames = []
            }
        } else {
            fieldNames = nil
        }
    }
}

extension CloudSearchClientTypes.IndexField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateArrayOptions = "DateArrayOptions"
        case dateOptions = "DateOptions"
        case doubleArrayOptions = "DoubleArrayOptions"
        case doubleOptions = "DoubleOptions"
        case indexFieldName = "IndexFieldName"
        case indexFieldType = "IndexFieldType"
        case intArrayOptions = "IntArrayOptions"
        case intOptions = "IntOptions"
        case latLonOptions = "LatLonOptions"
        case literalArrayOptions = "LiteralArrayOptions"
        case literalOptions = "LiteralOptions"
        case textArrayOptions = "TextArrayOptions"
        case textOptions = "TextOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dateArrayOptions = dateArrayOptions {
            try container.encode(dateArrayOptions, forKey: ClientRuntime.Key("DateArrayOptions"))
        }
        if let dateOptions = dateOptions {
            try container.encode(dateOptions, forKey: ClientRuntime.Key("DateOptions"))
        }
        if let doubleArrayOptions = doubleArrayOptions {
            try container.encode(doubleArrayOptions, forKey: ClientRuntime.Key("DoubleArrayOptions"))
        }
        if let doubleOptions = doubleOptions {
            try container.encode(doubleOptions, forKey: ClientRuntime.Key("DoubleOptions"))
        }
        if let indexFieldName = indexFieldName {
            try container.encode(indexFieldName, forKey: ClientRuntime.Key("IndexFieldName"))
        }
        if let indexFieldType = indexFieldType {
            try container.encode(indexFieldType, forKey: ClientRuntime.Key("IndexFieldType"))
        }
        if let intArrayOptions = intArrayOptions {
            try container.encode(intArrayOptions, forKey: ClientRuntime.Key("IntArrayOptions"))
        }
        if let intOptions = intOptions {
            try container.encode(intOptions, forKey: ClientRuntime.Key("IntOptions"))
        }
        if let latLonOptions = latLonOptions {
            try container.encode(latLonOptions, forKey: ClientRuntime.Key("LatLonOptions"))
        }
        if let literalArrayOptions = literalArrayOptions {
            try container.encode(literalArrayOptions, forKey: ClientRuntime.Key("LiteralArrayOptions"))
        }
        if let literalOptions = literalOptions {
            try container.encode(literalOptions, forKey: ClientRuntime.Key("LiteralOptions"))
        }
        if let textArrayOptions = textArrayOptions {
            try container.encode(textArrayOptions, forKey: ClientRuntime.Key("TextArrayOptions"))
        }
        if let textOptions = textOptions {
            try container.encode(textOptions, forKey: ClientRuntime.Key("TextOptions"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexFieldName)
        indexFieldName = indexFieldNameDecoded
        let indexFieldTypeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexFieldType.self, forKey: .indexFieldType)
        indexFieldType = indexFieldTypeDecoded
        let intOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IntOptions.self, forKey: .intOptions)
        intOptions = intOptionsDecoded
        let doubleOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DoubleOptions.self, forKey: .doubleOptions)
        doubleOptions = doubleOptionsDecoded
        let literalOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.LiteralOptions.self, forKey: .literalOptions)
        literalOptions = literalOptionsDecoded
        let textOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.TextOptions.self, forKey: .textOptions)
        textOptions = textOptionsDecoded
        let dateOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DateOptions.self, forKey: .dateOptions)
        dateOptions = dateOptionsDecoded
        let latLonOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.LatLonOptions.self, forKey: .latLonOptions)
        latLonOptions = latLonOptionsDecoded
        let intArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IntArrayOptions.self, forKey: .intArrayOptions)
        intArrayOptions = intArrayOptionsDecoded
        let doubleArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DoubleArrayOptions.self, forKey: .doubleArrayOptions)
        doubleArrayOptions = doubleArrayOptionsDecoded
        let literalArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.LiteralArrayOptions.self, forKey: .literalArrayOptions)
        literalArrayOptions = literalArrayOptionsDecoded
        let textArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.TextArrayOptions.self, forKey: .textArrayOptions)
        textArrayOptions = textArrayOptionsDecoded
        let dateArrayOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DateArrayOptions.self, forKey: .dateArrayOptions)
        dateArrayOptions = dateArrayOptionsDecoded
    }
}

extension CloudSearchClientTypes {
    /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
    public struct IndexField: Swift.Equatable {
        /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
        public var dateArrayOptions: CloudSearchClientTypes.DateArrayOptions?
        /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
        public var dateOptions: CloudSearchClientTypes.DateOptions?
        /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
        public var doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions?
        /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
        public var doubleOptions: CloudSearchClientTypes.DoubleOptions?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        /// This member is required.
        public var indexFieldName: Swift.String?
        /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var indexFieldType: CloudSearchClientTypes.IndexFieldType?
        /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
        public var intArrayOptions: CloudSearchClientTypes.IntArrayOptions?
        /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
        public var intOptions: CloudSearchClientTypes.IntOptions?
        /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
        public var latLonOptions: CloudSearchClientTypes.LatLonOptions?
        /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
        public var literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions?
        /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
        public var literalOptions: CloudSearchClientTypes.LiteralOptions?
        /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
        public var textArrayOptions: CloudSearchClientTypes.TextArrayOptions?
        /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
        public var textOptions: CloudSearchClientTypes.TextOptions?

        public init (
            dateArrayOptions: CloudSearchClientTypes.DateArrayOptions? = nil,
            dateOptions: CloudSearchClientTypes.DateOptions? = nil,
            doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions? = nil,
            doubleOptions: CloudSearchClientTypes.DoubleOptions? = nil,
            indexFieldName: Swift.String? = nil,
            indexFieldType: CloudSearchClientTypes.IndexFieldType? = nil,
            intArrayOptions: CloudSearchClientTypes.IntArrayOptions? = nil,
            intOptions: CloudSearchClientTypes.IntOptions? = nil,
            latLonOptions: CloudSearchClientTypes.LatLonOptions? = nil,
            literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions? = nil,
            literalOptions: CloudSearchClientTypes.LiteralOptions? = nil,
            textArrayOptions: CloudSearchClientTypes.TextArrayOptions? = nil,
            textOptions: CloudSearchClientTypes.TextOptions? = nil
        )
        {
            self.dateArrayOptions = dateArrayOptions
            self.dateOptions = dateOptions
            self.doubleArrayOptions = doubleArrayOptions
            self.doubleOptions = doubleOptions
            self.indexFieldName = indexFieldName
            self.indexFieldType = indexFieldType
            self.intArrayOptions = intArrayOptions
            self.intOptions = intOptions
            self.latLonOptions = latLonOptions
            self.literalArrayOptions = literalArrayOptions
            self.literalOptions = literalOptions
            self.textArrayOptions = textArrayOptions
            self.textOptions = textOptions
        }
    }

}

extension CloudSearchClientTypes.IndexFieldStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.IndexField.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The value of an IndexField and its current status.
    public struct IndexFieldStatus: Swift.Equatable {
        /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
        /// This member is required.
        public var options: CloudSearchClientTypes.IndexField?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.IndexField? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
    public enum IndexFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case dateArray
        case double
        case doubleArray
        case int
        case intArray
        case latlon
        case literal
        case literalArray
        case text
        case textArray
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexFieldType] {
            return [
                .date,
                .dateArray,
                .double,
                .doubleArray,
                .int,
                .intArray,
                .latlon,
                .literal,
                .literalArray,
                .text,
                .textArray,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "date"
            case .dateArray: return "date-array"
            case .double: return "double"
            case .doubleArray: return "double-array"
            case .int: return "int"
            case .intArray: return "int-array"
            case .latlon: return "latlon"
            case .literal: return "literal"
            case .literalArray: return "literal-array"
            case .text: return "text"
            case .textArray: return "text-array"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IndexFieldType(rawValue: rawValue) ?? IndexFieldType.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.IntArrayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
    public struct IntArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.IntOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
    public struct IntOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension InternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InternalExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error occurred while processing the request. If this problem persists, report an issue from the [Service Health Dashboard](http://status.aws.amazon.com/).
public struct InternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTypeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it specified an invalid type definition.
public struct InvalidTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidTypeExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension InvalidTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.LatLonOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
    public struct LatLonOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because a resource limit has already been met.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.Limits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumPartitionCount = "MaximumPartitionCount"
        case maximumReplicationCount = "MaximumReplicationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if maximumPartitionCount != 0 {
            try container.encode(maximumPartitionCount, forKey: ClientRuntime.Key("MaximumPartitionCount"))
        }
        if maximumReplicationCount != 0 {
            try container.encode(maximumReplicationCount, forKey: ClientRuntime.Key("MaximumReplicationCount"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumReplicationCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maximumReplicationCount)
        maximumReplicationCount = maximumReplicationCountDecoded
        let maximumPartitionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maximumPartitionCount)
        maximumPartitionCount = maximumPartitionCountDecoded
    }
}

extension CloudSearchClientTypes {
    public struct Limits: Swift.Equatable {
        /// This member is required.
        public var maximumPartitionCount: Swift.Int
        /// This member is required.
        public var maximumReplicationCount: Swift.Int

        public init (
            maximumPartitionCount: Swift.Int = 0,
            maximumReplicationCount: Swift.Int = 0
        )
        {
            self.maximumPartitionCount = maximumPartitionCount
            self.maximumReplicationCount = maximumReplicationCount
        }
    }

}

extension ListDomainNamesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("ListDomainNames", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDomainNamesInput: Swift.Equatable {

    public init () { }
}

extension ListDomainNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDomainNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDomainNamesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainNames = output.domainNames
        } else {
            self.domainNames = nil
        }
    }
}

/// The result of a ListDomainNames request. Contains a list of the domains owned by an account.
public struct ListDomainNamesOutputResponse: Swift.Equatable {
    /// The names of the search domains owned by an account.
    public var domainNames: [Swift.String:Swift.String]?

    public init (
        domainNames: [Swift.String:Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

struct ListDomainNamesOutputResponseBody: Swift.Equatable {
    let domainNames: [Swift.String:Swift.String]?
}

extension ListDomainNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNames = "DomainNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListDomainNamesResult"))
        if containerValues.contains(.domainNames) {
            struct KeyVal0{struct key{}; struct value{}}
            let domainNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .domainNames)
            if let domainNamesWrappedContainer = domainNamesWrappedContainer {
                let domainNamesContainer = try domainNamesWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var domainNamesBuffer: [Swift.String:Swift.String]? = nil
                if let domainNamesContainer = domainNamesContainer {
                    domainNamesBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in domainNamesContainer {
                        domainNamesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                domainNames = domainNamesBuffer
            } else {
                domainNames = [:]
            }
        } else {
            domainNames = nil
        }
    }
}

extension CloudSearchClientTypes.LiteralArrayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
    public struct LiteralArrayOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.LiteralOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case facetEnabled = "FacetEnabled"
        case returnEnabled = "ReturnEnabled"
        case searchEnabled = "SearchEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let facetEnabled = facetEnabled {
            try container.encode(facetEnabled, forKey: ClientRuntime.Key("FacetEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let searchEnabled = searchEnabled {
            try container.encode(searchEnabled, forKey: ClientRuntime.Key("SearchEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let facetEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .facetEnabled)
        facetEnabled = facetEnabledDecoded
        let searchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .searchEnabled)
        searchEnabled = searchEnabledDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
    public struct LiteralOptions: Swift.Equatable {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// The state of processing a change to an option. One of:
    ///
    /// * RequiresIndexDocuments: The option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
    ///
    /// * Processing: The option's latest value is in the process of being activated.
    ///
    /// * Active: The option's latest value is fully deployed.
    ///
    /// * FailedToValidate: The option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
    public enum OptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failedtovalidate
        case processing
        case requiresindexdocuments
        case sdkUnknown(Swift.String)

        public static var allCases: [OptionState] {
            return [
                .active,
                .failedtovalidate,
                .processing,
                .requiresindexdocuments,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failedtovalidate: return "FailedToValidate"
            case .processing: return "Processing"
            case .requiresindexdocuments: return "RequiresIndexDocuments"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptionState(rawValue: rawValue) ?? OptionState.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.OptionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case pendingDeletion = "PendingDeletion"
        case state = "State"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let creationDate = creationDate {
            try container.encodeTimestamp(creationDate, format: .dateTime, forKey: ClientRuntime.Key("creationDate"))
        }
        if let pendingDeletion = pendingDeletion {
            try container.encode(pendingDeletion, forKey: ClientRuntime.Key("PendingDeletion"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let updateDate = updateDate {
            try container.encodeTimestamp(updateDate, format: .dateTime, forKey: ClientRuntime.Key("updateDate"))
        }
        if updateVersion != 0 {
            try container.encode(updateVersion, forKey: ClientRuntime.Key("UpdateVersion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationDate)
        creationDate = creationDateDecoded
        let updateDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateDate)
        updateDate = updateDateDecoded
        let updateVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionState.self, forKey: .state)
        state = stateDecoded
        let pendingDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pendingDeletion)
        pendingDeletion = pendingDeletionDecoded
    }
}

extension CloudSearchClientTypes {
    /// The status of domain configuration option.
    public struct OptionStatus: Swift.Equatable {
        /// A timestamp for when this option was created.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// Indicates that the option will be deleted once processing is complete.
        public var pendingDeletion: Swift.Bool?
        /// The state of processing a change to an option. Possible values:
        ///
        /// * RequiresIndexDocuments: the option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
        ///
        /// * Processing: the option's latest value is in the process of being activated.
        ///
        /// * Active: the option's latest value is completely deployed.
        ///
        /// * FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
        /// This member is required.
        public var state: CloudSearchClientTypes.OptionState?
        /// A timestamp for when this option was last updated.
        /// This member is required.
        public var updateDate: ClientRuntime.Date?
        /// A unique integer that indicates when this option was last updated.
        public var updateVersion: Swift.Int

        public init (
            creationDate: ClientRuntime.Date? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: CloudSearchClientTypes.OptionState? = nil,
            updateDate: ClientRuntime.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension CloudSearchClientTypes {
    /// The instance type (such as search.m1.small) on which an index partition is hosted.
    public enum PartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case search2xlarge
        case searchLarge
        case searchM1Large
        case searchM1Small
        case searchM22xlarge
        case searchM2Xlarge
        case searchM32xlarge
        case searchM3Large
        case searchM3Medium
        case searchM3Xlarge
        case searchMedium
        case searchPreviousgeneration2xlarge
        case searchPreviousgenerationLarge
        case searchPreviousgenerationSmall
        case searchPreviousgenerationXlarge
        case searchSmall
        case searchXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [PartitionInstanceType] {
            return [
                .search2xlarge,
                .searchLarge,
                .searchM1Large,
                .searchM1Small,
                .searchM22xlarge,
                .searchM2Xlarge,
                .searchM32xlarge,
                .searchM3Large,
                .searchM3Medium,
                .searchM3Xlarge,
                .searchMedium,
                .searchPreviousgeneration2xlarge,
                .searchPreviousgenerationLarge,
                .searchPreviousgenerationSmall,
                .searchPreviousgenerationXlarge,
                .searchSmall,
                .searchXlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .search2xlarge: return "search.2xlarge"
            case .searchLarge: return "search.large"
            case .searchM1Large: return "search.m1.large"
            case .searchM1Small: return "search.m1.small"
            case .searchM22xlarge: return "search.m2.2xlarge"
            case .searchM2Xlarge: return "search.m2.xlarge"
            case .searchM32xlarge: return "search.m3.2xlarge"
            case .searchM3Large: return "search.m3.large"
            case .searchM3Medium: return "search.m3.medium"
            case .searchM3Xlarge: return "search.m3.xlarge"
            case .searchMedium: return "search.medium"
            case .searchPreviousgeneration2xlarge: return "search.previousgeneration.2xlarge"
            case .searchPreviousgenerationLarge: return "search.previousgeneration.large"
            case .searchPreviousgenerationSmall: return "search.previousgeneration.small"
            case .searchPreviousgenerationXlarge: return "search.previousgeneration.xlarge"
            case .searchSmall: return "search.small"
            case .searchXlarge: return "search.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartitionInstanceType(rawValue: rawValue) ?? PartitionInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to reference a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudSearchClientTypes.ScalingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredInstanceType = "DesiredInstanceType"
        case desiredPartitionCount = "DesiredPartitionCount"
        case desiredReplicationCount = "DesiredReplicationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let desiredInstanceType = desiredInstanceType {
            try container.encode(desiredInstanceType, forKey: ClientRuntime.Key("DesiredInstanceType"))
        }
        if desiredPartitionCount != 0 {
            try container.encode(desiredPartitionCount, forKey: ClientRuntime.Key("DesiredPartitionCount"))
        }
        if desiredReplicationCount != 0 {
            try container.encode(desiredReplicationCount, forKey: ClientRuntime.Key("DesiredReplicationCount"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredInstanceTypeDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.PartitionInstanceType.self, forKey: .desiredInstanceType)
        desiredInstanceType = desiredInstanceTypeDecoded
        let desiredReplicationCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .desiredReplicationCount)
        desiredReplicationCount = desiredReplicationCountDecoded
        let desiredPartitionCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .desiredPartitionCount)
        desiredPartitionCount = desiredPartitionCountDecoded
    }
}

extension CloudSearchClientTypes {
    /// The desired instance type and desired number of replicas of each index partition.
    public struct ScalingParameters: Swift.Equatable {
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        public var desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType?
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        public var desiredPartitionCount: Swift.Int
        /// The number of replicas you want to preconfigure for each index partition.
        public var desiredReplicationCount: Swift.Int

        public init (
            desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType? = nil,
            desiredPartitionCount: Swift.Int = 0,
            desiredReplicationCount: Swift.Int = 0
        )
        {
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
            self.desiredReplicationCount = desiredReplicationCount
        }
    }

}

extension CloudSearchClientTypes.ScalingParametersStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ScalingParameters.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The status and configuration of a search domain's scaling parameters.
    public struct ScalingParametersStatus: Swift.Equatable {
        /// The desired instance type and desired number of replicas of each index partition.
        /// This member is required.
        public var options: CloudSearchClientTypes.ScalingParameters?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.ScalingParameters? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes.ServiceEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension CloudSearchClientTypes {
    /// The endpoint to which service requests can be submitted.
    public struct ServiceEndpoint: Swift.Equatable {
        /// The endpoint to which service requests can be submitted. For example, search-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com or doc-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com.
        public var endpoint: Swift.String?

        public init (
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension CloudSearchClientTypes.Suggester: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentSuggesterOptions = "DocumentSuggesterOptions"
        case suggesterName = "SuggesterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let documentSuggesterOptions = documentSuggesterOptions {
            try container.encode(documentSuggesterOptions, forKey: ClientRuntime.Key("DocumentSuggesterOptions"))
        }
        if let suggesterName = suggesterName {
            try container.encode(suggesterName, forKey: ClientRuntime.Key("SuggesterName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suggesterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suggesterName)
        suggesterName = suggesterNameDecoded
        let documentSuggesterOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DocumentSuggesterOptions.self, forKey: .documentSuggesterOptions)
        documentSuggesterOptions = documentSuggesterOptionsDecoded
    }
}

extension CloudSearchClientTypes {
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    public struct Suggester: Swift.Equatable {
        /// Options for a search suggester.
        /// This member is required.
        public var documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var suggesterName: Swift.String?

        public init (
            documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions? = nil,
            suggesterName: Swift.String? = nil
        )
        {
            self.documentSuggesterOptions = documentSuggesterOptions
            self.suggesterName = suggesterName
        }
    }

}

extension CloudSearchClientTypes {
    public enum SuggesterFuzzyMatching: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggesterFuzzyMatching] {
            return [
                .high,
                .low,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SuggesterFuzzyMatching(rawValue: rawValue) ?? SuggesterFuzzyMatching.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.SuggesterStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let options = options {
            try container.encode(options, forKey: ClientRuntime.Key("Options"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.Suggester.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudSearchClientTypes {
    /// The value of a Suggester and its current status.
    public struct SuggesterStatus: Swift.Equatable {
        /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
        /// This member is required.
        public var options: CloudSearchClientTypes.Suggester?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init (
            options: CloudSearchClientTypes.Suggester? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension CloudSearchClientTypes {
    /// The minimum required TLS version.
    public enum TLSSecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyMinTls10201907
        case policyMinTls12201907
        case sdkUnknown(Swift.String)

        public static var allCases: [TLSSecurityPolicy] {
            return [
                .policyMinTls10201907,
                .policyMinTls12201907,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyMinTls10201907: return "Policy-Min-TLS-1-0-2019-07"
            case .policyMinTls12201907: return "Policy-Min-TLS-1-2-2019-07"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TLSSecurityPolicy(rawValue: rawValue) ?? TLSSecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudSearchClientTypes.TextArrayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sourceFields = "SourceFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: ClientRuntime.Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let sourceFields = sourceFields {
            try container.encode(sourceFields, forKey: ClientRuntime.Key("SourceFields"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFields)
        sourceFields = sourceFieldsDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let highlightEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .highlightEnabled)
        highlightEnabled = highlightEnabledDecoded
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
    public struct TextArrayOptions: Swift.Equatable {
        /// The name of an analysis scheme for a text-array field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init (
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes.TextOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisScheme = "AnalysisScheme"
        case defaultValue = "DefaultValue"
        case highlightEnabled = "HighlightEnabled"
        case returnEnabled = "ReturnEnabled"
        case sortEnabled = "SortEnabled"
        case sourceField = "SourceField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let analysisScheme = analysisScheme {
            try container.encode(analysisScheme, forKey: ClientRuntime.Key("AnalysisScheme"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let highlightEnabled = highlightEnabled {
            try container.encode(highlightEnabled, forKey: ClientRuntime.Key("HighlightEnabled"))
        }
        if let returnEnabled = returnEnabled {
            try container.encode(returnEnabled, forKey: ClientRuntime.Key("ReturnEnabled"))
        }
        if let sortEnabled = sortEnabled {
            try container.encode(sortEnabled, forKey: ClientRuntime.Key("SortEnabled"))
        }
        if let sourceField = sourceField {
            try container.encode(sourceField, forKey: ClientRuntime.Key("SourceField"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
        let returnEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnEnabled)
        returnEnabled = returnEnabledDecoded
        let sortEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sortEnabled)
        sortEnabled = sortEnabledDecoded
        let highlightEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .highlightEnabled)
        highlightEnabled = highlightEnabledDecoded
        let analysisSchemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisScheme)
        analysisScheme = analysisSchemeDecoded
    }
}

extension CloudSearchClientTypes {
    /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
    public struct TextOptions: Swift.Equatable {
        /// The name of an analysis scheme for a text field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init (
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension UpdateAvailabilityOptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        try container.encode("UpdateAvailabilityOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateAvailabilityOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateAvailabilityOptions] operation. Specifies the name of the domain you want to update and the Multi-AZ availability option.
public struct UpdateAvailabilityOptionsInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false.
    /// This member is required.
    public var multiAZ: Swift.Bool?

    public init (
        domainName: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.multiAZ = multiAZ
    }
}

struct UpdateAvailabilityOptionsInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let multiAZ: Swift.Bool?
}

extension UpdateAvailabilityOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case multiAZ = "MultiAZ"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
    }
}

extension UpdateAvailabilityOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAvailabilityOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAvailabilityOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAvailabilityOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAvailabilityOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityOptions = output.availabilityOptions
        } else {
            self.availabilityOptions = nil
        }
    }
}

/// The result of a UpdateAvailabilityOptions request. Contains the status of the domain's availability options.
public struct UpdateAvailabilityOptionsOutputResponse: Swift.Equatable {
    /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init (
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

struct UpdateAvailabilityOptionsOutputResponseBody: Swift.Equatable {
    let availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?
}

extension UpdateAvailabilityOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityOptions = "AvailabilityOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateAvailabilityOptionsResult"))
        let availabilityOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AvailabilityOptionsStatus.self, forKey: .availabilityOptions)
        availabilityOptions = availabilityOptionsDecoded
    }
}

extension UpdateDomainEndpointOptionsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainEndpointOptions = domainEndpointOptions {
            try container.encode(domainEndpointOptions, forKey: ClientRuntime.Key("DomainEndpointOptions"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("UpdateDomainEndpointOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateDomainEndpointOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateDomainEndpointOptions] operation. Specifies the name of the domain you want to update and the domain endpoint options.
public struct UpdateDomainEndpointOptionsInput: Swift.Equatable {
    /// Whether to require that all requests to the domain arrive over HTTPS. We recommend Policy-Min-TLS-1-2-2019-07 for TLSSecurityPolicy. For compatibility with older clients, the default is Policy-Min-TLS-1-0-2019-07.
    /// This member is required.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
    }
}

struct UpdateDomainEndpointOptionsInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions?
}

extension UpdateDomainEndpointOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainEndpointOptions.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
    }
}

extension UpdateDomainEndpointOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateDomainEndpointOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledAction" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDomainEndpointOptionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainEndpointOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDomainEndpointOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainEndpointOptions = output.domainEndpointOptions
        } else {
            self.domainEndpointOptions = nil
        }
    }
}

/// The result of a UpdateDomainEndpointOptions request. Contains the configuration and status of the domain's endpoint options.
public struct UpdateDomainEndpointOptionsOutputResponse: Swift.Equatable {
    /// The newly-configured domain endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init (
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

struct UpdateDomainEndpointOptionsOutputResponseBody: Swift.Equatable {
    let domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?
}

extension UpdateDomainEndpointOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainEndpointOptions = "DomainEndpointOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateDomainEndpointOptionsResult"))
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.DomainEndpointOptionsStatus.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
    }
}

extension UpdateScalingParametersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let scalingParameters = scalingParameters {
            try container.encode(scalingParameters, forKey: ClientRuntime.Key("ScalingParameters"))
        }
        try container.encode("UpdateScalingParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateScalingParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateScalingParameters] operation. Specifies the name of the domain you want to update and the scaling parameters you want to configure.
public struct UpdateScalingParametersInput: Swift.Equatable {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The desired instance type and desired number of replicas of each index partition.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParameters?

    public init (
        domainName: Swift.String? = nil,
        scalingParameters: CloudSearchClientTypes.ScalingParameters? = nil
    )
    {
        self.domainName = domainName
        self.scalingParameters = scalingParameters
    }
}

struct UpdateScalingParametersInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let scalingParameters: CloudSearchClientTypes.ScalingParameters?
}

extension UpdateScalingParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case scalingParameters = "ScalingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let scalingParametersDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ScalingParameters.self, forKey: .scalingParameters)
        scalingParameters = scalingParametersDecoded
    }
}

extension UpdateScalingParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateScalingParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateScalingParametersOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScalingParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateScalingParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scalingParameters = output.scalingParameters
        } else {
            self.scalingParameters = nil
        }
    }
}

/// The result of a UpdateScalingParameters request. Contains the status of the newly-configured scaling parameters.
public struct UpdateScalingParametersOutputResponse: Swift.Equatable {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init (
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

struct UpdateScalingParametersOutputResponseBody: Swift.Equatable {
    let scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?
}

extension UpdateScalingParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scalingParameters = "ScalingParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateScalingParametersResult"))
        let scalingParametersDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.ScalingParametersStatus.self, forKey: .scalingParameters)
        scalingParameters = scalingParametersDecoded
    }
}

extension UpdateServiceAccessPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessPolicies = accessPolicies {
            try container.encode(accessPolicies, forKey: ClientRuntime.Key("AccessPolicies"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        try container.encode("UpdateServiceAccessPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2013-01-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension UpdateServiceAccessPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Container for the parameters to the [UpdateServiceAccessPolicies] operation. Specifies the name of the domain you want to update and the access rules you want to configure.
public struct UpdateServiceAccessPoliciesInput: Swift.Equatable {
    /// The access rules you want to configure. These rules replace any existing rules.
    /// This member is required.
    public var accessPolicies: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        accessPolicies: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.domainName = domainName
    }
}

struct UpdateServiceAccessPoliciesInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let accessPolicies: Swift.String?
}

extension UpdateServiceAccessPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
    }
}

extension UpdateServiceAccessPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateServiceAccessPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidType" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceeded" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServiceAccessPoliciesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceAccessPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateServiceAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicies = output.accessPolicies
        } else {
            self.accessPolicies = nil
        }
    }
}

/// The result of an UpdateServiceAccessPolicies request. Contains the new access policies.
public struct UpdateServiceAccessPoliciesOutputResponse: Swift.Equatable {
    /// The access rules configured for the domain.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init (
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

struct UpdateServiceAccessPoliciesOutputResponseBody: Swift.Equatable {
    let accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?
}

extension UpdateServiceAccessPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateServiceAccessPoliciesResult"))
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(CloudSearchClientTypes.AccessPoliciesStatus.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ValidationExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.code = output.error.code
            self.message = output.error.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it has invalid parameters.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A machine-parsable string error or warning code.
    public var code: Swift.String?
    /// A human-readable string error or warning message.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
