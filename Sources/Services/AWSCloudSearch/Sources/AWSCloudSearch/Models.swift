//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
@_spi(SmithyReadWrite) import class SmithyFormURL.Writer
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyXML.Reader
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSQueryError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct ListDomainNamesInput {

    public init() { }
}

/// An error occurred while processing the request.
public struct BaseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BaseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// An internal error occurred while processing the request. If this problem persists, report an issue from the [Service Health Dashboard](http://status.aws.amazon.com/).
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request was rejected because it attempted to reference a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request was rejected because it has invalid parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// Container for the parameters to the [BuildSuggester] operation. Specifies the name of the domain you want to update.
public struct BuildSuggestersInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The result of a BuildSuggester request. Contains a list of the fields used for suggestions.
public struct BuildSuggestersOutput {
    /// A list of field names.
    public var fieldNames: [Swift.String]?

    public init(
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

/// The request was rejected because a resource limit has already been met.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request was rejected because it attempted to create a resource that already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// Container for the parameters to the [CreateDomain] operation. Specifies a name for the new search domain.
public struct CreateDomainInput {
    /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension CloudSearchClientTypes {
    /// The endpoint to which service requests can be submitted.
    public struct ServiceEndpoint {
        /// The endpoint to which service requests can be submitted. For example, search-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com or doc-imdb-movies-oopcnjfn6ugofer3zx5iadxxca.eu-west-1.cloudsearch.amazonaws.com.
        public var endpoint: Swift.String?

        public init(
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension CloudSearchClientTypes {
    public struct Limits {
        /// This member is required.
        public var maximumPartitionCount: Swift.Int?
        /// This member is required.
        public var maximumReplicationCount: Swift.Int?

        public init(
            maximumPartitionCount: Swift.Int? = nil,
            maximumReplicationCount: Swift.Int? = nil
        )
        {
            self.maximumPartitionCount = maximumPartitionCount
            self.maximumReplicationCount = maximumReplicationCount
        }
    }

}

extension CloudSearchClientTypes {
    /// The current status of the search domain.
    public struct DomainStatus {
        /// The Amazon Resource Name (ARN) of the search domain. See [Identifiers for IAM Entities](http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html) in Using AWS Identity and Access Management for more information.
        public var arn: Swift.String?
        /// True if the search domain is created. It can take several minutes to initialize a domain when [CreateDomain] is called. Newly created search domains are returned from [DescribeDomains] with a false value for Created until domain creation is complete.
        public var created: Swift.Bool?
        /// True if the search domain has been deleted. The system must clean up resources dedicated to the search domain when [DeleteDomain] is called. Newly deleted search domains are returned from [DescribeDomains] with a true value for IsDeleted for several minutes until resource cleanup is complete.
        public var deleted: Swift.Bool?
        /// The service endpoint for updating documents in a search domain.
        public var docService: CloudSearchClientTypes.ServiceEndpoint?
        /// An internally generated unique identifier for a domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        /// This member is required.
        public var domainName: Swift.String?
        public var limits: CloudSearchClientTypes.Limits?
        /// True if processing is being done to activate the current domain configuration.
        public var processing: Swift.Bool?
        /// True if [IndexDocuments] needs to be called to activate the current domain configuration.
        /// This member is required.
        public var requiresIndexDocuments: Swift.Bool?
        /// The number of search instances that are available to process search requests.
        public var searchInstanceCount: Swift.Int?
        /// The instance type that is being used to process search requests.
        public var searchInstanceType: Swift.String?
        /// The number of partitions across which the search index is spread.
        public var searchPartitionCount: Swift.Int?
        /// The service endpoint for requesting search results from a search domain.
        public var searchService: CloudSearchClientTypes.ServiceEndpoint?

        public init(
            arn: Swift.String? = nil,
            created: Swift.Bool? = nil,
            deleted: Swift.Bool? = nil,
            docService: CloudSearchClientTypes.ServiceEndpoint? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            limits: CloudSearchClientTypes.Limits? = nil,
            processing: Swift.Bool? = nil,
            requiresIndexDocuments: Swift.Bool? = nil,
            searchInstanceCount: Swift.Int? = nil,
            searchInstanceType: Swift.String? = nil,
            searchPartitionCount: Swift.Int? = nil,
            searchService: CloudSearchClientTypes.ServiceEndpoint? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.deleted = deleted
            self.docService = docService
            self.domainId = domainId
            self.domainName = domainName
            self.limits = limits
            self.processing = processing
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchInstanceCount = searchInstanceCount
            self.searchInstanceType = searchInstanceType
            self.searchPartitionCount = searchPartitionCount
            self.searchService = searchService
        }
    }

}

/// The result of a CreateDomainRequest. Contains the status of a newly created domain.
public struct CreateDomainOutput {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init(
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

/// The request was rejected because it specified an invalid type definition.
public struct InvalidTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidType" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension CloudSearchClientTypes {

    public enum AlgorithmicStemming: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case full
        case light
        case minimal
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AlgorithmicStemming] {
            return [
                .full,
                .light,
                .minimal,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .full: return "full"
            case .light: return "light"
            case .minimal: return "minimal"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudSearchClientTypes {
    /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
    public struct AnalysisOptions {
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see [Language Specific Text Processing Settings](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/text-processing.html#text-processing-settings) in the Amazon CloudSearch Developer Guide
        public var algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming?
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        public var japaneseTokenizationDictionary: Swift.String?
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        public var stemmingDictionary: Swift.String?
        /// A JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported.
        public var stopwords: Swift.String?
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see [Synonyms](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-analysis-schemes.html#synonyms) in the Amazon CloudSearch Developer Guide.
        public var synonyms: Swift.String?

        public init(
            algorithmicStemming: CloudSearchClientTypes.AlgorithmicStemming? = nil,
            japaneseTokenizationDictionary: Swift.String? = nil,
            stemmingDictionary: Swift.String? = nil,
            stopwords: Swift.String? = nil,
            synonyms: Swift.String? = nil
        )
        {
            self.algorithmicStemming = algorithmicStemming
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stemmingDictionary = stemmingDictionary
            self.stopwords = stopwords
            self.synonyms = synonyms
        }
    }

}

extension CloudSearchClientTypes {

    /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
    public enum AnalysisSchemeLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ar
        case bg
        case ca
        case cs
        case da
        case de
        case el
        case en
        case es
        case eu
        case fa
        case fi
        case fr
        case ga
        case gl
        case he
        case hi
        case hu
        case hy
        case id
        case it
        case ja
        case ko
        case lv
        case mul
        case nl
        case no
        case pt
        case ro
        case ru
        case sv
        case th
        case tr
        case zhHans
        case zhHant
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisSchemeLanguage] {
            return [
                .ar,
                .bg,
                .ca,
                .cs,
                .da,
                .de,
                .el,
                .en,
                .es,
                .eu,
                .fa,
                .fi,
                .fr,
                .ga,
                .gl,
                .he,
                .hi,
                .hu,
                .hy,
                .id,
                .it,
                .ja,
                .ko,
                .lv,
                .mul,
                .nl,
                .no,
                .pt,
                .ro,
                .ru,
                .sv,
                .th,
                .tr,
                .zhHans,
                .zhHant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ar: return "ar"
            case .bg: return "bg"
            case .ca: return "ca"
            case .cs: return "cs"
            case .da: return "da"
            case .de: return "de"
            case .el: return "el"
            case .en: return "en"
            case .es: return "es"
            case .eu: return "eu"
            case .fa: return "fa"
            case .fi: return "fi"
            case .fr: return "fr"
            case .ga: return "ga"
            case .gl: return "gl"
            case .he: return "he"
            case .hi: return "hi"
            case .hu: return "hu"
            case .hy: return "hy"
            case .id: return "id"
            case .it: return "it"
            case .ja: return "ja"
            case .ko: return "ko"
            case .lv: return "lv"
            case .mul: return "mul"
            case .nl: return "nl"
            case .no: return "no"
            case .pt: return "pt"
            case .ro: return "ro"
            case .ru: return "ru"
            case .sv: return "sv"
            case .th: return "th"
            case .tr: return "tr"
            case .zhHans: return "zh-Hans"
            case .zhHant: return "zh-Hant"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudSearchClientTypes {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    public struct AnalysisScheme {
        /// Synonyms, stopwords, and stemming options for an analysis scheme. Includes tokenization dictionary for Japanese.
        public var analysisOptions: CloudSearchClientTypes.AnalysisOptions?
        /// An [IETF RFC 4646](http://tools.ietf.org/html/rfc4646) language code or mul for multiple languages.
        /// This member is required.
        public var analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var analysisSchemeName: Swift.String?

        public init(
            analysisOptions: CloudSearchClientTypes.AnalysisOptions? = nil,
            analysisSchemeLanguage: CloudSearchClientTypes.AnalysisSchemeLanguage? = nil,
            analysisSchemeName: Swift.String? = nil
        )
        {
            self.analysisOptions = analysisOptions
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
        }
    }

}

/// Container for the parameters to the [DefineAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme configuration.
public struct DefineAnalysisSchemeInput {
    /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisScheme?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        analysisScheme: CloudSearchClientTypes.AnalysisScheme? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisScheme = analysisScheme
        self.domainName = domainName
    }
}

extension CloudSearchClientTypes {

    /// The state of processing a change to an option. One of:
    ///
    /// * RequiresIndexDocuments: The option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
    ///
    /// * Processing: The option's latest value is in the process of being activated.
    ///
    /// * Active: The option's latest value is fully deployed.
    ///
    /// * FailedToValidate: The option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
    public enum OptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failedtovalidate
        case processing
        case requiresindexdocuments
        case sdkUnknown(Swift.String)

        public static var allCases: [OptionState] {
            return [
                .active,
                .failedtovalidate,
                .processing,
                .requiresindexdocuments
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failedtovalidate: return "FailedToValidate"
            case .processing: return "Processing"
            case .requiresindexdocuments: return "RequiresIndexDocuments"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudSearchClientTypes {
    /// The status of domain configuration option.
    public struct OptionStatus {
        /// A timestamp for when this option was created.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// Indicates that the option will be deleted once processing is complete.
        public var pendingDeletion: Swift.Bool?
        /// The state of processing a change to an option. Possible values:
        ///
        /// * RequiresIndexDocuments: the option's latest value will not be deployed until [IndexDocuments] has been called and indexing is complete.
        ///
        /// * Processing: the option's latest value is in the process of being activated.
        ///
        /// * Active: the option's latest value is completely deployed.
        ///
        /// * FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents.
        /// This member is required.
        public var state: CloudSearchClientTypes.OptionState?
        /// A timestamp for when this option was last updated.
        /// This member is required.
        public var updateDate: Foundation.Date?
        /// A unique integer that indicates when this option was last updated.
        public var updateVersion: Swift.Int

        public init(
            creationDate: Foundation.Date? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: CloudSearchClientTypes.OptionState? = nil,
            updateDate: Foundation.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension CloudSearchClientTypes {
    /// The status and configuration of an AnalysisScheme.
    public struct AnalysisSchemeStatus {
        /// Configuration information for an analysis scheme. Each analysis scheme has a unique name and specifies the language of the text to be processed. The following options can be configured for an analysis scheme: Synonyms, Stopwords, StemmingDictionary, JapaneseTokenizationDictionary and AlgorithmicStemming.
        /// This member is required.
        public var options: CloudSearchClientTypes.AnalysisScheme?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.AnalysisScheme? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a [DefineAnalysisScheme] request. Contains the status of the newly-configured analysis scheme.
public struct DefineAnalysisSchemeOutput {
    /// The status and configuration of an AnalysisScheme.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init(
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

extension CloudSearchClientTypes {
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    public struct Expression {
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var expressionName: Swift.String?
        /// The expression to evaluate for sorting while processing a search request. The Expression syntax is based on JavaScript expressions. For more information, see [Configuring Expressions](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-expressions.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var expressionValue: Swift.String?

        public init(
            expressionName: Swift.String? = nil,
            expressionValue: Swift.String? = nil
        )
        {
            self.expressionName = expressionName
            self.expressionValue = expressionValue
        }
    }

}

/// Container for the parameters to the [DefineExpression] operation. Specifies the name of the domain you want to update and the expression you want to configure.
public struct DefineExpressionInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// A named expression that can be evaluated at search time. Can be used to sort the search results, define other expressions, or return computed information in the search results.
    /// This member is required.
    public var expression: CloudSearchClientTypes.Expression?

    public init(
        domainName: Swift.String? = nil,
        expression: CloudSearchClientTypes.Expression? = nil
    )
    {
        self.domainName = domainName
        self.expression = expression
    }
}

extension CloudSearchClientTypes {
    /// The value of an Expression and its current status.
    public struct ExpressionStatus {
        /// The expression that is evaluated for sorting while processing a search request.
        /// This member is required.
        public var options: CloudSearchClientTypes.Expression?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.Expression? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a DefineExpression request. Contains the status of the newly-configured expression.
public struct DefineExpressionOutput {
    /// The value of an Expression and its current status.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init(
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
    public struct DateArrayOptions {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
    public struct DateOptions {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
    public struct DoubleArrayOptions {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
    public struct DoubleOptions {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Double?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.Double? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {

    /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
    public enum IndexFieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case date
        case dateArray
        case double
        case doubleArray
        case int
        case intArray
        case latlon
        case literal
        case literalArray
        case text
        case textArray
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexFieldType] {
            return [
                .date,
                .dateArray,
                .double,
                .doubleArray,
                .int,
                .intArray,
                .latlon,
                .literal,
                .literalArray,
                .text,
                .textArray
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .date: return "date"
            case .dateArray: return "date-array"
            case .double: return "double"
            case .doubleArray: return "double-array"
            case .int: return "int"
            case .intArray: return "int-array"
            case .latlon: return "latlon"
            case .literal: return "literal"
            case .literalArray: return "literal-array"
            case .text: return "text"
            case .textArray: return "text-array"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
    public struct IntArrayOptions {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
    public struct IntOptions {
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public var defaultValue: Swift.Int?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// The name of the source field to map to the field.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.Int? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
    public struct LatLonOptions {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
    public struct LiteralArrayOptions {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
    public struct LiteralOptions {
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether facet information can be returned for the field.
        public var facetEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the contents of the field are searchable.
        public var searchEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            facetEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            searchEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.facetEnabled = facetEnabled
            self.returnEnabled = returnEnabled
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
    public struct TextArrayOptions {
        /// The name of an analysis scheme for a text-array field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// A list of source fields to map to the field.
        public var sourceFields: Swift.String?

        public init(
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sourceFields: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
        }
    }

}

extension CloudSearchClientTypes {
    /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
    public struct TextOptions {
        /// The name of an analysis scheme for a text field.
        public var analysisScheme: Swift.String?
        /// A value to use for the field if the field isn't specified for a document.
        public var defaultValue: Swift.String?
        /// Whether highlights can be returned for the field.
        public var highlightEnabled: Swift.Bool?
        /// Whether the contents of the field can be returned in the search results.
        public var returnEnabled: Swift.Bool?
        /// Whether the field can be used to sort the search results.
        public var sortEnabled: Swift.Bool?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        public var sourceField: Swift.String?

        public init(
            analysisScheme: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            highlightEnabled: Swift.Bool? = nil,
            returnEnabled: Swift.Bool? = nil,
            sortEnabled: Swift.Bool? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.analysisScheme = analysisScheme
            self.defaultValue = defaultValue
            self.highlightEnabled = highlightEnabled
            self.returnEnabled = returnEnabled
            self.sortEnabled = sortEnabled
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
    public struct IndexField {
        /// Options for a field that contains an array of dates. Present if IndexFieldType specifies the field is of type date-array. All options are enabled by default.
        public var dateArrayOptions: CloudSearchClientTypes.DateArrayOptions?
        /// Options for a date field. Dates and times are specified in UTC (Coordinated Universal Time) according to IETF RFC3339: yyyy-mm-ddT00:00:00Z. Present if IndexFieldType specifies the field is of type date. All options are enabled by default.
        public var dateOptions: CloudSearchClientTypes.DateOptions?
        /// Options for a field that contains an array of double-precision 64-bit floating point values. Present if IndexFieldType specifies the field is of type double-array. All options are enabled by default.
        public var doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions?
        /// Options for a double-precision 64-bit floating point field. Present if IndexFieldType specifies the field is of type double. All options are enabled by default.
        public var doubleOptions: CloudSearchClientTypes.DoubleOptions?
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options. Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported. The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id.
        /// This member is required.
        public var indexFieldName: Swift.String?
        /// The type of field. The valid options for a field depend on the field type. For more information about the supported field types, see [Configuring Index Fields](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-index-fields.html) in the Amazon CloudSearch Developer Guide.
        /// This member is required.
        public var indexFieldType: CloudSearchClientTypes.IndexFieldType?
        /// Options for a field that contains an array of 64-bit signed integers. Present if IndexFieldType specifies the field is of type int-array. All options are enabled by default.
        public var intArrayOptions: CloudSearchClientTypes.IntArrayOptions?
        /// Options for a 64-bit signed integer field. Present if IndexFieldType specifies the field is of type int. All options are enabled by default.
        public var intOptions: CloudSearchClientTypes.IntOptions?
        /// Options for a latlon field. A latlon field contains a location stored as a latitude and longitude value pair. Present if IndexFieldType specifies the field is of type latlon. All options are enabled by default.
        public var latLonOptions: CloudSearchClientTypes.LatLonOptions?
        /// Options for a field that contains an array of literal strings. Present if IndexFieldType specifies the field is of type literal-array. All options are enabled by default.
        public var literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions?
        /// Options for literal field. Present if IndexFieldType specifies the field is of type literal. All options are enabled by default.
        public var literalOptions: CloudSearchClientTypes.LiteralOptions?
        /// Options for a field that contains an array of text strings. Present if IndexFieldType specifies the field is of type text-array. A text-array field is always searchable. All options are enabled by default.
        public var textArrayOptions: CloudSearchClientTypes.TextArrayOptions?
        /// Options for text field. Present if IndexFieldType specifies the field is of type text. A text field is always searchable. All options are enabled by default.
        public var textOptions: CloudSearchClientTypes.TextOptions?

        public init(
            dateArrayOptions: CloudSearchClientTypes.DateArrayOptions? = nil,
            dateOptions: CloudSearchClientTypes.DateOptions? = nil,
            doubleArrayOptions: CloudSearchClientTypes.DoubleArrayOptions? = nil,
            doubleOptions: CloudSearchClientTypes.DoubleOptions? = nil,
            indexFieldName: Swift.String? = nil,
            indexFieldType: CloudSearchClientTypes.IndexFieldType? = nil,
            intArrayOptions: CloudSearchClientTypes.IntArrayOptions? = nil,
            intOptions: CloudSearchClientTypes.IntOptions? = nil,
            latLonOptions: CloudSearchClientTypes.LatLonOptions? = nil,
            literalArrayOptions: CloudSearchClientTypes.LiteralArrayOptions? = nil,
            literalOptions: CloudSearchClientTypes.LiteralOptions? = nil,
            textArrayOptions: CloudSearchClientTypes.TextArrayOptions? = nil,
            textOptions: CloudSearchClientTypes.TextOptions? = nil
        )
        {
            self.dateArrayOptions = dateArrayOptions
            self.dateOptions = dateOptions
            self.doubleArrayOptions = doubleArrayOptions
            self.doubleOptions = doubleOptions
            self.indexFieldName = indexFieldName
            self.indexFieldType = indexFieldType
            self.intArrayOptions = intArrayOptions
            self.intOptions = intOptions
            self.latLonOptions = latLonOptions
            self.literalArrayOptions = literalArrayOptions
            self.literalOptions = literalOptions
            self.textArrayOptions = textArrayOptions
            self.textOptions = textOptions
        }
    }

}

/// Container for the parameters to the [DefineIndexField] operation. Specifies the name of the domain you want to update and the index field configuration.
public struct DefineIndexFieldInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The index field and field options you want to configure.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexField?

    public init(
        domainName: Swift.String? = nil,
        indexField: CloudSearchClientTypes.IndexField? = nil
    )
    {
        self.domainName = domainName
        self.indexField = indexField
    }
}

extension CloudSearchClientTypes {
    /// The value of an IndexField and its current status.
    public struct IndexFieldStatus {
        /// Configuration information for a field in the index, including its name, type, and options. The supported options depend on the [IndexFieldType].
        /// This member is required.
        public var options: CloudSearchClientTypes.IndexField?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.IndexField? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a [DefineIndexField] request. Contains the status of the newly-configured index field.
public struct DefineIndexFieldOutput {
    /// The value of an IndexField and its current status.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init(
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

extension CloudSearchClientTypes {

    public enum SuggesterFuzzyMatching: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggesterFuzzyMatching] {
            return [
                .high,
                .low,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudSearchClientTypes {
    /// Options for a search suggester.
    public struct DocumentSuggesterOptions {
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none.
        public var fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching?
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        public var sortExpression: Swift.String?
        /// The name of the index field you want to use for suggestions.
        /// This member is required.
        public var sourceField: Swift.String?

        public init(
            fuzzyMatching: CloudSearchClientTypes.SuggesterFuzzyMatching? = nil,
            sortExpression: Swift.String? = nil,
            sourceField: Swift.String? = nil
        )
        {
            self.fuzzyMatching = fuzzyMatching
            self.sortExpression = sortExpression
            self.sourceField = sourceField
        }
    }

}

extension CloudSearchClientTypes {
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    public struct Suggester {
        /// Options for a search suggester.
        /// This member is required.
        public var documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions?
        /// Names must begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore).
        /// This member is required.
        public var suggesterName: Swift.String?

        public init(
            documentSuggesterOptions: CloudSearchClientTypes.DocumentSuggesterOptions? = nil,
            suggesterName: Swift.String? = nil
        )
        {
            self.documentSuggesterOptions = documentSuggesterOptions
            self.suggesterName = suggesterName
        }
    }

}

/// Container for the parameters to the [DefineSuggester] operation. Specifies the name of the domain you want to update and the suggester configuration.
public struct DefineSuggesterInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.Suggester?

    public init(
        domainName: Swift.String? = nil,
        suggester: CloudSearchClientTypes.Suggester? = nil
    )
    {
        self.domainName = domainName
        self.suggester = suggester
    }
}

extension CloudSearchClientTypes {
    /// The value of a Suggester and its current status.
    public struct SuggesterStatus {
        /// Configuration information for a search suggester. Each suggester has a unique name and specifies the text field you want to use for suggestions. The following options can be configured for a suggester: FuzzyMatching, SortExpression.
        /// This member is required.
        public var options: CloudSearchClientTypes.Suggester?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.Suggester? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a DefineSuggester request. Contains the status of the newly-configured suggester.
public struct DefineSuggesterOutput {
    /// The value of a Suggester and its current status.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init(
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

/// Container for the parameters to the [DeleteAnalysisScheme] operation. Specifies the name of the domain you want to update and the analysis scheme you want to delete.
public struct DeleteAnalysisSchemeInput {
    /// The name of the analysis scheme you want to delete.
    /// This member is required.
    public var analysisSchemeName: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        analysisSchemeName: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeName = analysisSchemeName
        self.domainName = domainName
    }
}

/// The result of a DeleteAnalysisScheme request. Contains the status of the deleted analysis scheme.
public struct DeleteAnalysisSchemeOutput {
    /// The status of the analysis scheme being deleted.
    /// This member is required.
    public var analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus?

    public init(
        analysisScheme: CloudSearchClientTypes.AnalysisSchemeStatus? = nil
    )
    {
        self.analysisScheme = analysisScheme
    }
}

/// Container for the parameters to the [DeleteDomain] operation. Specifies the name of the domain you want to delete.
public struct DeleteDomainInput {
    /// The name of the domain you want to permanently delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The result of a DeleteDomain request. Contains the status of a newly deleted domain, or no status if the domain has already been completely deleted.
public struct DeleteDomainOutput {
    /// The current status of the search domain.
    public var domainStatus: CloudSearchClientTypes.DomainStatus?

    public init(
        domainStatus: CloudSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

/// Container for the parameters to the [DeleteExpression] operation. Specifies the name of the domain you want to update and the name of the expression you want to delete.
public struct DeleteExpressionInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the [Expression] to delete.
    /// This member is required.
    public var expressionName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        expressionName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.expressionName = expressionName
    }
}

/// The result of a [DeleteExpression] request. Specifies the expression being deleted.
public struct DeleteExpressionOutput {
    /// The status of the expression being deleted.
    /// This member is required.
    public var expression: CloudSearchClientTypes.ExpressionStatus?

    public init(
        expression: CloudSearchClientTypes.ExpressionStatus? = nil
    )
    {
        self.expression = expression
    }
}

/// Container for the parameters to the [DeleteIndexField] operation. Specifies the name of the domain you want to update and the name of the index field you want to delete.
public struct DeleteIndexFieldInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the index field your want to remove from the domain's indexing options.
    /// This member is required.
    public var indexFieldName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        indexFieldName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.indexFieldName = indexFieldName
    }
}

/// The result of a [DeleteIndexField] request.
public struct DeleteIndexFieldOutput {
    /// The status of the index field being deleted.
    /// This member is required.
    public var indexField: CloudSearchClientTypes.IndexFieldStatus?

    public init(
        indexField: CloudSearchClientTypes.IndexFieldStatus? = nil
    )
    {
        self.indexField = indexField
    }
}

/// Container for the parameters to the [DeleteSuggester] operation. Specifies the name of the domain you want to update and name of the suggester you want to delete.
public struct DeleteSuggesterInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Specifies the name of the suggester you want to delete.
    /// This member is required.
    public var suggesterName: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        suggesterName: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.suggesterName = suggesterName
    }
}

/// The result of a DeleteSuggester request. Contains the status of the deleted suggester.
public struct DeleteSuggesterOutput {
    /// The status of the suggester being deleted.
    /// This member is required.
    public var suggester: CloudSearchClientTypes.SuggesterStatus?

    public init(
        suggester: CloudSearchClientTypes.SuggesterStatus? = nil
    )
    {
        self.suggester = suggester
    }
}

/// Container for the parameters to the [DescribeAnalysisSchemes] operation. Specifies the name of the domain you want to describe. To limit the response to particular analysis schemes, specify the names of the analysis schemes you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAnalysisSchemesInput {
    /// The analysis schemes you want to describe.
    public var analysisSchemeNames: [Swift.String]?
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        analysisSchemeNames: [Swift.String]? = nil,
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.analysisSchemeNames = analysisSchemeNames
        self.deployed = deployed
        self.domainName = domainName
    }
}

/// The result of a DescribeAnalysisSchemes request. Contains the analysis schemes configured for the domain specified in the request.
public struct DescribeAnalysisSchemesOutput {
    /// The analysis scheme descriptions.
    /// This member is required.
    public var analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]?

    public init(
        analysisSchemes: [CloudSearchClientTypes.AnalysisSchemeStatus]? = nil
    )
    {
        self.analysisSchemes = analysisSchemes
    }
}

/// The request was rejected because it attempted an operation which is not enabled.
public struct DisabledOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A machine-parsable string error or warning code.
        public internal(set) var code: Swift.String? = nil
        /// A human-readable string error or warning message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DisabledAction" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// Container for the parameters to the [DescribeAvailabilityOptions] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeAvailabilityOptionsInput {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension CloudSearchClientTypes {
    /// The status and configuration of the domain's availability options.
    public struct AvailabilityOptionsStatus {
        /// The availability options configured for the domain.
        /// This member is required.
        public var options: Swift.Bool
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: Swift.Bool = false,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a DescribeAvailabilityOptions request. Indicates whether or not the Multi-AZ option is enabled for the domain specified in the request.
public struct DescribeAvailabilityOptionsOutput {
    /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init(
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

/// Container for the parameters to the [DescribeDomainEndpointOptions] operation. Specify the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeDomainEndpointOptionsInput {
    /// Whether to retrieve the latest configuration (which might be in a Processing state) or the current, active configuration. Defaults to false.
    public var deployed: Swift.Bool?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension CloudSearchClientTypes {

    /// The minimum required TLS version.
    public enum TLSSecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case policyMinTls10201907
        case policyMinTls12201907
        case sdkUnknown(Swift.String)

        public static var allCases: [TLSSecurityPolicy] {
            return [
                .policyMinTls10201907,
                .policyMinTls12201907
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .policyMinTls10201907: return "Policy-Min-TLS-1-0-2019-07"
            case .policyMinTls12201907: return "Policy-Min-TLS-1-2-2019-07"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudSearchClientTypes {
    /// The domain's endpoint options.
    public struct DomainEndpointOptions {
        /// Whether the domain is HTTPS only enabled.
        public var enforceHTTPS: Swift.Bool?
        /// The minimum required TLS version
        public var tlsSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy?

        public init(
            enforceHTTPS: Swift.Bool? = nil,
            tlsSecurityPolicy: CloudSearchClientTypes.TLSSecurityPolicy? = nil
        )
        {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension CloudSearchClientTypes {
    /// The configuration and status of the domain's endpoint options.
    public struct DomainEndpointOptionsStatus {
        /// The domain endpoint options configured for the domain.
        /// This member is required.
        public var options: CloudSearchClientTypes.DomainEndpointOptions?
        /// The status of the configured domain endpoint options.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.DomainEndpointOptions? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a DescribeDomainEndpointOptions request. Contains the status and configuration of a search domain's endpoint options.
public struct DescribeDomainEndpointOptionsOutput {
    /// The status and configuration of a search domain's endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init(
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

/// Container for the parameters to the [DescribeDomains] operation. By default shows the status of all domains. To restrict the response to particular domains, specify the names of the domains you want to describe.
public struct DescribeDomainsInput {
    /// The names of the domains you want to include in the response.
    public var domainNames: [Swift.String]?

    public init(
        domainNames: [Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

/// The result of a DescribeDomains request. Contains the status of the domains specified in the request or all domains owned by the account.
public struct DescribeDomainsOutput {
    /// A list that contains the status of each requested domain.
    /// This member is required.
    public var domainStatusList: [CloudSearchClientTypes.DomainStatus]?

    public init(
        domainStatusList: [CloudSearchClientTypes.DomainStatus]? = nil
    )
    {
        self.domainStatusList = domainStatusList
    }
}

/// Container for the parameters to the [DescribeDomains] operation. Specifies the name of the domain you want to describe. To restrict the response to particular expressions, specify the names of the expressions you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeExpressionsInput {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// Limits the [DescribeExpressions] response to the specified expressions. If not specified, all expressions are shown.
    public var expressionNames: [Swift.String]?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        expressionNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.expressionNames = expressionNames
    }
}

/// The result of a DescribeExpressions request. Contains the expressions configured for the domain specified in the request.
public struct DescribeExpressionsOutput {
    /// The expressions configured for the domain.
    /// This member is required.
    public var expressions: [CloudSearchClientTypes.ExpressionStatus]?

    public init(
        expressions: [CloudSearchClientTypes.ExpressionStatus]? = nil
    )
    {
        self.expressions = expressions
    }
}

/// Container for the parameters to the [DescribeIndexFields] operation. Specifies the name of the domain you want to describe. To restrict the response to particular index fields, specify the names of the index fields you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeIndexFieldsInput {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
    public var fieldNames: [Swift.String]?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        fieldNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.fieldNames = fieldNames
    }
}

/// The result of a DescribeIndexFields request. Contains the index fields configured for the domain specified in the request.
public struct DescribeIndexFieldsOutput {
    /// The index fields configured for the domain.
    /// This member is required.
    public var indexFields: [CloudSearchClientTypes.IndexFieldStatus]?

    public init(
        indexFields: [CloudSearchClientTypes.IndexFieldStatus]? = nil
    )
    {
        self.indexFields = indexFields
    }
}

/// Container for the parameters to the [DescribeScalingParameters] operation. Specifies the name of the domain you want to describe.
public struct DescribeScalingParametersInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension CloudSearchClientTypes {

    /// The instance type (such as search.m1.small) on which an index partition is hosted.
    public enum PartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case search2xlarge
        case searchLarge
        case searchM1Large
        case searchM1Small
        case searchM22xlarge
        case searchM2Xlarge
        case searchM32xlarge
        case searchM3Large
        case searchM3Medium
        case searchM3Xlarge
        case searchMedium
        case searchPreviousgeneration2xlarge
        case searchPreviousgenerationLarge
        case searchPreviousgenerationSmall
        case searchPreviousgenerationXlarge
        case searchSmall
        case searchXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [PartitionInstanceType] {
            return [
                .search2xlarge,
                .searchLarge,
                .searchM1Large,
                .searchM1Small,
                .searchM22xlarge,
                .searchM2Xlarge,
                .searchM32xlarge,
                .searchM3Large,
                .searchM3Medium,
                .searchM3Xlarge,
                .searchMedium,
                .searchPreviousgeneration2xlarge,
                .searchPreviousgenerationLarge,
                .searchPreviousgenerationSmall,
                .searchPreviousgenerationXlarge,
                .searchSmall,
                .searchXlarge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .search2xlarge: return "search.2xlarge"
            case .searchLarge: return "search.large"
            case .searchM1Large: return "search.m1.large"
            case .searchM1Small: return "search.m1.small"
            case .searchM22xlarge: return "search.m2.2xlarge"
            case .searchM2Xlarge: return "search.m2.xlarge"
            case .searchM32xlarge: return "search.m3.2xlarge"
            case .searchM3Large: return "search.m3.large"
            case .searchM3Medium: return "search.m3.medium"
            case .searchM3Xlarge: return "search.m3.xlarge"
            case .searchMedium: return "search.medium"
            case .searchPreviousgeneration2xlarge: return "search.previousgeneration.2xlarge"
            case .searchPreviousgenerationLarge: return "search.previousgeneration.large"
            case .searchPreviousgenerationSmall: return "search.previousgeneration.small"
            case .searchPreviousgenerationXlarge: return "search.previousgeneration.xlarge"
            case .searchSmall: return "search.small"
            case .searchXlarge: return "search.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudSearchClientTypes {
    /// The desired instance type and desired number of replicas of each index partition.
    public struct ScalingParameters {
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        public var desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType?
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        public var desiredPartitionCount: Swift.Int
        /// The number of replicas you want to preconfigure for each index partition.
        public var desiredReplicationCount: Swift.Int

        public init(
            desiredInstanceType: CloudSearchClientTypes.PartitionInstanceType? = nil,
            desiredPartitionCount: Swift.Int = 0,
            desiredReplicationCount: Swift.Int = 0
        )
        {
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
            self.desiredReplicationCount = desiredReplicationCount
        }
    }

}

extension CloudSearchClientTypes {
    /// The status and configuration of a search domain's scaling parameters.
    public struct ScalingParametersStatus {
        /// The desired instance type and desired number of replicas of each index partition.
        /// This member is required.
        public var options: CloudSearchClientTypes.ScalingParameters?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: CloudSearchClientTypes.ScalingParameters? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a DescribeScalingParameters request. Contains the scaling parameters configured for the domain specified in the request.
public struct DescribeScalingParametersOutput {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init(
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

/// Container for the parameters to the [DescribeServiceAccessPolicies] operation. Specifies the name of the domain you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeServiceAccessPoliciesInput {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
    }
}

extension CloudSearchClientTypes {
    /// The configured access rules for the domain's document and search endpoints, and the current status of those rules.
    public struct AccessPoliciesStatus {
        /// Access rules for a domain's document or search service endpoints. For more information, see [Configuring Access for a Search Domain](http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-access.html) in the Amazon CloudSearch Developer Guide. The maximum size of a policy document is 100 KB.
        /// This member is required.
        public var options: Swift.String?
        /// The status of domain configuration option.
        /// This member is required.
        public var status: CloudSearchClientTypes.OptionStatus?

        public init(
            options: Swift.String? = nil,
            status: CloudSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// The result of a DescribeServiceAccessPolicies request.
public struct DescribeServiceAccessPoliciesOutput {
    /// The access rules configured for the domain specified in the request.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init(
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

/// Container for the parameters to the [DescribeSuggester] operation. Specifies the name of the domain you want to describe. To restrict the response to particular suggesters, specify the names of the suggesters you want to describe. To show the active configuration and exclude any pending changes, set the Deployed option to true.
public struct DescribeSuggestersInput {
    /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
    public var deployed: Swift.Bool?
    /// The name of the domain you want to describe.
    /// This member is required.
    public var domainName: Swift.String?
    /// The suggesters you want to describe.
    public var suggesterNames: [Swift.String]?

    public init(
        deployed: Swift.Bool? = nil,
        domainName: Swift.String? = nil,
        suggesterNames: [Swift.String]? = nil
    )
    {
        self.deployed = deployed
        self.domainName = domainName
        self.suggesterNames = suggesterNames
    }
}

/// The result of a DescribeSuggesters request.
public struct DescribeSuggestersOutput {
    /// The suggesters configured for the domain specified in the request.
    /// This member is required.
    public var suggesters: [CloudSearchClientTypes.SuggesterStatus]?

    public init(
        suggesters: [CloudSearchClientTypes.SuggesterStatus]? = nil
    )
    {
        self.suggesters = suggesters
    }
}

/// Container for the parameters to the [IndexDocuments] operation. Specifies the name of the domain you want to re-index.
public struct IndexDocumentsInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The result of an IndexDocuments request. Contains the status of the indexing operation, including the fields being indexed.
public struct IndexDocumentsOutput {
    /// The names of the fields that are currently being indexed.
    public var fieldNames: [Swift.String]?

    public init(
        fieldNames: [Swift.String]? = nil
    )
    {
        self.fieldNames = fieldNames
    }
}

/// The result of a ListDomainNames request. Contains a list of the domains owned by an account.
public struct ListDomainNamesOutput {
    /// The names of the search domains owned by an account.
    public var domainNames: [Swift.String: Swift.String]?

    public init(
        domainNames: [Swift.String: Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

/// Container for the parameters to the [UpdateAvailabilityOptions] operation. Specifies the name of the domain you want to update and the Multi-AZ availability option.
public struct UpdateAvailabilityOptionsInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false.
    /// This member is required.
    public var multiAZ: Swift.Bool?

    public init(
        domainName: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.multiAZ = multiAZ
    }
}

/// The result of a UpdateAvailabilityOptions request. Contains the status of the domain's availability options.
public struct UpdateAvailabilityOptionsOutput {
    /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain.
    public var availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus?

    public init(
        availabilityOptions: CloudSearchClientTypes.AvailabilityOptionsStatus? = nil
    )
    {
        self.availabilityOptions = availabilityOptions
    }
}

/// Container for the parameters to the [UpdateDomainEndpointOptions] operation. Specifies the name of the domain you want to update and the domain endpoint options.
public struct UpdateDomainEndpointOptionsInput {
    /// Whether to require that all requests to the domain arrive over HTTPS. We recommend Policy-Min-TLS-1-2-2019-07 for TLSSecurityPolicy. For compatibility with older clients, the default is Policy-Min-TLS-1-0-2019-07.
    /// This member is required.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions?
    /// A string that represents the name of a domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
    }
}

/// The result of a UpdateDomainEndpointOptions request. Contains the configuration and status of the domain's endpoint options.
public struct UpdateDomainEndpointOptionsOutput {
    /// The newly-configured domain endpoint options.
    public var domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus?

    public init(
        domainEndpointOptions: CloudSearchClientTypes.DomainEndpointOptionsStatus? = nil
    )
    {
        self.domainEndpointOptions = domainEndpointOptions
    }
}

/// Container for the parameters to the [UpdateScalingParameters] operation. Specifies the name of the domain you want to update and the scaling parameters you want to configure.
public struct UpdateScalingParametersInput {
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// The desired instance type and desired number of replicas of each index partition.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParameters?

    public init(
        domainName: Swift.String? = nil,
        scalingParameters: CloudSearchClientTypes.ScalingParameters? = nil
    )
    {
        self.domainName = domainName
        self.scalingParameters = scalingParameters
    }
}

/// The result of a UpdateScalingParameters request. Contains the status of the newly-configured scaling parameters.
public struct UpdateScalingParametersOutput {
    /// The status and configuration of a search domain's scaling parameters.
    /// This member is required.
    public var scalingParameters: CloudSearchClientTypes.ScalingParametersStatus?

    public init(
        scalingParameters: CloudSearchClientTypes.ScalingParametersStatus? = nil
    )
    {
        self.scalingParameters = scalingParameters
    }
}

/// Container for the parameters to the [UpdateServiceAccessPolicies] operation. Specifies the name of the domain you want to update and the access rules you want to configure.
public struct UpdateServiceAccessPoliciesInput {
    /// The access rules you want to configure. These rules replace any existing rules.
    /// This member is required.
    public var accessPolicies: Swift.String?
    /// A string that represents the name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        accessPolicies: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.domainName = domainName
    }
}

/// The result of an UpdateServiceAccessPolicies request. Contains the new access policies.
public struct UpdateServiceAccessPoliciesOutput {
    /// The access rules configured for the domain.
    /// This member is required.
    public var accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus?

    public init(
        accessPolicies: CloudSearchClientTypes.AccessPoliciesStatus? = nil
    )
    {
        self.accessPolicies = accessPolicies
    }
}

extension BuildSuggestersInput {

    static func urlPathProvider(_ value: BuildSuggestersInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        return "/"
    }
}

extension DefineAnalysisSchemeInput {

    static func urlPathProvider(_ value: DefineAnalysisSchemeInput) -> Swift.String? {
        return "/"
    }
}

extension DefineExpressionInput {

    static func urlPathProvider(_ value: DefineExpressionInput) -> Swift.String? {
        return "/"
    }
}

extension DefineIndexFieldInput {

    static func urlPathProvider(_ value: DefineIndexFieldInput) -> Swift.String? {
        return "/"
    }
}

extension DefineSuggesterInput {

    static func urlPathProvider(_ value: DefineSuggesterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAnalysisSchemeInput {

    static func urlPathProvider(_ value: DeleteAnalysisSchemeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteExpressionInput {

    static func urlPathProvider(_ value: DeleteExpressionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteIndexFieldInput {

    static func urlPathProvider(_ value: DeleteIndexFieldInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSuggesterInput {

    static func urlPathProvider(_ value: DeleteSuggesterInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAnalysisSchemesInput {

    static func urlPathProvider(_ value: DescribeAnalysisSchemesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAvailabilityOptionsInput {

    static func urlPathProvider(_ value: DescribeAvailabilityOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDomainEndpointOptionsInput {

    static func urlPathProvider(_ value: DescribeDomainEndpointOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDomainsInput {

    static func urlPathProvider(_ value: DescribeDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExpressionsInput {

    static func urlPathProvider(_ value: DescribeExpressionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeIndexFieldsInput {

    static func urlPathProvider(_ value: DescribeIndexFieldsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeScalingParametersInput {

    static func urlPathProvider(_ value: DescribeScalingParametersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServiceAccessPoliciesInput {

    static func urlPathProvider(_ value: DescribeServiceAccessPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSuggestersInput {

    static func urlPathProvider(_ value: DescribeSuggestersInput) -> Swift.String? {
        return "/"
    }
}

extension IndexDocumentsInput {

    static func urlPathProvider(_ value: IndexDocumentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDomainNamesInput {

    static func urlPathProvider(_ value: ListDomainNamesInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAvailabilityOptionsInput {

    static func urlPathProvider(_ value: UpdateAvailabilityOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDomainEndpointOptionsInput {

    static func urlPathProvider(_ value: UpdateDomainEndpointOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateScalingParametersInput {

    static func urlPathProvider(_ value: UpdateScalingParametersInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServiceAccessPoliciesInput {

    static func urlPathProvider(_ value: UpdateServiceAccessPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension BuildSuggestersInput {

    static func write(value: BuildSuggestersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("BuildSuggesters")
        try writer["Version"].write("2013-01-01")
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("CreateDomain")
        try writer["Version"].write("2013-01-01")
    }
}

extension DefineAnalysisSchemeInput {

    static func write(value: DefineAnalysisSchemeInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AnalysisScheme"].write(value.analysisScheme, with: CloudSearchClientTypes.AnalysisScheme.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DefineAnalysisScheme")
        try writer["Version"].write("2013-01-01")
    }
}

extension DefineExpressionInput {

    static func write(value: DefineExpressionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Expression"].write(value.expression, with: CloudSearchClientTypes.Expression.write(value:to:))
        try writer["Action"].write("DefineExpression")
        try writer["Version"].write("2013-01-01")
    }
}

extension DefineIndexFieldInput {

    static func write(value: DefineIndexFieldInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["IndexField"].write(value.indexField, with: CloudSearchClientTypes.IndexField.write(value:to:))
        try writer["Action"].write("DefineIndexField")
        try writer["Version"].write("2013-01-01")
    }
}

extension DefineSuggesterInput {

    static func write(value: DefineSuggesterInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Suggester"].write(value.suggester, with: CloudSearchClientTypes.Suggester.write(value:to:))
        try writer["Action"].write("DefineSuggester")
        try writer["Version"].write("2013-01-01")
    }
}

extension DeleteAnalysisSchemeInput {

    static func write(value: DeleteAnalysisSchemeInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AnalysisSchemeName"].write(value.analysisSchemeName)
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DeleteAnalysisScheme")
        try writer["Version"].write("2013-01-01")
    }
}

extension DeleteDomainInput {

    static func write(value: DeleteDomainInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DeleteDomain")
        try writer["Version"].write("2013-01-01")
    }
}

extension DeleteExpressionInput {

    static func write(value: DeleteExpressionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["ExpressionName"].write(value.expressionName)
        try writer["Action"].write("DeleteExpression")
        try writer["Version"].write("2013-01-01")
    }
}

extension DeleteIndexFieldInput {

    static func write(value: DeleteIndexFieldInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["IndexFieldName"].write(value.indexFieldName)
        try writer["Action"].write("DeleteIndexField")
        try writer["Version"].write("2013-01-01")
    }
}

extension DeleteSuggesterInput {

    static func write(value: DeleteSuggesterInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["SuggesterName"].write(value.suggesterName)
        try writer["Action"].write("DeleteSuggester")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeAnalysisSchemesInput {

    static func write(value: DescribeAnalysisSchemesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AnalysisSchemeNames"].writeList(value.analysisSchemeNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Deployed"].write(value.deployed)
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DescribeAnalysisSchemes")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeAvailabilityOptionsInput {

    static func write(value: DescribeAvailabilityOptionsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Deployed"].write(value.deployed)
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DescribeAvailabilityOptions")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeDomainEndpointOptionsInput {

    static func write(value: DescribeDomainEndpointOptionsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Deployed"].write(value.deployed)
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DescribeDomainEndpointOptions")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeDomainsInput {

    static func write(value: DescribeDomainsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainNames"].writeList(value.domainNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DescribeDomains")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeExpressionsInput {

    static func write(value: DescribeExpressionsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Deployed"].write(value.deployed)
        try writer["DomainName"].write(value.domainName)
        try writer["ExpressionNames"].writeList(value.expressionNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DescribeExpressions")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeIndexFieldsInput {

    static func write(value: DescribeIndexFieldsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Deployed"].write(value.deployed)
        try writer["DomainName"].write(value.domainName)
        try writer["FieldNames"].writeList(value.fieldNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DescribeIndexFields")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeScalingParametersInput {

    static func write(value: DescribeScalingParametersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DescribeScalingParameters")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeServiceAccessPoliciesInput {

    static func write(value: DescribeServiceAccessPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Deployed"].write(value.deployed)
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("DescribeServiceAccessPolicies")
        try writer["Version"].write("2013-01-01")
    }
}

extension DescribeSuggestersInput {

    static func write(value: DescribeSuggestersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Deployed"].write(value.deployed)
        try writer["DomainName"].write(value.domainName)
        try writer["SuggesterNames"].writeList(value.suggesterNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DescribeSuggesters")
        try writer["Version"].write("2013-01-01")
    }
}

extension IndexDocumentsInput {

    static func write(value: IndexDocumentsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("IndexDocuments")
        try writer["Version"].write("2013-01-01")
    }
}

extension ListDomainNamesInput {

    static func write(value: ListDomainNamesInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("ListDomainNames")
        try writer["Version"].write("2013-01-01")
    }
}

extension UpdateAvailabilityOptionsInput {

    static func write(value: UpdateAvailabilityOptionsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["MultiAZ"].write(value.multiAZ)
        try writer["Action"].write("UpdateAvailabilityOptions")
        try writer["Version"].write("2013-01-01")
    }
}

extension UpdateDomainEndpointOptionsInput {

    static func write(value: UpdateDomainEndpointOptionsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainEndpointOptions"].write(value.domainEndpointOptions, with: CloudSearchClientTypes.DomainEndpointOptions.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("UpdateDomainEndpointOptions")
        try writer["Version"].write("2013-01-01")
    }
}

extension UpdateScalingParametersInput {

    static func write(value: UpdateScalingParametersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["ScalingParameters"].write(value.scalingParameters, with: CloudSearchClientTypes.ScalingParameters.write(value:to:))
        try writer["Action"].write("UpdateScalingParameters")
        try writer["Version"].write("2013-01-01")
    }
}

extension UpdateServiceAccessPoliciesInput {

    static func write(value: UpdateServiceAccessPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AccessPolicies"].write(value.accessPolicies)
        try writer["DomainName"].write(value.domainName)
        try writer["Action"].write("UpdateServiceAccessPolicies")
        try writer["Version"].write("2013-01-01")
    }
}

extension BuildSuggestersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BuildSuggestersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["BuildSuggestersResult"]
        var value = BuildSuggestersOutput()
        value.fieldNames = try reader["FieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateDomainResult"]
        var value = CreateDomainOutput()
        value.domainStatus = try reader["DomainStatus"].readIfPresent(with: CloudSearchClientTypes.DomainStatus.read(from:))
        return value
    }
}

extension DefineAnalysisSchemeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DefineAnalysisSchemeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DefineAnalysisSchemeResult"]
        var value = DefineAnalysisSchemeOutput()
        value.analysisScheme = try reader["AnalysisScheme"].readIfPresent(with: CloudSearchClientTypes.AnalysisSchemeStatus.read(from:))
        return value
    }
}

extension DefineExpressionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DefineExpressionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DefineExpressionResult"]
        var value = DefineExpressionOutput()
        value.expression = try reader["Expression"].readIfPresent(with: CloudSearchClientTypes.ExpressionStatus.read(from:))
        return value
    }
}

extension DefineIndexFieldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DefineIndexFieldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DefineIndexFieldResult"]
        var value = DefineIndexFieldOutput()
        value.indexField = try reader["IndexField"].readIfPresent(with: CloudSearchClientTypes.IndexFieldStatus.read(from:))
        return value
    }
}

extension DefineSuggesterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DefineSuggesterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DefineSuggesterResult"]
        var value = DefineSuggesterOutput()
        value.suggester = try reader["Suggester"].readIfPresent(with: CloudSearchClientTypes.SuggesterStatus.read(from:))
        return value
    }
}

extension DeleteAnalysisSchemeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAnalysisSchemeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DeleteAnalysisSchemeResult"]
        var value = DeleteAnalysisSchemeOutput()
        value.analysisScheme = try reader["AnalysisScheme"].readIfPresent(with: CloudSearchClientTypes.AnalysisSchemeStatus.read(from:))
        return value
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DeleteDomainResult"]
        var value = DeleteDomainOutput()
        value.domainStatus = try reader["DomainStatus"].readIfPresent(with: CloudSearchClientTypes.DomainStatus.read(from:))
        return value
    }
}

extension DeleteExpressionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteExpressionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DeleteExpressionResult"]
        var value = DeleteExpressionOutput()
        value.expression = try reader["Expression"].readIfPresent(with: CloudSearchClientTypes.ExpressionStatus.read(from:))
        return value
    }
}

extension DeleteIndexFieldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIndexFieldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DeleteIndexFieldResult"]
        var value = DeleteIndexFieldOutput()
        value.indexField = try reader["IndexField"].readIfPresent(with: CloudSearchClientTypes.IndexFieldStatus.read(from:))
        return value
    }
}

extension DeleteSuggesterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSuggesterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DeleteSuggesterResult"]
        var value = DeleteSuggesterOutput()
        value.suggester = try reader["Suggester"].readIfPresent(with: CloudSearchClientTypes.SuggesterStatus.read(from:))
        return value
    }
}

extension DescribeAnalysisSchemesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAnalysisSchemesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeAnalysisSchemesResult"]
        var value = DescribeAnalysisSchemesOutput()
        value.analysisSchemes = try reader["AnalysisSchemes"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.AnalysisSchemeStatus.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeAvailabilityOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAvailabilityOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeAvailabilityOptionsResult"]
        var value = DescribeAvailabilityOptionsOutput()
        value.availabilityOptions = try reader["AvailabilityOptions"].readIfPresent(with: CloudSearchClientTypes.AvailabilityOptionsStatus.read(from:))
        return value
    }
}

extension DescribeDomainEndpointOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainEndpointOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeDomainEndpointOptionsResult"]
        var value = DescribeDomainEndpointOptionsOutput()
        value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(with: CloudSearchClientTypes.DomainEndpointOptionsStatus.read(from:))
        return value
    }
}

extension DescribeDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeDomainsResult"]
        var value = DescribeDomainsOutput()
        value.domainStatusList = try reader["DomainStatusList"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.DomainStatus.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeExpressionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExpressionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeExpressionsResult"]
        var value = DescribeExpressionsOutput()
        value.expressions = try reader["Expressions"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.ExpressionStatus.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeIndexFieldsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeIndexFieldsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeIndexFieldsResult"]
        var value = DescribeIndexFieldsOutput()
        value.indexFields = try reader["IndexFields"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.IndexFieldStatus.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeScalingParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeScalingParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeScalingParametersResult"]
        var value = DescribeScalingParametersOutput()
        value.scalingParameters = try reader["ScalingParameters"].readIfPresent(with: CloudSearchClientTypes.ScalingParametersStatus.read(from:))
        return value
    }
}

extension DescribeServiceAccessPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServiceAccessPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeServiceAccessPoliciesResult"]
        var value = DescribeServiceAccessPoliciesOutput()
        value.accessPolicies = try reader["AccessPolicies"].readIfPresent(with: CloudSearchClientTypes.AccessPoliciesStatus.read(from:))
        return value
    }
}

extension DescribeSuggestersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSuggestersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeSuggestersResult"]
        var value = DescribeSuggestersOutput()
        value.suggesters = try reader["Suggesters"].readListIfPresent(memberReadingClosure: CloudSearchClientTypes.SuggesterStatus.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IndexDocumentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> IndexDocumentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["IndexDocumentsResult"]
        var value = IndexDocumentsOutput()
        value.fieldNames = try reader["FieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDomainNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListDomainNamesResult"]
        var value = ListDomainNamesOutput()
        value.domainNames = try reader["DomainNames"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateAvailabilityOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAvailabilityOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UpdateAvailabilityOptionsResult"]
        var value = UpdateAvailabilityOptionsOutput()
        value.availabilityOptions = try reader["AvailabilityOptions"].readIfPresent(with: CloudSearchClientTypes.AvailabilityOptionsStatus.read(from:))
        return value
    }
}

extension UpdateDomainEndpointOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainEndpointOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UpdateDomainEndpointOptionsResult"]
        var value = UpdateDomainEndpointOptionsOutput()
        value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(with: CloudSearchClientTypes.DomainEndpointOptionsStatus.read(from:))
        return value
    }
}

extension UpdateScalingParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateScalingParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UpdateScalingParametersResult"]
        var value = UpdateScalingParametersOutput()
        value.scalingParameters = try reader["ScalingParameters"].readIfPresent(with: CloudSearchClientTypes.ScalingParametersStatus.read(from:))
        return value
    }
}

extension UpdateServiceAccessPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceAccessPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["UpdateServiceAccessPoliciesResult"]
        var value = UpdateServiceAccessPoliciesOutput()
        value.accessPolicies = try reader["AccessPolicies"].readIfPresent(with: CloudSearchClientTypes.AccessPoliciesStatus.read(from:))
        return value
    }
}

enum BuildSuggestersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExists": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DefineAnalysisSchemeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DefineExpressionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DefineIndexFieldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DefineSuggesterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAnalysisSchemeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteExpressionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIndexFieldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSuggesterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAnalysisSchemesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAvailabilityOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledAction": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainEndpointOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledAction": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExpressionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeIndexFieldsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeScalingParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServiceAccessPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSuggestersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum IndexDocumentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAvailabilityOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledAction": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainEndpointOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledAction": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateScalingParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceAccessPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidType": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceeded": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InternalException {
        let reader = baseError.errorBodyReader
        var value = InternalException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BaseException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> BaseException {
        let reader = baseError.errorBodyReader
        var value = BaseException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTypeException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidTypeException {
        let reader = baseError.errorBodyReader
        var value = InvalidTypeException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DisabledOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DisabledOperationException {
        let reader = baseError.errorBodyReader
        var value = DisabledOperationException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudSearchClientTypes.DomainStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DomainStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DomainStatus()
        value.domainId = try reader["DomainId"].readIfPresent() ?? ""
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.arn = try reader["ARN"].readIfPresent()
        value.created = try reader["Created"].readIfPresent()
        value.deleted = try reader["Deleted"].readIfPresent()
        value.docService = try reader["DocService"].readIfPresent(with: CloudSearchClientTypes.ServiceEndpoint.read(from:))
        value.searchService = try reader["SearchService"].readIfPresent(with: CloudSearchClientTypes.ServiceEndpoint.read(from:))
        value.requiresIndexDocuments = try reader["RequiresIndexDocuments"].readIfPresent() ?? false
        value.processing = try reader["Processing"].readIfPresent()
        value.searchInstanceType = try reader["SearchInstanceType"].readIfPresent()
        value.searchPartitionCount = try reader["SearchPartitionCount"].readIfPresent()
        value.searchInstanceCount = try reader["SearchInstanceCount"].readIfPresent()
        value.limits = try reader["Limits"].readIfPresent(with: CloudSearchClientTypes.Limits.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.Limits {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.Limits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.Limits()
        value.maximumReplicationCount = try reader["MaximumReplicationCount"].readIfPresent() ?? 0
        value.maximumPartitionCount = try reader["MaximumPartitionCount"].readIfPresent() ?? 0
        return value
    }
}

extension CloudSearchClientTypes.ServiceEndpoint {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.ServiceEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.ServiceEndpoint()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.AnalysisSchemeStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.AnalysisSchemeStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.AnalysisSchemeStatus()
        value.options = try reader["Options"].readIfPresent(with: CloudSearchClientTypes.AnalysisScheme.read(from:))
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.OptionStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.OptionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.OptionStatus()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateVersion = try reader["UpdateVersion"].readIfPresent() ?? 0
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.pendingDeletion = try reader["PendingDeletion"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.AnalysisScheme {

    static func write(value: CloudSearchClientTypes.AnalysisScheme?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AnalysisOptions"].write(value.analysisOptions, with: CloudSearchClientTypes.AnalysisOptions.write(value:to:))
        try writer["AnalysisSchemeLanguage"].write(value.analysisSchemeLanguage)
        try writer["AnalysisSchemeName"].write(value.analysisSchemeName)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.AnalysisScheme {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.AnalysisScheme()
        value.analysisSchemeName = try reader["AnalysisSchemeName"].readIfPresent() ?? ""
        value.analysisSchemeLanguage = try reader["AnalysisSchemeLanguage"].readIfPresent() ?? .sdkUnknown("")
        value.analysisOptions = try reader["AnalysisOptions"].readIfPresent(with: CloudSearchClientTypes.AnalysisOptions.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.AnalysisOptions {

    static func write(value: CloudSearchClientTypes.AnalysisOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AlgorithmicStemming"].write(value.algorithmicStemming)
        try writer["JapaneseTokenizationDictionary"].write(value.japaneseTokenizationDictionary)
        try writer["StemmingDictionary"].write(value.stemmingDictionary)
        try writer["Stopwords"].write(value.stopwords)
        try writer["Synonyms"].write(value.synonyms)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.AnalysisOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.AnalysisOptions()
        value.synonyms = try reader["Synonyms"].readIfPresent()
        value.stopwords = try reader["Stopwords"].readIfPresent()
        value.stemmingDictionary = try reader["StemmingDictionary"].readIfPresent()
        value.japaneseTokenizationDictionary = try reader["JapaneseTokenizationDictionary"].readIfPresent()
        value.algorithmicStemming = try reader["AlgorithmicStemming"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.ExpressionStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.ExpressionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.ExpressionStatus()
        value.options = try reader["Options"].readIfPresent(with: CloudSearchClientTypes.Expression.read(from:))
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.Expression {

    static func write(value: CloudSearchClientTypes.Expression?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ExpressionName"].write(value.expressionName)
        try writer["ExpressionValue"].write(value.expressionValue)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.Expression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.Expression()
        value.expressionName = try reader["ExpressionName"].readIfPresent() ?? ""
        value.expressionValue = try reader["ExpressionValue"].readIfPresent() ?? ""
        return value
    }
}

extension CloudSearchClientTypes.IndexFieldStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.IndexFieldStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.IndexFieldStatus()
        value.options = try reader["Options"].readIfPresent(with: CloudSearchClientTypes.IndexField.read(from:))
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.IndexField {

    static func write(value: CloudSearchClientTypes.IndexField?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DateArrayOptions"].write(value.dateArrayOptions, with: CloudSearchClientTypes.DateArrayOptions.write(value:to:))
        try writer["DateOptions"].write(value.dateOptions, with: CloudSearchClientTypes.DateOptions.write(value:to:))
        try writer["DoubleArrayOptions"].write(value.doubleArrayOptions, with: CloudSearchClientTypes.DoubleArrayOptions.write(value:to:))
        try writer["DoubleOptions"].write(value.doubleOptions, with: CloudSearchClientTypes.DoubleOptions.write(value:to:))
        try writer["IndexFieldName"].write(value.indexFieldName)
        try writer["IndexFieldType"].write(value.indexFieldType)
        try writer["IntArrayOptions"].write(value.intArrayOptions, with: CloudSearchClientTypes.IntArrayOptions.write(value:to:))
        try writer["IntOptions"].write(value.intOptions, with: CloudSearchClientTypes.IntOptions.write(value:to:))
        try writer["LatLonOptions"].write(value.latLonOptions, with: CloudSearchClientTypes.LatLonOptions.write(value:to:))
        try writer["LiteralArrayOptions"].write(value.literalArrayOptions, with: CloudSearchClientTypes.LiteralArrayOptions.write(value:to:))
        try writer["LiteralOptions"].write(value.literalOptions, with: CloudSearchClientTypes.LiteralOptions.write(value:to:))
        try writer["TextArrayOptions"].write(value.textArrayOptions, with: CloudSearchClientTypes.TextArrayOptions.write(value:to:))
        try writer["TextOptions"].write(value.textOptions, with: CloudSearchClientTypes.TextOptions.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.IndexField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.IndexField()
        value.indexFieldName = try reader["IndexFieldName"].readIfPresent() ?? ""
        value.indexFieldType = try reader["IndexFieldType"].readIfPresent() ?? .sdkUnknown("")
        value.intOptions = try reader["IntOptions"].readIfPresent(with: CloudSearchClientTypes.IntOptions.read(from:))
        value.doubleOptions = try reader["DoubleOptions"].readIfPresent(with: CloudSearchClientTypes.DoubleOptions.read(from:))
        value.literalOptions = try reader["LiteralOptions"].readIfPresent(with: CloudSearchClientTypes.LiteralOptions.read(from:))
        value.textOptions = try reader["TextOptions"].readIfPresent(with: CloudSearchClientTypes.TextOptions.read(from:))
        value.dateOptions = try reader["DateOptions"].readIfPresent(with: CloudSearchClientTypes.DateOptions.read(from:))
        value.latLonOptions = try reader["LatLonOptions"].readIfPresent(with: CloudSearchClientTypes.LatLonOptions.read(from:))
        value.intArrayOptions = try reader["IntArrayOptions"].readIfPresent(with: CloudSearchClientTypes.IntArrayOptions.read(from:))
        value.doubleArrayOptions = try reader["DoubleArrayOptions"].readIfPresent(with: CloudSearchClientTypes.DoubleArrayOptions.read(from:))
        value.literalArrayOptions = try reader["LiteralArrayOptions"].readIfPresent(with: CloudSearchClientTypes.LiteralArrayOptions.read(from:))
        value.textArrayOptions = try reader["TextArrayOptions"].readIfPresent(with: CloudSearchClientTypes.TextArrayOptions.read(from:))
        value.dateArrayOptions = try reader["DateArrayOptions"].readIfPresent(with: CloudSearchClientTypes.DateArrayOptions.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.DateArrayOptions {

    static func write(value: CloudSearchClientTypes.DateArrayOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SourceFields"].write(value.sourceFields)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DateArrayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DateArrayOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceFields = try reader["SourceFields"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.TextArrayOptions {

    static func write(value: CloudSearchClientTypes.TextArrayOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AnalysisScheme"].write(value.analysisScheme)
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["HighlightEnabled"].write(value.highlightEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SourceFields"].write(value.sourceFields)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.TextArrayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.TextArrayOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceFields = try reader["SourceFields"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        value.highlightEnabled = try reader["HighlightEnabled"].readIfPresent()
        value.analysisScheme = try reader["AnalysisScheme"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.LiteralArrayOptions {

    static func write(value: CloudSearchClientTypes.LiteralArrayOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SourceFields"].write(value.sourceFields)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.LiteralArrayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.LiteralArrayOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceFields = try reader["SourceFields"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.DoubleArrayOptions {

    static func write(value: CloudSearchClientTypes.DoubleArrayOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SourceFields"].write(value.sourceFields)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DoubleArrayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DoubleArrayOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceFields = try reader["SourceFields"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.IntArrayOptions {

    static func write(value: CloudSearchClientTypes.IntArrayOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SourceFields"].write(value.sourceFields)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.IntArrayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.IntArrayOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceFields = try reader["SourceFields"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.LatLonOptions {

    static func write(value: CloudSearchClientTypes.LatLonOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SortEnabled"].write(value.sortEnabled)
        try writer["SourceField"].write(value.sourceField)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.LatLonOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.LatLonOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceField = try reader["SourceField"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        value.sortEnabled = try reader["SortEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.DateOptions {

    static func write(value: CloudSearchClientTypes.DateOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SortEnabled"].write(value.sortEnabled)
        try writer["SourceField"].write(value.sourceField)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DateOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DateOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceField = try reader["SourceField"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        value.sortEnabled = try reader["SortEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.TextOptions {

    static func write(value: CloudSearchClientTypes.TextOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AnalysisScheme"].write(value.analysisScheme)
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["HighlightEnabled"].write(value.highlightEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SortEnabled"].write(value.sortEnabled)
        try writer["SourceField"].write(value.sourceField)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.TextOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.TextOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceField = try reader["SourceField"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        value.sortEnabled = try reader["SortEnabled"].readIfPresent()
        value.highlightEnabled = try reader["HighlightEnabled"].readIfPresent()
        value.analysisScheme = try reader["AnalysisScheme"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.LiteralOptions {

    static func write(value: CloudSearchClientTypes.LiteralOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SortEnabled"].write(value.sortEnabled)
        try writer["SourceField"].write(value.sourceField)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.LiteralOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.LiteralOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceField = try reader["SourceField"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        value.sortEnabled = try reader["SortEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.DoubleOptions {

    static func write(value: CloudSearchClientTypes.DoubleOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SortEnabled"].write(value.sortEnabled)
        try writer["SourceField"].write(value.sourceField)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DoubleOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DoubleOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceField = try reader["SourceField"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        value.sortEnabled = try reader["SortEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.IntOptions {

    static func write(value: CloudSearchClientTypes.IntOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["FacetEnabled"].write(value.facetEnabled)
        try writer["ReturnEnabled"].write(value.returnEnabled)
        try writer["SearchEnabled"].write(value.searchEnabled)
        try writer["SortEnabled"].write(value.sortEnabled)
        try writer["SourceField"].write(value.sourceField)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.IntOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.IntOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.sourceField = try reader["SourceField"].readIfPresent()
        value.facetEnabled = try reader["FacetEnabled"].readIfPresent()
        value.searchEnabled = try reader["SearchEnabled"].readIfPresent()
        value.returnEnabled = try reader["ReturnEnabled"].readIfPresent()
        value.sortEnabled = try reader["SortEnabled"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.SuggesterStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.SuggesterStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.SuggesterStatus()
        value.options = try reader["Options"].readIfPresent(with: CloudSearchClientTypes.Suggester.read(from:))
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.Suggester {

    static func write(value: CloudSearchClientTypes.Suggester?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DocumentSuggesterOptions"].write(value.documentSuggesterOptions, with: CloudSearchClientTypes.DocumentSuggesterOptions.write(value:to:))
        try writer["SuggesterName"].write(value.suggesterName)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.Suggester {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.Suggester()
        value.suggesterName = try reader["SuggesterName"].readIfPresent() ?? ""
        value.documentSuggesterOptions = try reader["DocumentSuggesterOptions"].readIfPresent(with: CloudSearchClientTypes.DocumentSuggesterOptions.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.DocumentSuggesterOptions {

    static func write(value: CloudSearchClientTypes.DocumentSuggesterOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["FuzzyMatching"].write(value.fuzzyMatching)
        try writer["SortExpression"].write(value.sortExpression)
        try writer["SourceField"].write(value.sourceField)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DocumentSuggesterOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DocumentSuggesterOptions()
        value.sourceField = try reader["SourceField"].readIfPresent() ?? ""
        value.fuzzyMatching = try reader["FuzzyMatching"].readIfPresent()
        value.sortExpression = try reader["SortExpression"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.AvailabilityOptionsStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.AvailabilityOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.AvailabilityOptionsStatus()
        value.options = try reader["Options"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.DomainEndpointOptionsStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DomainEndpointOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DomainEndpointOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: CloudSearchClientTypes.DomainEndpointOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.DomainEndpointOptions {

    static func write(value: CloudSearchClientTypes.DomainEndpointOptions?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["EnforceHTTPS"].write(value.enforceHTTPS)
        try writer["TLSSecurityPolicy"].write(value.tlsSecurityPolicy)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.DomainEndpointOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.DomainEndpointOptions()
        value.enforceHTTPS = try reader["EnforceHTTPS"].readIfPresent()
        value.tlsSecurityPolicy = try reader["TLSSecurityPolicy"].readIfPresent()
        return value
    }
}

extension CloudSearchClientTypes.ScalingParametersStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.ScalingParametersStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.ScalingParametersStatus()
        value.options = try reader["Options"].readIfPresent(with: CloudSearchClientTypes.ScalingParameters.read(from:))
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension CloudSearchClientTypes.ScalingParameters {

    static func write(value: CloudSearchClientTypes.ScalingParameters?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DesiredInstanceType"].write(value.desiredInstanceType)
        try writer["DesiredPartitionCount"].write(value.desiredPartitionCount)
        try writer["DesiredReplicationCount"].write(value.desiredReplicationCount)
    }

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.ScalingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.ScalingParameters()
        value.desiredInstanceType = try reader["DesiredInstanceType"].readIfPresent()
        value.desiredReplicationCount = try reader["DesiredReplicationCount"].readIfPresent() ?? 0
        value.desiredPartitionCount = try reader["DesiredPartitionCount"].readIfPresent() ?? 0
        return value
    }
}

extension CloudSearchClientTypes.AccessPoliciesStatus {

    static func read(from reader: SmithyXML.Reader) throws -> CloudSearchClientTypes.AccessPoliciesStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudSearchClientTypes.AccessPoliciesStatus()
        value.options = try reader["Options"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent(with: CloudSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

public enum CloudSearchClientTypes {}
