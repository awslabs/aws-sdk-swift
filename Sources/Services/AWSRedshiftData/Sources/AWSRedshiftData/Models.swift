//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// The Amazon Redshift Data API operation failed because the maximum number of active sessions exceeded.
public struct ActiveSessionsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActiveSessionsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of active statements exceeds the limit.
public struct ActiveStatementsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActiveStatementsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An SQL statement encountered an environmental error while running.
public struct BatchExecuteStatementException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Statement identifier of the exception.
        /// This member is required.
        public internal(set) var statementId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchExecuteStatementException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.statementId = statementId
    }
}

/// The Amazon Redshift Data API operation failed due to invalid input.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Redshift Data API operation failed due to invalid input.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchExecuteStatementInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The session identifier of the query.
    public var sessionId: Swift.String?
    /// The number of seconds to keep the session alive after the query finishes. The maximum time a session can keep alive is 24 hours. After 24 hours, the session is forced closed and the query is terminated.
    public var sessionKeepAliveSeconds: Swift.Int?
    /// One or more SQL statements to run. The SQL statements are run as a single transaction. They run serially in the order of the array. Subsequent SQL statements don't start until the previous statement in the array completes. If any SQL statement fails, then because they are run as one transaction, all work is rolled back.
    /// This member is required.
    public var sqls: [Swift.String]?
    /// The name of the SQL statements. You can name the SQL statements when you create them to identify the query.
    public var statementName: Swift.String?
    /// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statements run.
    public var withEvent: Swift.Bool?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionKeepAliveSeconds: Swift.Int? = nil,
        sqls: [Swift.String]? = nil,
        statementName: Swift.String? = nil,
        withEvent: Swift.Bool? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.secretArn = secretArn
        self.sessionId = sessionId
        self.sessionKeepAliveSeconds = sessionKeepAliveSeconds
        self.sqls = sqls
        self.statementName = statementName
        self.withEvent = withEvent
        self.workgroupName = workgroupName
    }
}

public struct BatchExecuteStatementOutput {
    /// The cluster identifier. This element is not returned when connecting to a serverless workgroup.
    public var clusterIdentifier: Swift.String?
    /// The date and time (UTC) the statement was created.
    public var createdAt: Foundation.Date?
    /// The name of the database.
    public var database: Swift.String?
    /// A list of colon (:) separated names of database groups.
    public var dbGroups: [Swift.String]?
    /// The database user name.
    public var dbUser: Swift.String?
    /// The identifier of the SQL statement whose results are to be fetched. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. This identifier is returned by BatchExecuteStatment.
    public var id: Swift.String?
    /// The name or ARN of the secret that enables access to the database.
    public var secretArn: Swift.String?
    /// The session identifier of the query.
    public var sessionId: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This element is not returned when connecting to a provisioned cluster.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        database: Swift.String? = nil,
        dbGroups: [Swift.String]? = nil,
        dbUser: Swift.String? = nil,
        id: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbGroups = dbGroups
        self.dbUser = dbUser
        self.id = id
        self.secretArn = secretArn
        self.sessionId = sessionId
        self.workgroupName = workgroupName
    }
}

/// Connection to a database failed.
public struct DatabaseConnectionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DatabaseConnectionException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Redshift Data API operation failed due to a missing resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Resource identifier associated with the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

public struct CancelStatementInput {
    /// The identifier of the SQL statement to cancel. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. This identifier is returned by BatchExecuteStatment, ExecuteStatment, and ListStatements.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct CancelStatementOutput {
    /// A value that indicates whether the cancel statement succeeded (true).
    public var status: Swift.Bool?

    public init(
        status: Swift.Bool? = nil
    )
    {
        self.status = status
    }
}

extension RedshiftDataClientTypes {
    /// The properties (metadata) of a column.
    public struct ColumnMetadata {
        /// The default value of the column.
        public var columnDefault: Swift.String?
        /// A value that indicates whether the column is case-sensitive.
        public var isCaseSensitive: Swift.Bool
        /// A value that indicates whether the column contains currency values.
        public var isCurrency: Swift.Bool
        /// A value that indicates whether an integer column is signed.
        public var isSigned: Swift.Bool
        /// The label for the column.
        public var label: Swift.String?
        /// The length of the column.
        public var length: Swift.Int
        /// The name of the column.
        public var name: Swift.String?
        /// A value that indicates whether the column is nullable.
        public var nullable: Swift.Int
        /// The precision value of a decimal number column.
        public var precision: Swift.Int
        /// The scale value of a decimal number column.
        public var scale: Swift.Int
        /// The name of the schema that contains the table that includes the column.
        public var schemaName: Swift.String?
        /// The name of the table that includes the column.
        public var tableName: Swift.String?
        /// The database-specific data type of the column.
        public var typeName: Swift.String?

        public init(
            columnDefault: Swift.String? = nil,
            isCaseSensitive: Swift.Bool = false,
            isCurrency: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            label: Swift.String? = nil,
            length: Swift.Int = 0,
            name: Swift.String? = nil,
            nullable: Swift.Int = 0,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.columnDefault = columnDefault
            self.isCaseSensitive = isCaseSensitive
            self.isCurrency = isCurrency
            self.isSigned = isSigned
            self.label = label
            self.length = length
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.typeName = typeName
        }
    }

}

public struct DescribeStatementInput {
    /// The identifier of the SQL statement to describe. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. A suffix indicates the number of the SQL statement. For example, d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the second SQL statement of a batch query. This identifier is returned by BatchExecuteStatment, ExecuteStatement, and ListStatements.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension RedshiftDataClientTypes {
    /// A parameter used in a SQL statement.
    public struct SqlParameter {
        /// The name of the parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the parameter. Amazon Redshift implicitly converts to the proper data type. For more information, see [Data types](https://docs.aws.amazon.com/redshift/latest/dg/c_Supported_data_types.html) in the Amazon Redshift Database Developer Guide.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension RedshiftDataClientTypes {

    public enum StatusString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case all
        case failed
        case finished
        case picked
        case started
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusString] {
            return [
                .aborted,
                .all,
                .failed,
                .finished,
                .picked,
                .started,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .picked: return "PICKED"
            case .started: return "STARTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftDataClientTypes {

    public enum StatementStatusString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case failed
        case finished
        case picked
        case started
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementStatusString] {
            return [
                .aborted,
                .failed,
                .finished,
                .picked,
                .started,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .picked: return "PICKED"
            case .started: return "STARTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftDataClientTypes {
    /// Information about an SQL statement.
    public struct SubStatementData {
        /// The date and time (UTC) the statement was created.
        public var createdAt: Foundation.Date?
        /// The amount of time in nanoseconds that the statement ran.
        public var duration: Swift.Int
        /// The error message from the cluster if the SQL statement encountered an error while running.
        public var error: Swift.String?
        /// A value that indicates whether the statement has a result set. The result set can be empty. The value is true for an empty result set.
        public var hasResultSet: Swift.Bool?
        /// The identifier of the SQL statement. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. A suffix indicates the number of the SQL statement. For example, d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the second SQL statement of a batch query.
        /// This member is required.
        public var id: Swift.String?
        /// The SQL statement text.
        public var queryString: Swift.String?
        /// The SQL statement identifier. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
        public var redshiftQueryId: Swift.Int
        /// Either the number of rows returned from the SQL statement or the number of rows affected. If result size is greater than zero, the result rows can be the number of rows affected by SQL statements such as INSERT, UPDATE, DELETE, COPY, and others. A -1 indicates the value is null.
        public var resultRows: Swift.Int
        /// The size in bytes of the returned results. A -1 indicates the value is null.
        public var resultSize: Swift.Int
        /// The status of the SQL statement. An example is the that the SQL statement finished.
        public var status: RedshiftDataClientTypes.StatementStatusString?
        /// The date and time (UTC) that the statement metadata was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            duration: Swift.Int = 0,
            error: Swift.String? = nil,
            hasResultSet: Swift.Bool? = nil,
            id: Swift.String? = nil,
            queryString: Swift.String? = nil,
            redshiftQueryId: Swift.Int = 0,
            resultRows: Swift.Int = 0,
            resultSize: Swift.Int = 0,
            status: RedshiftDataClientTypes.StatementStatusString? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.duration = duration
            self.error = error
            self.hasResultSet = hasResultSet
            self.id = id
            self.queryString = queryString
            self.redshiftQueryId = redshiftQueryId
            self.resultRows = resultRows
            self.resultSize = resultSize
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

public struct DescribeStatementOutput {
    /// The cluster identifier.
    public var clusterIdentifier: Swift.String?
    /// The date and time (UTC) when the SQL statement was submitted to run.
    public var createdAt: Foundation.Date?
    /// The name of the database.
    public var database: Swift.String?
    /// The database user name.
    public var dbUser: Swift.String?
    /// The amount of time in nanoseconds that the statement ran.
    public var duration: Swift.Int
    /// The error message from the cluster if the SQL statement encountered an error while running.
    public var error: Swift.String?
    /// A value that indicates whether the statement has a result set. The result set can be empty. The value is true for an empty result set. The value is true if any substatement returns a result set.
    public var hasResultSet: Swift.Bool?
    /// The identifier of the SQL statement described. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
    /// This member is required.
    public var id: Swift.String?
    /// The parameters for the SQL statement.
    public var queryParameters: [RedshiftDataClientTypes.SqlParameter]?
    /// The SQL statement text.
    public var queryString: Swift.String?
    /// The process identifier from Amazon Redshift.
    public var redshiftPid: Swift.Int
    /// The identifier of the query generated by Amazon Redshift. These identifiers are also available in the query column of the STL_QUERY system view.
    public var redshiftQueryId: Swift.Int
    /// Either the number of rows returned from the SQL statement or the number of rows affected. If result size is greater than zero, the result rows can be the number of rows affected by SQL statements such as INSERT, UPDATE, DELETE, COPY, and others. A -1 indicates the value is null.
    public var resultRows: Swift.Int
    /// The size in bytes of the returned results. A -1 indicates the value is null.
    public var resultSize: Swift.Int
    /// The name or Amazon Resource Name (ARN) of the secret that enables access to the database.
    public var secretArn: Swift.String?
    /// The session identifier of the query.
    public var sessionId: Swift.String?
    /// The status of the SQL statement being described. Status values are defined as follows:
    ///
    /// * ABORTED - The query run was stopped by the user.
    ///
    /// * ALL - A status value that includes all query statuses. This value can be used to filter results.
    ///
    /// * FAILED - The query run failed.
    ///
    /// * FINISHED - The query has finished running.
    ///
    /// * PICKED - The query has been chosen to be run.
    ///
    /// * STARTED - The query run has started.
    ///
    /// * SUBMITTED - The query was submitted, but not yet processed.
    public var status: RedshiftDataClientTypes.StatusString?
    /// The SQL statements from a multiple statement run.
    public var subStatements: [RedshiftDataClientTypes.SubStatementData]?
    /// The date and time (UTC) that the metadata for the SQL statement was last updated. An example is the time the status last changed.
    public var updatedAt: Foundation.Date?
    /// The serverless workgroup name or Amazon Resource Name (ARN).
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        duration: Swift.Int = 0,
        error: Swift.String? = nil,
        hasResultSet: Swift.Bool? = nil,
        id: Swift.String? = nil,
        queryParameters: [RedshiftDataClientTypes.SqlParameter]? = nil,
        queryString: Swift.String? = nil,
        redshiftPid: Swift.Int = 0,
        redshiftQueryId: Swift.Int = 0,
        resultRows: Swift.Int = 0,
        resultSize: Swift.Int = 0,
        secretArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        status: RedshiftDataClientTypes.StatusString? = nil,
        subStatements: [RedshiftDataClientTypes.SubStatementData]? = nil,
        updatedAt: Foundation.Date? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbUser = dbUser
        self.duration = duration
        self.error = error
        self.hasResultSet = hasResultSet
        self.id = id
        self.queryParameters = queryParameters
        self.queryString = queryString
        self.redshiftPid = redshiftPid
        self.redshiftQueryId = redshiftQueryId
        self.resultRows = resultRows
        self.resultSize = resultSize
        self.secretArn = secretArn
        self.sessionId = sessionId
        self.status = status
        self.subStatements = subStatements
        self.updatedAt = updatedAt
        self.workgroupName = workgroupName
    }
}

/// The Amazon Redshift Data API operation failed due to timeout.
public struct QueryTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeTableInput {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// A database name. The connected database is specified when you connect with your authentication credentials.
    public var connectedDatabase: Swift.String?
    /// The name of the database that contains the tables to be described. If ConnectedDatabase is not specified, this is also the database to connect to with your authentication credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of tables to return in the response. If more tables exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The schema that contains the table. If no schema is specified, then matching tables for all schemas are returned.
    public var schema: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The table name. If no table is specified, then all tables for all matching schemas are returned. If no table and no schema is specified, then all tables for all schemas in the database are returned
    public var table: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        connectedDatabase: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        table: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schema = schema
        self.secretArn = secretArn
        self.table = table
        self.workgroupName = workgroupName
    }
}

public struct DescribeTableOutput {
    /// A list of columns in the table.
    public var columnList: [RedshiftDataClientTypes.ColumnMetadata]?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The table name.
    public var tableName: Swift.String?

    public init(
        columnList: [RedshiftDataClientTypes.ColumnMetadata]? = nil,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.columnList = columnList
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

/// The SQL statement encountered an environmental error while running.
public struct ExecuteStatementException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Statement identifier of the exception.
        /// This member is required.
        public internal(set) var statementId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExecuteStatementException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.statementId = statementId
    }
}

public struct ExecuteStatementInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The parameters for the SQL statement.
    public var parameters: [RedshiftDataClientTypes.SqlParameter]?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The session identifier of the query.
    public var sessionId: Swift.String?
    /// The number of seconds to keep the session alive after the query finishes. The maximum time a session can keep alive is 24 hours. After 24 hours, the session is forced closed and the query is terminated.
    public var sessionKeepAliveSeconds: Swift.Int?
    /// The SQL statement text to run.
    /// This member is required.
    public var sql: Swift.String?
    /// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
    public var statementName: Swift.String?
    /// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
    public var withEvent: Swift.Bool?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        parameters: [RedshiftDataClientTypes.SqlParameter]? = nil,
        secretArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionKeepAliveSeconds: Swift.Int? = nil,
        sql: Swift.String? = nil,
        statementName: Swift.String? = nil,
        withEvent: Swift.Bool? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.parameters = parameters
        self.secretArn = secretArn
        self.sessionId = sessionId
        self.sessionKeepAliveSeconds = sessionKeepAliveSeconds
        self.sql = sql
        self.statementName = statementName
        self.withEvent = withEvent
        self.workgroupName = workgroupName
    }
}

public struct ExecuteStatementOutput {
    /// The cluster identifier. This element is not returned when connecting to a serverless workgroup.
    public var clusterIdentifier: Swift.String?
    /// The date and time (UTC) the statement was created.
    public var createdAt: Foundation.Date?
    /// The name of the database.
    public var database: Swift.String?
    /// A list of colon (:) separated names of database groups.
    public var dbGroups: [Swift.String]?
    /// The database user name.
    public var dbUser: Swift.String?
    /// The identifier of the SQL statement whose results are to be fetched. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
    public var id: Swift.String?
    /// The name or ARN of the secret that enables access to the database.
    public var secretArn: Swift.String?
    /// The session identifier of the query.
    public var sessionId: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This element is not returned when connecting to a provisioned cluster.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        database: Swift.String? = nil,
        dbGroups: [Swift.String]? = nil,
        dbUser: Swift.String? = nil,
        id: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbGroups = dbGroups
        self.dbUser = dbUser
        self.id = id
        self.secretArn = secretArn
        self.sessionId = sessionId
        self.workgroupName = workgroupName
    }
}

extension RedshiftDataClientTypes {
    /// A data value in a column.
    public enum Field {
        /// A value that indicates whether the data is NULL.
        case isnull(Swift.Bool)
        /// A value of the Boolean data type.
        case booleanvalue(Swift.Bool)
        /// A value of the long data type.
        case longvalue(Swift.Int)
        /// A value of the double data type.
        case doublevalue(Swift.Double)
        /// A value of the string data type.
        case stringvalue(Swift.String)
        /// A value of the BLOB data type.
        case blobvalue(Foundation.Data)
        case sdkUnknown(Swift.String)
    }

}

public struct GetStatementResultInput {
    /// The identifier of the SQL statement whose results are to be fetched. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. A suffix indicates then number of the SQL statement. For example, d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the second SQL statement of a batch query. This identifier is returned by BatchExecuteStatment, ExecuteStatment, and ListStatements.
    /// This member is required.
    public var id: Swift.String?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.nextToken = nextToken
    }
}

public struct GetStatementResultOutput {
    /// The properties (metadata) of a column.
    public var columnMetadata: [RedshiftDataClientTypes.ColumnMetadata]?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The results of the SQL statement.
    /// This member is required.
    public var records: [[RedshiftDataClientTypes.Field]]?
    /// The total number of rows in the result set returned from a query. You can use this number to estimate the number of calls to the GetStatementResult operation needed to page through the results.
    public var totalNumRows: Swift.Int

    public init(
        columnMetadata: [RedshiftDataClientTypes.ColumnMetadata]? = nil,
        nextToken: Swift.String? = nil,
        records: [[RedshiftDataClientTypes.Field]]? = nil,
        totalNumRows: Swift.Int = 0
    )
    {
        self.columnMetadata = columnMetadata
        self.nextToken = nextToken
        self.records = records
        self.totalNumRows = totalNumRows
    }
}

public struct ListDatabasesInput {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of databases to return in the response. If more databases exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secretArn = secretArn
        self.workgroupName = workgroupName
    }
}

public struct ListDatabasesOutput {
    /// The names of databases.
    public var databases: [Swift.String]?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?

    public init(
        databases: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

public struct ListSchemasInput {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// A database name. The connected database is specified when you connect with your authentication credentials.
    public var connectedDatabase: Swift.String?
    /// The name of the database that contains the schemas to list. If ConnectedDatabase is not specified, this is also the database to connect to with your authentication credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of schemas to return in the response. If more schemas exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// A pattern to filter results by schema name. Within a schema pattern, "%" means match any substring of 0 or more characters and "_" means match any one character. Only schema name entries matching the search pattern are returned.
    public var schemaPattern: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        connectedDatabase: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        schemaPattern: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaPattern = schemaPattern
        self.secretArn = secretArn
        self.workgroupName = workgroupName
    }
}

public struct ListSchemasOutput {
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The schemas that match the request pattern.
    public var schemas: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

public struct ListStatementsInput {
    /// The maximum number of SQL statements to return in the response. If more SQL statements exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// A value that filters which statements to return in the response. If true, all statements run by the caller's IAM role are returned. If false, only statements run by the caller's IAM role in the current IAM session are returned. The default is true.
    public var roleLevel: Swift.Bool?
    /// The name of the SQL statement specified as input to BatchExecuteStatement or ExecuteStatement to identify the query. You can list multiple statements by providing a prefix that matches the beginning of the statement name. For example, to list myStatement1, myStatement2, myStatement3, and so on, then provide the a value of myStatement. Data API does a case-sensitive match of SQL statement names to the prefix value you provide.
    public var statementName: Swift.String?
    /// The status of the SQL statement to list. Status values are defined as follows:
    ///
    /// * ABORTED - The query run was stopped by the user.
    ///
    /// * ALL - A status value that includes all query statuses. This value can be used to filter results.
    ///
    /// * FAILED - The query run failed.
    ///
    /// * FINISHED - The query has finished running.
    ///
    /// * PICKED - The query has been chosen to be run.
    ///
    /// * STARTED - The query run has started.
    ///
    /// * SUBMITTED - The query was submitted, but not yet processed.
    public var status: RedshiftDataClientTypes.StatusString?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        roleLevel: Swift.Bool? = nil,
        statementName: Swift.String? = nil,
        status: RedshiftDataClientTypes.StatusString? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roleLevel = roleLevel
        self.statementName = statementName
        self.status = status
    }
}

extension RedshiftDataClientTypes {
    /// The SQL statement to run.
    public struct StatementData {
        /// The date and time (UTC) the statement was created.
        public var createdAt: Foundation.Date?
        /// The SQL statement identifier. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
        /// This member is required.
        public var id: Swift.String?
        /// A value that indicates whether the statement is a batch query request.
        public var isBatchStatement: Swift.Bool?
        /// The parameters used in a SQL statement.
        public var queryParameters: [RedshiftDataClientTypes.SqlParameter]?
        /// The SQL statement.
        public var queryString: Swift.String?
        /// One or more SQL statements. Each query string in the array corresponds to one of the queries in a batch query request.
        public var queryStrings: [Swift.String]?
        /// The name or Amazon Resource Name (ARN) of the secret that enables access to the database.
        public var secretArn: Swift.String?
        /// The session identifier of the query.
        public var sessionId: Swift.String?
        /// The name of the SQL statement.
        public var statementName: Swift.String?
        /// The status of the SQL statement. An example is the that the SQL statement finished.
        public var status: RedshiftDataClientTypes.StatusString?
        /// The date and time (UTC) that the statement metadata was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            isBatchStatement: Swift.Bool? = nil,
            queryParameters: [RedshiftDataClientTypes.SqlParameter]? = nil,
            queryString: Swift.String? = nil,
            queryStrings: [Swift.String]? = nil,
            secretArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            statementName: Swift.String? = nil,
            status: RedshiftDataClientTypes.StatusString? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.isBatchStatement = isBatchStatement
            self.queryParameters = queryParameters
            self.queryString = queryString
            self.queryStrings = queryStrings
            self.secretArn = secretArn
            self.sessionId = sessionId
            self.statementName = statementName
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

public struct ListStatementsOutput {
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The SQL statements.
    /// This member is required.
    public var statements: [RedshiftDataClientTypes.StatementData]?

    public init(
        nextToken: Swift.String? = nil,
        statements: [RedshiftDataClientTypes.StatementData]? = nil
    )
    {
        self.nextToken = nextToken
        self.statements = statements
    }
}

public struct ListTablesInput {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// A database name. The connected database is specified when you connect with your authentication credentials.
    public var connectedDatabase: Swift.String?
    /// The name of the database that contains the tables to list. If ConnectedDatabase is not specified, this is also the database to connect to with your authentication credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of tables to return in the response. If more tables exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// A pattern to filter results by schema name. Within a schema pattern, "%" means match any substring of 0 or more characters and "_" means match any one character. Only schema name entries matching the search pattern are returned. If SchemaPattern is not specified, then all tables that match TablePattern are returned. If neither SchemaPattern or TablePattern are specified, then all tables are returned.
    public var schemaPattern: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// A pattern to filter results by table name. Within a table pattern, "%" means match any substring of 0 or more characters and "_" means match any one character. Only table name entries matching the search pattern are returned. If TablePattern is not specified, then all tables that match SchemaPatternare returned. If neither SchemaPattern or TablePattern are specified, then all tables are returned.
    public var tablePattern: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        connectedDatabase: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        schemaPattern: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        tablePattern: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaPattern = schemaPattern
        self.secretArn = secretArn
        self.tablePattern = tablePattern
        self.workgroupName = workgroupName
    }
}

extension RedshiftDataClientTypes {
    /// The properties of a table.
    public struct TableMember {
        /// The name of the table.
        public var name: Swift.String?
        /// The schema containing the table.
        public var schema: Swift.String?
        /// The type of the table. Possible values include TABLE, VIEW, SYSTEM TABLE, GLOBAL TEMPORARY, LOCAL TEMPORARY, ALIAS, and SYNONYM.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            schema: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.schema = schema
            self.type = type
        }
    }

}

public struct ListTablesOutput {
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The tables that match the request pattern.
    public var tables: [RedshiftDataClientTypes.TableMember]?

    public init(
        nextToken: Swift.String? = nil,
        tables: [RedshiftDataClientTypes.TableMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

extension BatchExecuteStatementInput {

    static func urlPathProvider(_ value: BatchExecuteStatementInput) -> Swift.String? {
        return "/"
    }
}

extension CancelStatementInput {

    static func urlPathProvider(_ value: CancelStatementInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStatementInput {

    static func urlPathProvider(_ value: DescribeStatementInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTableInput {

    static func urlPathProvider(_ value: DescribeTableInput) -> Swift.String? {
        return "/"
    }
}

extension ExecuteStatementInput {

    static func urlPathProvider(_ value: ExecuteStatementInput) -> Swift.String? {
        return "/"
    }
}

extension GetStatementResultInput {

    static func urlPathProvider(_ value: GetStatementResultInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatabasesInput {

    static func urlPathProvider(_ value: ListDatabasesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSchemasInput {

    static func urlPathProvider(_ value: ListSchemasInput) -> Swift.String? {
        return "/"
    }
}

extension ListStatementsInput {

    static func urlPathProvider(_ value: ListStatementsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTablesInput {

    static func urlPathProvider(_ value: ListTablesInput) -> Swift.String? {
        return "/"
    }
}

extension BatchExecuteStatementInput {

    static func write(value: BatchExecuteStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["Database"].write(value.database)
        try writer["DbUser"].write(value.dbUser)
        try writer["SecretArn"].write(value.secretArn)
        try writer["SessionId"].write(value.sessionId)
        try writer["SessionKeepAliveSeconds"].write(value.sessionKeepAliveSeconds)
        try writer["Sqls"].writeList(value.sqls, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatementName"].write(value.statementName)
        try writer["WithEvent"].write(value.withEvent)
        try writer["WorkgroupName"].write(value.workgroupName)
    }
}

extension CancelStatementInput {

    static func write(value: CancelStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension DescribeStatementInput {

    static func write(value: DescribeStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension DescribeTableInput {

    static func write(value: DescribeTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["ConnectedDatabase"].write(value.connectedDatabase)
        try writer["Database"].write(value.database)
        try writer["DbUser"].write(value.dbUser)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Schema"].write(value.schema)
        try writer["SecretArn"].write(value.secretArn)
        try writer["Table"].write(value.table)
        try writer["WorkgroupName"].write(value.workgroupName)
    }
}

extension ExecuteStatementInput {

    static func write(value: ExecuteStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["Database"].write(value.database)
        try writer["DbUser"].write(value.dbUser)
        try writer["Parameters"].writeList(value.parameters, memberWritingClosure: RedshiftDataClientTypes.SqlParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecretArn"].write(value.secretArn)
        try writer["SessionId"].write(value.sessionId)
        try writer["SessionKeepAliveSeconds"].write(value.sessionKeepAliveSeconds)
        try writer["Sql"].write(value.sql)
        try writer["StatementName"].write(value.statementName)
        try writer["WithEvent"].write(value.withEvent)
        try writer["WorkgroupName"].write(value.workgroupName)
    }
}

extension GetStatementResultInput {

    static func write(value: GetStatementResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDatabasesInput {

    static func write(value: ListDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["Database"].write(value.database)
        try writer["DbUser"].write(value.dbUser)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SecretArn"].write(value.secretArn)
        try writer["WorkgroupName"].write(value.workgroupName)
    }
}

extension ListSchemasInput {

    static func write(value: ListSchemasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["ConnectedDatabase"].write(value.connectedDatabase)
        try writer["Database"].write(value.database)
        try writer["DbUser"].write(value.dbUser)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SchemaPattern"].write(value.schemaPattern)
        try writer["SecretArn"].write(value.secretArn)
        try writer["WorkgroupName"].write(value.workgroupName)
    }
}

extension ListStatementsInput {

    static func write(value: ListStatementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RoleLevel"].write(value.roleLevel)
        try writer["StatementName"].write(value.statementName)
        try writer["Status"].write(value.status)
    }
}

extension ListTablesInput {

    static func write(value: ListTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["ConnectedDatabase"].write(value.connectedDatabase)
        try writer["Database"].write(value.database)
        try writer["DbUser"].write(value.dbUser)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SchemaPattern"].write(value.schemaPattern)
        try writer["SecretArn"].write(value.secretArn)
        try writer["TablePattern"].write(value.tablePattern)
        try writer["WorkgroupName"].write(value.workgroupName)
    }
}

extension BatchExecuteStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchExecuteStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchExecuteStatementOutput()
        value.clusterIdentifier = try reader["ClusterIdentifier"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.database = try reader["Database"].readIfPresent()
        value.dbGroups = try reader["DbGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dbUser = try reader["DbUser"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.workgroupName = try reader["WorkgroupName"].readIfPresent()
        return value
    }
}

extension CancelStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelStatementOutput()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStatementOutput()
        value.clusterIdentifier = try reader["ClusterIdentifier"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.database = try reader["Database"].readIfPresent()
        value.dbUser = try reader["DbUser"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.error = try reader["Error"].readIfPresent()
        value.hasResultSet = try reader["HasResultSet"].readIfPresent()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.queryParameters = try reader["QueryParameters"].readListIfPresent(memberReadingClosure: RedshiftDataClientTypes.SqlParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.queryString = try reader["QueryString"].readIfPresent()
        value.redshiftPid = try reader["RedshiftPid"].readIfPresent() ?? 0
        value.redshiftQueryId = try reader["RedshiftQueryId"].readIfPresent() ?? 0
        value.resultRows = try reader["ResultRows"].readIfPresent() ?? 0
        value.resultSize = try reader["ResultSize"].readIfPresent() ?? 0
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.subStatements = try reader["SubStatements"].readListIfPresent(memberReadingClosure: RedshiftDataClientTypes.SubStatementData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.workgroupName = try reader["WorkgroupName"].readIfPresent()
        return value
    }
}

extension DescribeTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTableOutput()
        value.columnList = try reader["ColumnList"].readListIfPresent(memberReadingClosure: RedshiftDataClientTypes.ColumnMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        return value
    }
}

extension ExecuteStatementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteStatementOutput()
        value.clusterIdentifier = try reader["ClusterIdentifier"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.database = try reader["Database"].readIfPresent()
        value.dbGroups = try reader["DbGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dbUser = try reader["DbUser"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.workgroupName = try reader["WorkgroupName"].readIfPresent()
        return value
    }
}

extension GetStatementResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStatementResultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStatementResultOutput()
        value.columnMetadata = try reader["ColumnMetadata"].readListIfPresent(memberReadingClosure: RedshiftDataClientTypes.ColumnMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.records = try reader["Records"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: RedshiftDataClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        value.totalNumRows = try reader["TotalNumRows"].readIfPresent() ?? 0
        return value
    }
}

extension ListDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatabasesOutput()
        value.databases = try reader["Databases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemasOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStatementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStatementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStatementsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.statements = try reader["Statements"].readListIfPresent(memberReadingClosure: RedshiftDataClientTypes.StatementData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTablesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tables = try reader["Tables"].readListIfPresent(memberReadingClosure: RedshiftDataClientTypes.TableMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum BatchExecuteStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ActiveSessionsExceededException": return try ActiveSessionsExceededException.makeError(baseError: baseError)
            case "ActiveStatementsExceededException": return try ActiveStatementsExceededException.makeError(baseError: baseError)
            case "BatchExecuteStatementException": return try BatchExecuteStatementException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DatabaseConnectionException": return try DatabaseConnectionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DatabaseConnectionException": return try DatabaseConnectionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "QueryTimeoutException": return try QueryTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteStatementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ActiveSessionsExceededException": return try ActiveSessionsExceededException.makeError(baseError: baseError)
            case "ActiveStatementsExceededException": return try ActiveStatementsExceededException.makeError(baseError: baseError)
            case "ExecuteStatementException": return try ExecuteStatementException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStatementResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DatabaseConnectionException": return try DatabaseConnectionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "QueryTimeoutException": return try QueryTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DatabaseConnectionException": return try DatabaseConnectionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "QueryTimeoutException": return try QueryTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStatementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DatabaseConnectionException": return try DatabaseConnectionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "QueryTimeoutException": return try QueryTimeoutException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ActiveStatementsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ActiveStatementsExceededException {
        let reader = baseError.errorBodyReader
        var value = ActiveStatementsExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ActiveSessionsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ActiveSessionsExceededException {
        let reader = baseError.errorBodyReader
        var value = ActiveSessionsExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BatchExecuteStatementException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BatchExecuteStatementException {
        let reader = baseError.errorBodyReader
        var value = BatchExecuteStatementException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.statementId = try reader["StatementId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DatabaseConnectionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DatabaseConnectionException {
        let reader = baseError.errorBodyReader
        var value = DatabaseConnectionException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryTimeoutException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> QueryTimeoutException {
        let reader = baseError.errorBodyReader
        var value = QueryTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExecuteStatementException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExecuteStatementException {
        let reader = baseError.errorBodyReader
        var value = ExecuteStatementException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.statementId = try reader["StatementId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RedshiftDataClientTypes.SqlParameter {

    static func write(value: RedshiftDataClientTypes.SqlParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftDataClientTypes.SqlParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftDataClientTypes.SqlParameter()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension RedshiftDataClientTypes.SubStatementData {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftDataClientTypes.SubStatementData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftDataClientTypes.SubStatementData()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.error = try reader["Error"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.queryString = try reader["QueryString"].readIfPresent()
        value.resultRows = try reader["ResultRows"].readIfPresent() ?? 0
        value.resultSize = try reader["ResultSize"].readIfPresent() ?? 0
        value.redshiftQueryId = try reader["RedshiftQueryId"].readIfPresent() ?? 0
        value.hasResultSet = try reader["HasResultSet"].readIfPresent()
        return value
    }
}

extension RedshiftDataClientTypes.ColumnMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftDataClientTypes.ColumnMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftDataClientTypes.ColumnMetadata()
        value.isCaseSensitive = try reader["isCaseSensitive"].readIfPresent() ?? false
        value.isCurrency = try reader["isCurrency"].readIfPresent() ?? false
        value.isSigned = try reader["isSigned"].readIfPresent() ?? false
        value.label = try reader["label"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.nullable = try reader["nullable"].readIfPresent() ?? 0
        value.precision = try reader["precision"].readIfPresent() ?? 0
        value.scale = try reader["scale"].readIfPresent() ?? 0
        value.schemaName = try reader["schemaName"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent()
        value.typeName = try reader["typeName"].readIfPresent()
        value.length = try reader["length"].readIfPresent() ?? 0
        value.columnDefault = try reader["columnDefault"].readIfPresent()
        return value
    }
}

extension RedshiftDataClientTypes.Field {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftDataClientTypes.Field {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "isNull":
                return .isnull(try reader["isNull"].read())
            case "booleanValue":
                return .booleanvalue(try reader["booleanValue"].read())
            case "longValue":
                return .longvalue(try reader["longValue"].read())
            case "doubleValue":
                return .doublevalue(try reader["doubleValue"].read())
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "blobValue":
                return .blobvalue(try reader["blobValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RedshiftDataClientTypes.StatementData {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftDataClientTypes.StatementData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftDataClientTypes.StatementData()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.queryString = try reader["QueryString"].readIfPresent()
        value.queryStrings = try reader["QueryStrings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.secretArn = try reader["SecretArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statementName = try reader["StatementName"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.queryParameters = try reader["QueryParameters"].readListIfPresent(memberReadingClosure: RedshiftDataClientTypes.SqlParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isBatchStatement = try reader["IsBatchStatement"].readIfPresent()
        value.sessionId = try reader["SessionId"].readIfPresent()
        return value
    }
}

extension RedshiftDataClientTypes.TableMember {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftDataClientTypes.TableMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftDataClientTypes.TableMember()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

public enum RedshiftDataClientTypes {}
