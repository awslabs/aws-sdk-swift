// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActiveStatementsExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ActiveStatementsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of active statements exceeds the limit.
public struct ActiveStatementsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActiveStatementsExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ActiveStatementsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ActiveStatementsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchExecuteStatementException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchExecuteStatementExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.statementId = output.statementId
        } else {
            self.properties.message = nil
            self.properties.statementId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An SQL statement encountered an environmental error while running.
public struct BatchExecuteStatementException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Statement identifier of the exception.
        /// This member is required.
        public internal(set) var statementId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchExecuteStatementException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.statementId = statementId
    }
}

struct BatchExecuteStatementExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let statementId: Swift.String?
}

extension BatchExecuteStatementExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statementId = "StatementId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension BatchExecuteStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case secretArn = "SecretArn"
        case sqls = "Sqls"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
        case workgroupName = "WorkgroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sqls = sqls {
            var sqlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sqls)
            for statementstring0 in sqls {
                try sqlsContainer.encode(statementstring0)
            }
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let withEvent = self.withEvent {
            try encodeContainer.encode(withEvent, forKey: .withEvent)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension BatchExecuteStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchExecuteStatementInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// One or more SQL statements to run. The SQL statements are run as a single transaction. They run serially in the order of the array. Subsequent SQL statements don't start until the previous statement in the array completes. If any SQL statement fails, then because they are run as one transaction, all work is rolled back.
    /// This member is required.
    public var sqls: [Swift.String]?
    /// The name of the SQL statements. You can name the SQL statements when you create them to identify the query.
    public var statementName: Swift.String?
    /// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statements run.
    public var withEvent: Swift.Bool?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sqls: [Swift.String]? = nil,
        statementName: Swift.String? = nil,
        withEvent: Swift.Bool? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.secretArn = secretArn
        self.sqls = sqls
        self.statementName = statementName
        self.withEvent = withEvent
        self.workgroupName = workgroupName
    }
}

struct BatchExecuteStatementInputBody: Swift.Equatable {
    let sqls: [Swift.String]?
    let clusterIdentifier: Swift.String?
    let secretArn: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let withEvent: Swift.Bool?
    let statementName: Swift.String?
    let workgroupName: Swift.String?
    let clientToken: Swift.String?
}

extension BatchExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case secretArn = "SecretArn"
        case sqls = "Sqls"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sqls)
        var sqlsDecoded0:[Swift.String]? = nil
        if let sqlsContainer = sqlsContainer {
            sqlsDecoded0 = [Swift.String]()
            for string0 in sqlsContainer {
                if let string0 = string0 {
                    sqlsDecoded0?.append(string0)
                }
            }
        }
        sqls = sqlsDecoded0
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let withEventDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withEvent)
        withEvent = withEventDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchExecuteStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchExecuteStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterIdentifier = output.clusterIdentifier
            self.createdAt = output.createdAt
            self.database = output.database
            self.dbUser = output.dbUser
            self.id = output.id
            self.secretArn = output.secretArn
            self.workgroupName = output.workgroupName
        } else {
            self.clusterIdentifier = nil
            self.createdAt = nil
            self.database = nil
            self.dbUser = nil
            self.id = nil
            self.secretArn = nil
            self.workgroupName = nil
        }
    }
}

public struct BatchExecuteStatementOutput: Swift.Equatable {
    /// The cluster identifier. This element is not returned when connecting to a serverless workgroup.
    public var clusterIdentifier: Swift.String?
    /// The date and time (UTC) the statement was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the database.
    public var database: Swift.String?
    /// The database user name.
    public var dbUser: Swift.String?
    /// The identifier of the SQL statement whose results are to be fetched. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. This identifier is returned by BatchExecuteStatment.
    public var id: Swift.String?
    /// The name or ARN of the secret that enables access to the database.
    public var secretArn: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This element is not returned when connecting to a provisioned cluster.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        id: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbUser = dbUser
        self.id = id
        self.secretArn = secretArn
        self.workgroupName = workgroupName
    }
}

struct BatchExecuteStatementOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let clusterIdentifier: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let secretArn: Swift.String?
    let workgroupName: Swift.String?
}

extension BatchExecuteStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case createdAt = "CreatedAt"
        case database = "Database"
        case dbUser = "DbUser"
        case id = "Id"
        case secretArn = "SecretArn"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

enum BatchExecuteStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ActiveStatementsExceededException": return try await ActiveStatementsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BatchExecuteStatementException": return try await BatchExecuteStatementException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension CancelStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelStatementInput: Swift.Equatable {
    /// The identifier of the SQL statement to cancel. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. This identifier is returned by BatchExecuteStatment, ExecuteStatment, and ListStatements.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CancelStatementInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension CancelStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CancelStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CancelStatementOutput: Swift.Equatable {
    /// A value that indicates whether the cancel statement succeeded (true).
    public var status: Swift.Bool?

    public init(
        status: Swift.Bool? = nil
    )
    {
        self.status = status
    }
}

struct CancelStatementOutputBody: Swift.Equatable {
    let status: Swift.Bool?
}

extension CancelStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .status)
        status = statusDecoded
    }
}

enum CancelStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DatabaseConnectionException": return try await DatabaseConnectionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftDataClientTypes.ColumnMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDefault
        case isCaseSensitive
        case isCurrency
        case isSigned
        case label
        case length
        case name
        case nullable
        case precision
        case scale
        case schemaName
        case tableName
        case typeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDefault = self.columnDefault {
            try encodeContainer.encode(columnDefault, forKey: .columnDefault)
        }
        if isCaseSensitive != false {
            try encodeContainer.encode(isCaseSensitive, forKey: .isCaseSensitive)
        }
        if isCurrency != false {
            try encodeContainer.encode(isCurrency, forKey: .isCurrency)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if nullable != 0 {
            try encodeContainer.encode(nullable, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let typeName = self.typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCaseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCaseSensitive) ?? false
        isCaseSensitive = isCaseSensitiveDecoded
        let isCurrencyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCurrency) ?? false
        isCurrency = isCurrencyDecoded
        let isSignedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSigned) ?? false
        isSigned = isSignedDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nullableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nullable) ?? 0
        nullable = nullableDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .precision) ?? 0
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scale) ?? 0
        scale = scaleDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length) ?? 0
        length = lengthDecoded
        let columnDefaultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnDefault)
        columnDefault = columnDefaultDecoded
    }
}

extension RedshiftDataClientTypes {
    /// The properties (metadata) of a column.
    public struct ColumnMetadata: Swift.Equatable {
        /// The default value of the column.
        public var columnDefault: Swift.String?
        /// A value that indicates whether the column is case-sensitive.
        public var isCaseSensitive: Swift.Bool
        /// A value that indicates whether the column contains currency values.
        public var isCurrency: Swift.Bool
        /// A value that indicates whether an integer column is signed.
        public var isSigned: Swift.Bool
        /// The label for the column.
        public var label: Swift.String?
        /// The length of the column.
        public var length: Swift.Int
        /// The name of the column.
        public var name: Swift.String?
        /// A value that indicates whether the column is nullable.
        public var nullable: Swift.Int
        /// The precision value of a decimal number column.
        public var precision: Swift.Int
        /// The scale value of a decimal number column.
        public var scale: Swift.Int
        /// The name of the schema that contains the table that includes the column.
        public var schemaName: Swift.String?
        /// The name of the table that includes the column.
        public var tableName: Swift.String?
        /// The database-specific data type of the column.
        public var typeName: Swift.String?

        public init(
            columnDefault: Swift.String? = nil,
            isCaseSensitive: Swift.Bool = false,
            isCurrency: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            label: Swift.String? = nil,
            length: Swift.Int = 0,
            name: Swift.String? = nil,
            nullable: Swift.Int = 0,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.columnDefault = columnDefault
            self.isCaseSensitive = isCaseSensitive
            self.isCurrency = isCurrency
            self.isSigned = isSigned
            self.label = label
            self.length = length
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.typeName = typeName
        }
    }

}

extension DatabaseConnectionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DatabaseConnectionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Connection to a database failed.
public struct DatabaseConnectionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DatabaseConnectionException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DatabaseConnectionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DatabaseConnectionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribeStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStatementInput: Swift.Equatable {
    /// The identifier of the SQL statement to describe. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. A suffix indicates the number of the SQL statement. For example, d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the second SQL statement of a batch query. This identifier is returned by BatchExecuteStatment, ExecuteStatement, and ListStatements.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeStatementInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DescribeStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterIdentifier = output.clusterIdentifier
            self.createdAt = output.createdAt
            self.database = output.database
            self.dbUser = output.dbUser
            self.duration = output.duration
            self.error = output.error
            self.hasResultSet = output.hasResultSet
            self.id = output.id
            self.queryParameters = output.queryParameters
            self.queryString = output.queryString
            self.redshiftPid = output.redshiftPid
            self.redshiftQueryId = output.redshiftQueryId
            self.resultRows = output.resultRows
            self.resultSize = output.resultSize
            self.secretArn = output.secretArn
            self.status = output.status
            self.subStatements = output.subStatements
            self.updatedAt = output.updatedAt
            self.workgroupName = output.workgroupName
        } else {
            self.clusterIdentifier = nil
            self.createdAt = nil
            self.database = nil
            self.dbUser = nil
            self.duration = 0
            self.error = nil
            self.hasResultSet = nil
            self.id = nil
            self.queryParameters = nil
            self.queryString = nil
            self.redshiftPid = 0
            self.redshiftQueryId = 0
            self.resultRows = 0
            self.resultSize = 0
            self.secretArn = nil
            self.status = nil
            self.subStatements = nil
            self.updatedAt = nil
            self.workgroupName = nil
        }
    }
}

public struct DescribeStatementOutput: Swift.Equatable {
    /// The cluster identifier.
    public var clusterIdentifier: Swift.String?
    /// The date and time (UTC) when the SQL statement was submitted to run.
    public var createdAt: ClientRuntime.Date?
    /// The name of the database.
    public var database: Swift.String?
    /// The database user name.
    public var dbUser: Swift.String?
    /// The amount of time in nanoseconds that the statement ran.
    public var duration: Swift.Int
    /// The error message from the cluster if the SQL statement encountered an error while running.
    public var error: Swift.String?
    /// A value that indicates whether the statement has a result set. The result set can be empty. The value is true for an empty result set. The value is true if any substatement returns a result set.
    public var hasResultSet: Swift.Bool?
    /// The identifier of the SQL statement described. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
    /// This member is required.
    public var id: Swift.String?
    /// The parameters for the SQL statement.
    public var queryParameters: [RedshiftDataClientTypes.SqlParameter]?
    /// The SQL statement text.
    public var queryString: Swift.String?
    /// The process identifier from Amazon Redshift.
    public var redshiftPid: Swift.Int
    /// The identifier of the query generated by Amazon Redshift. These identifiers are also available in the query column of the STL_QUERY system view.
    public var redshiftQueryId: Swift.Int
    /// Either the number of rows returned from the SQL statement or the number of rows affected. If result size is greater than zero, the result rows can be the number of rows affected by SQL statements such as INSERT, UPDATE, DELETE, COPY, and others. A -1 indicates the value is null.
    public var resultRows: Swift.Int
    /// The size in bytes of the returned results. A -1 indicates the value is null.
    public var resultSize: Swift.Int
    /// The name or Amazon Resource Name (ARN) of the secret that enables access to the database.
    public var secretArn: Swift.String?
    /// The status of the SQL statement being described. Status values are defined as follows:
    ///
    /// * ABORTED - The query run was stopped by the user.
    ///
    /// * ALL - A status value that includes all query statuses. This value can be used to filter results.
    ///
    /// * FAILED - The query run failed.
    ///
    /// * FINISHED - The query has finished running.
    ///
    /// * PICKED - The query has been chosen to be run.
    ///
    /// * STARTED - The query run has started.
    ///
    /// * SUBMITTED - The query was submitted, but not yet processed.
    public var status: RedshiftDataClientTypes.StatusString?
    /// The SQL statements from a multiple statement run.
    public var subStatements: [RedshiftDataClientTypes.SubStatementData]?
    /// The date and time (UTC) that the metadata for the SQL statement was last updated. An example is the time the status last changed.
    public var updatedAt: ClientRuntime.Date?
    /// The serverless workgroup name or Amazon Resource Name (ARN).
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        duration: Swift.Int = 0,
        error: Swift.String? = nil,
        hasResultSet: Swift.Bool? = nil,
        id: Swift.String? = nil,
        queryParameters: [RedshiftDataClientTypes.SqlParameter]? = nil,
        queryString: Swift.String? = nil,
        redshiftPid: Swift.Int = 0,
        redshiftQueryId: Swift.Int = 0,
        resultRows: Swift.Int = 0,
        resultSize: Swift.Int = 0,
        secretArn: Swift.String? = nil,
        status: RedshiftDataClientTypes.StatusString? = nil,
        subStatements: [RedshiftDataClientTypes.SubStatementData]? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbUser = dbUser
        self.duration = duration
        self.error = error
        self.hasResultSet = hasResultSet
        self.id = id
        self.queryParameters = queryParameters
        self.queryString = queryString
        self.redshiftPid = redshiftPid
        self.redshiftQueryId = redshiftQueryId
        self.resultRows = resultRows
        self.resultSize = resultSize
        self.secretArn = secretArn
        self.status = status
        self.subStatements = subStatements
        self.updatedAt = updatedAt
        self.workgroupName = workgroupName
    }
}

struct DescribeStatementOutputBody: Swift.Equatable {
    let id: Swift.String?
    let secretArn: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let clusterIdentifier: Swift.String?
    let duration: Swift.Int
    let error: Swift.String?
    let status: RedshiftDataClientTypes.StatusString?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let redshiftPid: Swift.Int
    let hasResultSet: Swift.Bool?
    let queryString: Swift.String?
    let resultRows: Swift.Int
    let resultSize: Swift.Int
    let redshiftQueryId: Swift.Int
    let queryParameters: [RedshiftDataClientTypes.SqlParameter]?
    let subStatements: [RedshiftDataClientTypes.SubStatementData]?
    let workgroupName: Swift.String?
}

extension DescribeStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case createdAt = "CreatedAt"
        case database = "Database"
        case dbUser = "DbUser"
        case duration = "Duration"
        case error = "Error"
        case hasResultSet = "HasResultSet"
        case id = "Id"
        case queryParameters = "QueryParameters"
        case queryString = "QueryString"
        case redshiftPid = "RedshiftPid"
        case redshiftQueryId = "RedshiftQueryId"
        case resultRows = "ResultRows"
        case resultSize = "ResultSize"
        case secretArn = "SecretArn"
        case status = "Status"
        case subStatements = "SubStatements"
        case updatedAt = "UpdatedAt"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftDataClientTypes.StatusString.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let redshiftPidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .redshiftPid) ?? 0
        redshiftPid = redshiftPidDecoded
        let hasResultSetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasResultSet)
        hasResultSet = hasResultSetDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let resultRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resultRows) ?? 0
        resultRows = resultRowsDecoded
        let resultSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resultSize) ?? 0
        resultSize = resultSizeDecoded
        let redshiftQueryIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .redshiftQueryId) ?? 0
        redshiftQueryId = redshiftQueryIdDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.SqlParameter?].self, forKey: .queryParameters)
        var queryParametersDecoded0:[RedshiftDataClientTypes.SqlParameter]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [RedshiftDataClientTypes.SqlParameter]()
            for structure0 in queryParametersContainer {
                if let structure0 = structure0 {
                    queryParametersDecoded0?.append(structure0)
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let subStatementsContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.SubStatementData?].self, forKey: .subStatements)
        var subStatementsDecoded0:[RedshiftDataClientTypes.SubStatementData]? = nil
        if let subStatementsContainer = subStatementsContainer {
            subStatementsDecoded0 = [RedshiftDataClientTypes.SubStatementData]()
            for structure0 in subStatementsContainer {
                if let structure0 = structure0 {
                    subStatementsDecoded0?.append(structure0)
                }
            }
        }
        subStatements = subStatementsDecoded0
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

enum DescribeStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schema = "Schema"
        case secretArn = "SecretArn"
        case table = "Table"
        case workgroupName = "WorkgroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let connectedDatabase = self.connectedDatabase {
            try encodeContainer.encode(connectedDatabase, forKey: .connectedDatabase)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension DescribeTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTableInput: Swift.Equatable {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// A database name. The connected database is specified when you connect with your authentication credentials.
    public var connectedDatabase: Swift.String?
    /// The name of the database that contains the tables to be described. If ConnectedDatabase is not specified, this is also the database to connect to with your authentication credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of tables to return in the response. If more tables exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The schema that contains the table. If no schema is specified, then matching tables for all schemas are returned.
    public var schema: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The table name. If no table is specified, then all tables for all matching schemas are returned. If no table and no schema is specified, then all tables for all schemas in the database are returned
    public var table: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        connectedDatabase: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        table: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schema = schema
        self.secretArn = secretArn
        self.table = table
        self.workgroupName = workgroupName
    }
}

struct DescribeTableInputBody: Swift.Equatable {
    let clusterIdentifier: Swift.String?
    let secretArn: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let connectedDatabase: Swift.String?
    let schema: Swift.String?
    let table: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let workgroupName: Swift.String?
}

extension DescribeTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schema = "Schema"
        case secretArn = "SecretArn"
        case table = "Table"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let connectedDatabaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDatabase)
        connectedDatabase = connectedDatabaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let tableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .table)
        table = tableDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension DescribeTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.columnList = output.columnList
            self.nextToken = output.nextToken
            self.tableName = output.tableName
        } else {
            self.columnList = nil
            self.nextToken = nil
            self.tableName = nil
        }
    }
}

public struct DescribeTableOutput: Swift.Equatable {
    /// A list of columns in the table.
    public var columnList: [RedshiftDataClientTypes.ColumnMetadata]?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The table name.
    public var tableName: Swift.String?

    public init(
        columnList: [RedshiftDataClientTypes.ColumnMetadata]? = nil,
        nextToken: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.columnList = columnList
        self.nextToken = nextToken
        self.tableName = tableName
    }
}

struct DescribeTableOutputBody: Swift.Equatable {
    let tableName: Swift.String?
    let columnList: [RedshiftDataClientTypes.ColumnMetadata]?
    let nextToken: Swift.String?
}

extension DescribeTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnList = "ColumnList"
        case nextToken = "NextToken"
        case tableName = "TableName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let columnListContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.ColumnMetadata?].self, forKey: .columnList)
        var columnListDecoded0:[RedshiftDataClientTypes.ColumnMetadata]? = nil
        if let columnListContainer = columnListContainer {
            columnListDecoded0 = [RedshiftDataClientTypes.ColumnMetadata]()
            for structure0 in columnListContainer {
                if let structure0 = structure0 {
                    columnListDecoded0?.append(structure0)
                }
            }
        }
        columnList = columnListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DatabaseConnectionException": return try await DatabaseConnectionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteStatementException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteStatementExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.statementId = output.statementId
        } else {
            self.properties.message = nil
            self.properties.statementId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The SQL statement encountered an environmental error while running.
public struct ExecuteStatementException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Statement identifier of the exception.
        /// This member is required.
        public internal(set) var statementId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExecuteStatementException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.statementId = statementId
    }
}

struct ExecuteStatementExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let statementId: Swift.String?
}

extension ExecuteStatementExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statementId = "StatementId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension ExecuteStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case parameters = "Parameters"
        case secretArn = "SecretArn"
        case sql = "Sql"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
        case workgroupName = "WorkgroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for sqlparameter0 in parameters {
                try parametersContainer.encode(sqlparameter0)
            }
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = self.sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let withEvent = self.withEvent {
            try encodeContainer.encode(withEvent, forKey: .withEvent)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ExecuteStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExecuteStatementInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The parameters for the SQL statement.
    public var parameters: [RedshiftDataClientTypes.SqlParameter]?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The SQL statement text to run.
    /// This member is required.
    public var sql: Swift.String?
    /// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
    public var statementName: Swift.String?
    /// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
    public var withEvent: Swift.Bool?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterIdentifier: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        parameters: [RedshiftDataClientTypes.SqlParameter]? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        statementName: Swift.String? = nil,
        withEvent: Swift.Bool? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.parameters = parameters
        self.secretArn = secretArn
        self.sql = sql
        self.statementName = statementName
        self.withEvent = withEvent
        self.workgroupName = workgroupName
    }
}

struct ExecuteStatementInputBody: Swift.Equatable {
    let sql: Swift.String?
    let clusterIdentifier: Swift.String?
    let secretArn: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let withEvent: Swift.Bool?
    let statementName: Swift.String?
    let parameters: [RedshiftDataClientTypes.SqlParameter]?
    let workgroupName: Swift.String?
    let clientToken: Swift.String?
}

extension ExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case parameters = "Parameters"
        case secretArn = "SecretArn"
        case sql = "Sql"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let withEventDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withEvent)
        withEvent = withEventDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let parametersContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.SqlParameter?].self, forKey: .parameters)
        var parametersDecoded0:[RedshiftDataClientTypes.SqlParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [RedshiftDataClientTypes.SqlParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ExecuteStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterIdentifier = output.clusterIdentifier
            self.createdAt = output.createdAt
            self.database = output.database
            self.dbUser = output.dbUser
            self.id = output.id
            self.secretArn = output.secretArn
            self.workgroupName = output.workgroupName
        } else {
            self.clusterIdentifier = nil
            self.createdAt = nil
            self.database = nil
            self.dbUser = nil
            self.id = nil
            self.secretArn = nil
            self.workgroupName = nil
        }
    }
}

public struct ExecuteStatementOutput: Swift.Equatable {
    /// The cluster identifier. This element is not returned when connecting to a serverless workgroup.
    public var clusterIdentifier: Swift.String?
    /// The date and time (UTC) the statement was created.
    public var createdAt: ClientRuntime.Date?
    /// The name of the database.
    public var database: Swift.String?
    /// The database user name.
    public var dbUser: Swift.String?
    /// The identifier of the SQL statement whose results are to be fetched. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
    public var id: Swift.String?
    /// The name or ARN of the secret that enables access to the database.
    public var secretArn: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This element is not returned when connecting to a provisioned cluster.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        id: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.createdAt = createdAt
        self.database = database
        self.dbUser = dbUser
        self.id = id
        self.secretArn = secretArn
        self.workgroupName = workgroupName
    }
}

struct ExecuteStatementOutputBody: Swift.Equatable {
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let clusterIdentifier: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let secretArn: Swift.String?
    let workgroupName: Swift.String?
}

extension ExecuteStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case createdAt = "CreatedAt"
        case database = "Database"
        case dbUser = "DbUser"
        case id = "Id"
        case secretArn = "SecretArn"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

enum ExecuteStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ActiveStatementsExceededException": return try await ActiveStatementsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExecuteStatementException": return try await ExecuteStatementException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedshiftDataClientTypes.Field: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blobvalue = "blobValue"
        case booleanvalue = "booleanValue"
        case doublevalue = "doubleValue"
        case isnull = "isNull"
        case longvalue = "longValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .blobvalue(blobvalue):
                try container.encode(blobvalue.base64EncodedString(), forKey: .blobvalue)
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .isnull(isnull):
                try container.encode(isnull, forKey: .isnull)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isnullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isnull)
        if let isnull = isnullDecoded {
            self = .isnull(isnull)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let blobvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blobvalue)
        if let blobvalue = blobvalueDecoded {
            self = .blobvalue(blobvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RedshiftDataClientTypes {
    /// A data value in a column.
    public enum Field: Swift.Equatable {
        /// A value that indicates whether the data is NULL.
        case isnull(Swift.Bool)
        /// A value of the Boolean data type.
        case booleanvalue(Swift.Bool)
        /// A value of the long data type.
        case longvalue(Swift.Int)
        /// A value of the double data type.
        case doublevalue(Swift.Double)
        /// A value of the string data type.
        case stringvalue(Swift.String)
        /// A value of the BLOB data type.
        case blobvalue(ClientRuntime.Data)
        case sdkUnknown(Swift.String)
    }

}

extension GetStatementResultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetStatementResultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetStatementResultInput: Swift.Equatable {
    /// The identifier of the SQL statement whose results are to be fetched. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. A suffix indicates then number of the SQL statement. For example, d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the second SQL statement of a batch query. This identifier is returned by BatchExecuteStatment, ExecuteStatment, and ListStatements.
    /// This member is required.
    public var id: Swift.String?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?

    public init(
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.nextToken = nextToken
    }
}

struct GetStatementResultInputBody: Swift.Equatable {
    let id: Swift.String?
    let nextToken: Swift.String?
}

extension GetStatementResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetStatementResultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStatementResultOutputBody = try responseDecoder.decode(responseBody: data)
            self.columnMetadata = output.columnMetadata
            self.nextToken = output.nextToken
            self.records = output.records
            self.totalNumRows = output.totalNumRows
        } else {
            self.columnMetadata = nil
            self.nextToken = nil
            self.records = nil
            self.totalNumRows = 0
        }
    }
}

public struct GetStatementResultOutput: Swift.Equatable {
    /// The properties (metadata) of a column.
    public var columnMetadata: [RedshiftDataClientTypes.ColumnMetadata]?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The results of the SQL statement.
    /// This member is required.
    public var records: [[RedshiftDataClientTypes.Field]]?
    /// The total number of rows in the result set returned from a query. You can use this number to estimate the number of calls to the GetStatementResult operation needed to page through the results.
    public var totalNumRows: Swift.Int

    public init(
        columnMetadata: [RedshiftDataClientTypes.ColumnMetadata]? = nil,
        nextToken: Swift.String? = nil,
        records: [[RedshiftDataClientTypes.Field]]? = nil,
        totalNumRows: Swift.Int = 0
    )
    {
        self.columnMetadata = columnMetadata
        self.nextToken = nextToken
        self.records = records
        self.totalNumRows = totalNumRows
    }
}

struct GetStatementResultOutputBody: Swift.Equatable {
    let records: [[RedshiftDataClientTypes.Field]]?
    let columnMetadata: [RedshiftDataClientTypes.ColumnMetadata]?
    let totalNumRows: Swift.Int
    let nextToken: Swift.String?
}

extension GetStatementResultOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnMetadata = "ColumnMetadata"
        case nextToken = "NextToken"
        case records = "Records"
        case totalNumRows = "TotalNumRows"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([[RedshiftDataClientTypes.Field?]?].self, forKey: .records)
        var recordsDecoded0:[[RedshiftDataClientTypes.Field]]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [[RedshiftDataClientTypes.Field]]()
            for list0 in recordsContainer {
                var list0Decoded0: [RedshiftDataClientTypes.Field]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [RedshiftDataClientTypes.Field]()
                    for union1 in list0 {
                        if let union1 = union1 {
                            list0Decoded0?.append(union1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    recordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        records = recordsDecoded0
        let columnMetadataContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[RedshiftDataClientTypes.ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [RedshiftDataClientTypes.ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
        let totalNumRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumRows) ?? 0
        totalNumRows = totalNumRowsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetStatementResultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Redshift Data API operation failed due to invalid input.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretArn = "SecretArn"
        case workgroupName = "WorkgroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ListDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatabasesInput: Swift.Equatable {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of databases to return in the response. If more databases exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secretArn = secretArn
        self.workgroupName = workgroupName
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    let clusterIdentifier: Swift.String?
    let database: Swift.String?
    let secretArn: Swift.String?
    let dbUser: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let workgroupName: Swift.String?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case secretArn = "SecretArn"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension ListDatabasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatabasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutput: Swift.Equatable {
    /// The names of databases.
    public var databases: [Swift.String]?
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?

    public init(
        databases: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputBody: Swift.Equatable {
    let databases: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListDatabasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .databases)
        var databasesDecoded0:[Swift.String]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [Swift.String]()
            for string0 in databasesContainer {
                if let string0 = string0 {
                    databasesDecoded0?.append(string0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatabasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DatabaseConnectionException": return try await DatabaseConnectionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
        case workgroupName = "WorkgroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let connectedDatabase = self.connectedDatabase {
            try encodeContainer.encode(connectedDatabase, forKey: .connectedDatabase)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaPattern = self.schemaPattern {
            try encodeContainer.encode(schemaPattern, forKey: .schemaPattern)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ListSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSchemasInput: Swift.Equatable {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// A database name. The connected database is specified when you connect with your authentication credentials.
    public var connectedDatabase: Swift.String?
    /// The name of the database that contains the schemas to list. If ConnectedDatabase is not specified, this is also the database to connect to with your authentication credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of schemas to return in the response. If more schemas exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// A pattern to filter results by schema name. Within a schema pattern, "%" means match any substring of 0 or more characters and "_" means match any one character. Only schema name entries matching the search pattern are returned.
    public var schemaPattern: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        connectedDatabase: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        schemaPattern: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaPattern = schemaPattern
        self.secretArn = secretArn
        self.workgroupName = workgroupName
    }
}

struct ListSchemasInputBody: Swift.Equatable {
    let clusterIdentifier: Swift.String?
    let secretArn: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let connectedDatabase: Swift.String?
    let schemaPattern: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let workgroupName: Swift.String?
}

extension ListSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let connectedDatabaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDatabase)
        connectedDatabase = connectedDatabaseDecoded
        let schemaPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaPattern)
        schemaPattern = schemaPatternDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension ListSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutput: Swift.Equatable {
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The schemas that match the request pattern.
    public var schemas: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputBody: Swift.Equatable {
    let schemas: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemas)
        var schemasDecoded0:[Swift.String]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [Swift.String]()
            for string0 in schemasContainer {
                if let string0 = string0 {
                    schemasDecoded0?.append(string0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DatabaseConnectionException": return try await DatabaseConnectionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStatementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roleLevel = "RoleLevel"
        case statementName = "StatementName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let roleLevel = self.roleLevel {
            try encodeContainer.encode(roleLevel, forKey: .roleLevel)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension ListStatementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListStatementsInput: Swift.Equatable {
    /// The maximum number of SQL statements to return in the response. If more SQL statements exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// A value that filters which statements to return in the response. If true, all statements run by the caller's IAM role are returned. If false, only statements run by the caller's IAM role in the current IAM session are returned. The default is true.
    public var roleLevel: Swift.Bool?
    /// The name of the SQL statement specified as input to BatchExecuteStatement or ExecuteStatement to identify the query. You can list multiple statements by providing a prefix that matches the beginning of the statement name. For example, to list myStatement1, myStatement2, myStatement3, and so on, then provide the a value of myStatement. Data API does a case-sensitive match of SQL statement names to the prefix value you provide.
    public var statementName: Swift.String?
    /// The status of the SQL statement to list. Status values are defined as follows:
    ///
    /// * ABORTED - The query run was stopped by the user.
    ///
    /// * ALL - A status value that includes all query statuses. This value can be used to filter results.
    ///
    /// * FAILED - The query run failed.
    ///
    /// * FINISHED - The query has finished running.
    ///
    /// * PICKED - The query has been chosen to be run.
    ///
    /// * STARTED - The query run has started.
    ///
    /// * SUBMITTED - The query was submitted, but not yet processed.
    public var status: RedshiftDataClientTypes.StatusString?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        roleLevel: Swift.Bool? = nil,
        statementName: Swift.String? = nil,
        status: RedshiftDataClientTypes.StatusString? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roleLevel = roleLevel
        self.statementName = statementName
        self.status = status
    }
}

struct ListStatementsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let statementName: Swift.String?
    let status: RedshiftDataClientTypes.StatusString?
    let roleLevel: Swift.Bool?
}

extension ListStatementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roleLevel = "RoleLevel"
        case statementName = "StatementName"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftDataClientTypes.StatusString.self, forKey: .status)
        status = statusDecoded
        let roleLevelDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roleLevel)
        roleLevel = roleLevelDecoded
    }
}

extension ListStatementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStatementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.statements = output.statements
        } else {
            self.nextToken = nil
            self.statements = nil
        }
    }
}

public struct ListStatementsOutput: Swift.Equatable {
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The SQL statements.
    /// This member is required.
    public var statements: [RedshiftDataClientTypes.StatementData]?

    public init(
        nextToken: Swift.String? = nil,
        statements: [RedshiftDataClientTypes.StatementData]? = nil
    )
    {
        self.nextToken = nextToken
        self.statements = statements
    }
}

struct ListStatementsOutputBody: Swift.Equatable {
    let statements: [RedshiftDataClientTypes.StatementData]?
    let nextToken: Swift.String?
}

extension ListStatementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case statements = "Statements"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.StatementData?].self, forKey: .statements)
        var statementsDecoded0:[RedshiftDataClientTypes.StatementData]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [RedshiftDataClientTypes.StatementData]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStatementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
        case tablePattern = "TablePattern"
        case workgroupName = "WorkgroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let connectedDatabase = self.connectedDatabase {
            try encodeContainer.encode(connectedDatabase, forKey: .connectedDatabase)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaPattern = self.schemaPattern {
            try encodeContainer.encode(schemaPattern, forKey: .schemaPattern)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let tablePattern = self.tablePattern {
            try encodeContainer.encode(tablePattern, forKey: .tablePattern)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }
}

extension ListTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTablesInput: Swift.Equatable {
    /// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
    public var clusterIdentifier: Swift.String?
    /// A database name. The connected database is specified when you connect with your authentication credentials.
    public var connectedDatabase: Swift.String?
    /// The name of the database that contains the tables to list. If ConnectedDatabase is not specified, this is also the database to connect to with your authentication credentials.
    /// This member is required.
    public var database: Swift.String?
    /// The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.
    public var dbUser: Swift.String?
    /// The maximum number of tables to return in the response. If more tables exist than fit in one response, then NextToken is returned to page through the results.
    public var maxResults: Swift.Int
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// A pattern to filter results by schema name. Within a schema pattern, "%" means match any substring of 0 or more characters and "_" means match any one character. Only schema name entries matching the search pattern are returned. If SchemaPattern is not specified, then all tables that match TablePattern are returned. If neither SchemaPattern or TablePattern are specified, then all tables are returned.
    public var schemaPattern: Swift.String?
    /// The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.
    public var secretArn: Swift.String?
    /// A pattern to filter results by table name. Within a table pattern, "%" means match any substring of 0 or more characters and "_" means match any one character. Only table name entries matching the search pattern are returned. If TablePattern is not specified, then all tables that match SchemaPatternare returned. If neither SchemaPattern or TablePattern are specified, then all tables are returned.
    public var tablePattern: Swift.String?
    /// The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
    public var workgroupName: Swift.String?

    public init(
        clusterIdentifier: Swift.String? = nil,
        connectedDatabase: Swift.String? = nil,
        database: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        schemaPattern: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        tablePattern: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.clusterIdentifier = clusterIdentifier
        self.connectedDatabase = connectedDatabase
        self.database = database
        self.dbUser = dbUser
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaPattern = schemaPattern
        self.secretArn = secretArn
        self.tablePattern = tablePattern
        self.workgroupName = workgroupName
    }
}

struct ListTablesInputBody: Swift.Equatable {
    let clusterIdentifier: Swift.String?
    let secretArn: Swift.String?
    let dbUser: Swift.String?
    let database: Swift.String?
    let connectedDatabase: Swift.String?
    let schemaPattern: Swift.String?
    let tablePattern: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let workgroupName: Swift.String?
}

extension ListTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case connectedDatabase = "ConnectedDatabase"
        case database = "Database"
        case dbUser = "DbUser"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaPattern = "SchemaPattern"
        case secretArn = "SecretArn"
        case tablePattern = "TablePattern"
        case workgroupName = "WorkgroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let connectedDatabaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectedDatabase)
        connectedDatabase = connectedDatabaseDecoded
        let schemaPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaPattern)
        schemaPattern = schemaPatternDecoded
        let tablePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tablePattern)
        tablePattern = tablePatternDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
    }
}

extension ListTablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutput: Swift.Equatable {
    /// A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned NextToken value in the next NextToken parameter and retrying the command. If the NextToken field is empty, all response records have been retrieved for the request.
    public var nextToken: Swift.String?
    /// The tables that match the request pattern.
    public var tables: [RedshiftDataClientTypes.TableMember]?

    public init(
        nextToken: Swift.String? = nil,
        tables: [RedshiftDataClientTypes.TableMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputBody: Swift.Equatable {
    let tables: [RedshiftDataClientTypes.TableMember]?
    let nextToken: Swift.String?
}

extension ListTablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tables = "Tables"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.TableMember?].self, forKey: .tables)
        var tablesDecoded0:[RedshiftDataClientTypes.TableMember]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [RedshiftDataClientTypes.TableMember]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DatabaseConnectionException": return try await DatabaseConnectionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Redshift Data API operation failed due to a missing resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Resource identifier associated with the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension RedshiftDataClientTypes.SqlParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RedshiftDataClientTypes {
    /// A parameter used in a SQL statement.
    public struct SqlParameter: Swift.Equatable {
        /// The name of the parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the parameter. Amazon Redshift implicitly converts to the proper data type. For more information, see [Data types](https://docs.aws.amazon.com/redshift/latest/dg/c_Supported_data_types.html) in the Amazon Redshift Database Developer Guide.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension RedshiftDataClientTypes.StatementData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case id = "Id"
        case isBatchStatement = "IsBatchStatement"
        case queryParameters = "QueryParameters"
        case queryString = "QueryString"
        case queryStrings = "QueryStrings"
        case secretArn = "SecretArn"
        case statementName = "StatementName"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isBatchStatement = self.isBatchStatement {
            try encodeContainer.encode(isBatchStatement, forKey: .isBatchStatement)
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryParameters)
            for sqlparameter0 in queryParameters {
                try queryParametersContainer.encode(sqlparameter0)
            }
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryStrings = queryStrings {
            var queryStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryStrings)
            for statementstring0 in queryStrings {
                try queryStringsContainer.encode(statementstring0)
            }
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryStringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryStrings)
        var queryStringsDecoded0:[Swift.String]? = nil
        if let queryStringsContainer = queryStringsContainer {
            queryStringsDecoded0 = [Swift.String]()
            for string0 in queryStringsContainer {
                if let string0 = string0 {
                    queryStringsDecoded0?.append(string0)
                }
            }
        }
        queryStrings = queryStringsDecoded0
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftDataClientTypes.StatusString.self, forKey: .status)
        status = statusDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([RedshiftDataClientTypes.SqlParameter?].self, forKey: .queryParameters)
        var queryParametersDecoded0:[RedshiftDataClientTypes.SqlParameter]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [RedshiftDataClientTypes.SqlParameter]()
            for structure0 in queryParametersContainer {
                if let structure0 = structure0 {
                    queryParametersDecoded0?.append(structure0)
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let isBatchStatementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBatchStatement)
        isBatchStatement = isBatchStatementDecoded
    }
}

extension RedshiftDataClientTypes {
    /// The SQL statement to run.
    public struct StatementData: Swift.Equatable {
        /// The date and time (UTC) the statement was created.
        public var createdAt: ClientRuntime.Date?
        /// The SQL statement identifier. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
        /// This member is required.
        public var id: Swift.String?
        /// A value that indicates whether the statement is a batch query request.
        public var isBatchStatement: Swift.Bool?
        /// The parameters used in a SQL statement.
        public var queryParameters: [RedshiftDataClientTypes.SqlParameter]?
        /// The SQL statement.
        public var queryString: Swift.String?
        /// One or more SQL statements. Each query string in the array corresponds to one of the queries in a batch query request.
        public var queryStrings: [Swift.String]?
        /// The name or Amazon Resource Name (ARN) of the secret that enables access to the database.
        public var secretArn: Swift.String?
        /// The name of the SQL statement.
        public var statementName: Swift.String?
        /// The status of the SQL statement. An example is the that the SQL statement finished.
        public var status: RedshiftDataClientTypes.StatusString?
        /// The date and time (UTC) that the statement metadata was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            isBatchStatement: Swift.Bool? = nil,
            queryParameters: [RedshiftDataClientTypes.SqlParameter]? = nil,
            queryString: Swift.String? = nil,
            queryStrings: [Swift.String]? = nil,
            secretArn: Swift.String? = nil,
            statementName: Swift.String? = nil,
            status: RedshiftDataClientTypes.StatusString? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.isBatchStatement = isBatchStatement
            self.queryParameters = queryParameters
            self.queryString = queryString
            self.queryStrings = queryStrings
            self.secretArn = secretArn
            self.statementName = statementName
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension RedshiftDataClientTypes {
    public enum StatementStatusString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case failed
        case finished
        case picked
        case started
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementStatusString] {
            return [
                .aborted,
                .failed,
                .finished,
                .picked,
                .started,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .picked: return "PICKED"
            case .started: return "STARTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatementStatusString(rawValue: rawValue) ?? StatementStatusString.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftDataClientTypes {
    public enum StatusString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case all
        case failed
        case finished
        case picked
        case started
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusString] {
            return [
                .aborted,
                .all,
                .failed,
                .finished,
                .picked,
                .started,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .picked: return "PICKED"
            case .started: return "STARTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusString(rawValue: rawValue) ?? StatusString.sdkUnknown(rawValue)
        }
    }
}

extension RedshiftDataClientTypes.SubStatementData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case duration = "Duration"
        case error = "Error"
        case hasResultSet = "HasResultSet"
        case id = "Id"
        case queryString = "QueryString"
        case redshiftQueryId = "RedshiftQueryId"
        case resultRows = "ResultRows"
        case resultSize = "ResultSize"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let hasResultSet = self.hasResultSet {
            try encodeContainer.encode(hasResultSet, forKey: .hasResultSet)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if redshiftQueryId != 0 {
            try encodeContainer.encode(redshiftQueryId, forKey: .redshiftQueryId)
        }
        if resultRows != 0 {
            try encodeContainer.encode(resultRows, forKey: .resultRows)
        }
        if resultSize != 0 {
            try encodeContainer.encode(resultSize, forKey: .resultSize)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RedshiftDataClientTypes.StatementStatusString.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let resultRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resultRows) ?? 0
        resultRows = resultRowsDecoded
        let resultSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resultSize) ?? 0
        resultSize = resultSizeDecoded
        let redshiftQueryIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .redshiftQueryId) ?? 0
        redshiftQueryId = redshiftQueryIdDecoded
        let hasResultSetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasResultSet)
        hasResultSet = hasResultSetDecoded
    }
}

extension RedshiftDataClientTypes {
    /// Information about an SQL statement.
    public struct SubStatementData: Swift.Equatable {
        /// The date and time (UTC) the statement was created.
        public var createdAt: ClientRuntime.Date?
        /// The amount of time in nanoseconds that the statement ran.
        public var duration: Swift.Int
        /// The error message from the cluster if the SQL statement encountered an error while running.
        public var error: Swift.String?
        /// A value that indicates whether the statement has a result set. The result set can be empty. The value is true for an empty result set.
        public var hasResultSet: Swift.Bool?
        /// The identifier of the SQL statement. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API. A suffix indicates the number of the SQL statement. For example, d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the second SQL statement of a batch query.
        /// This member is required.
        public var id: Swift.String?
        /// The SQL statement text.
        public var queryString: Swift.String?
        /// The SQL statement identifier. This value is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
        public var redshiftQueryId: Swift.Int
        /// Either the number of rows returned from the SQL statement or the number of rows affected. If result size is greater than zero, the result rows can be the number of rows affected by SQL statements such as INSERT, UPDATE, DELETE, COPY, and others. A -1 indicates the value is null.
        public var resultRows: Swift.Int
        /// The size in bytes of the returned results. A -1 indicates the value is null.
        public var resultSize: Swift.Int
        /// The status of the SQL statement. An example is the that the SQL statement finished.
        public var status: RedshiftDataClientTypes.StatementStatusString?
        /// The date and time (UTC) that the statement metadata was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            duration: Swift.Int = 0,
            error: Swift.String? = nil,
            hasResultSet: Swift.Bool? = nil,
            id: Swift.String? = nil,
            queryString: Swift.String? = nil,
            redshiftQueryId: Swift.Int = 0,
            resultRows: Swift.Int = 0,
            resultSize: Swift.Int = 0,
            status: RedshiftDataClientTypes.StatementStatusString? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.duration = duration
            self.error = error
            self.hasResultSet = hasResultSet
            self.id = id
            self.queryString = queryString
            self.redshiftQueryId = redshiftQueryId
            self.resultRows = resultRows
            self.resultSize = resultSize
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension RedshiftDataClientTypes.TableMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case schema
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension RedshiftDataClientTypes {
    /// The properties of a table.
    public struct TableMember: Swift.Equatable {
        /// The name of the table.
        public var name: Swift.String?
        /// The schema containing the table.
        public var schema: Swift.String?
        /// The type of the table. Possible values include TABLE, VIEW, SYSTEM TABLE, GLOBAL TEMPORARY, LOCAL TEMPORARY, ALIAS, and SYNONYM.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            schema: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.schema = schema
            self.type = type
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Redshift Data API operation failed due to invalid input.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
