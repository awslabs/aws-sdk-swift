//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

public struct DeleteDatabaseOutput {

    public init() { }
}

public struct DeleteTableOutput {

    public init() { }
}

/// You are not authorized to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TimestreamWriteClientTypes {

    public enum BatchLoadDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchLoadDataFormat] {
            return [
                .csv
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    /// Details about the progress of a batch load task.
    public struct BatchLoadProgressReport {
        ///
        public var bytesMetered: Swift.Int
        ///
        public var fileFailures: Swift.Int
        ///
        public var parseFailures: Swift.Int
        ///
        public var recordIngestionFailures: Swift.Int
        ///
        public var recordsIngested: Swift.Int
        ///
        public var recordsProcessed: Swift.Int

        public init(
            bytesMetered: Swift.Int = 0,
            fileFailures: Swift.Int = 0,
            parseFailures: Swift.Int = 0,
            recordIngestionFailures: Swift.Int = 0,
            recordsIngested: Swift.Int = 0,
            recordsProcessed: Swift.Int = 0
        )
        {
            self.bytesMetered = bytesMetered
            self.fileFailures = fileFailures
            self.parseFailures = parseFailures
            self.recordIngestionFailures = recordIngestionFailures
            self.recordsIngested = recordsIngested
            self.recordsProcessed = recordsProcessed
        }
    }

}

extension TimestreamWriteClientTypes {

    public enum BatchLoadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case failed
        case inProgress
        case pendingResume
        case progressStopped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchLoadStatus] {
            return [
                .created,
                .failed,
                .inProgress,
                .pendingResume,
                .progressStopped,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pendingResume: return "PENDING_RESUME"
            case .progressStopped: return "PROGRESS_STOPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    /// Details about a batch load task.
    public struct BatchLoadTask {
        /// The time when the Timestream batch load task was created.
        public var creationTime: Foundation.Date?
        /// Database name for the database into which a batch load task loads data.
        public var databaseName: Swift.String?
        /// The time when the Timestream batch load task was last updated.
        public var lastUpdatedTime: Foundation.Date?
        ///
        public var resumableUntil: Foundation.Date?
        /// Table name for the table into which a batch load task loads data.
        public var tableName: Swift.String?
        /// The ID of the batch load task.
        public var taskId: Swift.String?
        /// Status of the batch load task.
        public var taskStatus: TimestreamWriteClientTypes.BatchLoadStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            resumableUntil: Foundation.Date? = nil,
            tableName: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: TimestreamWriteClientTypes.BatchLoadStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.resumableUntil = resumableUntil
            self.tableName = tableName
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }

}

extension TimestreamWriteClientTypes {
    ///
    public struct DimensionMapping {
        ///
        public var destinationColumn: Swift.String?
        ///
        public var sourceColumn: Swift.String?

        public init(
            destinationColumn: Swift.String? = nil,
            sourceColumn: Swift.String? = nil
        )
        {
            self.destinationColumn = destinationColumn
            self.sourceColumn = sourceColumn
        }
    }

}

extension TimestreamWriteClientTypes {

    public enum MeasureValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bigint
        case boolean
        case double
        case multi
        case timestamp
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [MeasureValueType] {
            return [
                .bigint,
                .boolean,
                .double,
                .multi,
                .timestamp,
                .varchar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .multi: return "MULTI"
            case .timestamp: return "TIMESTAMP"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {

    public enum ScalarMeasureValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bigint
        case boolean
        case double
        case timestamp
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarMeasureValueType] {
            return [
                .bigint,
                .boolean,
                .double,
                .timestamp,
                .varchar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .timestamp: return "TIMESTAMP"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct MultiMeasureAttributeMapping {
        ///
        public var measureValueType: TimestreamWriteClientTypes.ScalarMeasureValueType?
        ///
        /// This member is required.
        public var sourceColumn: Swift.String?
        ///
        public var targetMultiMeasureAttributeName: Swift.String?

        public init(
            measureValueType: TimestreamWriteClientTypes.ScalarMeasureValueType? = nil,
            sourceColumn: Swift.String? = nil,
            targetMultiMeasureAttributeName: Swift.String? = nil
        )
        {
            self.measureValueType = measureValueType
            self.sourceColumn = sourceColumn
            self.targetMultiMeasureAttributeName = targetMultiMeasureAttributeName
        }
    }

}

extension TimestreamWriteClientTypes {
    ///
    public struct MixedMeasureMapping {
        ///
        public var measureName: Swift.String?
        ///
        /// This member is required.
        public var measureValueType: TimestreamWriteClientTypes.MeasureValueType?
        ///
        public var multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]?
        ///
        public var sourceColumn: Swift.String?
        ///
        public var targetMeasureName: Swift.String?

        public init(
            measureName: Swift.String? = nil,
            measureValueType: TimestreamWriteClientTypes.MeasureValueType? = nil,
            multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]? = nil,
            sourceColumn: Swift.String? = nil,
            targetMeasureName: Swift.String? = nil
        )
        {
            self.measureName = measureName
            self.measureValueType = measureValueType
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.sourceColumn = sourceColumn
            self.targetMeasureName = targetMeasureName
        }
    }

}

extension TimestreamWriteClientTypes {
    ///
    public struct MultiMeasureMappings {
        ///
        /// This member is required.
        public var multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]?
        ///
        public var targetMultiMeasureName: Swift.String?

        public init(
            multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]? = nil,
            targetMultiMeasureName: Swift.String? = nil
        )
        {
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.targetMultiMeasureName = targetMultiMeasureName
        }
    }

}

extension TimestreamWriteClientTypes {

    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case microseconds
        case milliseconds
        case nanoseconds
        case seconds
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .microseconds,
                .milliseconds,
                .nanoseconds,
                .seconds
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .microseconds: return "MICROSECONDS"
            case .milliseconds: return "MILLISECONDS"
            case .nanoseconds: return "NANOSECONDS"
            case .seconds: return "SECONDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    /// Data model for a batch load task.
    public struct DataModel {
        /// Source to target mappings for dimensions.
        /// This member is required.
        public var dimensionMappings: [TimestreamWriteClientTypes.DimensionMapping]?
        ///
        public var measureNameColumn: Swift.String?
        /// Source to target mappings for measures.
        public var mixedMeasureMappings: [TimestreamWriteClientTypes.MixedMeasureMapping]?
        /// Source to target mappings for multi-measure records.
        public var multiMeasureMappings: TimestreamWriteClientTypes.MultiMeasureMappings?
        /// Source column to be mapped to time.
        public var timeColumn: Swift.String?
        /// The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds, or other supported values. Default is MILLISECONDS.
        public var timeUnit: TimestreamWriteClientTypes.TimeUnit?

        public init(
            dimensionMappings: [TimestreamWriteClientTypes.DimensionMapping]? = nil,
            measureNameColumn: Swift.String? = nil,
            mixedMeasureMappings: [TimestreamWriteClientTypes.MixedMeasureMapping]? = nil,
            multiMeasureMappings: TimestreamWriteClientTypes.MultiMeasureMappings? = nil,
            timeColumn: Swift.String? = nil,
            timeUnit: TimestreamWriteClientTypes.TimeUnit? = nil
        )
        {
            self.dimensionMappings = dimensionMappings
            self.measureNameColumn = measureNameColumn
            self.mixedMeasureMappings = mixedMeasureMappings
            self.multiMeasureMappings = multiMeasureMappings
            self.timeColumn = timeColumn
            self.timeUnit = timeUnit
        }
    }

}

extension TimestreamWriteClientTypes {
    ///
    public struct DataModelS3Configuration {
        ///
        public var bucketName: Swift.String?
        ///
        public var objectKey: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension TimestreamWriteClientTypes {
    ///
    public struct DataModelConfiguration {
        ///
        public var dataModel: TimestreamWriteClientTypes.DataModel?
        ///
        public var dataModelS3Configuration: TimestreamWriteClientTypes.DataModelS3Configuration?

        public init(
            dataModel: TimestreamWriteClientTypes.DataModel? = nil,
            dataModelS3Configuration: TimestreamWriteClientTypes.DataModelS3Configuration? = nil
        )
        {
            self.dataModel = dataModel
            self.dataModelS3Configuration = dataModelS3Configuration
        }
    }

}

extension TimestreamWriteClientTypes {
    /// A delimited data format where the column separator can be a comma and the record separator is a newline character.
    public struct CsvConfiguration {
        /// Column separator can be one of comma (','), pipe ('|), semicolon (';'), tab('/t'), or blank space (' ').
        public var columnSeparator: Swift.String?
        /// Escape character can be one of
        public var escapeChar: Swift.String?
        /// Can be blank space (' ').
        public var nullValue: Swift.String?
        /// Can be single quote (') or double quote (").
        public var quoteChar: Swift.String?
        /// Specifies to trim leading and trailing white space.
        public var trimWhiteSpace: Swift.Bool?

        public init(
            columnSeparator: Swift.String? = nil,
            escapeChar: Swift.String? = nil,
            nullValue: Swift.String? = nil,
            quoteChar: Swift.String? = nil,
            trimWhiteSpace: Swift.Bool? = nil
        )
        {
            self.columnSeparator = columnSeparator
            self.escapeChar = escapeChar
            self.nullValue = nullValue
            self.quoteChar = quoteChar
            self.trimWhiteSpace = trimWhiteSpace
        }
    }

}

extension TimestreamWriteClientTypes {
    ///
    public struct DataSourceS3Configuration {
        /// The bucket name of the customer S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        ///
        public var objectKeyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension TimestreamWriteClientTypes {
    /// Defines configuration details about the data source.
    public struct DataSourceConfiguration {
        /// A delimited data format where the column separator can be a comma and the record separator is a newline character.
        public var csvConfiguration: TimestreamWriteClientTypes.CsvConfiguration?
        /// This is currently CSV.
        /// This member is required.
        public var dataFormat: TimestreamWriteClientTypes.BatchLoadDataFormat?
        /// Configuration of an S3 location for a file which contains data to load.
        /// This member is required.
        public var dataSourceS3Configuration: TimestreamWriteClientTypes.DataSourceS3Configuration?

        public init(
            csvConfiguration: TimestreamWriteClientTypes.CsvConfiguration? = nil,
            dataFormat: TimestreamWriteClientTypes.BatchLoadDataFormat? = nil,
            dataSourceS3Configuration: TimestreamWriteClientTypes.DataSourceS3Configuration? = nil
        )
        {
            self.csvConfiguration = csvConfiguration
            self.dataFormat = dataFormat
            self.dataSourceS3Configuration = dataSourceS3Configuration
        }
    }

}

extension TimestreamWriteClientTypes {

    public enum S3EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [S3EncryptionOption] {
            return [
                .sseKms,
                .sseS3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct ReportS3Configuration {
        ///
        /// This member is required.
        public var bucketName: Swift.String?
        ///
        public var encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption?
        ///
        public var kmsKeyId: Swift.String?
        ///
        public var objectKeyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption? = nil,
            kmsKeyId: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.kmsKeyId = kmsKeyId
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension TimestreamWriteClientTypes {
    /// Report configuration for a batch load task. This contains details about where error reports are stored.
    public struct ReportConfiguration {
        /// Configuration of an S3 location to write error reports and events for a batch load.
        public var reportS3Configuration: TimestreamWriteClientTypes.ReportS3Configuration?

        public init(
            reportS3Configuration: TimestreamWriteClientTypes.ReportS3Configuration? = nil
        )
        {
            self.reportS3Configuration = reportS3Configuration
        }
    }

}

extension TimestreamWriteClientTypes {
    /// Details about a batch load task.
    public struct BatchLoadTaskDescription {
        /// The time when the Timestream batch load task was created.
        public var creationTime: Foundation.Date?
        /// Data model configuration for a batch load task. This contains details about where a data model for a batch load task is stored.
        public var dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration?
        /// Configuration details about the data source for a batch load task.
        public var dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration?
        ///
        public var errorMessage: Swift.String?
        /// The time when the Timestream batch load task was last updated.
        public var lastUpdatedTime: Foundation.Date?
        ///
        public var progressReport: TimestreamWriteClientTypes.BatchLoadProgressReport?
        ///
        public var recordVersion: Swift.Int
        /// Report configuration for a batch load task. This contains details about where error reports are stored.
        public var reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration?
        ///
        public var resumableUntil: Foundation.Date?
        ///
        public var targetDatabaseName: Swift.String?
        ///
        public var targetTableName: Swift.String?
        /// The ID of the batch load task.
        public var taskId: Swift.String?
        /// Status of the batch load task.
        public var taskStatus: TimestreamWriteClientTypes.BatchLoadStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration? = nil,
            dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            progressReport: TimestreamWriteClientTypes.BatchLoadProgressReport? = nil,
            recordVersion: Swift.Int = 0,
            reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration? = nil,
            resumableUntil: Foundation.Date? = nil,
            targetDatabaseName: Swift.String? = nil,
            targetTableName: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: TimestreamWriteClientTypes.BatchLoadStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.dataModelConfiguration = dataModelConfiguration
            self.dataSourceConfiguration = dataSourceConfiguration
            self.errorMessage = errorMessage
            self.lastUpdatedTime = lastUpdatedTime
            self.progressReport = progressReport
            self.recordVersion = recordVersion
            self.reportConfiguration = reportConfiguration
            self.resumableUntil = resumableUntil
            self.targetDatabaseName = targetDatabaseName
            self.targetTableName = targetTableName
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }

}

/// Timestream was unable to process this request because it contains resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Timestream was unable to fully process this request because of an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested endpoint was not valid.
public struct InvalidEndpointException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEndpointException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation tried to access a nonexistent resource. The resource might not be specified correctly, or its status might not be ACTIVE.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The instance quota of resource exceeded for this account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Too many requests were made by a user and they exceeded the service quotas. The request was throttled.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An invalid or malformed request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateBatchLoadTaskInput {
    ///
    public var clientToken: Swift.String?
    ///
    public var dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration?
    /// Defines configuration details about the data source for a batch load task.
    /// This member is required.
    public var dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration?
    ///
    public var recordVersion: Swift.Int?
    /// Report configuration for a batch load task. This contains details about where error reports are stored.
    /// This member is required.
    public var reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration?
    /// Target Timestream database for a batch load task.
    /// This member is required.
    public var targetDatabaseName: Swift.String?
    /// Target Timestream table for a batch load task.
    /// This member is required.
    public var targetTableName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration? = nil,
        dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration? = nil,
        recordVersion: Swift.Int? = 0,
        reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetTableName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataModelConfiguration = dataModelConfiguration
        self.dataSourceConfiguration = dataSourceConfiguration
        self.recordVersion = recordVersion
        self.reportConfiguration = reportConfiguration
        self.targetDatabaseName = targetDatabaseName
        self.targetTableName = targetTableName
    }
}

extension CreateBatchLoadTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBatchLoadTaskInput(dataModelConfiguration: \(Swift.String(describing: dataModelConfiguration)), dataSourceConfiguration: \(Swift.String(describing: dataSourceConfiguration)), recordVersion: \(Swift.String(describing: recordVersion)), reportConfiguration: \(Swift.String(describing: reportConfiguration)), targetDatabaseName: \(Swift.String(describing: targetDatabaseName)), targetTableName: \(Swift.String(describing: targetTableName)), clientToken: \"CONTENT_REDACTED\")"}
}

public struct CreateBatchLoadTaskOutput {
    /// The ID of the batch load task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension TimestreamWriteClientTypes {
    /// A tag is a label that you assign to a Timestream database and/or table. Each tag consists of a key and an optional value, both of which you define. With tags, you can categorize databases and/or tables, for example, by purpose, owner, or environment.
    public struct Tag {
        /// The key of the tag. Tag keys are case sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case-sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateDatabaseInput {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The KMS key for the database. If the KMS key is not specified, the database will be encrypted with a Timestream managed KMS key located in your account. For more information, see [Amazon Web Services managed keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyId: Swift.String?
    /// A list of key-value pairs to label the table.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init(
        databaseName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
        self.tags = tags
    }
}

extension TimestreamWriteClientTypes {
    /// A top-level container for a table. Databases and tables are the fundamental management concepts in Amazon Timestream. All tables in a database are encrypted with the same KMS key.
    public struct Database {
        /// The Amazon Resource Name that uniquely identifies this database.
        public var arn: Swift.String?
        /// The time when the database was created, calculated from the Unix epoch time.
        public var creationTime: Foundation.Date?
        /// The name of the Timestream database.
        public var databaseName: Swift.String?
        /// The identifier of the KMS key used to encrypt the data stored in the database.
        public var kmsKeyId: Swift.String?
        /// The last time that this database was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The total number of tables found within a Timestream database.
        public var tableCount: Swift.Int

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            tableCount: Swift.Int = 0
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
            self.lastUpdatedTime = lastUpdatedTime
            self.tableCount = tableCount
        }
    }

}

public struct CreateDatabaseOutput {
    /// The newly created Timestream database.
    public var database: TimestreamWriteClientTypes.Database?

    public init(
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

extension TimestreamWriteClientTypes {
    /// The configuration that specifies an S3 location.
    public struct S3Configuration {
        /// The bucket name of the customer S3 bucket.
        public var bucketName: Swift.String?
        /// The encryption option for the customer S3 location. Options are S3 server-side encryption with an S3 managed key or Amazon Web Services managed key.
        public var encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption?
        /// The KMS key ID for the customer S3 location when encrypting with an Amazon Web Services managed key.
        public var kmsKeyId: Swift.String?
        /// The object key preview for the customer S3 location.
        public var objectKeyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption? = nil,
            kmsKeyId: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.kmsKeyId = kmsKeyId
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension TimestreamWriteClientTypes {
    /// The location to write error reports for records rejected, asynchronously, during magnetic store writes.
    public struct MagneticStoreRejectedDataLocation {
        /// Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes.
        public var s3Configuration: TimestreamWriteClientTypes.S3Configuration?

        public init(
            s3Configuration: TimestreamWriteClientTypes.S3Configuration? = nil
        )
        {
            self.s3Configuration = s3Configuration
        }
    }

}

extension TimestreamWriteClientTypes {
    /// The set of properties on a table for configuring magnetic store writes.
    public struct MagneticStoreWriteProperties {
        /// A flag to enable magnetic store writes.
        /// This member is required.
        public var enableMagneticStoreWrites: Swift.Bool?
        /// The location to write error reports for records rejected asynchronously during magnetic store writes.
        public var magneticStoreRejectedDataLocation: TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation?

        public init(
            enableMagneticStoreWrites: Swift.Bool? = nil,
            magneticStoreRejectedDataLocation: TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation? = nil
        )
        {
            self.enableMagneticStoreWrites = enableMagneticStoreWrites
            self.magneticStoreRejectedDataLocation = magneticStoreRejectedDataLocation
        }
    }

}

extension TimestreamWriteClientTypes {
    /// Retention properties contain the duration for which your time-series data must be stored in the magnetic store and the memory store.
    public struct RetentionProperties {
        /// The duration for which data must be stored in the magnetic store.
        /// This member is required.
        public var magneticStoreRetentionPeriodInDays: Swift.Int?
        /// The duration for which data must be stored in the memory store.
        /// This member is required.
        public var memoryStoreRetentionPeriodInHours: Swift.Int?

        public init(
            magneticStoreRetentionPeriodInDays: Swift.Int? = nil,
            memoryStoreRetentionPeriodInHours: Swift.Int? = nil
        )
        {
            self.magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDays
            self.memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHours
        }
    }

}

extension TimestreamWriteClientTypes {

    public enum PartitionKeyEnforcementLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `optional`
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [PartitionKeyEnforcementLevel] {
            return [
                .optional,
                .required
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .optional: return "OPTIONAL"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {

    public enum PartitionKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dimension
        case measure
        case sdkUnknown(Swift.String)

        public static var allCases: [PartitionKeyType] {
            return [
                .dimension,
                .measure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dimension: return "DIMENSION"
            case .measure: return "MEASURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    /// An attribute used in partitioning data in a table. A dimension key partitions data using the values of the dimension specified by the dimension-name as partition key, while a measure key partitions data using measure names (values of the 'measure_name' column).
    public struct PartitionKey {
        /// The level of enforcement for the specification of a dimension key in ingested records. Options are REQUIRED (dimension key must be specified) and OPTIONAL (dimension key does not have to be specified).
        public var enforcementInRecord: TimestreamWriteClientTypes.PartitionKeyEnforcementLevel?
        /// The name of the attribute used for a dimension key.
        public var name: Swift.String?
        /// The type of the partition key. Options are DIMENSION (dimension key) and MEASURE (measure key).
        /// This member is required.
        public var type: TimestreamWriteClientTypes.PartitionKeyType?

        public init(
            enforcementInRecord: TimestreamWriteClientTypes.PartitionKeyEnforcementLevel? = nil,
            name: Swift.String? = nil,
            type: TimestreamWriteClientTypes.PartitionKeyType? = nil
        )
        {
            self.enforcementInRecord = enforcementInRecord
            self.name = name
            self.type = type
        }
    }

}

extension TimestreamWriteClientTypes {
    /// A Schema specifies the expected data model of the table.
    public struct Schema {
        /// A non-empty list of partition keys defining the attributes used to partition the table data. The order of the list determines the partition hierarchy. The name and type of each partition key as well as the partition key order cannot be changed after the table is created. However, the enforcement level of each partition key can be changed.
        public var compositePartitionKey: [TimestreamWriteClientTypes.PartitionKey]?

        public init(
            compositePartitionKey: [TimestreamWriteClientTypes.PartitionKey]? = nil
        )
        {
            self.compositePartitionKey = compositePartitionKey
        }
    }

}

public struct CreateTableInput {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Contains properties to set on the table when enabling magnetic store writes.
    public var magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
    /// The duration for which your time-series data must be stored in the memory store and the magnetic store.
    public var retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    /// The schema of the table.
    public var schema: TimestreamWriteClientTypes.Schema?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?
    /// A list of key-value pairs to label the table.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init(
        databaseName: Swift.String? = nil,
        magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties? = nil,
        retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
        schema: TimestreamWriteClientTypes.Schema? = nil,
        tableName: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.magneticStoreWriteProperties = magneticStoreWriteProperties
        self.retentionProperties = retentionProperties
        self.schema = schema
        self.tableName = tableName
        self.tags = tags
    }
}

extension TimestreamWriteClientTypes {

    public enum TableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case restoring
        case sdkUnknown(Swift.String)

        public static var allCases: [TableStatus] {
            return [
                .active,
                .deleting,
                .restoring
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .restoring: return "RESTORING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    /// Represents a database table in Timestream. Tables contain one or more related time series. You can modify the retention duration of the memory store and the magnetic store for a table.
    public struct Table {
        /// The Amazon Resource Name that uniquely identifies this table.
        public var arn: Swift.String?
        /// The time when the Timestream table was created.
        public var creationTime: Foundation.Date?
        /// The name of the Timestream database that contains this table.
        public var databaseName: Swift.String?
        /// The time when the Timestream table was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// Contains properties to set on the table when enabling magnetic store writes.
        public var magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
        /// The retention duration for the memory store and magnetic store.
        public var retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
        /// The schema of the table.
        public var schema: TimestreamWriteClientTypes.Schema?
        /// The name of the Timestream table.
        public var tableName: Swift.String?
        /// The current state of the table:
        ///
        /// * DELETING - The table is being deleted.
        ///
        /// * ACTIVE - The table is ready for use.
        public var tableStatus: TimestreamWriteClientTypes.TableStatus?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            databaseName: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties? = nil,
            retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
            schema: TimestreamWriteClientTypes.Schema? = nil,
            tableName: Swift.String? = nil,
            tableStatus: TimestreamWriteClientTypes.TableStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.schema = schema
            self.tableName = tableName
            self.tableStatus = tableStatus
        }
    }

}

public struct CreateTableOutput {
    /// The newly created Timestream table.
    public var table: TimestreamWriteClientTypes.Table?

    public init(
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

public struct DeleteDatabaseInput {
    /// The name of the Timestream database to be deleted.
    /// This member is required.
    public var databaseName: Swift.String?

    public init(
        databaseName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

public struct DeleteTableInput {
    /// The name of the database where the Timestream database is to be deleted.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the Timestream table to be deleted.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct DescribeBatchLoadTaskInput {
    /// The ID of the batch load task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct DescribeBatchLoadTaskOutput {
    /// Description of the batch load task.
    /// This member is required.
    public var batchLoadTaskDescription: TimestreamWriteClientTypes.BatchLoadTaskDescription?

    public init(
        batchLoadTaskDescription: TimestreamWriteClientTypes.BatchLoadTaskDescription? = nil
    )
    {
        self.batchLoadTaskDescription = batchLoadTaskDescription
    }
}

public struct DescribeDatabaseInput {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?

    public init(
        databaseName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

public struct DescribeDatabaseOutput {
    /// The name of the Timestream table.
    public var database: TimestreamWriteClientTypes.Database?

    public init(
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

public struct DescribeEndpointsInput {

    public init() { }
}

extension TimestreamWriteClientTypes {
    /// Represents an available endpoint against which to make API calls against, as well as the TTL for that endpoint.
    public struct Endpoint {
        /// An endpoint address.
        /// This member is required.
        public var address: Swift.String?
        /// The TTL for the endpoint, in minutes.
        /// This member is required.
        public var cachePeriodInMinutes: Swift.Int

        public init(
            address: Swift.String? = nil,
            cachePeriodInMinutes: Swift.Int = 0
        )
        {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }
    }

}

public struct DescribeEndpointsOutput {
    /// An Endpoints object is returned when a DescribeEndpoints request is made.
    /// This member is required.
    public var endpoints: [TimestreamWriteClientTypes.Endpoint]?

    public init(
        endpoints: [TimestreamWriteClientTypes.Endpoint]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

public struct DescribeTableInput {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

public struct DescribeTableOutput {
    /// The Timestream table.
    public var table: TimestreamWriteClientTypes.Table?

    public init(
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

extension TimestreamWriteClientTypes {

    public enum DimensionValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionValueType] {
            return [
                .varchar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TimestreamWriteClientTypes {
    /// Represents the metadata attributes of the time series. For example, the name and Availability Zone of an EC2 instance or the name of the manufacturer of a wind turbine are dimensions.
    public struct Dimension {
        /// The data type of the dimension for the time-series data point.
        public var dimensionValueType: TimestreamWriteClientTypes.DimensionValueType?
        /// Dimension represents the metadata attributes of the time series. For example, the name and Availability Zone of an EC2 instance or the name of the manufacturer of a wind turbine are dimensions. For constraints on dimension names, see [Naming Constraints](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html#limits.naming).
        /// This member is required.
        public var name: Swift.String?
        /// The value of the dimension.
        /// This member is required.
        public var value: Swift.String?

        public init(
            dimensionValueType: TimestreamWriteClientTypes.DimensionValueType? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimensionValueType = dimensionValueType
            self.name = name
            self.value = value
        }
    }

}

public struct ListBatchLoadTasksInput {
    /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// Status of the batch load task.
    public var taskStatus: TimestreamWriteClientTypes.BatchLoadStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        taskStatus: TimestreamWriteClientTypes.BatchLoadStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskStatus = taskStatus
    }
}

public struct ListBatchLoadTasksOutput {
    /// A list of batch load task details.
    public var batchLoadTasks: [TimestreamWriteClientTypes.BatchLoadTask]?
    /// A token to specify where to start paginating. Provide the next ListBatchLoadTasksRequest.
    public var nextToken: Swift.String?

    public init(
        batchLoadTasks: [TimestreamWriteClientTypes.BatchLoadTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchLoadTasks = batchLoadTasks
        self.nextToken = nextToken
    }
}

public struct ListDatabasesInput {
    /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDatabasesOutput {
    /// A list of database names.
    public var databases: [TimestreamWriteClientTypes.Database]?
    /// The pagination token. This parameter is returned when the response is truncated.
    public var nextToken: Swift.String?

    public init(
        databases: [TimestreamWriteClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

public struct ListTablesInput {
    /// The name of the Timestream database.
    public var databaseName: Swift.String?
    /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListTablesOutput {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tables.
    public var tables: [TimestreamWriteClientTypes.Table]?

    public init(
        nextToken: Swift.String? = nil,
        tables: [TimestreamWriteClientTypes.Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

public struct ListTagsForResourceInput {
    /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The tags currently associated with the Timestream resource.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init(
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension TimestreamWriteClientTypes {
    /// Represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures. MeasureValue has both name and value. MeasureValue is only allowed for type MULTI. Using MULTI type, you can pass multiple data attributes associated with the same time series in a single record
    public struct MeasureValue {
        /// The name of the MeasureValue. For constraints on MeasureValue names, see [ Naming Constraints](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html#limits.naming) in the Amazon Timestream Developer Guide.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the data type of the MeasureValue for the time-series data point.
        /// This member is required.
        public var type: TimestreamWriteClientTypes.MeasureValueType?
        /// The value for the MeasureValue. For information, see [Data types](https://docs.aws.amazon.com/timestream/latest/developerguide/writes.html#writes.data-types).
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: TimestreamWriteClientTypes.MeasureValueType? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension TimestreamWriteClientTypes {
    /// Represents a time-series data point being written into Timestream. Each record contains an array of dimensions. Dimensions represent the metadata attributes of a time-series data point, such as the instance name or Availability Zone of an EC2 instance. A record also contains the measure name, which is the name of the measure being collected (for example, the CPU utilization of an EC2 instance). Additionally, a record contains the measure value and the value type, which is the data type of the measure value. Also, the record contains the timestamp of when the measure was collected and the timestamp unit, which represents the granularity of the timestamp. Records have a Version field, which is a 64-bit long that you can use for updating data points. Writes of a duplicate record with the same dimension, timestamp, and measure name but different measure value will only succeed if the Version attribute of the record in the write request is higher than that of the existing record. Timestream defaults to a Version of 1 for records without the Version field.
    public struct Record {
        /// Contains the list of dimensions for time-series data points.
        public var dimensions: [TimestreamWriteClientTypes.Dimension]?
        /// Measure represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures.
        public var measureName: Swift.String?
        /// Contains the measure value for the time-series data point.
        public var measureValue: Swift.String?
        /// Contains the data type of the measure value for the time-series data point. Default type is DOUBLE. For more information, see [Data types](https://docs.aws.amazon.com/timestream/latest/developerguide/writes.html#writes.data-types).
        public var measureValueType: TimestreamWriteClientTypes.MeasureValueType?
        /// Contains the list of MeasureValue for time-series data points. This is only allowed for type MULTI. For scalar values, use MeasureValue attribute of the record directly.
        public var measureValues: [TimestreamWriteClientTypes.MeasureValue]?
        /// Contains the time at which the measure value for the data point was collected. The time value plus the unit provides the time elapsed since the epoch. For example, if the time value is 12345 and the unit is ms, then 12345 ms have elapsed since the epoch.
        public var time: Swift.String?
        /// The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds, or other supported values. Default is MILLISECONDS.
        public var timeUnit: TimestreamWriteClientTypes.TimeUnit?
        /// 64-bit attribute used for record updates. Write requests for duplicate data with a higher version number will update the existing measure value and version. In cases where the measure value is the same, Version will still be updated. Default value is 1. Version must be 1 or greater, or you will receive a ValidationException error.
        public var version: Swift.Int?

        public init(
            dimensions: [TimestreamWriteClientTypes.Dimension]? = nil,
            measureName: Swift.String? = nil,
            measureValue: Swift.String? = nil,
            measureValueType: TimestreamWriteClientTypes.MeasureValueType? = nil,
            measureValues: [TimestreamWriteClientTypes.MeasureValue]? = nil,
            time: Swift.String? = nil,
            timeUnit: TimestreamWriteClientTypes.TimeUnit? = nil,
            version: Swift.Int? = 0
        )
        {
            self.dimensions = dimensions
            self.measureName = measureName
            self.measureValue = measureValue
            self.measureValueType = measureValueType
            self.measureValues = measureValues
            self.time = time
            self.timeUnit = timeUnit
            self.version = version
        }
    }

}

extension TimestreamWriteClientTypes {
    /// Information on the records ingested by this request.
    public struct RecordsIngested {
        /// Count of records ingested into the magnetic store.
        public var magneticStore: Swift.Int
        /// Count of records ingested into the memory store.
        public var memoryStore: Swift.Int
        /// Total count of successfully ingested records.
        public var total: Swift.Int

        public init(
            magneticStore: Swift.Int = 0,
            memoryStore: Swift.Int = 0,
            total: Swift.Int = 0
        )
        {
            self.magneticStore = magneticStore
            self.memoryStore = memoryStore
            self.total = total
        }
    }

}

extension TimestreamWriteClientTypes {
    /// Represents records that were not successfully inserted into Timestream due to data validation issues that must be resolved before reinserting time-series data into the system.
    public struct RejectedRecord {
        /// The existing version of the record. This value is populated in scenarios where an identical record exists with a higher version than the version in the write request.
        public var existingVersion: Swift.Int?
        /// The reason why a record was not successfully inserted into Timestream. Possible causes of failure include:
        ///
        /// * Records with duplicate data where there are multiple records with the same dimensions, timestamps, and measure names but:
        ///
        /// * Measure values are different
        ///
        /// * Version is not present in the request, or the value of version in the new record is equal to or lower than the existing value
        ///
        ///
        /// If Timestream rejects data for this case, the ExistingVersion field in the RejectedRecords response will indicate the current record’s version. To force an update, you can resend the request with a version for the record set to a value greater than the ExistingVersion.
        ///
        /// * Records with timestamps that lie outside the retention duration of the memory store. When the retention window is updated, you will receive a RejectedRecords exception if you immediately try to ingest data within the new window. To avoid a RejectedRecords exception, wait until the duration of the new window to ingest new data. For further information, see [ Best Practices for Configuring Timestream](https://docs.aws.amazon.com/timestream/latest/developerguide/best-practices.html#configuration) and [the explanation of how storage works in Timestream](https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html).
        ///
        /// * Records with dimensions or measures that exceed the Timestream defined limits.
        ///
        ///
        /// For more information, see [Access Management](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html) in the Timestream Developer Guide.
        public var reason: Swift.String?
        /// The index of the record in the input request for WriteRecords. Indexes begin with 0.
        public var recordIndex: Swift.Int

        public init(
            existingVersion: Swift.Int? = 0,
            reason: Swift.String? = nil,
            recordIndex: Swift.Int = 0
        )
        {
            self.existingVersion = existingVersion
            self.reason = reason
            self.recordIndex = recordIndex
        }
    }

}

/// WriteRecords would throw this exception in the following cases:
///
/// * Records with duplicate data where there are multiple records with the same dimensions, timestamps, and measure names but:
///
/// * Measure values are different
///
/// * Version is not present in the request or the value of version in the new record is equal to or lower than the existing value
///
///
/// In this case, if Timestream rejects data, the ExistingVersion field in the RejectedRecords response will indicate the current record’s version. To force an update, you can resend the request with a version for the record set to a value greater than the ExistingVersion.
///
/// * Records with timestamps that lie outside the retention duration of the memory store.
///
/// * Records with dimensions or measures that exceed the Timestream defined limits.
///
///
/// For more information, see [Quotas](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html) in the Amazon Timestream Developer Guide.
public struct RejectedRecordsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RejectedRecordsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]? = nil
    )
    {
        self.properties.message = message
        self.properties.rejectedRecords = rejectedRecords
    }
}

public struct ResumeBatchLoadTaskInput {
    /// The ID of the batch load task to resume.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct ResumeBatchLoadTaskOutput {

    public init() { }
}

public struct TagResourceInput {
    /// Identifies the Timestream resource to which tags should be added. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to be assigned to the Timestream resource.
    /// This member is required.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Timestream resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags keys. Existing tags of the resource whose keys are members of this list will be removed from the Timestream resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateDatabaseInput {
    /// The name of the database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The identifier of the new KMS key (KmsKeyId) to be used to encrypt the data stored in the database. If the KmsKeyId currently registered with the database is the same as the KmsKeyId in the request, there will not be any update. You can specify the KmsKeyId using any of the following:
    ///
    /// * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Key ARN: arn:aws:kms:us-east-1:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Alias name: alias/ExampleAlias
    ///
    /// * Alias ARN: arn:aws:kms:us-east-1:111122223333:alias/ExampleAlias
    /// This member is required.
    public var kmsKeyId: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
    }
}

public struct UpdateDatabaseOutput {
    /// A top-level container for a table. Databases and tables are the fundamental management concepts in Amazon Timestream. All tables in a database are encrypted with the same KMS key.
    public var database: TimestreamWriteClientTypes.Database?

    public init(
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

public struct UpdateTableInput {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Contains properties to set on the table when enabling magnetic store writes.
    public var magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
    /// The retention duration of the memory store and the magnetic store.
    public var retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    /// The schema of the table.
    public var schema: TimestreamWriteClientTypes.Schema?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties? = nil,
        retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
        schema: TimestreamWriteClientTypes.Schema? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.magneticStoreWriteProperties = magneticStoreWriteProperties
        self.retentionProperties = retentionProperties
        self.schema = schema
        self.tableName = tableName
    }
}

public struct UpdateTableOutput {
    /// The updated Timestream table.
    public var table: TimestreamWriteClientTypes.Table?

    public init(
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

public struct WriteRecordsInput {
    /// A record that contains the common measure, dimension, time, and version attributes shared across all the records in the request. The measure and dimension attributes specified will be merged with the measure and dimension attributes in the records object when the data is written into Timestream. Dimensions may not overlap, or a ValidationException will be thrown. In other words, a record must contain dimensions with unique names.
    public var commonAttributes: TimestreamWriteClientTypes.Record?
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// An array of records that contain the unique measure, dimension, time, and version attributes for each time-series data point.
    /// This member is required.
    public var records: [TimestreamWriteClientTypes.Record]?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        commonAttributes: TimestreamWriteClientTypes.Record? = nil,
        databaseName: Swift.String? = nil,
        records: [TimestreamWriteClientTypes.Record]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.commonAttributes = commonAttributes
        self.databaseName = databaseName
        self.records = records
        self.tableName = tableName
    }
}

public struct WriteRecordsOutput {
    /// Information on the records ingested by this request.
    public var recordsIngested: TimestreamWriteClientTypes.RecordsIngested?

    public init(
        recordsIngested: TimestreamWriteClientTypes.RecordsIngested? = nil
    )
    {
        self.recordsIngested = recordsIngested
    }
}

extension CreateBatchLoadTaskInput {

    static func urlPathProvider(_ value: CreateBatchLoadTaskInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatabaseInput {

    static func urlPathProvider(_ value: CreateDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTableInput {

    static func urlPathProvider(_ value: CreateTableInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDatabaseInput {

    static func urlPathProvider(_ value: DeleteDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTableInput {

    static func urlPathProvider(_ value: DeleteTableInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBatchLoadTaskInput {

    static func urlPathProvider(_ value: DescribeBatchLoadTaskInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatabaseInput {

    static func urlPathProvider(_ value: DescribeDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEndpointsInput {

    static func urlPathProvider(_ value: DescribeEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTableInput {

    static func urlPathProvider(_ value: DescribeTableInput) -> Swift.String? {
        return "/"
    }
}

extension ListBatchLoadTasksInput {

    static func urlPathProvider(_ value: ListBatchLoadTasksInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatabasesInput {

    static func urlPathProvider(_ value: ListDatabasesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTablesInput {

    static func urlPathProvider(_ value: ListTablesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ResumeBatchLoadTaskInput {

    static func urlPathProvider(_ value: ResumeBatchLoadTaskInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDatabaseInput {

    static func urlPathProvider(_ value: UpdateDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTableInput {

    static func urlPathProvider(_ value: UpdateTableInput) -> Swift.String? {
        return "/"
    }
}

extension WriteRecordsInput {

    static func urlPathProvider(_ value: WriteRecordsInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBatchLoadTaskInput {

    static func write(value: CreateBatchLoadTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataModelConfiguration"].write(value.dataModelConfiguration, with: TimestreamWriteClientTypes.DataModelConfiguration.write(value:to:))
        try writer["DataSourceConfiguration"].write(value.dataSourceConfiguration, with: TimestreamWriteClientTypes.DataSourceConfiguration.write(value:to:))
        try writer["RecordVersion"].write(value.recordVersion)
        try writer["ReportConfiguration"].write(value.reportConfiguration, with: TimestreamWriteClientTypes.ReportConfiguration.write(value:to:))
        try writer["TargetDatabaseName"].write(value.targetDatabaseName)
        try writer["TargetTableName"].write(value.targetTableName)
    }
}

extension CreateDatabaseInput {

    static func write(value: CreateDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TimestreamWriteClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTableInput {

    static func write(value: CreateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MagneticStoreWriteProperties"].write(value.magneticStoreWriteProperties, with: TimestreamWriteClientTypes.MagneticStoreWriteProperties.write(value:to:))
        try writer["RetentionProperties"].write(value.retentionProperties, with: TimestreamWriteClientTypes.RetentionProperties.write(value:to:))
        try writer["Schema"].write(value.schema, with: TimestreamWriteClientTypes.Schema.write(value:to:))
        try writer["TableName"].write(value.tableName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TimestreamWriteClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteDatabaseInput {

    static func write(value: DeleteDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
    }
}

extension DeleteTableInput {

    static func write(value: DeleteTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension DescribeBatchLoadTaskInput {

    static func write(value: DescribeBatchLoadTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TaskId"].write(value.taskId)
    }
}

extension DescribeDatabaseInput {

    static func write(value: DescribeDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
    }
}

extension DescribeEndpointsInput {

    static func write(value: DescribeEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeTableInput {

    static func write(value: DescribeTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
    }
}

extension ListBatchLoadTasksInput {

    static func write(value: ListBatchLoadTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TaskStatus"].write(value.taskStatus)
    }
}

extension ListDatabasesInput {

    static func write(value: ListDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTablesInput {

    static func write(value: ListTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension ResumeBatchLoadTaskInput {

    static func write(value: ResumeBatchLoadTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TaskId"].write(value.taskId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: TimestreamWriteClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDatabaseInput {

    static func write(value: UpdateDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["KmsKeyId"].write(value.kmsKeyId)
    }
}

extension UpdateTableInput {

    static func write(value: UpdateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MagneticStoreWriteProperties"].write(value.magneticStoreWriteProperties, with: TimestreamWriteClientTypes.MagneticStoreWriteProperties.write(value:to:))
        try writer["RetentionProperties"].write(value.retentionProperties, with: TimestreamWriteClientTypes.RetentionProperties.write(value:to:))
        try writer["Schema"].write(value.schema, with: TimestreamWriteClientTypes.Schema.write(value:to:))
        try writer["TableName"].write(value.tableName)
    }
}

extension WriteRecordsInput {

    static func write(value: WriteRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommonAttributes"].write(value.commonAttributes, with: TimestreamWriteClientTypes.Record.write(value:to:))
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Records"].writeList(value.records, memberWritingClosure: TimestreamWriteClientTypes.Record.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension CreateBatchLoadTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBatchLoadTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBatchLoadTaskOutput()
        value.taskId = try reader["TaskId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatabaseOutput()
        value.database = try reader["Database"].readIfPresent(with: TimestreamWriteClientTypes.Database.read(from:))
        return value
    }
}

extension CreateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTableOutput()
        value.table = try reader["Table"].readIfPresent(with: TimestreamWriteClientTypes.Table.read(from:))
        return value
    }
}

extension DeleteDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatabaseOutput {
        return DeleteDatabaseOutput()
    }
}

extension DeleteTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableOutput {
        return DeleteTableOutput()
    }
}

extension DescribeBatchLoadTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBatchLoadTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBatchLoadTaskOutput()
        value.batchLoadTaskDescription = try reader["BatchLoadTaskDescription"].readIfPresent(with: TimestreamWriteClientTypes.BatchLoadTaskDescription.read(from:))
        return value
    }
}

extension DescribeDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatabaseOutput()
        value.database = try reader["Database"].readIfPresent(with: TimestreamWriteClientTypes.Database.read(from:))
        return value
    }
}

extension DescribeEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEndpointsOutput()
        value.endpoints = try reader["Endpoints"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.Endpoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTableOutput()
        value.table = try reader["Table"].readIfPresent(with: TimestreamWriteClientTypes.Table.read(from:))
        return value
    }
}

extension ListBatchLoadTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBatchLoadTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBatchLoadTasksOutput()
        value.batchLoadTasks = try reader["BatchLoadTasks"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.BatchLoadTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatabasesOutput()
        value.databases = try reader["Databases"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.Database.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTablesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tables = try reader["Tables"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.Table.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ResumeBatchLoadTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeBatchLoadTaskOutput {
        return ResumeBatchLoadTaskOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDatabaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDatabaseOutput()
        value.database = try reader["Database"].readIfPresent(with: TimestreamWriteClientTypes.Database.read(from:))
        return value
    }
}

extension UpdateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTableOutput()
        value.table = try reader["Table"].readIfPresent(with: TimestreamWriteClientTypes.Table.read(from:))
        return value
    }
}

extension WriteRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> WriteRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = WriteRecordsOutput()
        value.recordsIngested = try reader["RecordsIngested"].readIfPresent(with: TimestreamWriteClientTypes.RecordsIngested.read(from:))
        return value
    }
}

enum CreateBatchLoadTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBatchLoadTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBatchLoadTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeBatchLoadTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDatabaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum WriteRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "RejectedRecordsException": return try RejectedRecordsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEndpointException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEndpointException {
        let reader = baseError.errorBodyReader
        var value = InvalidEndpointException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RejectedRecordsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RejectedRecordsException {
        let reader = baseError.errorBodyReader
        var value = RejectedRecordsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.rejectedRecords = try reader["RejectedRecords"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.RejectedRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TimestreamWriteClientTypes.Database {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.Database {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.Database()
        value.arn = try reader["Arn"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableCount = try reader["TableCount"].readIfPresent() ?? 0
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension TimestreamWriteClientTypes.Table {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.Table {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.Table()
        value.arn = try reader["Arn"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableStatus = try reader["TableStatus"].readIfPresent()
        value.retentionProperties = try reader["RetentionProperties"].readIfPresent(with: TimestreamWriteClientTypes.RetentionProperties.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.magneticStoreWriteProperties = try reader["MagneticStoreWriteProperties"].readIfPresent(with: TimestreamWriteClientTypes.MagneticStoreWriteProperties.read(from:))
        value.schema = try reader["Schema"].readIfPresent(with: TimestreamWriteClientTypes.Schema.read(from:))
        return value
    }
}

extension TimestreamWriteClientTypes.Schema {

    static func write(value: TimestreamWriteClientTypes.Schema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompositePartitionKey"].writeList(value.compositePartitionKey, memberWritingClosure: TimestreamWriteClientTypes.PartitionKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.Schema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.Schema()
        value.compositePartitionKey = try reader["CompositePartitionKey"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.PartitionKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TimestreamWriteClientTypes.PartitionKey {

    static func write(value: TimestreamWriteClientTypes.PartitionKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnforcementInRecord"].write(value.enforcementInRecord)
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.PartitionKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.PartitionKey()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["Name"].readIfPresent()
        value.enforcementInRecord = try reader["EnforcementInRecord"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.MagneticStoreWriteProperties {

    static func write(value: TimestreamWriteClientTypes.MagneticStoreWriteProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableMagneticStoreWrites"].write(value.enableMagneticStoreWrites)
        try writer["MagneticStoreRejectedDataLocation"].write(value.magneticStoreRejectedDataLocation, with: TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.MagneticStoreWriteProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.MagneticStoreWriteProperties()
        value.enableMagneticStoreWrites = try reader["EnableMagneticStoreWrites"].readIfPresent() ?? false
        value.magneticStoreRejectedDataLocation = try reader["MagneticStoreRejectedDataLocation"].readIfPresent(with: TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation.read(from:))
        return value
    }
}

extension TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation {

    static func write(value: TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Configuration"].write(value.s3Configuration, with: TimestreamWriteClientTypes.S3Configuration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation()
        value.s3Configuration = try reader["S3Configuration"].readIfPresent(with: TimestreamWriteClientTypes.S3Configuration.read(from:))
        return value
    }
}

extension TimestreamWriteClientTypes.S3Configuration {

    static func write(value: TimestreamWriteClientTypes.S3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["EncryptionOption"].write(value.encryptionOption)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["ObjectKeyPrefix"].write(value.objectKeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.S3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.S3Configuration()
        value.bucketName = try reader["BucketName"].readIfPresent()
        value.objectKeyPrefix = try reader["ObjectKeyPrefix"].readIfPresent()
        value.encryptionOption = try reader["EncryptionOption"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.RetentionProperties {

    static func write(value: TimestreamWriteClientTypes.RetentionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MagneticStoreRetentionPeriodInDays"].write(value.magneticStoreRetentionPeriodInDays)
        try writer["MemoryStoreRetentionPeriodInHours"].write(value.memoryStoreRetentionPeriodInHours)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.RetentionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.RetentionProperties()
        value.memoryStoreRetentionPeriodInHours = try reader["MemoryStoreRetentionPeriodInHours"].readIfPresent() ?? 0
        value.magneticStoreRetentionPeriodInDays = try reader["MagneticStoreRetentionPeriodInDays"].readIfPresent() ?? 0
        return value
    }
}

extension TimestreamWriteClientTypes.BatchLoadTaskDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.BatchLoadTaskDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.BatchLoadTaskDescription()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.dataSourceConfiguration = try reader["DataSourceConfiguration"].readIfPresent(with: TimestreamWriteClientTypes.DataSourceConfiguration.read(from:))
        value.progressReport = try reader["ProgressReport"].readIfPresent(with: TimestreamWriteClientTypes.BatchLoadProgressReport.read(from:))
        value.reportConfiguration = try reader["ReportConfiguration"].readIfPresent(with: TimestreamWriteClientTypes.ReportConfiguration.read(from:))
        value.dataModelConfiguration = try reader["DataModelConfiguration"].readIfPresent(with: TimestreamWriteClientTypes.DataModelConfiguration.read(from:))
        value.targetDatabaseName = try reader["TargetDatabaseName"].readIfPresent()
        value.targetTableName = try reader["TargetTableName"].readIfPresent()
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        value.recordVersion = try reader["RecordVersion"].readIfPresent() ?? 0
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resumableUntil = try reader["ResumableUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension TimestreamWriteClientTypes.DataModelConfiguration {

    static func write(value: TimestreamWriteClientTypes.DataModelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataModel"].write(value.dataModel, with: TimestreamWriteClientTypes.DataModel.write(value:to:))
        try writer["DataModelS3Configuration"].write(value.dataModelS3Configuration, with: TimestreamWriteClientTypes.DataModelS3Configuration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.DataModelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.DataModelConfiguration()
        value.dataModel = try reader["DataModel"].readIfPresent(with: TimestreamWriteClientTypes.DataModel.read(from:))
        value.dataModelS3Configuration = try reader["DataModelS3Configuration"].readIfPresent(with: TimestreamWriteClientTypes.DataModelS3Configuration.read(from:))
        return value
    }
}

extension TimestreamWriteClientTypes.DataModelS3Configuration {

    static func write(value: TimestreamWriteClientTypes.DataModelS3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["ObjectKey"].write(value.objectKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.DataModelS3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.DataModelS3Configuration()
        value.bucketName = try reader["BucketName"].readIfPresent()
        value.objectKey = try reader["ObjectKey"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.DataModel {

    static func write(value: TimestreamWriteClientTypes.DataModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionMappings"].writeList(value.dimensionMappings, memberWritingClosure: TimestreamWriteClientTypes.DimensionMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MeasureNameColumn"].write(value.measureNameColumn)
        try writer["MixedMeasureMappings"].writeList(value.mixedMeasureMappings, memberWritingClosure: TimestreamWriteClientTypes.MixedMeasureMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MultiMeasureMappings"].write(value.multiMeasureMappings, with: TimestreamWriteClientTypes.MultiMeasureMappings.write(value:to:))
        try writer["TimeColumn"].write(value.timeColumn)
        try writer["TimeUnit"].write(value.timeUnit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.DataModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.DataModel()
        value.timeColumn = try reader["TimeColumn"].readIfPresent()
        value.timeUnit = try reader["TimeUnit"].readIfPresent()
        value.dimensionMappings = try reader["DimensionMappings"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.DimensionMapping.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.multiMeasureMappings = try reader["MultiMeasureMappings"].readIfPresent(with: TimestreamWriteClientTypes.MultiMeasureMappings.read(from:))
        value.mixedMeasureMappings = try reader["MixedMeasureMappings"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.MixedMeasureMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.measureNameColumn = try reader["MeasureNameColumn"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.MixedMeasureMapping {

    static func write(value: TimestreamWriteClientTypes.MixedMeasureMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MeasureName"].write(value.measureName)
        try writer["MeasureValueType"].write(value.measureValueType)
        try writer["MultiMeasureAttributeMappings"].writeList(value.multiMeasureAttributeMappings, memberWritingClosure: TimestreamWriteClientTypes.MultiMeasureAttributeMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceColumn"].write(value.sourceColumn)
        try writer["TargetMeasureName"].write(value.targetMeasureName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.MixedMeasureMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.MixedMeasureMapping()
        value.measureName = try reader["MeasureName"].readIfPresent()
        value.sourceColumn = try reader["SourceColumn"].readIfPresent()
        value.targetMeasureName = try reader["TargetMeasureName"].readIfPresent()
        value.measureValueType = try reader["MeasureValueType"].readIfPresent() ?? .sdkUnknown("")
        value.multiMeasureAttributeMappings = try reader["MultiMeasureAttributeMappings"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.MultiMeasureAttributeMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TimestreamWriteClientTypes.MultiMeasureAttributeMapping {

    static func write(value: TimestreamWriteClientTypes.MultiMeasureAttributeMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MeasureValueType"].write(value.measureValueType)
        try writer["SourceColumn"].write(value.sourceColumn)
        try writer["TargetMultiMeasureAttributeName"].write(value.targetMultiMeasureAttributeName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.MultiMeasureAttributeMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.MultiMeasureAttributeMapping()
        value.sourceColumn = try reader["SourceColumn"].readIfPresent() ?? ""
        value.targetMultiMeasureAttributeName = try reader["TargetMultiMeasureAttributeName"].readIfPresent()
        value.measureValueType = try reader["MeasureValueType"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.MultiMeasureMappings {

    static func write(value: TimestreamWriteClientTypes.MultiMeasureMappings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MultiMeasureAttributeMappings"].writeList(value.multiMeasureAttributeMappings, memberWritingClosure: TimestreamWriteClientTypes.MultiMeasureAttributeMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetMultiMeasureName"].write(value.targetMultiMeasureName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.MultiMeasureMappings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.MultiMeasureMappings()
        value.targetMultiMeasureName = try reader["TargetMultiMeasureName"].readIfPresent()
        value.multiMeasureAttributeMappings = try reader["MultiMeasureAttributeMappings"].readListIfPresent(memberReadingClosure: TimestreamWriteClientTypes.MultiMeasureAttributeMapping.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TimestreamWriteClientTypes.DimensionMapping {

    static func write(value: TimestreamWriteClientTypes.DimensionMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationColumn"].write(value.destinationColumn)
        try writer["SourceColumn"].write(value.sourceColumn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.DimensionMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.DimensionMapping()
        value.sourceColumn = try reader["SourceColumn"].readIfPresent()
        value.destinationColumn = try reader["DestinationColumn"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.ReportConfiguration {

    static func write(value: TimestreamWriteClientTypes.ReportConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReportS3Configuration"].write(value.reportS3Configuration, with: TimestreamWriteClientTypes.ReportS3Configuration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.ReportConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.ReportConfiguration()
        value.reportS3Configuration = try reader["ReportS3Configuration"].readIfPresent(with: TimestreamWriteClientTypes.ReportS3Configuration.read(from:))
        return value
    }
}

extension TimestreamWriteClientTypes.ReportS3Configuration {

    static func write(value: TimestreamWriteClientTypes.ReportS3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["EncryptionOption"].write(value.encryptionOption)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["ObjectKeyPrefix"].write(value.objectKeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.ReportS3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.ReportS3Configuration()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.objectKeyPrefix = try reader["ObjectKeyPrefix"].readIfPresent()
        value.encryptionOption = try reader["EncryptionOption"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.BatchLoadProgressReport {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.BatchLoadProgressReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.BatchLoadProgressReport()
        value.recordsProcessed = try reader["RecordsProcessed"].readIfPresent() ?? 0
        value.recordsIngested = try reader["RecordsIngested"].readIfPresent() ?? 0
        value.parseFailures = try reader["ParseFailures"].readIfPresent() ?? 0
        value.recordIngestionFailures = try reader["RecordIngestionFailures"].readIfPresent() ?? 0
        value.fileFailures = try reader["FileFailures"].readIfPresent() ?? 0
        value.bytesMetered = try reader["BytesMetered"].readIfPresent() ?? 0
        return value
    }
}

extension TimestreamWriteClientTypes.DataSourceConfiguration {

    static func write(value: TimestreamWriteClientTypes.DataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CsvConfiguration"].write(value.csvConfiguration, with: TimestreamWriteClientTypes.CsvConfiguration.write(value:to:))
        try writer["DataFormat"].write(value.dataFormat)
        try writer["DataSourceS3Configuration"].write(value.dataSourceS3Configuration, with: TimestreamWriteClientTypes.DataSourceS3Configuration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.DataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.DataSourceConfiguration()
        value.dataSourceS3Configuration = try reader["DataSourceS3Configuration"].readIfPresent(with: TimestreamWriteClientTypes.DataSourceS3Configuration.read(from:))
        value.csvConfiguration = try reader["CsvConfiguration"].readIfPresent(with: TimestreamWriteClientTypes.CsvConfiguration.read(from:))
        value.dataFormat = try reader["DataFormat"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TimestreamWriteClientTypes.CsvConfiguration {

    static func write(value: TimestreamWriteClientTypes.CsvConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnSeparator"].write(value.columnSeparator)
        try writer["EscapeChar"].write(value.escapeChar)
        try writer["NullValue"].write(value.nullValue)
        try writer["QuoteChar"].write(value.quoteChar)
        try writer["TrimWhiteSpace"].write(value.trimWhiteSpace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.CsvConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.CsvConfiguration()
        value.columnSeparator = try reader["ColumnSeparator"].readIfPresent()
        value.escapeChar = try reader["EscapeChar"].readIfPresent()
        value.quoteChar = try reader["QuoteChar"].readIfPresent()
        value.nullValue = try reader["NullValue"].readIfPresent()
        value.trimWhiteSpace = try reader["TrimWhiteSpace"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.DataSourceS3Configuration {

    static func write(value: TimestreamWriteClientTypes.DataSourceS3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["ObjectKeyPrefix"].write(value.objectKeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.DataSourceS3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.DataSourceS3Configuration()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.objectKeyPrefix = try reader["ObjectKeyPrefix"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.Endpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.Endpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.Endpoint()
        value.address = try reader["Address"].readIfPresent() ?? ""
        value.cachePeriodInMinutes = try reader["CachePeriodInMinutes"].readIfPresent() ?? 0
        return value
    }
}

extension TimestreamWriteClientTypes.BatchLoadTask {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.BatchLoadTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.BatchLoadTask()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resumableUntil = try reader["ResumableUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension TimestreamWriteClientTypes.Tag {

    static func write(value: TimestreamWriteClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension TimestreamWriteClientTypes.RecordsIngested {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.RecordsIngested {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.RecordsIngested()
        value.total = try reader["Total"].readIfPresent() ?? 0
        value.memoryStore = try reader["MemoryStore"].readIfPresent() ?? 0
        value.magneticStore = try reader["MagneticStore"].readIfPresent() ?? 0
        return value
    }
}

extension TimestreamWriteClientTypes.RejectedRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> TimestreamWriteClientTypes.RejectedRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TimestreamWriteClientTypes.RejectedRecord()
        value.recordIndex = try reader["RecordIndex"].readIfPresent() ?? 0
        value.reason = try reader["Reason"].readIfPresent()
        value.existingVersion = try reader["ExistingVersion"].readIfPresent()
        return value
    }
}

extension TimestreamWriteClientTypes.Record {

    static func write(value: TimestreamWriteClientTypes.Record?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: TimestreamWriteClientTypes.Dimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MeasureName"].write(value.measureName)
        try writer["MeasureValue"].write(value.measureValue)
        try writer["MeasureValueType"].write(value.measureValueType)
        try writer["MeasureValues"].writeList(value.measureValues, memberWritingClosure: TimestreamWriteClientTypes.MeasureValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Time"].write(value.time)
        try writer["TimeUnit"].write(value.timeUnit)
        try writer["Version"].write(value.version)
    }
}

extension TimestreamWriteClientTypes.MeasureValue {

    static func write(value: TimestreamWriteClientTypes.MeasureValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }
}

extension TimestreamWriteClientTypes.Dimension {

    static func write(value: TimestreamWriteClientTypes.Dimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionValueType"].write(value.dimensionValueType)
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }
}

public enum TimestreamWriteClientTypes {}
