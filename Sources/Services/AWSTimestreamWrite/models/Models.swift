// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamWriteClientTypes {
    public enum BatchLoadDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchLoadDataFormat] {
            return [
                .csv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchLoadDataFormat(rawValue: rawValue) ?? BatchLoadDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.BatchLoadProgressReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesMetered = "BytesMetered"
        case fileFailures = "FileFailures"
        case parseFailures = "ParseFailures"
        case recordIngestionFailures = "RecordIngestionFailures"
        case recordsIngested = "RecordsIngested"
        case recordsProcessed = "RecordsProcessed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytesMetered != 0 {
            try encodeContainer.encode(bytesMetered, forKey: .bytesMetered)
        }
        if fileFailures != 0 {
            try encodeContainer.encode(fileFailures, forKey: .fileFailures)
        }
        if parseFailures != 0 {
            try encodeContainer.encode(parseFailures, forKey: .parseFailures)
        }
        if recordIngestionFailures != 0 {
            try encodeContainer.encode(recordIngestionFailures, forKey: .recordIngestionFailures)
        }
        if recordsIngested != 0 {
            try encodeContainer.encode(recordsIngested, forKey: .recordsIngested)
        }
        if recordsProcessed != 0 {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed) ?? 0
        recordsProcessed = recordsProcessedDecoded
        let recordsIngestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsIngested) ?? 0
        recordsIngested = recordsIngestedDecoded
        let parseFailuresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parseFailures) ?? 0
        parseFailures = parseFailuresDecoded
        let recordIngestionFailuresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordIngestionFailures) ?? 0
        recordIngestionFailures = recordIngestionFailuresDecoded
        let fileFailuresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileFailures) ?? 0
        fileFailures = fileFailuresDecoded
        let bytesMeteredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesMetered) ?? 0
        bytesMetered = bytesMeteredDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Details about the progress of a batch load task.
    public struct BatchLoadProgressReport: Swift.Equatable {
        ///
        public var bytesMetered: Swift.Int
        ///
        public var fileFailures: Swift.Int
        ///
        public var parseFailures: Swift.Int
        ///
        public var recordIngestionFailures: Swift.Int
        ///
        public var recordsIngested: Swift.Int
        ///
        public var recordsProcessed: Swift.Int

        public init (
            bytesMetered: Swift.Int = 0,
            fileFailures: Swift.Int = 0,
            parseFailures: Swift.Int = 0,
            recordIngestionFailures: Swift.Int = 0,
            recordsIngested: Swift.Int = 0,
            recordsProcessed: Swift.Int = 0
        )
        {
            self.bytesMetered = bytesMetered
            self.fileFailures = fileFailures
            self.parseFailures = parseFailures
            self.recordIngestionFailures = recordIngestionFailures
            self.recordsIngested = recordsIngested
            self.recordsProcessed = recordsProcessed
        }
    }

}

extension TimestreamWriteClientTypes {
    public enum BatchLoadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case inProgress
        case pendingResume
        case progressStopped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchLoadStatus] {
            return [
                .created,
                .failed,
                .inProgress,
                .pendingResume,
                .progressStopped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pendingResume: return "PENDING_RESUME"
            case .progressStopped: return "PROGRESS_STOPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchLoadStatus(rawValue: rawValue) ?? BatchLoadStatus.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.BatchLoadTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case lastUpdatedTime = "LastUpdatedTime"
        case resumableUntil = "ResumableUntil"
        case tableName = "TableName"
        case taskId = "TaskId"
        case taskStatus = "TaskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resumableUntil = self.resumableUntil {
            try encodeContainer.encodeTimestamp(resumableUntil, format: .epochSeconds, forKey: .resumableUntil)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.BatchLoadStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let resumableUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resumableUntil)
        resumableUntil = resumableUntilDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Details about a batch load task.
    public struct BatchLoadTask: Swift.Equatable {
        /// The time when the Timestream batch load task was created.
        public var creationTime: ClientRuntime.Date?
        /// Database name for the database into which a batch load task loads data.
        public var databaseName: Swift.String?
        /// The time when the Timestream batch load task was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        ///
        public var resumableUntil: ClientRuntime.Date?
        /// Table name for the table into which a batch load task loads data.
        public var tableName: Swift.String?
        /// The ID of the batch load task.
        public var taskId: Swift.String?
        /// Status of the batch load task.
        public var taskStatus: TimestreamWriteClientTypes.BatchLoadStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resumableUntil: ClientRuntime.Date? = nil,
            tableName: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: TimestreamWriteClientTypes.BatchLoadStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.resumableUntil = resumableUntil
            self.tableName = tableName
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }

}

extension TimestreamWriteClientTypes.BatchLoadTaskDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataModelConfiguration = "DataModelConfiguration"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case errorMessage = "ErrorMessage"
        case lastUpdatedTime = "LastUpdatedTime"
        case progressReport = "ProgressReport"
        case recordVersion = "RecordVersion"
        case reportConfiguration = "ReportConfiguration"
        case resumableUntil = "ResumableUntil"
        case targetDatabaseName = "TargetDatabaseName"
        case targetTableName = "TargetTableName"
        case taskId = "TaskId"
        case taskStatus = "TaskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataModelConfiguration = self.dataModelConfiguration {
            try encodeContainer.encode(dataModelConfiguration, forKey: .dataModelConfiguration)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let progressReport = self.progressReport {
            try encodeContainer.encode(progressReport, forKey: .progressReport)
        }
        if recordVersion != 0 {
            try encodeContainer.encode(recordVersion, forKey: .recordVersion)
        }
        if let reportConfiguration = self.reportConfiguration {
            try encodeContainer.encode(reportConfiguration, forKey: .reportConfiguration)
        }
        if let resumableUntil = self.resumableUntil {
            try encodeContainer.encodeTimestamp(resumableUntil, format: .epochSeconds, forKey: .resumableUntil)
        }
        if let targetDatabaseName = self.targetDatabaseName {
            try encodeContainer.encode(targetDatabaseName, forKey: .targetDatabaseName)
        }
        if let targetTableName = self.targetTableName {
            try encodeContainer.encode(targetTableName, forKey: .targetTableName)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let progressReportDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.BatchLoadProgressReport.self, forKey: .progressReport)
        progressReport = progressReportDecoded
        let reportConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.ReportConfiguration.self, forKey: .reportConfiguration)
        reportConfiguration = reportConfigurationDecoded
        let dataModelConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DataModelConfiguration.self, forKey: .dataModelConfiguration)
        dataModelConfiguration = dataModelConfigurationDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetTableName)
        targetTableName = targetTableNameDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.BatchLoadStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let recordVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordVersion) ?? 0
        recordVersion = recordVersionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let resumableUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resumableUntil)
        resumableUntil = resumableUntilDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Details about a batch load task.
    public struct BatchLoadTaskDescription: Swift.Equatable {
        /// The time when the Timestream batch load task was created.
        public var creationTime: ClientRuntime.Date?
        /// Data model configuration for a batch load task. This contains details about where a data model for a batch load task is stored.
        public var dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration?
        /// Configuration details about the data source for a batch load task.
        public var dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration?
        ///
        public var errorMessage: Swift.String?
        /// The time when the Timestream batch load task was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        ///
        public var progressReport: TimestreamWriteClientTypes.BatchLoadProgressReport?
        ///
        public var recordVersion: Swift.Int
        /// Report configuration for a batch load task. This contains details about where error reports are stored.
        public var reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration?
        ///
        public var resumableUntil: ClientRuntime.Date?
        ///
        public var targetDatabaseName: Swift.String?
        ///
        public var targetTableName: Swift.String?
        /// The ID of the batch load task.
        public var taskId: Swift.String?
        /// Status of the batch load task.
        public var taskStatus: TimestreamWriteClientTypes.BatchLoadStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration? = nil,
            dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            progressReport: TimestreamWriteClientTypes.BatchLoadProgressReport? = nil,
            recordVersion: Swift.Int = 0,
            reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration? = nil,
            resumableUntil: ClientRuntime.Date? = nil,
            targetDatabaseName: Swift.String? = nil,
            targetTableName: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: TimestreamWriteClientTypes.BatchLoadStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.dataModelConfiguration = dataModelConfiguration
            self.dataSourceConfiguration = dataSourceConfiguration
            self.errorMessage = errorMessage
            self.lastUpdatedTime = lastUpdatedTime
            self.progressReport = progressReport
            self.recordVersion = recordVersion
            self.reportConfiguration = reportConfiguration
            self.resumableUntil = resumableUntil
            self.targetDatabaseName = targetDatabaseName
            self.targetTableName = targetTableName
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Timestream was unable to process this request because it contains resource that already exists.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateBatchLoadTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBatchLoadTaskInput(dataModelConfiguration: \(Swift.String(describing: dataModelConfiguration)), dataSourceConfiguration: \(Swift.String(describing: dataSourceConfiguration)), recordVersion: \(Swift.String(describing: recordVersion)), reportConfiguration: \(Swift.String(describing: reportConfiguration)), targetDatabaseName: \(Swift.String(describing: targetDatabaseName)), targetTableName: \(Swift.String(describing: targetTableName)), clientToken: \"CONTENT_REDACTED\")"}
}

extension CreateBatchLoadTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataModelConfiguration = "DataModelConfiguration"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case recordVersion = "RecordVersion"
        case reportConfiguration = "ReportConfiguration"
        case targetDatabaseName = "TargetDatabaseName"
        case targetTableName = "TargetTableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataModelConfiguration = self.dataModelConfiguration {
            try encodeContainer.encode(dataModelConfiguration, forKey: .dataModelConfiguration)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let recordVersion = self.recordVersion {
            try encodeContainer.encode(recordVersion, forKey: .recordVersion)
        }
        if let reportConfiguration = self.reportConfiguration {
            try encodeContainer.encode(reportConfiguration, forKey: .reportConfiguration)
        }
        if let targetDatabaseName = self.targetDatabaseName {
            try encodeContainer.encode(targetDatabaseName, forKey: .targetDatabaseName)
        }
        if let targetTableName = self.targetTableName {
            try encodeContainer.encode(targetTableName, forKey: .targetTableName)
        }
    }
}

extension CreateBatchLoadTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBatchLoadTaskInput: Swift.Equatable {
    ///
    public var clientToken: Swift.String?
    ///
    public var dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration?
    /// Defines configuration details about the data source for a batch load task.
    /// This member is required.
    public var dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration?
    ///
    public var recordVersion: Swift.Int?
    /// Report configuration for a batch load task. This contains details about where error reports are stored.
    /// This member is required.
    public var reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration?
    /// Target Timestream database for a batch load task.
    /// This member is required.
    public var targetDatabaseName: Swift.String?
    /// Target Timestream table for a batch load task.
    /// This member is required.
    public var targetTableName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration? = nil,
        dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration? = nil,
        recordVersion: Swift.Int? = nil,
        reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetTableName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataModelConfiguration = dataModelConfiguration
        self.dataSourceConfiguration = dataSourceConfiguration
        self.recordVersion = recordVersion
        self.reportConfiguration = reportConfiguration
        self.targetDatabaseName = targetDatabaseName
        self.targetTableName = targetTableName
    }
}

struct CreateBatchLoadTaskInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let dataModelConfiguration: TimestreamWriteClientTypes.DataModelConfiguration?
    let dataSourceConfiguration: TimestreamWriteClientTypes.DataSourceConfiguration?
    let reportConfiguration: TimestreamWriteClientTypes.ReportConfiguration?
    let targetDatabaseName: Swift.String?
    let targetTableName: Swift.String?
    let recordVersion: Swift.Int?
}

extension CreateBatchLoadTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataModelConfiguration = "DataModelConfiguration"
        case dataSourceConfiguration = "DataSourceConfiguration"
        case recordVersion = "RecordVersion"
        case reportConfiguration = "ReportConfiguration"
        case targetDatabaseName = "TargetDatabaseName"
        case targetTableName = "TargetTableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let dataModelConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DataModelConfiguration.self, forKey: .dataModelConfiguration)
        dataModelConfiguration = dataModelConfigurationDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let reportConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.ReportConfiguration.self, forKey: .reportConfiguration)
        reportConfiguration = reportConfigurationDecoded
        let targetDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetDatabaseName)
        targetDatabaseName = targetDatabaseNameDecoded
        let targetTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetTableName)
        targetTableName = targetTableNameDecoded
        let recordVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordVersion)
        recordVersion = recordVersionDecoded
    }
}

extension CreateBatchLoadTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBatchLoadTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBatchLoadTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBatchLoadTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBatchLoadTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct CreateBatchLoadTaskOutputResponse: Swift.Equatable {
    /// The ID of the batch load task.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CreateBatchLoadTaskOutputResponseBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension CreateBatchLoadTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension CreateDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatabaseInput: Swift.Equatable {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The KMS key for the database. If the KMS key is not specified, the database will be encrypted with a Timestream managed KMS key located in your account. For more information, see [Amazon Web Services managed keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
    public var kmsKeyId: Swift.String?
    /// A list of key-value pairs to label the table.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        databaseName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
        self.tags = tags
    }
}

struct CreateDatabaseInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [TimestreamWriteClientTypes.Tag]?
}

extension CreateDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct CreateDatabaseOutputResponse: Swift.Equatable {
    /// The newly created Timestream database.
    public var database: TimestreamWriteClientTypes.Database?

    public init (
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct CreateDatabaseOutputResponseBody: Swift.Equatable {
    let database: TimestreamWriteClientTypes.Database?
}

extension CreateDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

extension CreateTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let magneticStoreWriteProperties = self.magneticStoreWriteProperties {
            try encodeContainer.encode(magneticStoreWriteProperties, forKey: .magneticStoreWriteProperties)
        }
        if let retentionProperties = self.retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTableInput: Swift.Equatable {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Contains properties to set on the table when enabling magnetic store writes.
    public var magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
    /// The duration for which your time-series data must be stored in the memory store and the magnetic store.
    public var retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?
    /// A list of key-value pairs to label the table.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        databaseName: Swift.String? = nil,
        magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties? = nil,
        retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
        tableName: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.magneticStoreWriteProperties = magneticStoreWriteProperties
        self.retentionProperties = retentionProperties
        self.tableName = tableName
        self.tags = tags
    }
}

struct CreateTableInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    let tags: [TimestreamWriteClientTypes.Tag]?
    let magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
}

extension CreateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let magneticStoreWritePropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MagneticStoreWriteProperties.self, forKey: .magneticStoreWriteProperties)
        magneticStoreWriteProperties = magneticStoreWritePropertiesDecoded
    }
}

extension CreateTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct CreateTableOutputResponse: Swift.Equatable {
    /// The newly created Timestream table.
    public var table: TimestreamWriteClientTypes.Table?

    public init (
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

struct CreateTableOutputResponseBody: Swift.Equatable {
    let table: TimestreamWriteClientTypes.Table?
}

extension CreateTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case table = "Table"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension TimestreamWriteClientTypes.CsvConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnSeparator = "ColumnSeparator"
        case escapeChar = "EscapeChar"
        case nullValue = "NullValue"
        case quoteChar = "QuoteChar"
        case trimWhiteSpace = "TrimWhiteSpace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnSeparator = self.columnSeparator {
            try encodeContainer.encode(columnSeparator, forKey: .columnSeparator)
        }
        if let escapeChar = self.escapeChar {
            try encodeContainer.encode(escapeChar, forKey: .escapeChar)
        }
        if let nullValue = self.nullValue {
            try encodeContainer.encode(nullValue, forKey: .nullValue)
        }
        if let quoteChar = self.quoteChar {
            try encodeContainer.encode(quoteChar, forKey: .quoteChar)
        }
        if let trimWhiteSpace = self.trimWhiteSpace {
            try encodeContainer.encode(trimWhiteSpace, forKey: .trimWhiteSpace)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnSeparatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnSeparator)
        columnSeparator = columnSeparatorDecoded
        let escapeCharDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .escapeChar)
        escapeChar = escapeCharDecoded
        let quoteCharDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteChar)
        quoteChar = quoteCharDecoded
        let nullValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nullValue)
        nullValue = nullValueDecoded
        let trimWhiteSpaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimWhiteSpace)
        trimWhiteSpace = trimWhiteSpaceDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// A delimited data format where the column separator can be a comma and the record separator is a newline character.
    public struct CsvConfiguration: Swift.Equatable {
        /// Column separator can be one of comma (','), pipe ('|), semicolon (';'), tab('/t'), or blank space (' ').
        public var columnSeparator: Swift.String?
        /// Escape character can be one of
        public var escapeChar: Swift.String?
        /// Can be blank space (' ').
        public var nullValue: Swift.String?
        /// Can be single quote (') or double quote (").
        public var quoteChar: Swift.String?
        /// Specifies to trim leading and trailing white space.
        public var trimWhiteSpace: Swift.Bool?

        public init (
            columnSeparator: Swift.String? = nil,
            escapeChar: Swift.String? = nil,
            nullValue: Swift.String? = nil,
            quoteChar: Swift.String? = nil,
            trimWhiteSpace: Swift.Bool? = nil
        )
        {
            self.columnSeparator = columnSeparator
            self.escapeChar = escapeChar
            self.nullValue = nullValue
            self.quoteChar = quoteChar
            self.trimWhiteSpace = trimWhiteSpace
        }
    }

}

extension TimestreamWriteClientTypes.DataModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionMappings = "DimensionMappings"
        case measureNameColumn = "MeasureNameColumn"
        case mixedMeasureMappings = "MixedMeasureMappings"
        case multiMeasureMappings = "MultiMeasureMappings"
        case timeColumn = "TimeColumn"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionMappings = dimensionMappings {
            var dimensionMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionMappings)
            for dimensionmapping0 in dimensionMappings {
                try dimensionMappingsContainer.encode(dimensionmapping0)
            }
        }
        if let measureNameColumn = self.measureNameColumn {
            try encodeContainer.encode(measureNameColumn, forKey: .measureNameColumn)
        }
        if let mixedMeasureMappings = mixedMeasureMappings {
            var mixedMeasureMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mixedMeasureMappings)
            for mixedmeasuremapping0 in mixedMeasureMappings {
                try mixedMeasureMappingsContainer.encode(mixedmeasuremapping0)
            }
        }
        if let multiMeasureMappings = self.multiMeasureMappings {
            try encodeContainer.encode(multiMeasureMappings, forKey: .multiMeasureMappings)
        }
        if let timeColumn = self.timeColumn {
            try encodeContainer.encode(timeColumn, forKey: .timeColumn)
        }
        if let timeUnit = self.timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeColumn)
        timeColumn = timeColumnDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let dimensionMappingsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.DimensionMapping?].self, forKey: .dimensionMappings)
        var dimensionMappingsDecoded0:[TimestreamWriteClientTypes.DimensionMapping]? = nil
        if let dimensionMappingsContainer = dimensionMappingsContainer {
            dimensionMappingsDecoded0 = [TimestreamWriteClientTypes.DimensionMapping]()
            for structure0 in dimensionMappingsContainer {
                if let structure0 = structure0 {
                    dimensionMappingsDecoded0?.append(structure0)
                }
            }
        }
        dimensionMappings = dimensionMappingsDecoded0
        let multiMeasureMappingsDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MultiMeasureMappings.self, forKey: .multiMeasureMappings)
        multiMeasureMappings = multiMeasureMappingsDecoded
        let mixedMeasureMappingsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.MixedMeasureMapping?].self, forKey: .mixedMeasureMappings)
        var mixedMeasureMappingsDecoded0:[TimestreamWriteClientTypes.MixedMeasureMapping]? = nil
        if let mixedMeasureMappingsContainer = mixedMeasureMappingsContainer {
            mixedMeasureMappingsDecoded0 = [TimestreamWriteClientTypes.MixedMeasureMapping]()
            for structure0 in mixedMeasureMappingsContainer {
                if let structure0 = structure0 {
                    mixedMeasureMappingsDecoded0?.append(structure0)
                }
            }
        }
        mixedMeasureMappings = mixedMeasureMappingsDecoded0
        let measureNameColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureNameColumn)
        measureNameColumn = measureNameColumnDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Data model for a batch load task.
    public struct DataModel: Swift.Equatable {
        /// Source to target mappings for dimensions.
        /// This member is required.
        public var dimensionMappings: [TimestreamWriteClientTypes.DimensionMapping]?
        ///
        public var measureNameColumn: Swift.String?
        /// Source to target mappings for measures.
        public var mixedMeasureMappings: [TimestreamWriteClientTypes.MixedMeasureMapping]?
        /// Source to target mappings for multi-measure records.
        public var multiMeasureMappings: TimestreamWriteClientTypes.MultiMeasureMappings?
        /// Source column to be mapped to time.
        public var timeColumn: Swift.String?
        /// The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds, or other supported values. Default is MILLISECONDS.
        public var timeUnit: TimestreamWriteClientTypes.TimeUnit?

        public init (
            dimensionMappings: [TimestreamWriteClientTypes.DimensionMapping]? = nil,
            measureNameColumn: Swift.String? = nil,
            mixedMeasureMappings: [TimestreamWriteClientTypes.MixedMeasureMapping]? = nil,
            multiMeasureMappings: TimestreamWriteClientTypes.MultiMeasureMappings? = nil,
            timeColumn: Swift.String? = nil,
            timeUnit: TimestreamWriteClientTypes.TimeUnit? = nil
        )
        {
            self.dimensionMappings = dimensionMappings
            self.measureNameColumn = measureNameColumn
            self.mixedMeasureMappings = mixedMeasureMappings
            self.multiMeasureMappings = multiMeasureMappings
            self.timeColumn = timeColumn
            self.timeUnit = timeUnit
        }
    }

}

extension TimestreamWriteClientTypes.DataModelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataModel = "DataModel"
        case dataModelS3Configuration = "DataModelS3Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataModel = self.dataModel {
            try encodeContainer.encode(dataModel, forKey: .dataModel)
        }
        if let dataModelS3Configuration = self.dataModelS3Configuration {
            try encodeContainer.encode(dataModelS3Configuration, forKey: .dataModelS3Configuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataModelDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DataModel.self, forKey: .dataModel)
        dataModel = dataModelDecoded
        let dataModelS3ConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DataModelS3Configuration.self, forKey: .dataModelS3Configuration)
        dataModelS3Configuration = dataModelS3ConfigurationDecoded
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct DataModelConfiguration: Swift.Equatable {
        ///
        public var dataModel: TimestreamWriteClientTypes.DataModel?
        ///
        public var dataModelS3Configuration: TimestreamWriteClientTypes.DataModelS3Configuration?

        public init (
            dataModel: TimestreamWriteClientTypes.DataModel? = nil,
            dataModelS3Configuration: TimestreamWriteClientTypes.DataModelS3Configuration? = nil
        )
        {
            self.dataModel = dataModel
            self.dataModelS3Configuration = dataModelS3Configuration
        }
    }

}

extension TimestreamWriteClientTypes.DataModelS3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct DataModelS3Configuration: Swift.Equatable {
        ///
        public var bucketName: Swift.String?
        ///
        public var objectKey: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension TimestreamWriteClientTypes.DataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvConfiguration = "CsvConfiguration"
        case dataFormat = "DataFormat"
        case dataSourceS3Configuration = "DataSourceS3Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvConfiguration = self.csvConfiguration {
            try encodeContainer.encode(csvConfiguration, forKey: .csvConfiguration)
        }
        if let dataFormat = self.dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataSourceS3Configuration = self.dataSourceS3Configuration {
            try encodeContainer.encode(dataSourceS3Configuration, forKey: .dataSourceS3Configuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceS3ConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DataSourceS3Configuration.self, forKey: .dataSourceS3Configuration)
        dataSourceS3Configuration = dataSourceS3ConfigurationDecoded
        let csvConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.CsvConfiguration.self, forKey: .csvConfiguration)
        csvConfiguration = csvConfigurationDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.BatchLoadDataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Defines configuration details about the data source.
    public struct DataSourceConfiguration: Swift.Equatable {
        /// A delimited data format where the column separator can be a comma and the record separator is a newline character.
        public var csvConfiguration: TimestreamWriteClientTypes.CsvConfiguration?
        /// This is currently CSV.
        /// This member is required.
        public var dataFormat: TimestreamWriteClientTypes.BatchLoadDataFormat?
        /// Configuration of an S3 location for a file which contains data to load.
        /// This member is required.
        public var dataSourceS3Configuration: TimestreamWriteClientTypes.DataSourceS3Configuration?

        public init (
            csvConfiguration: TimestreamWriteClientTypes.CsvConfiguration? = nil,
            dataFormat: TimestreamWriteClientTypes.BatchLoadDataFormat? = nil,
            dataSourceS3Configuration: TimestreamWriteClientTypes.DataSourceS3Configuration? = nil
        )
        {
            self.csvConfiguration = csvConfiguration
            self.dataFormat = dataFormat
            self.dataSourceS3Configuration = dataSourceS3Configuration
        }
    }

}

extension TimestreamWriteClientTypes.DataSourceS3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKeyPrefix = "ObjectKeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKeyPrefix = self.objectKeyPrefix {
            try encodeContainer.encode(objectKeyPrefix, forKey: .objectKeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKeyPrefix)
        objectKeyPrefix = objectKeyPrefixDecoded
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct DataSourceS3Configuration: Swift.Equatable {
        /// The bucket name of the customer S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        ///
        public var objectKeyPrefix: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension TimestreamWriteClientTypes.Database: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case lastUpdatedTime = "LastUpdatedTime"
        case tableCount = "TableCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if tableCount != 0 {
            try encodeContainer.encode(tableCount, forKey: .tableCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tableCount) ?? 0
        tableCount = tableCountDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// A top-level container for a table. Databases and tables are the fundamental management concepts in Amazon Timestream. All tables in a database are encrypted with the same KMS key.
    public struct Database: Swift.Equatable {
        /// The Amazon Resource Name that uniquely identifies this database.
        public var arn: Swift.String?
        /// The time when the database was created, calculated from the Unix epoch time.
        public var creationTime: ClientRuntime.Date?
        /// The name of the Timestream database.
        public var databaseName: Swift.String?
        /// The identifier of the KMS key used to encrypt the data stored in the database.
        public var kmsKeyId: Swift.String?
        /// The last time that this database was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The total number of tables found within a Timestream database.
        public var tableCount: Swift.Int

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            tableCount: Swift.Int = 0
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
            self.lastUpdatedTime = lastUpdatedTime
            self.tableCount = tableCount
        }
    }

}

extension DeleteDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

extension DeleteDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatabaseInput: Swift.Equatable {
    /// The name of the Timestream database to be deleted.
    /// This member is required.
    public var databaseName: Swift.String?

    public init (
        databaseName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

struct DeleteDatabaseInputBody: Swift.Equatable {
    let databaseName: Swift.String?
}

extension DeleteDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DeleteDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatabaseOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension DeleteTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTableInput: Swift.Equatable {
    /// The name of the database where the Timestream database is to be deleted.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the Timestream table to be deleted.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct DeleteTableInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let tableName: Swift.String?
}

extension DeleteTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DeleteTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTableOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeBatchLoadTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

extension DescribeBatchLoadTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBatchLoadTaskInput: Swift.Equatable {
    /// The ID of the batch load task.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeBatchLoadTaskInputBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension DescribeBatchLoadTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension DescribeBatchLoadTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBatchLoadTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBatchLoadTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBatchLoadTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBatchLoadTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchLoadTaskDescription = output.batchLoadTaskDescription
        } else {
            self.batchLoadTaskDescription = nil
        }
    }
}

public struct DescribeBatchLoadTaskOutputResponse: Swift.Equatable {
    /// Description of the batch load task.
    /// This member is required.
    public var batchLoadTaskDescription: TimestreamWriteClientTypes.BatchLoadTaskDescription?

    public init (
        batchLoadTaskDescription: TimestreamWriteClientTypes.BatchLoadTaskDescription? = nil
    )
    {
        self.batchLoadTaskDescription = batchLoadTaskDescription
    }
}

struct DescribeBatchLoadTaskOutputResponseBody: Swift.Equatable {
    let batchLoadTaskDescription: TimestreamWriteClientTypes.BatchLoadTaskDescription?
}

extension DescribeBatchLoadTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchLoadTaskDescription = "BatchLoadTaskDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchLoadTaskDescriptionDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.BatchLoadTaskDescription.self, forKey: .batchLoadTaskDescription)
        batchLoadTaskDescription = batchLoadTaskDescriptionDecoded
    }
}

extension DescribeDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

extension DescribeDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatabaseInput: Swift.Equatable {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?

    public init (
        databaseName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

struct DescribeDatabaseInputBody: Swift.Equatable {
    let databaseName: Swift.String?
}

extension DescribeDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DescribeDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct DescribeDatabaseOutputResponse: Swift.Equatable {
    /// The name of the Timestream table.
    public var database: TimestreamWriteClientTypes.Database?

    public init (
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct DescribeDatabaseOutputResponseBody: Swift.Equatable {
    let database: TimestreamWriteClientTypes.Database?
}

extension DescribeDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

extension DescribeEndpointsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEndpointsInput: Swift.Equatable {

    public init () { }
}

struct DescribeEndpointsInputBody: Swift.Equatable {
}

extension DescribeEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
        } else {
            self.endpoints = nil
        }
    }
}

public struct DescribeEndpointsOutputResponse: Swift.Equatable {
    /// An Endpoints object is returned when a DescribeEndpoints request is made.
    /// This member is required.
    public var endpoints: [TimestreamWriteClientTypes.Endpoint]?

    public init (
        endpoints: [TimestreamWriteClientTypes.Endpoint]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

struct DescribeEndpointsOutputResponseBody: Swift.Equatable {
    let endpoints: [TimestreamWriteClientTypes.Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[TimestreamWriteClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [TimestreamWriteClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension DescribeTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension DescribeTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTableInput: Swift.Equatable {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct DescribeTableInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let tableName: Swift.String?
}

extension DescribeTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DescribeTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct DescribeTableOutputResponse: Swift.Equatable {
    /// The Timestream table.
    public var table: TimestreamWriteClientTypes.Table?

    public init (
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

struct DescribeTableOutputResponseBody: Swift.Equatable {
    let table: TimestreamWriteClientTypes.Table?
}

extension DescribeTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case table = "Table"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension TimestreamWriteClientTypes.Dimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValueType = "DimensionValueType"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionValueType = self.dimensionValueType {
            try encodeContainer.encode(dimensionValueType.rawValue, forKey: .dimensionValueType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let dimensionValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DimensionValueType.self, forKey: .dimensionValueType)
        dimensionValueType = dimensionValueTypeDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Represents the metadata attributes of the time series. For example, the name and Availability Zone of an EC2 instance or the name of the manufacturer of a wind turbine are dimensions.
    public struct Dimension: Swift.Equatable {
        /// The data type of the dimension for the time-series data point.
        public var dimensionValueType: TimestreamWriteClientTypes.DimensionValueType?
        /// Dimension represents the metadata attributes of the time series. For example, the name and Availability Zone of an EC2 instance or the name of the manufacturer of a wind turbine are dimensions. For constraints on dimension names, see [Naming Constraints](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html#limits.naming).
        /// This member is required.
        public var name: Swift.String?
        /// The value of the dimension.
        /// This member is required.
        public var value: Swift.String?

        public init (
            dimensionValueType: TimestreamWriteClientTypes.DimensionValueType? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimensionValueType = dimensionValueType
            self.name = name
            self.value = value
        }
    }

}

extension TimestreamWriteClientTypes.DimensionMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationColumn = "DestinationColumn"
        case sourceColumn = "SourceColumn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationColumn = self.destinationColumn {
            try encodeContainer.encode(destinationColumn, forKey: .destinationColumn)
        }
        if let sourceColumn = self.sourceColumn {
            try encodeContainer.encode(sourceColumn, forKey: .sourceColumn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceColumn)
        sourceColumn = sourceColumnDecoded
        let destinationColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationColumn)
        destinationColumn = destinationColumnDecoded
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct DimensionMapping: Swift.Equatable {
        ///
        public var destinationColumn: Swift.String?
        ///
        public var sourceColumn: Swift.String?

        public init (
            destinationColumn: Swift.String? = nil,
            sourceColumn: Swift.String? = nil
        )
        {
            self.destinationColumn = destinationColumn
            self.sourceColumn = sourceColumn
        }
    }

}

extension TimestreamWriteClientTypes {
    public enum DimensionValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionValueType] {
            return [
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionValueType(rawValue: rawValue) ?? DimensionValueType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case cachePeriodInMinutes = "CachePeriodInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if cachePeriodInMinutes != 0 {
            try encodeContainer.encode(cachePeriodInMinutes, forKey: .cachePeriodInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let cachePeriodInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cachePeriodInMinutes) ?? 0
        cachePeriodInMinutes = cachePeriodInMinutesDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Represents an available endpoint against which to make API calls against, as well as the TTL for that endpoint.
    public struct Endpoint: Swift.Equatable {
        /// An endpoint address.
        /// This member is required.
        public var address: Swift.String?
        /// The TTL for the endpoint, in minutes.
        /// This member is required.
        public var cachePeriodInMinutes: Swift.Int

        public init (
            address: Swift.String? = nil,
            cachePeriodInMinutes: Swift.Int = 0
        )
        {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Timestream was unable to fully process this request because of an internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested endpoint was not valid.
public struct InvalidEndpointException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEndpointExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBatchLoadTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskStatus = "TaskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }
}

extension ListBatchLoadTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBatchLoadTasksInput: Swift.Equatable {
    /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// Status of the batch load task.
    public var taskStatus: TimestreamWriteClientTypes.BatchLoadStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        taskStatus: TimestreamWriteClientTypes.BatchLoadStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskStatus = taskStatus
    }
}

struct ListBatchLoadTasksInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let taskStatus: TimestreamWriteClientTypes.BatchLoadStatus?
}

extension ListBatchLoadTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskStatus = "TaskStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.BatchLoadStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
    }
}

extension ListBatchLoadTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBatchLoadTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBatchLoadTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBatchLoadTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBatchLoadTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchLoadTasks = output.batchLoadTasks
            self.nextToken = output.nextToken
        } else {
            self.batchLoadTasks = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchLoadTasksOutputResponse: Swift.Equatable {
    /// A list of batch load task details.
    public var batchLoadTasks: [TimestreamWriteClientTypes.BatchLoadTask]?
    /// A token to specify where to start paginating. Provide the next ListBatchLoadTasksRequest.
    public var nextToken: Swift.String?

    public init (
        batchLoadTasks: [TimestreamWriteClientTypes.BatchLoadTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchLoadTasks = batchLoadTasks
        self.nextToken = nextToken
    }
}

struct ListBatchLoadTasksOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let batchLoadTasks: [TimestreamWriteClientTypes.BatchLoadTask]?
}

extension ListBatchLoadTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchLoadTasks = "BatchLoadTasks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let batchLoadTasksContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.BatchLoadTask?].self, forKey: .batchLoadTasks)
        var batchLoadTasksDecoded0:[TimestreamWriteClientTypes.BatchLoadTask]? = nil
        if let batchLoadTasksContainer = batchLoadTasksContainer {
            batchLoadTasksDecoded0 = [TimestreamWriteClientTypes.BatchLoadTask]()
            for structure0 in batchLoadTasksContainer {
                if let structure0 = structure0 {
                    batchLoadTasksDecoded0?.append(structure0)
                }
            }
        }
        batchLoadTasks = batchLoadTasksDecoded0
    }
}

extension ListDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatabasesInput: Swift.Equatable {
    /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatabasesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Swift.Equatable {
    /// A list of database names.
    public var databases: [TimestreamWriteClientTypes.Database]?
    /// The pagination token. This parameter is returned when the response is truncated.
    public var nextToken: Swift.String?

    public init (
        databases: [TimestreamWriteClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Swift.Equatable {
    let databases: [TimestreamWriteClientTypes.Database]?
    let nextToken: Swift.String?
}

extension ListDatabasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Database?].self, forKey: .databases)
        var databasesDecoded0:[TimestreamWriteClientTypes.Database]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [TimestreamWriteClientTypes.Database]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTablesInput: Swift.Equatable {
    /// The name of the Timestream database.
    public var databaseName: Swift.String?
    /// The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTablesInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTablesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTablesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTablesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTablesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTablesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutputResponse: Swift.Equatable {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tables.
    public var tables: [TimestreamWriteClientTypes.Table]?

    public init (
        nextToken: Swift.String? = nil,
        tables: [TimestreamWriteClientTypes.Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputResponseBody: Swift.Equatable {
    let tables: [TimestreamWriteClientTypes.Table]?
    let nextToken: Swift.String?
}

extension ListTablesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tables = "Tables"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Table?].self, forKey: .tables)
        var tablesDecoded0:[TimestreamWriteClientTypes.Table]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [TimestreamWriteClientTypes.Table]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags currently associated with the Timestream resource.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [TimestreamWriteClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Configuration = "S3Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.S3Configuration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// The location to write error reports for records rejected, asynchronously, during magnetic store writes.
    public struct MagneticStoreRejectedDataLocation: Swift.Equatable {
        /// Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes.
        public var s3Configuration: TimestreamWriteClientTypes.S3Configuration?

        public init (
            s3Configuration: TimestreamWriteClientTypes.S3Configuration? = nil
        )
        {
            self.s3Configuration = s3Configuration
        }
    }

}

extension TimestreamWriteClientTypes.MagneticStoreWriteProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableMagneticStoreWrites = "EnableMagneticStoreWrites"
        case magneticStoreRejectedDataLocation = "MagneticStoreRejectedDataLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableMagneticStoreWrites = self.enableMagneticStoreWrites {
            try encodeContainer.encode(enableMagneticStoreWrites, forKey: .enableMagneticStoreWrites)
        }
        if let magneticStoreRejectedDataLocation = self.magneticStoreRejectedDataLocation {
            try encodeContainer.encode(magneticStoreRejectedDataLocation, forKey: .magneticStoreRejectedDataLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableMagneticStoreWritesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMagneticStoreWrites)
        enableMagneticStoreWrites = enableMagneticStoreWritesDecoded
        let magneticStoreRejectedDataLocationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation.self, forKey: .magneticStoreRejectedDataLocation)
        magneticStoreRejectedDataLocation = magneticStoreRejectedDataLocationDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// The set of properties on a table for configuring magnetic store writes.
    public struct MagneticStoreWriteProperties: Swift.Equatable {
        /// A flag to enable magnetic store writes.
        /// This member is required.
        public var enableMagneticStoreWrites: Swift.Bool?
        /// The location to write error reports for records rejected asynchronously during magnetic store writes.
        public var magneticStoreRejectedDataLocation: TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation?

        public init (
            enableMagneticStoreWrites: Swift.Bool? = nil,
            magneticStoreRejectedDataLocation: TimestreamWriteClientTypes.MagneticStoreRejectedDataLocation? = nil
        )
        {
            self.enableMagneticStoreWrites = enableMagneticStoreWrites
            self.magneticStoreRejectedDataLocation = magneticStoreRejectedDataLocation
        }
    }

}

extension TimestreamWriteClientTypes.MeasureValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MeasureValueType.self, forKey: .type)
        type = typeDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures. MeasureValue has both name and value. MeasureValue is only allowed for type MULTI. Using MULTI type, you can pass multiple data attributes associated with the same time series in a single record
    public struct MeasureValue: Swift.Equatable {
        /// The name of the MeasureValue. For constraints on MeasureValue names, see [ Naming Constraints](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html#limits.naming) in the Amazon Timestream Developer Guide.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the data type of the MeasureValue for the time-series data point.
        /// This member is required.
        public var type: TimestreamWriteClientTypes.MeasureValueType?
        /// The value for the MeasureValue.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: TimestreamWriteClientTypes.MeasureValueType? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension TimestreamWriteClientTypes {
    public enum MeasureValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case double
        case multi
        case timestamp
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [MeasureValueType] {
            return [
                .bigint,
                .boolean,
                .double,
                .multi,
                .timestamp,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .multi: return "MULTI"
            case .timestamp: return "TIMESTAMP"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MeasureValueType(rawValue: rawValue) ?? MeasureValueType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.MixedMeasureMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case measureName = "MeasureName"
        case measureValueType = "MeasureValueType"
        case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
        case sourceColumn = "SourceColumn"
        case targetMeasureName = "TargetMeasureName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let measureName = self.measureName {
            try encodeContainer.encode(measureName, forKey: .measureName)
        }
        if let measureValueType = self.measureValueType {
            try encodeContainer.encode(measureValueType.rawValue, forKey: .measureValueType)
        }
        if let multiMeasureAttributeMappings = multiMeasureAttributeMappings {
            var multiMeasureAttributeMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .multiMeasureAttributeMappings)
            for multimeasureattributemapping0 in multiMeasureAttributeMappings {
                try multiMeasureAttributeMappingsContainer.encode(multimeasureattributemapping0)
            }
        }
        if let sourceColumn = self.sourceColumn {
            try encodeContainer.encode(sourceColumn, forKey: .sourceColumn)
        }
        if let targetMeasureName = self.targetMeasureName {
            try encodeContainer.encode(targetMeasureName, forKey: .targetMeasureName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let measureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureName)
        measureName = measureNameDecoded
        let sourceColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceColumn)
        sourceColumn = sourceColumnDecoded
        let targetMeasureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetMeasureName)
        targetMeasureName = targetMeasureNameDecoded
        let measureValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MeasureValueType.self, forKey: .measureValueType)
        measureValueType = measureValueTypeDecoded
        let multiMeasureAttributeMappingsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.MultiMeasureAttributeMapping?].self, forKey: .multiMeasureAttributeMappings)
        var multiMeasureAttributeMappingsDecoded0:[TimestreamWriteClientTypes.MultiMeasureAttributeMapping]? = nil
        if let multiMeasureAttributeMappingsContainer = multiMeasureAttributeMappingsContainer {
            multiMeasureAttributeMappingsDecoded0 = [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]()
            for structure0 in multiMeasureAttributeMappingsContainer {
                if let structure0 = structure0 {
                    multiMeasureAttributeMappingsDecoded0?.append(structure0)
                }
            }
        }
        multiMeasureAttributeMappings = multiMeasureAttributeMappingsDecoded0
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct MixedMeasureMapping: Swift.Equatable {
        ///
        public var measureName: Swift.String?
        ///
        /// This member is required.
        public var measureValueType: TimestreamWriteClientTypes.MeasureValueType?
        ///
        public var multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]?
        ///
        public var sourceColumn: Swift.String?
        ///
        public var targetMeasureName: Swift.String?

        public init (
            measureName: Swift.String? = nil,
            measureValueType: TimestreamWriteClientTypes.MeasureValueType? = nil,
            multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]? = nil,
            sourceColumn: Swift.String? = nil,
            targetMeasureName: Swift.String? = nil
        )
        {
            self.measureName = measureName
            self.measureValueType = measureValueType
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.sourceColumn = sourceColumn
            self.targetMeasureName = targetMeasureName
        }
    }

}

extension TimestreamWriteClientTypes.MultiMeasureAttributeMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case measureValueType = "MeasureValueType"
        case sourceColumn = "SourceColumn"
        case targetMultiMeasureAttributeName = "TargetMultiMeasureAttributeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let measureValueType = self.measureValueType {
            try encodeContainer.encode(measureValueType.rawValue, forKey: .measureValueType)
        }
        if let sourceColumn = self.sourceColumn {
            try encodeContainer.encode(sourceColumn, forKey: .sourceColumn)
        }
        if let targetMultiMeasureAttributeName = self.targetMultiMeasureAttributeName {
            try encodeContainer.encode(targetMultiMeasureAttributeName, forKey: .targetMultiMeasureAttributeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceColumnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceColumn)
        sourceColumn = sourceColumnDecoded
        let targetMultiMeasureAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetMultiMeasureAttributeName)
        targetMultiMeasureAttributeName = targetMultiMeasureAttributeNameDecoded
        let measureValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.ScalarMeasureValueType.self, forKey: .measureValueType)
        measureValueType = measureValueTypeDecoded
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct MultiMeasureAttributeMapping: Swift.Equatable {
        ///
        public var measureValueType: TimestreamWriteClientTypes.ScalarMeasureValueType?
        ///
        /// This member is required.
        public var sourceColumn: Swift.String?
        ///
        public var targetMultiMeasureAttributeName: Swift.String?

        public init (
            measureValueType: TimestreamWriteClientTypes.ScalarMeasureValueType? = nil,
            sourceColumn: Swift.String? = nil,
            targetMultiMeasureAttributeName: Swift.String? = nil
        )
        {
            self.measureValueType = measureValueType
            self.sourceColumn = sourceColumn
            self.targetMultiMeasureAttributeName = targetMultiMeasureAttributeName
        }
    }

}

extension TimestreamWriteClientTypes.MultiMeasureMappings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multiMeasureAttributeMappings = "MultiMeasureAttributeMappings"
        case targetMultiMeasureName = "TargetMultiMeasureName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multiMeasureAttributeMappings = multiMeasureAttributeMappings {
            var multiMeasureAttributeMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .multiMeasureAttributeMappings)
            for multimeasureattributemapping0 in multiMeasureAttributeMappings {
                try multiMeasureAttributeMappingsContainer.encode(multimeasureattributemapping0)
            }
        }
        if let targetMultiMeasureName = self.targetMultiMeasureName {
            try encodeContainer.encode(targetMultiMeasureName, forKey: .targetMultiMeasureName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetMultiMeasureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetMultiMeasureName)
        targetMultiMeasureName = targetMultiMeasureNameDecoded
        let multiMeasureAttributeMappingsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.MultiMeasureAttributeMapping?].self, forKey: .multiMeasureAttributeMappings)
        var multiMeasureAttributeMappingsDecoded0:[TimestreamWriteClientTypes.MultiMeasureAttributeMapping]? = nil
        if let multiMeasureAttributeMappingsContainer = multiMeasureAttributeMappingsContainer {
            multiMeasureAttributeMappingsDecoded0 = [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]()
            for structure0 in multiMeasureAttributeMappingsContainer {
                if let structure0 = structure0 {
                    multiMeasureAttributeMappingsDecoded0?.append(structure0)
                }
            }
        }
        multiMeasureAttributeMappings = multiMeasureAttributeMappingsDecoded0
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct MultiMeasureMappings: Swift.Equatable {
        ///
        /// This member is required.
        public var multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]?
        ///
        public var targetMultiMeasureName: Swift.String?

        public init (
            multiMeasureAttributeMappings: [TimestreamWriteClientTypes.MultiMeasureAttributeMapping]? = nil,
            targetMultiMeasureName: Swift.String? = nil
        )
        {
            self.multiMeasureAttributeMappings = multiMeasureAttributeMappings
            self.targetMultiMeasureName = targetMultiMeasureName
        }
    }

}

extension TimestreamWriteClientTypes.Record: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case measureName = "MeasureName"
        case measureValue = "MeasureValue"
        case measureValueType = "MeasureValueType"
        case measureValues = "MeasureValues"
        case time = "Time"
        case timeUnit = "TimeUnit"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimension0 in dimensions {
                try dimensionsContainer.encode(dimension0)
            }
        }
        if let measureName = self.measureName {
            try encodeContainer.encode(measureName, forKey: .measureName)
        }
        if let measureValue = self.measureValue {
            try encodeContainer.encode(measureValue, forKey: .measureValue)
        }
        if let measureValueType = self.measureValueType {
            try encodeContainer.encode(measureValueType.rawValue, forKey: .measureValueType)
        }
        if let measureValues = measureValues {
            var measureValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .measureValues)
            for measurevalue0 in measureValues {
                try measureValuesContainer.encode(measurevalue0)
            }
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let timeUnit = self.timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Dimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[TimestreamWriteClientTypes.Dimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [TimestreamWriteClientTypes.Dimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let measureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureName)
        measureName = measureNameDecoded
        let measureValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureValue)
        measureValue = measureValueDecoded
        let measureValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MeasureValueType.self, forKey: .measureValueType)
        measureValueType = measureValueTypeDecoded
        let timeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .time)
        time = timeDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let measureValuesContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.MeasureValue?].self, forKey: .measureValues)
        var measureValuesDecoded0:[TimestreamWriteClientTypes.MeasureValue]? = nil
        if let measureValuesContainer = measureValuesContainer {
            measureValuesDecoded0 = [TimestreamWriteClientTypes.MeasureValue]()
            for structure0 in measureValuesContainer {
                if let structure0 = structure0 {
                    measureValuesDecoded0?.append(structure0)
                }
            }
        }
        measureValues = measureValuesDecoded0
    }
}

extension TimestreamWriteClientTypes {
    /// Represents a time-series data point being written into Timestream. Each record contains an array of dimensions. Dimensions represent the metadata attributes of a time-series data point, such as the instance name or Availability Zone of an EC2 instance. A record also contains the measure name, which is the name of the measure being collected (for example, the CPU utilization of an EC2 instance). Additionally, a record contains the measure value and the value type, which is the data type of the measure value. Also, the record contains the timestamp of when the measure was collected and the timestamp unit, which represents the granularity of the timestamp. Records have a Version field, which is a 64-bit long that you can use for updating data points. Writes of a duplicate record with the same dimension, timestamp, and measure name but different measure value will only succeed if the Version attribute of the record in the write request is higher than that of the existing record. Timestream defaults to a Version of 1 for records without the Version field.
    public struct Record: Swift.Equatable {
        /// Contains the list of dimensions for time-series data points.
        public var dimensions: [TimestreamWriteClientTypes.Dimension]?
        /// Measure represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures.
        public var measureName: Swift.String?
        /// Contains the measure value for the time-series data point.
        public var measureValue: Swift.String?
        /// Contains the data type of the measure value for the time-series data point. Default type is DOUBLE.
        public var measureValueType: TimestreamWriteClientTypes.MeasureValueType?
        /// Contains the list of MeasureValue for time-series data points. This is only allowed for type MULTI. For scalar values, use MeasureValue attribute of the record directly.
        public var measureValues: [TimestreamWriteClientTypes.MeasureValue]?
        /// Contains the time at which the measure value for the data point was collected. The time value plus the unit provides the time elapsed since the epoch. For example, if the time value is 12345 and the unit is ms, then 12345 ms have elapsed since the epoch.
        public var time: Swift.String?
        /// The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds, or other supported values. Default is MILLISECONDS.
        public var timeUnit: TimestreamWriteClientTypes.TimeUnit?
        /// 64-bit attribute used for record updates. Write requests for duplicate data with a higher version number will update the existing measure value and version. In cases where the measure value is the same, Version will still be updated. Default value is 1. Version must be 1 or greater, or you will receive a ValidationException error.
        public var version: Swift.Int?

        public init (
            dimensions: [TimestreamWriteClientTypes.Dimension]? = nil,
            measureName: Swift.String? = nil,
            measureValue: Swift.String? = nil,
            measureValueType: TimestreamWriteClientTypes.MeasureValueType? = nil,
            measureValues: [TimestreamWriteClientTypes.MeasureValue]? = nil,
            time: Swift.String? = nil,
            timeUnit: TimestreamWriteClientTypes.TimeUnit? = nil,
            version: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.measureName = measureName
            self.measureValue = measureValue
            self.measureValueType = measureValueType
            self.measureValues = measureValues
            self.time = time
            self.timeUnit = timeUnit
            self.version = version
        }
    }

}

extension TimestreamWriteClientTypes.RecordsIngested: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case magneticStore = "MagneticStore"
        case memoryStore = "MemoryStore"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if magneticStore != 0 {
            try encodeContainer.encode(magneticStore, forKey: .magneticStore)
        }
        if memoryStore != 0 {
            try encodeContainer.encode(memoryStore, forKey: .memoryStore)
        }
        if total != 0 {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total) ?? 0
        total = totalDecoded
        let memoryStoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryStore) ?? 0
        memoryStore = memoryStoreDecoded
        let magneticStoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .magneticStore) ?? 0
        magneticStore = magneticStoreDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Information on the records ingested by this request.
    public struct RecordsIngested: Swift.Equatable {
        /// Count of records ingested into the magnetic store.
        public var magneticStore: Swift.Int
        /// Count of records ingested into the memory store.
        public var memoryStore: Swift.Int
        /// Total count of successfully ingested records.
        public var total: Swift.Int

        public init (
            magneticStore: Swift.Int = 0,
            memoryStore: Swift.Int = 0,
            total: Swift.Int = 0
        )
        {
            self.magneticStore = magneticStore
            self.memoryStore = memoryStore
            self.total = total
        }
    }

}

extension TimestreamWriteClientTypes.RejectedRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case existingVersion = "ExistingVersion"
        case reason = "Reason"
        case recordIndex = "RecordIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let existingVersion = self.existingVersion {
            try encodeContainer.encode(existingVersion, forKey: .existingVersion)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if recordIndex != 0 {
            try encodeContainer.encode(recordIndex, forKey: .recordIndex)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordIndex) ?? 0
        recordIndex = recordIndexDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let existingVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .existingVersion)
        existingVersion = existingVersionDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Represents records that were not successfully inserted into Timestream due to data validation issues that must be resolved before reinserting time-series data into the system.
    public struct RejectedRecord: Swift.Equatable {
        /// The existing version of the record. This value is populated in scenarios where an identical record exists with a higher version than the version in the write request.
        public var existingVersion: Swift.Int?
        /// The reason why a record was not successfully inserted into Timestream. Possible causes of failure include:
        ///
        /// * Records with duplicate data where there are multiple records with the same dimensions, timestamps, and measure names but:
        ///
        /// * Measure values are different
        ///
        /// * Version is not present in the request, or the value of version in the new record is equal to or lower than the existing value
        ///
        ///
        /// If Timestream rejects data for this case, the ExistingVersion field in the RejectedRecords response will indicate the current record’s version. To force an update, you can resend the request with a version for the record set to a value greater than the ExistingVersion.
        ///
        /// * Records with timestamps that lie outside the retention duration of the memory store. When the retention window is updated, you will receive a RejectedRecords exception if you immediately try to ingest data within the new window. To avoid a RejectedRecords exception, wait until the duration of the new window to ingest new data. For further information, see [ Best Practices for Configuring Timestream](https://docs.aws.amazon.com/timestream/latest/developerguide/best-practices.html#configuration) and [the explanation of how storage works in Timestream](https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html).
        ///
        /// * Records with dimensions or measures that exceed the Timestream defined limits.
        ///
        ///
        /// For more information, see [Access Management](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html) in the Timestream Developer Guide.
        public var reason: Swift.String?
        /// The index of the record in the input request for WriteRecords. Indexes begin with 0.
        public var recordIndex: Swift.Int

        public init (
            existingVersion: Swift.Int? = nil,
            reason: Swift.String? = nil,
            recordIndex: Swift.Int = 0
        )
        {
            self.existingVersion = existingVersion
            self.reason = reason
            self.recordIndex = recordIndex
        }
    }

}

extension RejectedRecordsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RejectedRecordsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.rejectedRecords = output.rejectedRecords
        } else {
            self.message = nil
            self.rejectedRecords = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// WriteRecords would throw this exception in the following cases:
///
/// * Records with duplicate data where there are multiple records with the same dimensions, timestamps, and measure names but:
///
/// * Measure values are different
///
/// * Version is not present in the request or the value of version in the new record is equal to or lower than the existing value
///
///
/// In this case, if Timestream rejects data, the ExistingVersion field in the RejectedRecords response will indicate the current record’s version. To force an update, you can resend the request with a version for the record set to a value greater than the ExistingVersion.
///
/// * Records with timestamps that lie outside the retention duration of the memory store.
///
/// * Records with dimensions or measures that exceed the Timestream defined limits.
///
///
/// For more information, see [Quotas](https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html) in the Amazon Timestream Developer Guide.
public struct RejectedRecordsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    ///
    public var rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]?

    public init (
        message: Swift.String? = nil,
        rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]? = nil
    )
    {
        self.message = message
        self.rejectedRecords = rejectedRecords
    }
}

struct RejectedRecordsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]?
}

extension RejectedRecordsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case rejectedRecords = "RejectedRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let rejectedRecordsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.RejectedRecord?].self, forKey: .rejectedRecords)
        var rejectedRecordsDecoded0:[TimestreamWriteClientTypes.RejectedRecord]? = nil
        if let rejectedRecordsContainer = rejectedRecordsContainer {
            rejectedRecordsDecoded0 = [TimestreamWriteClientTypes.RejectedRecord]()
            for structure0 in rejectedRecordsContainer {
                if let structure0 = structure0 {
                    rejectedRecordsDecoded0?.append(structure0)
                }
            }
        }
        rejectedRecords = rejectedRecordsDecoded0
    }
}

extension TimestreamWriteClientTypes.ReportConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportS3Configuration = "ReportS3Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportS3Configuration = self.reportS3Configuration {
            try encodeContainer.encode(reportS3Configuration, forKey: .reportS3Configuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportS3ConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.ReportS3Configuration.self, forKey: .reportS3Configuration)
        reportS3Configuration = reportS3ConfigurationDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Report configuration for a batch load task. This contains details about where error reports are stored.
    public struct ReportConfiguration: Swift.Equatable {
        /// Configuration of an S3 location to write error reports and events for a batch load.
        public var reportS3Configuration: TimestreamWriteClientTypes.ReportS3Configuration?

        public init (
            reportS3Configuration: TimestreamWriteClientTypes.ReportS3Configuration? = nil
        )
        {
            self.reportS3Configuration = reportS3Configuration
        }
    }

}

extension TimestreamWriteClientTypes.ReportS3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case encryptionOption = "EncryptionOption"
        case kmsKeyId = "KmsKeyId"
        case objectKeyPrefix = "ObjectKeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let encryptionOption = self.encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let objectKeyPrefix = self.objectKeyPrefix {
            try encodeContainer.encode(objectKeyPrefix, forKey: .objectKeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKeyPrefix)
        objectKeyPrefix = objectKeyPrefixDecoded
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.S3EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension TimestreamWriteClientTypes {
    ///
    public struct ReportS3Configuration: Swift.Equatable {
        ///
        /// This member is required.
        public var bucketName: Swift.String?
        ///
        public var encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption?
        ///
        public var kmsKeyId: Swift.String?
        ///
        public var objectKeyPrefix: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption? = nil,
            kmsKeyId: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.kmsKeyId = kmsKeyId
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation tried to access a nonexistent resource. The resource might not be specified correctly, or its status might not be ACTIVE.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResumeBatchLoadTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

extension ResumeBatchLoadTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResumeBatchLoadTaskInput: Swift.Equatable {
    /// The ID of the batch load task to resume.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct ResumeBatchLoadTaskInputBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension ResumeBatchLoadTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension ResumeBatchLoadTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeBatchLoadTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResumeBatchLoadTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeBatchLoadTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResumeBatchLoadTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension TimestreamWriteClientTypes.RetentionProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case magneticStoreRetentionPeriodInDays = "MagneticStoreRetentionPeriodInDays"
        case memoryStoreRetentionPeriodInHours = "MemoryStoreRetentionPeriodInHours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if magneticStoreRetentionPeriodInDays != 0 {
            try encodeContainer.encode(magneticStoreRetentionPeriodInDays, forKey: .magneticStoreRetentionPeriodInDays)
        }
        if memoryStoreRetentionPeriodInHours != 0 {
            try encodeContainer.encode(memoryStoreRetentionPeriodInHours, forKey: .memoryStoreRetentionPeriodInHours)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memoryStoreRetentionPeriodInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryStoreRetentionPeriodInHours) ?? 0
        memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHoursDecoded
        let magneticStoreRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .magneticStoreRetentionPeriodInDays) ?? 0
        magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDaysDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Retention properties contain the duration for which your time-series data must be stored in the magnetic store and the memory store.
    public struct RetentionProperties: Swift.Equatable {
        /// The duration for which data must be stored in the magnetic store.
        /// This member is required.
        public var magneticStoreRetentionPeriodInDays: Swift.Int
        /// The duration for which data must be stored in the memory store.
        /// This member is required.
        public var memoryStoreRetentionPeriodInHours: Swift.Int

        public init (
            magneticStoreRetentionPeriodInDays: Swift.Int = 0,
            memoryStoreRetentionPeriodInHours: Swift.Int = 0
        )
        {
            self.magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDays
            self.memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHours
        }
    }

}

extension TimestreamWriteClientTypes.S3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case encryptionOption = "EncryptionOption"
        case kmsKeyId = "KmsKeyId"
        case objectKeyPrefix = "ObjectKeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let encryptionOption = self.encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let objectKeyPrefix = self.objectKeyPrefix {
            try encodeContainer.encode(objectKeyPrefix, forKey: .objectKeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKeyPrefix)
        objectKeyPrefix = objectKeyPrefixDecoded
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.S3EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// The configuration that specifies an S3 location.
    public struct S3Configuration: Swift.Equatable {
        /// The bucket name of the customer S3 bucket.
        public var bucketName: Swift.String?
        /// The encryption option for the customer S3 location. Options are S3 server-side encryption with an S3 managed key or Amazon Web Services managed key.
        public var encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption?
        /// The KMS key ID for the customer S3 location when encrypting with an Amazon Web Services managed key.
        public var kmsKeyId: Swift.String?
        /// The object key preview for the customer S3 location.
        public var objectKeyPrefix: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            encryptionOption: TimestreamWriteClientTypes.S3EncryptionOption? = nil,
            kmsKeyId: Swift.String? = nil,
            objectKeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.encryptionOption = encryptionOption
            self.kmsKeyId = kmsKeyId
            self.objectKeyPrefix = objectKeyPrefix
        }
    }

}

extension TimestreamWriteClientTypes {
    public enum S3EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [S3EncryptionOption] {
            return [
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3EncryptionOption(rawValue: rawValue) ?? S3EncryptionOption.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes {
    public enum ScalarMeasureValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case double
        case timestamp
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarMeasureValueType] {
            return [
                .bigint,
                .boolean,
                .double,
                .timestamp,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .timestamp: return "TIMESTAMP"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalarMeasureValueType(rawValue: rawValue) ?? ScalarMeasureValueType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The instance quota of resource exceeded for this account.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamWriteClientTypes.Table: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case lastUpdatedTime = "LastUpdatedTime"
        case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tableStatus = "TableStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let magneticStoreWriteProperties = self.magneticStoreWriteProperties {
            try encodeContainer.encode(magneticStoreWriteProperties, forKey: .magneticStoreWriteProperties)
        }
        if let retentionProperties = self.retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableStatus = self.tableStatus {
            try encodeContainer.encode(tableStatus.rawValue, forKey: .tableStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableStatusDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.TableStatus.self, forKey: .tableStatus)
        tableStatus = tableStatusDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let magneticStoreWritePropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MagneticStoreWriteProperties.self, forKey: .magneticStoreWriteProperties)
        magneticStoreWriteProperties = magneticStoreWritePropertiesDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// Represents a database table in Timestream. Tables contain one or more related time series. You can modify the retention duration of the memory store and the magnetic store for a table.
    public struct Table: Swift.Equatable {
        /// The Amazon Resource Name that uniquely identifies this table.
        public var arn: Swift.String?
        /// The time when the Timestream table was created.
        public var creationTime: ClientRuntime.Date?
        /// The name of the Timestream database that contains this table.
        public var databaseName: Swift.String?
        /// The time when the Timestream table was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Contains properties to set on the table when enabling magnetic store writes.
        public var magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
        /// The retention duration for the memory store and magnetic store.
        public var retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
        /// The name of the Timestream table.
        public var tableName: Swift.String?
        /// The current state of the table:
        ///
        /// * DELETING - The table is being deleted.
        ///
        /// * ACTIVE - The table is ready for use.
        public var tableStatus: TimestreamWriteClientTypes.TableStatus?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties? = nil,
            retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
            tableName: Swift.String? = nil,
            tableStatus: TimestreamWriteClientTypes.TableStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.magneticStoreWriteProperties = magneticStoreWriteProperties
            self.retentionProperties = retentionProperties
            self.tableName = tableName
            self.tableStatus = tableStatus
        }
    }

}

extension TimestreamWriteClientTypes {
    public enum TableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case restoring
        case sdkUnknown(Swift.String)

        public static var allCases: [TableStatus] {
            return [
                .active,
                .deleting,
                .restoring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .restoring: return "RESTORING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableStatus(rawValue: rawValue) ?? TableStatus.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimestreamWriteClientTypes {
    /// A tag is a label that you assign to a Timestream database and/or table. Each tag consists of a key and an optional value, both of which you define. With tags, you can categorize databases and/or tables, for example, by purpose, owner, or environment.
    public struct Tag: Swift.Equatable {
        /// The key of the tag. Tag keys are case sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case-sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Identifies the Timestream resource to which tags should be added. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to be assigned to the Timestream resource.
    /// This member is required.
    public var tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [TimestreamWriteClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Too many requests were made by a user and they exceeded the service quotas. The request was throttled.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamWriteClientTypes {
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case microseconds
        case milliseconds
        case nanoseconds
        case seconds
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .microseconds,
                .milliseconds,
                .nanoseconds,
                .seconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .microseconds: return "MICROSECONDS"
            case .milliseconds: return "MILLISECONDS"
            case .nanoseconds: return "NANOSECONDS"
            case .seconds: return "SECONDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Timestream resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags keys. Existing tags of the resource whose keys are members of this list will be removed from the Timestream resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

extension UpdateDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDatabaseInput: Swift.Equatable {
    /// The name of the database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The identifier of the new KMS key (KmsKeyId) to be used to encrypt the data stored in the database. If the KmsKeyId currently registered with the database is the same as the KmsKeyId in the request, there will not be any update. You can specify the KmsKeyId using any of the following:
    ///
    /// * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Key ARN: arn:aws:kms:us-east-1:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Alias name: alias/ExampleAlias
    ///
    /// * Alias ARN: arn:aws:kms:us-east-1:111122223333:alias/ExampleAlias
    /// This member is required.
    public var kmsKeyId: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
    }
}

struct UpdateDatabaseInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let kmsKeyId: Swift.String?
}

extension UpdateDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct UpdateDatabaseOutputResponse: Swift.Equatable {
    /// A top-level container for a table. Databases and tables are the fundamental management concepts in Amazon Timestream. All tables in a database are encrypted with the same KMS key.
    public var database: TimestreamWriteClientTypes.Database?

    public init (
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct UpdateDatabaseOutputResponseBody: Swift.Equatable {
    let database: TimestreamWriteClientTypes.Database?
}

extension UpdateDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

extension UpdateTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let magneticStoreWriteProperties = self.magneticStoreWriteProperties {
            try encodeContainer.encode(magneticStoreWriteProperties, forKey: .magneticStoreWriteProperties)
        }
        if let retentionProperties = self.retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension UpdateTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTableInput: Swift.Equatable {
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Contains properties to set on the table when enabling magnetic store writes.
    public var magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
    /// The retention duration of the memory store and the magnetic store.
    public var retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties? = nil,
        retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.magneticStoreWriteProperties = magneticStoreWriteProperties
        self.retentionProperties = retentionProperties
        self.tableName = tableName
    }
}

struct UpdateTableInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    let magneticStoreWriteProperties: TimestreamWriteClientTypes.MagneticStoreWriteProperties?
}

extension UpdateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case magneticStoreWriteProperties = "MagneticStoreWriteProperties"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
        let magneticStoreWritePropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MagneticStoreWriteProperties.self, forKey: .magneticStoreWriteProperties)
        magneticStoreWriteProperties = magneticStoreWritePropertiesDecoded
    }
}

extension UpdateTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct UpdateTableOutputResponse: Swift.Equatable {
    /// The updated Timestream table.
    public var table: TimestreamWriteClientTypes.Table?

    public init (
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

struct UpdateTableOutputResponseBody: Swift.Equatable {
    let table: TimestreamWriteClientTypes.Table?
}

extension UpdateTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case table = "Table"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid or malformed request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WriteRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonAttributes = "CommonAttributes"
        case databaseName = "DatabaseName"
        case records = "Records"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commonAttributes = self.commonAttributes {
            try encodeContainer.encode(commonAttributes, forKey: .commonAttributes)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for record0 in records {
                try recordsContainer.encode(record0)
            }
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension WriteRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct WriteRecordsInput: Swift.Equatable {
    /// A record that contains the common measure, dimension, time, and version attributes shared across all the records in the request. The measure and dimension attributes specified will be merged with the measure and dimension attributes in the records object when the data is written into Timestream. Dimensions may not overlap, or a ValidationException will be thrown. In other words, a record must contain dimensions with unique names.
    public var commonAttributes: TimestreamWriteClientTypes.Record?
    /// The name of the Timestream database.
    /// This member is required.
    public var databaseName: Swift.String?
    /// An array of records that contain the unique measure, dimension, time, and version attributes for each time-series data point.
    /// This member is required.
    public var records: [TimestreamWriteClientTypes.Record]?
    /// The name of the Timestream table.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        commonAttributes: TimestreamWriteClientTypes.Record? = nil,
        databaseName: Swift.String? = nil,
        records: [TimestreamWriteClientTypes.Record]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.commonAttributes = commonAttributes
        self.databaseName = databaseName
        self.records = records
        self.tableName = tableName
    }
}

struct WriteRecordsInputBody: Swift.Equatable {
    let databaseName: Swift.String?
    let tableName: Swift.String?
    let commonAttributes: TimestreamWriteClientTypes.Record?
    let records: [TimestreamWriteClientTypes.Record]?
}

extension WriteRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonAttributes = "CommonAttributes"
        case databaseName = "DatabaseName"
        case records = "Records"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let commonAttributesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Record.self, forKey: .commonAttributes)
        commonAttributes = commonAttributesDecoded
        let recordsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[TimestreamWriteClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [TimestreamWriteClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension WriteRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension WriteRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RejectedRecordsException" : self = .rejectedRecordsException(try RejectedRecordsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum WriteRecordsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case rejectedRecordsException(RejectedRecordsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension WriteRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: WriteRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordsIngested = output.recordsIngested
        } else {
            self.recordsIngested = nil
        }
    }
}

public struct WriteRecordsOutputResponse: Swift.Equatable {
    /// Information on the records ingested by this request.
    public var recordsIngested: TimestreamWriteClientTypes.RecordsIngested?

    public init (
        recordsIngested: TimestreamWriteClientTypes.RecordsIngested? = nil
    )
    {
        self.recordsIngested = recordsIngested
    }
}

struct WriteRecordsOutputResponseBody: Swift.Equatable {
    let recordsIngested: TimestreamWriteClientTypes.RecordsIngested?
}

extension WriteRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordsIngested = "RecordsIngested"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsIngestedDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.RecordsIngested.self, forKey: .recordsIngested)
        recordsIngested = recordsIngestedDecoded
    }
}
