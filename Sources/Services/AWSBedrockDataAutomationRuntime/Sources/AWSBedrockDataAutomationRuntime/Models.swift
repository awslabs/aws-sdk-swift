//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// This exception will be thrown when customer does not have access to API.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is for any internal un-expected service errors.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception will be thrown when resource provided from customer not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception will be thrown when customer reached API TPS limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception will be thrown when customer provided invalid parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Structure for request of GetDataAutomationStatus API.
public struct GetDataAutomationStatusInput: Swift.Sendable {
    /// Invocation arn.
    /// This member is required.
    public var invocationArn: Swift.String?

    public init(
        invocationArn: Swift.String? = nil
    ) {
        self.invocationArn = invocationArn
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Output configuration.
    public struct OutputConfiguration: Swift.Sendable {
        /// S3 uri.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// List of status supported by automation jobs
    public enum AutomationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clientError
        case created
        case inProgress
        case serviceError
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationJobStatus] {
            return [
                .clientError,
                .created,
                .inProgress,
                .serviceError,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "ClientError"
            case .created: return "Created"
            case .inProgress: return "InProgress"
            case .serviceError: return "ServiceError"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Response of GetDataAutomationStatus API.
public struct GetDataAutomationStatusOutput: Swift.Sendable {
    /// Error Message.
    public var errorMessage: Swift.String?
    /// Error Type.
    public var errorType: Swift.String?
    /// Output configuration.
    public var outputConfiguration: BedrockDataAutomationRuntimeClientTypes.OutputConfiguration?
    /// Job Status.
    public var status: BedrockDataAutomationRuntimeClientTypes.AutomationJobStatus?

    public init(
        errorMessage: Swift.String? = nil,
        errorType: Swift.String? = nil,
        outputConfiguration: BedrockDataAutomationRuntimeClientTypes.OutputConfiguration? = nil,
        status: BedrockDataAutomationRuntimeClientTypes.AutomationJobStatus? = nil
    ) {
        self.errorMessage = errorMessage
        self.errorType = errorType
        self.outputConfiguration = outputConfiguration
        self.status = status
    }
}

/// This exception will be thrown when service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Blueprint stage enum.
    public enum BlueprintStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintStage] {
            return [
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Structure for single blueprint entity.
    public struct Blueprint: Swift.Sendable {
        /// Arn of blueprint.
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Stage of blueprint.
        public var stage: BedrockDataAutomationRuntimeClientTypes.BlueprintStage?
        /// Version of blueprint.
        public var version: Swift.String?

        public init(
            blueprintArn: Swift.String? = nil,
            stage: BedrockDataAutomationRuntimeClientTypes.BlueprintStage? = nil,
            version: Swift.String? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.stage = stage
            self.version = version
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Data automation stage.
    public enum DataAutomationStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationStage] {
            return [
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Data automation configuration.
    public struct DataAutomationConfiguration: Swift.Sendable {
        /// Data automation project arn.
        /// This member is required.
        public var dataAutomationProjectArn: Swift.String?
        /// Data automation stage.
        public var stage: BedrockDataAutomationRuntimeClientTypes.DataAutomationStage?

        public init(
            dataAutomationProjectArn: Swift.String? = nil,
            stage: BedrockDataAutomationRuntimeClientTypes.DataAutomationStage? = nil
        ) {
            self.dataAutomationProjectArn = dataAutomationProjectArn
            self.stage = stage
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Encryption configuration.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// KMS encryption context.
        public var kmsEncryptionContext: [Swift.String: Swift.String]?
        /// Customer KMS key used for encryption
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init(
            kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil
        ) {
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Input configuration.
    public struct InputConfiguration: Swift.Sendable {
        /// S3 uri.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Event bridge configuration.
    public struct EventBridgeConfiguration: Swift.Sendable {
        /// Event bridge flag.
        /// This member is required.
        public var eventBridgeEnabled: Swift.Bool?

        public init(
            eventBridgeEnabled: Swift.Bool? = nil
        ) {
            self.eventBridgeEnabled = eventBridgeEnabled
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Notification configuration.
    public struct NotificationConfiguration: Swift.Sendable {
        /// Event bridge configuration.
        /// This member is required.
        public var eventBridgeConfiguration: BedrockDataAutomationRuntimeClientTypes.EventBridgeConfiguration?

        public init(
            eventBridgeConfiguration: BedrockDataAutomationRuntimeClientTypes.EventBridgeConfiguration? = nil
        ) {
            self.eventBridgeConfiguration = eventBridgeConfiguration
        }
    }
}

extension BedrockDataAutomationRuntimeClientTypes {

    /// Key value pair of a tag
    public struct Tag: Swift.Sendable {
        /// Defines the context of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Defines the value within the context. e.g. <key=reason, value=training>.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

/// Invoke Data Automation Async Request
public struct InvokeDataAutomationAsyncInput: Swift.Sendable {
    /// Blueprint list.
    public var blueprints: [BedrockDataAutomationRuntimeClientTypes.Blueprint]?
    /// Idempotency token.
    public var clientToken: Swift.String?
    /// Data automation configuration.
    public var dataAutomationConfiguration: BedrockDataAutomationRuntimeClientTypes.DataAutomationConfiguration?
    /// Data automation profile ARN
    /// This member is required.
    public var dataAutomationProfileArn: Swift.String?
    /// Encryption configuration.
    public var encryptionConfiguration: BedrockDataAutomationRuntimeClientTypes.EncryptionConfiguration?
    /// Input configuration.
    /// This member is required.
    public var inputConfiguration: BedrockDataAutomationRuntimeClientTypes.InputConfiguration?
    /// Notification configuration.
    public var notificationConfiguration: BedrockDataAutomationRuntimeClientTypes.NotificationConfiguration?
    /// Output configuration.
    /// This member is required.
    public var outputConfiguration: BedrockDataAutomationRuntimeClientTypes.OutputConfiguration?
    /// List of tags.
    public var tags: [BedrockDataAutomationRuntimeClientTypes.Tag]?

    public init(
        blueprints: [BedrockDataAutomationRuntimeClientTypes.Blueprint]? = nil,
        clientToken: Swift.String? = nil,
        dataAutomationConfiguration: BedrockDataAutomationRuntimeClientTypes.DataAutomationConfiguration? = nil,
        dataAutomationProfileArn: Swift.String? = nil,
        encryptionConfiguration: BedrockDataAutomationRuntimeClientTypes.EncryptionConfiguration? = nil,
        inputConfiguration: BedrockDataAutomationRuntimeClientTypes.InputConfiguration? = nil,
        notificationConfiguration: BedrockDataAutomationRuntimeClientTypes.NotificationConfiguration? = nil,
        outputConfiguration: BedrockDataAutomationRuntimeClientTypes.OutputConfiguration? = nil,
        tags: [BedrockDataAutomationRuntimeClientTypes.Tag]? = nil
    ) {
        self.blueprints = blueprints
        self.clientToken = clientToken
        self.dataAutomationConfiguration = dataAutomationConfiguration
        self.dataAutomationProfileArn = dataAutomationProfileArn
        self.encryptionConfiguration = encryptionConfiguration
        self.inputConfiguration = inputConfiguration
        self.notificationConfiguration = notificationConfiguration
        self.outputConfiguration = outputConfiguration
        self.tags = tags
    }
}

/// Invoke Data Automation Async Response
public struct InvokeDataAutomationAsyncOutput: Swift.Sendable {
    /// ARN of the automation job
    /// This member is required.
    public var invocationArn: Swift.String?

    public init(
        invocationArn: Swift.String? = nil
    ) {
        self.invocationArn = invocationArn
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// List of tags
    public var tags: [BedrockDataAutomationRuntimeClientTypes.Tag]?

    public init(
        tags: [BedrockDataAutomationRuntimeClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List of tags
    /// This member is required.
    public var tags: [BedrockDataAutomationRuntimeClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockDataAutomationRuntimeClientTypes.Tag]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List of tag keys
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension GetDataAutomationStatusInput {

    static func urlPathProvider(_ value: GetDataAutomationStatusInput) -> Swift.String? {
        return "/"
    }
}

extension InvokeDataAutomationAsyncInput {

    static func urlPathProvider(_ value: InvokeDataAutomationAsyncInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataAutomationStatusInput {

    static func write(value: GetDataAutomationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationArn"].write(value.invocationArn)
    }
}

extension InvokeDataAutomationAsyncInput {

    static func write(value: InvokeDataAutomationAsyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprints"].writeList(value.blueprints, memberWritingClosure: BedrockDataAutomationRuntimeClientTypes.Blueprint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["dataAutomationConfiguration"].write(value.dataAutomationConfiguration, with: BedrockDataAutomationRuntimeClientTypes.DataAutomationConfiguration.write(value:to:))
        try writer["dataAutomationProfileArn"].write(value.dataAutomationProfileArn)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationRuntimeClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["inputConfiguration"].write(value.inputConfiguration, with: BedrockDataAutomationRuntimeClientTypes.InputConfiguration.write(value:to:))
        try writer["notificationConfiguration"].write(value.notificationConfiguration, with: BedrockDataAutomationRuntimeClientTypes.NotificationConfiguration.write(value:to:))
        try writer["outputConfiguration"].write(value.outputConfiguration, with: BedrockDataAutomationRuntimeClientTypes.OutputConfiguration.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationRuntimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationRuntimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetDataAutomationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataAutomationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataAutomationStatusOutput()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorType = try reader["errorType"].readIfPresent()
        value.outputConfiguration = try reader["outputConfiguration"].readIfPresent(with: BedrockDataAutomationRuntimeClientTypes.OutputConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension InvokeDataAutomationAsyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeDataAutomationAsyncOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InvokeDataAutomationAsyncOutput()
        value.invocationArn = try reader["invocationArn"].readIfPresent() ?? ""
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: BedrockDataAutomationRuntimeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum GetDataAutomationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeDataAutomationAsyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockDataAutomationRuntimeClientTypes.OutputConfiguration {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.OutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationRuntimeClientTypes.OutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationRuntimeClientTypes.OutputConfiguration()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockDataAutomationRuntimeClientTypes.Tag {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationRuntimeClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationRuntimeClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockDataAutomationRuntimeClientTypes.InputConfiguration {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.InputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }
}

extension BedrockDataAutomationRuntimeClientTypes.DataAutomationConfiguration {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.DataAutomationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataAutomationProjectArn"].write(value.dataAutomationProjectArn)
        try writer["stage"].write(value.stage)
    }
}

extension BedrockDataAutomationRuntimeClientTypes.EncryptionConfiguration {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsEncryptionContext"].writeMap(value.kmsEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }
}

extension BedrockDataAutomationRuntimeClientTypes.NotificationConfiguration {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.NotificationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventBridgeConfiguration"].write(value.eventBridgeConfiguration, with: BedrockDataAutomationRuntimeClientTypes.EventBridgeConfiguration.write(value:to:))
    }
}

extension BedrockDataAutomationRuntimeClientTypes.EventBridgeConfiguration {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.EventBridgeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventBridgeEnabled"].write(value.eventBridgeEnabled)
    }
}

extension BedrockDataAutomationRuntimeClientTypes.Blueprint {

    static func write(value: BedrockDataAutomationRuntimeClientTypes.Blueprint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["stage"].write(value.stage)
        try writer["version"].write(value.version)
    }
}

public enum BedrockDataAutomationRuntimeClientTypes {}
