// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Route53ResolverClient {
    /// Paginate over `[ListFirewallConfigsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallConfigsOutputResponse`
    public func listFirewallConfigsPaginated(input: ListFirewallConfigsInput) -> ClientRuntime.PaginatorSequence<ListFirewallConfigsInput, ListFirewallConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFirewallConfigsInput, ListFirewallConfigsOutputResponse>(input: input, inputKey: \ListFirewallConfigsInput.nextToken, outputKey: \ListFirewallConfigsOutputResponse.nextToken, paginationFunction: self.listFirewallConfigs(input:))
    }
}

extension ListFirewallConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallConfigsInput {
        return ListFirewallConfigsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallConfigsInput, Output == ListFirewallConfigsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallConfig]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallConfig]`
    public func firewallConfigs() async throws -> [Route53ResolverClientTypes.FirewallConfig] {
        return try await self.asyncCompactMap { item in item.firewallConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallDomainListsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallDomainListsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallDomainListsOutputResponse`
    public func listFirewallDomainListsPaginated(input: ListFirewallDomainListsInput) -> ClientRuntime.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutputResponse>(input: input, inputKey: \ListFirewallDomainListsInput.nextToken, outputKey: \ListFirewallDomainListsOutputResponse.nextToken, paginationFunction: self.listFirewallDomainLists(input:))
    }
}

extension ListFirewallDomainListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallDomainListsInput {
        return ListFirewallDomainListsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallDomainListsInput, Output == ListFirewallDomainListsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallDomainListsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallDomainListMetadata]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallDomainListMetadata]`
    public func firewallDomainLists() async throws -> [Route53ResolverClientTypes.FirewallDomainListMetadata] {
        return try await self.asyncCompactMap { item in item.firewallDomainLists }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallDomainsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallDomainsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallDomainsOutputResponse`
    public func listFirewallDomainsPaginated(input: ListFirewallDomainsInput) -> ClientRuntime.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutputResponse>(input: input, inputKey: \ListFirewallDomainsInput.nextToken, outputKey: \ListFirewallDomainsOutputResponse.nextToken, paginationFunction: self.listFirewallDomains(input:))
    }
}

extension ListFirewallDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallDomainsInput {
        return ListFirewallDomainsInput(
            firewallDomainListId: self.firewallDomainListId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallDomainsInput, Output == ListFirewallDomainsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallDomainsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func domains() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.domains }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRuleGroupAssociationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRuleGroupAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRuleGroupAssociationsOutputResponse`
    public func listFirewallRuleGroupAssociationsPaginated(input: ListFirewallRuleGroupAssociationsInput) -> ClientRuntime.PaginatorSequence<ListFirewallRuleGroupAssociationsInput, ListFirewallRuleGroupAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFirewallRuleGroupAssociationsInput, ListFirewallRuleGroupAssociationsOutputResponse>(input: input, inputKey: \ListFirewallRuleGroupAssociationsInput.nextToken, outputKey: \ListFirewallRuleGroupAssociationsOutputResponse.nextToken, paginationFunction: self.listFirewallRuleGroupAssociations(input:))
    }
}

extension ListFirewallRuleGroupAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRuleGroupAssociationsInput {
        return ListFirewallRuleGroupAssociationsInput(
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority,
            status: self.status,
            vpcId: self.vpcId
        )}
}

extension PaginatorSequence where Input == ListFirewallRuleGroupAssociationsInput, Output == ListFirewallRuleGroupAssociationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRuleGroupAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRuleGroupAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRuleGroupAssociation]`
    public func firewallRuleGroupAssociations() async throws -> [Route53ResolverClientTypes.FirewallRuleGroupAssociation] {
        return try await self.asyncCompactMap { item in item.firewallRuleGroupAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRuleGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRuleGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRuleGroupsOutputResponse`
    public func listFirewallRuleGroupsPaginated(input: ListFirewallRuleGroupsInput) -> ClientRuntime.PaginatorSequence<ListFirewallRuleGroupsInput, ListFirewallRuleGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFirewallRuleGroupsInput, ListFirewallRuleGroupsOutputResponse>(input: input, inputKey: \ListFirewallRuleGroupsInput.nextToken, outputKey: \ListFirewallRuleGroupsOutputResponse.nextToken, paginationFunction: self.listFirewallRuleGroups(input:))
    }
}

extension ListFirewallRuleGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRuleGroupsInput {
        return ListFirewallRuleGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallRuleGroupsInput, Output == ListFirewallRuleGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRuleGroupsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRuleGroupMetadata]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRuleGroupMetadata]`
    public func firewallRuleGroups() async throws -> [Route53ResolverClientTypes.FirewallRuleGroupMetadata] {
        return try await self.asyncCompactMap { item in item.firewallRuleGroups }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRulesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRulesOutputResponse`
    public func listFirewallRulesPaginated(input: ListFirewallRulesInput) -> ClientRuntime.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutputResponse>(input: input, inputKey: \ListFirewallRulesInput.nextToken, outputKey: \ListFirewallRulesOutputResponse.nextToken, paginationFunction: self.listFirewallRules(input:))
    }
}

extension ListFirewallRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRulesInput {
        return ListFirewallRulesInput(
            action: self.action,
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority
        )}
}

extension PaginatorSequence where Input == ListFirewallRulesInput, Output == ListFirewallRulesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRulesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRule]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRule]`
    public func firewallRules() async throws -> [Route53ResolverClientTypes.FirewallRule] {
        return try await self.asyncCompactMap { item in item.firewallRules }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListOutpostResolversOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOutpostResolversInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOutpostResolversOutputResponse`
    public func listOutpostResolversPaginated(input: ListOutpostResolversInput) -> ClientRuntime.PaginatorSequence<ListOutpostResolversInput, ListOutpostResolversOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOutpostResolversInput, ListOutpostResolversOutputResponse>(input: input, inputKey: \ListOutpostResolversInput.nextToken, outputKey: \ListOutpostResolversOutputResponse.nextToken, paginationFunction: self.listOutpostResolvers(input:))
    }
}

extension ListOutpostResolversInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOutpostResolversInput {
        return ListOutpostResolversInput(
            maxResults: self.maxResults,
            nextToken: token,
            outpostArn: self.outpostArn
        )}
}

extension PaginatorSequence where Input == ListOutpostResolversInput, Output == ListOutpostResolversOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listOutpostResolversPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.OutpostResolver]`
    /// - Returns: `[Route53ResolverClientTypes.OutpostResolver]`
    public func outpostResolvers() async throws -> [Route53ResolverClientTypes.OutpostResolver] {
        return try await self.asyncCompactMap { item in item.outpostResolvers }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverConfigsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverConfigsOutputResponse`
    public func listResolverConfigsPaginated(input: ListResolverConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverConfigsInput, ListResolverConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverConfigsInput, ListResolverConfigsOutputResponse>(input: input, inputKey: \ListResolverConfigsInput.nextToken, outputKey: \ListResolverConfigsOutputResponse.nextToken, paginationFunction: self.listResolverConfigs(input:))
    }
}

extension ListResolverConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverConfigsInput {
        return ListResolverConfigsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverConfigsInput, Output == ListResolverConfigsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverConfig]`
    public func resolverConfigs() async throws -> [Route53ResolverClientTypes.ResolverConfig] {
        return try await self.asyncCompactMap { item in item.resolverConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverDnssecConfigsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverDnssecConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverDnssecConfigsOutputResponse`
    public func listResolverDnssecConfigsPaginated(input: ListResolverDnssecConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverDnssecConfigsInput, ListResolverDnssecConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverDnssecConfigsInput, ListResolverDnssecConfigsOutputResponse>(input: input, inputKey: \ListResolverDnssecConfigsInput.nextToken, outputKey: \ListResolverDnssecConfigsOutputResponse.nextToken, paginationFunction: self.listResolverDnssecConfigs(input:))
    }
}

extension ListResolverDnssecConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverDnssecConfigsInput {
        return ListResolverDnssecConfigsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverDnssecConfigsInput, Output == ListResolverDnssecConfigsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverDnssecConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverDnssecConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverDnssecConfig]`
    public func resolverDnssecConfigs() async throws -> [Route53ResolverClientTypes.ResolverDnssecConfig] {
        return try await self.asyncCompactMap { item in item.resolverDnssecConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverEndpointIpAddressesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverEndpointIpAddressesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverEndpointIpAddressesOutputResponse`
    public func listResolverEndpointIpAddressesPaginated(input: ListResolverEndpointIpAddressesInput) -> ClientRuntime.PaginatorSequence<ListResolverEndpointIpAddressesInput, ListResolverEndpointIpAddressesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverEndpointIpAddressesInput, ListResolverEndpointIpAddressesOutputResponse>(input: input, inputKey: \ListResolverEndpointIpAddressesInput.nextToken, outputKey: \ListResolverEndpointIpAddressesOutputResponse.nextToken, paginationFunction: self.listResolverEndpointIpAddresses(input:))
    }
}

extension ListResolverEndpointIpAddressesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverEndpointIpAddressesInput {
        return ListResolverEndpointIpAddressesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resolverEndpointId: self.resolverEndpointId
        )}
}

extension PaginatorSequence where Input == ListResolverEndpointIpAddressesInput, Output == ListResolverEndpointIpAddressesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverEndpointIpAddressesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.IpAddressResponse]`
    /// - Returns: `[Route53ResolverClientTypes.IpAddressResponse]`
    public func ipAddresses() async throws -> [Route53ResolverClientTypes.IpAddressResponse] {
        return try await self.asyncCompactMap { item in item.ipAddresses }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverEndpointsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverEndpointsOutputResponse`
    public func listResolverEndpointsPaginated(input: ListResolverEndpointsInput) -> ClientRuntime.PaginatorSequence<ListResolverEndpointsInput, ListResolverEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverEndpointsInput, ListResolverEndpointsOutputResponse>(input: input, inputKey: \ListResolverEndpointsInput.nextToken, outputKey: \ListResolverEndpointsOutputResponse.nextToken, paginationFunction: self.listResolverEndpoints(input:))
    }
}

extension ListResolverEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverEndpointsInput {
        return ListResolverEndpointsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverEndpointsInput, Output == ListResolverEndpointsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverEndpointsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverEndpoint]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverEndpoint]`
    public func resolverEndpoints() async throws -> [Route53ResolverClientTypes.ResolverEndpoint] {
        return try await self.asyncCompactMap { item in item.resolverEndpoints }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverQueryLogConfigAssociationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverQueryLogConfigAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverQueryLogConfigAssociationsOutputResponse`
    public func listResolverQueryLogConfigAssociationsPaginated(input: ListResolverQueryLogConfigAssociationsInput) -> ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigAssociationsInput, ListResolverQueryLogConfigAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigAssociationsInput, ListResolverQueryLogConfigAssociationsOutputResponse>(input: input, inputKey: \ListResolverQueryLogConfigAssociationsInput.nextToken, outputKey: \ListResolverQueryLogConfigAssociationsOutputResponse.nextToken, paginationFunction: self.listResolverQueryLogConfigAssociations(input:))
    }
}

extension ListResolverQueryLogConfigAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverQueryLogConfigAssociationsInput {
        return ListResolverQueryLogConfigAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where Input == ListResolverQueryLogConfigAssociationsInput, Output == ListResolverQueryLogConfigAssociationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverQueryLogConfigAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]`
    public func resolverQueryLogConfigAssociations() async throws -> [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation] {
        return try await self.asyncCompactMap { item in item.resolverQueryLogConfigAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverQueryLogConfigsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverQueryLogConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverQueryLogConfigsOutputResponse`
    public func listResolverQueryLogConfigsPaginated(input: ListResolverQueryLogConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigsInput, ListResolverQueryLogConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigsInput, ListResolverQueryLogConfigsOutputResponse>(input: input, inputKey: \ListResolverQueryLogConfigsInput.nextToken, outputKey: \ListResolverQueryLogConfigsOutputResponse.nextToken, paginationFunction: self.listResolverQueryLogConfigs(input:))
    }
}

extension ListResolverQueryLogConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverQueryLogConfigsInput {
        return ListResolverQueryLogConfigsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where Input == ListResolverQueryLogConfigsInput, Output == ListResolverQueryLogConfigsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverQueryLogConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverQueryLogConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverQueryLogConfig]`
    public func resolverQueryLogConfigs() async throws -> [Route53ResolverClientTypes.ResolverQueryLogConfig] {
        return try await self.asyncCompactMap { item in item.resolverQueryLogConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverRuleAssociationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverRuleAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverRuleAssociationsOutputResponse`
    public func listResolverRuleAssociationsPaginated(input: ListResolverRuleAssociationsInput) -> ClientRuntime.PaginatorSequence<ListResolverRuleAssociationsInput, ListResolverRuleAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverRuleAssociationsInput, ListResolverRuleAssociationsOutputResponse>(input: input, inputKey: \ListResolverRuleAssociationsInput.nextToken, outputKey: \ListResolverRuleAssociationsOutputResponse.nextToken, paginationFunction: self.listResolverRuleAssociations(input:))
    }
}

extension ListResolverRuleAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverRuleAssociationsInput {
        return ListResolverRuleAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverRuleAssociationsInput, Output == ListResolverRuleAssociationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverRuleAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverRuleAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverRuleAssociation]`
    public func resolverRuleAssociations() async throws -> [Route53ResolverClientTypes.ResolverRuleAssociation] {
        return try await self.asyncCompactMap { item in item.resolverRuleAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverRulesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverRulesOutputResponse`
    public func listResolverRulesPaginated(input: ListResolverRulesInput) -> ClientRuntime.PaginatorSequence<ListResolverRulesInput, ListResolverRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResolverRulesInput, ListResolverRulesOutputResponse>(input: input, inputKey: \ListResolverRulesInput.nextToken, outputKey: \ListResolverRulesOutputResponse.nextToken, paginationFunction: self.listResolverRules(input:))
    }
}

extension ListResolverRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverRulesInput {
        return ListResolverRulesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverRulesInput, Output == ListResolverRulesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverRulesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverRule]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverRule]`
    public func resolverRules() async throws -> [Route53ResolverClientTypes.ResolverRule] {
        return try await self.asyncCompactMap { item in item.resolverRules }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListTagsForResourceOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutputResponse`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutputResponse.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where Input == ListTagsForResourceInput, Output == ListTagsForResourceOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
    /// to access the nested member `[Route53ResolverClientTypes.Tag]`
    /// - Returns: `[Route53ResolverClientTypes.Tag]`
    public func tags() async throws -> [Route53ResolverClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
