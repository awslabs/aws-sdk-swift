// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Route53ResolverClient {
    /// Paginate over `[ListFirewallConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallConfigsOutput`
    public func listFirewallConfigsPaginated(input: ListFirewallConfigsInput) -> ClientRuntime.PaginatorSequence<ListFirewallConfigsInput, ListFirewallConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallConfigsInput, ListFirewallConfigsOutput>(input: input, inputKey: \ListFirewallConfigsInput.nextToken, outputKey: \ListFirewallConfigsOutput.nextToken, paginationFunction: self.listFirewallConfigs(input:))
    }
}

extension ListFirewallConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallConfigsInput {
        return ListFirewallConfigsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallConfigsInput, Output == ListFirewallConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallConfig]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallConfig]`
    public func firewallConfigs() async throws -> [Route53ResolverClientTypes.FirewallConfig] {
        return try await self.asyncCompactMap { item in item.firewallConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallDomainListsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallDomainListsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallDomainListsOutput`
    public func listFirewallDomainListsPaginated(input: ListFirewallDomainListsInput) -> ClientRuntime.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutput>(input: input, inputKey: \ListFirewallDomainListsInput.nextToken, outputKey: \ListFirewallDomainListsOutput.nextToken, paginationFunction: self.listFirewallDomainLists(input:))
    }
}

extension ListFirewallDomainListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallDomainListsInput {
        return ListFirewallDomainListsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallDomainListsInput, Output == ListFirewallDomainListsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallDomainListsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallDomainListMetadata]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallDomainListMetadata]`
    public func firewallDomainLists() async throws -> [Route53ResolverClientTypes.FirewallDomainListMetadata] {
        return try await self.asyncCompactMap { item in item.firewallDomainLists }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallDomainsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallDomainsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallDomainsOutput`
    public func listFirewallDomainsPaginated(input: ListFirewallDomainsInput) -> ClientRuntime.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutput>(input: input, inputKey: \ListFirewallDomainsInput.nextToken, outputKey: \ListFirewallDomainsOutput.nextToken, paginationFunction: self.listFirewallDomains(input:))
    }
}

extension ListFirewallDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallDomainsInput {
        return ListFirewallDomainsInput(
            firewallDomainListId: self.firewallDomainListId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallDomainsInput, Output == ListFirewallDomainsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallDomainsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func domains() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.domains }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRuleGroupAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRuleGroupAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRuleGroupAssociationsOutput`
    public func listFirewallRuleGroupAssociationsPaginated(input: ListFirewallRuleGroupAssociationsInput) -> ClientRuntime.PaginatorSequence<ListFirewallRuleGroupAssociationsInput, ListFirewallRuleGroupAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallRuleGroupAssociationsInput, ListFirewallRuleGroupAssociationsOutput>(input: input, inputKey: \ListFirewallRuleGroupAssociationsInput.nextToken, outputKey: \ListFirewallRuleGroupAssociationsOutput.nextToken, paginationFunction: self.listFirewallRuleGroupAssociations(input:))
    }
}

extension ListFirewallRuleGroupAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRuleGroupAssociationsInput {
        return ListFirewallRuleGroupAssociationsInput(
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority,
            status: self.status,
            vpcId: self.vpcId
        )}
}

extension PaginatorSequence where Input == ListFirewallRuleGroupAssociationsInput, Output == ListFirewallRuleGroupAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRuleGroupAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRuleGroupAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRuleGroupAssociation]`
    public func firewallRuleGroupAssociations() async throws -> [Route53ResolverClientTypes.FirewallRuleGroupAssociation] {
        return try await self.asyncCompactMap { item in item.firewallRuleGroupAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRuleGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRuleGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRuleGroupsOutput`
    public func listFirewallRuleGroupsPaginated(input: ListFirewallRuleGroupsInput) -> ClientRuntime.PaginatorSequence<ListFirewallRuleGroupsInput, ListFirewallRuleGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallRuleGroupsInput, ListFirewallRuleGroupsOutput>(input: input, inputKey: \ListFirewallRuleGroupsInput.nextToken, outputKey: \ListFirewallRuleGroupsOutput.nextToken, paginationFunction: self.listFirewallRuleGroups(input:))
    }
}

extension ListFirewallRuleGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRuleGroupsInput {
        return ListFirewallRuleGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFirewallRuleGroupsInput, Output == ListFirewallRuleGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRuleGroupsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRuleGroupMetadata]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRuleGroupMetadata]`
    public func firewallRuleGroups() async throws -> [Route53ResolverClientTypes.FirewallRuleGroupMetadata] {
        return try await self.asyncCompactMap { item in item.firewallRuleGroups }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRulesOutput`
    public func listFirewallRulesPaginated(input: ListFirewallRulesInput) -> ClientRuntime.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutput>(input: input, inputKey: \ListFirewallRulesInput.nextToken, outputKey: \ListFirewallRulesOutput.nextToken, paginationFunction: self.listFirewallRules(input:))
    }
}

extension ListFirewallRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRulesInput {
        return ListFirewallRulesInput(
            action: self.action,
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority
        )}
}

extension PaginatorSequence where Input == ListFirewallRulesInput, Output == ListFirewallRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRulesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRule]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRule]`
    public func firewallRules() async throws -> [Route53ResolverClientTypes.FirewallRule] {
        return try await self.asyncCompactMap { item in item.firewallRules }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListOutpostResolversOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOutpostResolversInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOutpostResolversOutput`
    public func listOutpostResolversPaginated(input: ListOutpostResolversInput) -> ClientRuntime.PaginatorSequence<ListOutpostResolversInput, ListOutpostResolversOutput> {
        return ClientRuntime.PaginatorSequence<ListOutpostResolversInput, ListOutpostResolversOutput>(input: input, inputKey: \ListOutpostResolversInput.nextToken, outputKey: \ListOutpostResolversOutput.nextToken, paginationFunction: self.listOutpostResolvers(input:))
    }
}

extension ListOutpostResolversInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOutpostResolversInput {
        return ListOutpostResolversInput(
            maxResults: self.maxResults,
            nextToken: token,
            outpostArn: self.outpostArn
        )}
}

extension PaginatorSequence where Input == ListOutpostResolversInput, Output == ListOutpostResolversOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOutpostResolversPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.OutpostResolver]`
    /// - Returns: `[Route53ResolverClientTypes.OutpostResolver]`
    public func outpostResolvers() async throws -> [Route53ResolverClientTypes.OutpostResolver] {
        return try await self.asyncCompactMap { item in item.outpostResolvers }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverConfigsOutput`
    public func listResolverConfigsPaginated(input: ListResolverConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverConfigsInput, ListResolverConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverConfigsInput, ListResolverConfigsOutput>(input: input, inputKey: \ListResolverConfigsInput.nextToken, outputKey: \ListResolverConfigsOutput.nextToken, paginationFunction: self.listResolverConfigs(input:))
    }
}

extension ListResolverConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverConfigsInput {
        return ListResolverConfigsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverConfigsInput, Output == ListResolverConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverConfig]`
    public func resolverConfigs() async throws -> [Route53ResolverClientTypes.ResolverConfig] {
        return try await self.asyncCompactMap { item in item.resolverConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverDnssecConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverDnssecConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverDnssecConfigsOutput`
    public func listResolverDnssecConfigsPaginated(input: ListResolverDnssecConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverDnssecConfigsInput, ListResolverDnssecConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverDnssecConfigsInput, ListResolverDnssecConfigsOutput>(input: input, inputKey: \ListResolverDnssecConfigsInput.nextToken, outputKey: \ListResolverDnssecConfigsOutput.nextToken, paginationFunction: self.listResolverDnssecConfigs(input:))
    }
}

extension ListResolverDnssecConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverDnssecConfigsInput {
        return ListResolverDnssecConfigsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverDnssecConfigsInput, Output == ListResolverDnssecConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverDnssecConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverDnssecConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverDnssecConfig]`
    public func resolverDnssecConfigs() async throws -> [Route53ResolverClientTypes.ResolverDnssecConfig] {
        return try await self.asyncCompactMap { item in item.resolverDnssecConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverEndpointIpAddressesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverEndpointIpAddressesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverEndpointIpAddressesOutput`
    public func listResolverEndpointIpAddressesPaginated(input: ListResolverEndpointIpAddressesInput) -> ClientRuntime.PaginatorSequence<ListResolverEndpointIpAddressesInput, ListResolverEndpointIpAddressesOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverEndpointIpAddressesInput, ListResolverEndpointIpAddressesOutput>(input: input, inputKey: \ListResolverEndpointIpAddressesInput.nextToken, outputKey: \ListResolverEndpointIpAddressesOutput.nextToken, paginationFunction: self.listResolverEndpointIpAddresses(input:))
    }
}

extension ListResolverEndpointIpAddressesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverEndpointIpAddressesInput {
        return ListResolverEndpointIpAddressesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resolverEndpointId: self.resolverEndpointId
        )}
}

extension PaginatorSequence where Input == ListResolverEndpointIpAddressesInput, Output == ListResolverEndpointIpAddressesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverEndpointIpAddressesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.IpAddressResponse]`
    /// - Returns: `[Route53ResolverClientTypes.IpAddressResponse]`
    public func ipAddresses() async throws -> [Route53ResolverClientTypes.IpAddressResponse] {
        return try await self.asyncCompactMap { item in item.ipAddresses }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverEndpointsOutput`
    public func listResolverEndpointsPaginated(input: ListResolverEndpointsInput) -> ClientRuntime.PaginatorSequence<ListResolverEndpointsInput, ListResolverEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverEndpointsInput, ListResolverEndpointsOutput>(input: input, inputKey: \ListResolverEndpointsInput.nextToken, outputKey: \ListResolverEndpointsOutput.nextToken, paginationFunction: self.listResolverEndpoints(input:))
    }
}

extension ListResolverEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverEndpointsInput {
        return ListResolverEndpointsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverEndpointsInput, Output == ListResolverEndpointsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverEndpointsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverEndpoint]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverEndpoint]`
    public func resolverEndpoints() async throws -> [Route53ResolverClientTypes.ResolverEndpoint] {
        return try await self.asyncCompactMap { item in item.resolverEndpoints }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverQueryLogConfigAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverQueryLogConfigAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverQueryLogConfigAssociationsOutput`
    public func listResolverQueryLogConfigAssociationsPaginated(input: ListResolverQueryLogConfigAssociationsInput) -> ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigAssociationsInput, ListResolverQueryLogConfigAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigAssociationsInput, ListResolverQueryLogConfigAssociationsOutput>(input: input, inputKey: \ListResolverQueryLogConfigAssociationsInput.nextToken, outputKey: \ListResolverQueryLogConfigAssociationsOutput.nextToken, paginationFunction: self.listResolverQueryLogConfigAssociations(input:))
    }
}

extension ListResolverQueryLogConfigAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverQueryLogConfigAssociationsInput {
        return ListResolverQueryLogConfigAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where Input == ListResolverQueryLogConfigAssociationsInput, Output == ListResolverQueryLogConfigAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverQueryLogConfigAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]`
    public func resolverQueryLogConfigAssociations() async throws -> [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation] {
        return try await self.asyncCompactMap { item in item.resolverQueryLogConfigAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverQueryLogConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverQueryLogConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverQueryLogConfigsOutput`
    public func listResolverQueryLogConfigsPaginated(input: ListResolverQueryLogConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigsInput, ListResolverQueryLogConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigsInput, ListResolverQueryLogConfigsOutput>(input: input, inputKey: \ListResolverQueryLogConfigsInput.nextToken, outputKey: \ListResolverQueryLogConfigsOutput.nextToken, paginationFunction: self.listResolverQueryLogConfigs(input:))
    }
}

extension ListResolverQueryLogConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverQueryLogConfigsInput {
        return ListResolverQueryLogConfigsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where Input == ListResolverQueryLogConfigsInput, Output == ListResolverQueryLogConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverQueryLogConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverQueryLogConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverQueryLogConfig]`
    public func resolverQueryLogConfigs() async throws -> [Route53ResolverClientTypes.ResolverQueryLogConfig] {
        return try await self.asyncCompactMap { item in item.resolverQueryLogConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverRuleAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverRuleAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverRuleAssociationsOutput`
    public func listResolverRuleAssociationsPaginated(input: ListResolverRuleAssociationsInput) -> ClientRuntime.PaginatorSequence<ListResolverRuleAssociationsInput, ListResolverRuleAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverRuleAssociationsInput, ListResolverRuleAssociationsOutput>(input: input, inputKey: \ListResolverRuleAssociationsInput.nextToken, outputKey: \ListResolverRuleAssociationsOutput.nextToken, paginationFunction: self.listResolverRuleAssociations(input:))
    }
}

extension ListResolverRuleAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverRuleAssociationsInput {
        return ListResolverRuleAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverRuleAssociationsInput, Output == ListResolverRuleAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverRuleAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverRuleAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverRuleAssociation]`
    public func resolverRuleAssociations() async throws -> [Route53ResolverClientTypes.ResolverRuleAssociation] {
        return try await self.asyncCompactMap { item in item.resolverRuleAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverRulesOutput`
    public func listResolverRulesPaginated(input: ListResolverRulesInput) -> ClientRuntime.PaginatorSequence<ListResolverRulesInput, ListResolverRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverRulesInput, ListResolverRulesOutput>(input: input, inputKey: \ListResolverRulesInput.nextToken, outputKey: \ListResolverRulesOutput.nextToken, paginationFunction: self.listResolverRules(input:))
    }
}

extension ListResolverRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverRulesInput {
        return ListResolverRulesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListResolverRulesInput, Output == ListResolverRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverRulesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverRule]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverRule]`
    public func resolverRules() async throws -> [Route53ResolverClientTypes.ResolverRule] {
        return try await self.asyncCompactMap { item in item.resolverRules }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListTagsForResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutput`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutput.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where Input == ListTagsForResourceInput, Output == ListTagsForResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
    /// to access the nested member `[Route53ResolverClientTypes.Tag]`
    /// - Returns: `[Route53ResolverClientTypes.Tag]`
    public func tags() async throws -> [Route53ResolverClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
