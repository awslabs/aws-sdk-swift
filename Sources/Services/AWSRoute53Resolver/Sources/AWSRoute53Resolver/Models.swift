//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// The current account doesn't have the IAM permissions required to perform the specified Resolver operation. This error can also be thrown when a customer has reached the 5120 character limit for a resource policy for CloudWatch Logs.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Route53ResolverClientTypes {

    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alert
        case allow
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .alert,
                .allow,
                .block
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alert: return "ALERT"
            case .allow: return "ALLOW"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The requested state transition isn't valid. For example, you can't delete a firewall domain list if it is in the process of being deleted, or you can't import domains into a domain list that is in the process of being deleted.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// We encountered an unknown error. Try again in a few minutes.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request caused one or more limits to be exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a LimitExceededException error, the type of resource that exceeded the current limit.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceNotFoundException error, the type of resource that doesn't exist.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

/// The request was throttled. Try again in a few minutes.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have provided an invalid command. If you ran the UpdateFirewallDomains request. supported values are ADD, REMOVE, or REPLACE a domain.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Route53ResolverClientTypes {

    public enum MutationProtectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MutationProtectionStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// One tag that you want to add to the specified resource. A tag consists of a Key (a name for the tag) and a Value.
    public struct Tag {
        /// The name for the tag. For example, if you want to associate Resolver resources with the account IDs of your customers for billing purposes, the value of Key might be account-id.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the tag. For example, if Key is account-id, then Value might be the ID of the customer account that you're creating the resource for.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct AssociateFirewallRuleGroupInput {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The unique identifier of the firewall rule group.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. When you create the association, the default setting is DISABLED.
    public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    /// A name that lets you identify the association, to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that you associate with the specified VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting. You must specify a unique priority for each rule group that you associate with a single VPC. To make it easier to insert rule groups later, leave space between the numbers, for example, use 101, 200, and so on. You can change the priority setting for a rule group association after you create it. The allowed values for Priority are between 100 and 9900.
    /// This member is required.
    public var priority: Swift.Int?
    /// A list of the tag keys and values that you want to associate with the rule group association.
    public var tags: [Route53ResolverClientTypes.Tag]?
    /// The unique identifier of the VPC that you want to associate with the rule group.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        creatorRequestId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
        self.tags = tags
        self.vpcId = vpcId
    }
}

extension Route53ResolverClientTypes {

    public enum FirewallRuleGroupAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRuleGroupAssociationStatus] {
            return [
                .complete,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// An association between a firewall rule group and a VPC, which enables DNS filtering for the VPC.
    public struct FirewallRuleGroupAssociation {
        /// The Amazon Resource Name (ARN) of the firewall rule group association.
        public var arn: Swift.String?
        /// The date and time that the association was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The unique identifier of the firewall rule group.
        public var firewallRuleGroupId: Swift.String?
        /// The identifier for the association.
        public var id: Swift.String?
        /// The owner of the association, used only for associations that are not managed by you. If you use Firewall Manager to manage your DNS Firewalls, then this reports Firewall Manager as the managed owner.
        public var managedOwnerName: Swift.String?
        /// The date and time that the association was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
        public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
        /// The name of the association.
        public var name: Swift.String?
        /// The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting from rule group with the lowest numeric priority setting.
        public var priority: Swift.Int?
        /// The current status of the association.
        public var status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
        /// Additional information about the status of the response, if available.
        public var statusMessage: Swift.String?
        /// The unique identifier of the VPC that is associated with the rule group.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            firewallRuleGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus? = nil,
            statusMessage: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.firewallRuleGroupId = firewallRuleGroupId
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.modificationTime = modificationTime
            self.mutationProtection = mutationProtection
            self.name = name
            self.priority = priority
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }
    }

}

public struct AssociateFirewallRuleGroupOutput {
    /// The association that you just created. The association has an ID that you can use to identify it in other requests, like update and delete.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

/// One or more parameters in this request are not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// For an InvalidParameterException error, the name of the parameter that's invalid.
        public internal(set) var fieldName: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldName: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldName = fieldName
        self.properties.message = message
    }
}

/// The request is invalid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource that you tried to create already exists.
public struct ResourceExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceExistsException error, the type of resource that the error applies to.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

extension Route53ResolverClientTypes {
    /// In an [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html) request, information about an IP address to update.
    public struct IpAddressUpdate {
        /// The new IPv4 address.
        public var ip: Swift.String?
        /// Only when removing an IP address from a Resolver endpoint: The ID of the IP address that you want to remove. To get this ID, use [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html).
        public var ipId: Swift.String?
        /// The new IPv6 address.
        public var ipv6: Swift.String?
        /// The ID of the subnet that includes the IP address that you want to update. To get this ID, use [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html).
        public var subnetId: Swift.String?

        public init(
            ip: Swift.String? = nil,
            ipId: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.ip = ip
            self.ipId = ipId
            self.ipv6 = ipv6
            self.subnetId = subnetId
        }
    }

}

public struct AssociateResolverEndpointIpAddressInput {
    /// Either the IPv4 address that you want to add to a Resolver endpoint or a subnet ID. If you specify a subnet ID, Resolver chooses an IP address for you from the available IPs in the specified subnet.
    /// This member is required.
    public var ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
    /// The ID of the Resolver endpoint that you want to associate IP addresses with.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        ipAddress: Route53ResolverClientTypes.IpAddressUpdate? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverEndpointDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inbound
        case outbound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointDirection] {
            return [
                .inbound,
                .outbound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inbound: return "INBOUND"
            case .outbound: return "OUTBOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {

    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case do53
        case doh
        case dohfips
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .do53,
                .doh,
                .dohfips
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .do53: return "Do53"
            case .doh: return "DoH"
            case .dohfips: return "DoH-FIPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dualstack
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointType] {
            return [
                .dualstack,
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualstack: return "DUALSTACK"
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionneeded
        case autorecovering
        case creating
        case deleting
        case operational
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointStatus] {
            return [
                .actionneeded,
                .autorecovering,
                .creating,
                .deleting,
                .operational,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionneeded: return "ACTION_NEEDED"
            case .autorecovering: return "AUTO_RECOVERING"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .operational: return "OPERATIONAL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html), [DeleteResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverEndpoint.html), [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html), Updates the name, or ResolverEndpointType for an endpoint, or [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html) request, a complex type that contains settings for an existing inbound or outbound Resolver endpoint.
    public struct ResolverEndpoint {
        /// The ARN (Amazon Resource Name) for the Resolver endpoint.
        public var arn: Swift.String?
        /// The date and time that the endpoint was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the Resolver endpoint. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// Indicates whether the Resolver endpoint allows inbound or outbound DNS queries:
        ///
        /// * INBOUND: allows DNS queries to your VPC from your network
        ///
        /// * OUTBOUND: allows DNS queries from your VPC to your network
        public var direction: Route53ResolverClientTypes.ResolverEndpointDirection?
        /// The ID of the VPC that you want to create the Resolver endpoint in.
        public var hostVPCId: Swift.String?
        /// The ID of the Resolver endpoint.
        public var id: Swift.String?
        /// The number of IP addresses that the Resolver endpoint can use for DNS queries.
        public var ipAddressCount: Swift.Int?
        /// The date and time that the endpoint was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name that you assigned to the Resolver endpoint when you submitted a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request.
        public var name: Swift.String?
        /// The ARN (Amazon Resource Name) for the Outpost.
        public var outpostArn: Swift.String?
        /// The Amazon EC2 instance type.
        public var preferredInstanceType: Swift.String?
        /// Protocols used for the endpoint. DoH-FIPS is applicable for inbound endpoints only. For an inbound endpoint you can apply the protocols as follows:
        ///
        /// * Do53 and DoH in combination.
        ///
        /// * Do53 and DoH-FIPS in combination.
        ///
        /// * Do53 alone.
        ///
        /// * DoH alone.
        ///
        /// * DoH-FIPS alone.
        ///
        /// * None, which is treated as Do53.
        ///
        ///
        /// For an outbound endpoint you can apply the protocols as follows:
        ///
        /// * Do53 and DoH in combination.
        ///
        /// * Do53 alone.
        ///
        /// * DoH alone.
        ///
        /// * None, which is treated as Do53.
        public var protocols: [Route53ResolverClientTypes.ModelProtocol]?
        /// The Resolver endpoint IP address type.
        public var resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
        /// The ID of one or more security groups that control access to this VPC. The security group must include one or more inbound rules (for inbound endpoints) or outbound rules (for outbound endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.
        public var securityGroupIds: [Swift.String]?
        /// A code that specifies the current status of the Resolver endpoint. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating and configuring one or more Amazon VPC network interfaces for this endpoint.
        ///
        /// * OPERATIONAL: The Amazon VPC network interfaces for this endpoint are correctly configured and able to pass inbound or outbound DNS queries between your network and Resolver.
        ///
        /// * UPDATING: Resolver is associating or disassociating one or more network interfaces with this endpoint.
        ///
        /// * AUTO_RECOVERING: Resolver is trying to recover one or more of the network interfaces that are associated with this endpoint. During the recovery process, the endpoint functions with limited capacity because of the limit on the number of DNS queries per IP address (per network interface). For the current limit, see [Limits on Route 53 Resolver](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html#limits-api-entities-resolver).
        ///
        /// * ACTION_NEEDED: This endpoint is unhealthy, and Resolver can't automatically recover it. To resolve the problem, we recommend that you check each IP address that you associated with the endpoint. For each IP address that isn't available, add another IP address and then delete the IP address that isn't available. (An endpoint must always include at least two IP addresses.) A status of ACTION_NEEDED can have a variety of causes. Here are two common causes:
        ///
        /// * One or more of the network interfaces that are associated with the endpoint were deleted using Amazon VPC.
        ///
        /// * The network interface couldn't be created for some reason that's outside the control of Resolver.
        ///
        ///
        ///
        ///
        /// * DELETING: Resolver is deleting this endpoint and the associated network interfaces.
        public var status: Route53ResolverClientTypes.ResolverEndpointStatus?
        /// A detailed description of the status of the Resolver endpoint.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            direction: Route53ResolverClientTypes.ResolverEndpointDirection? = nil,
            hostVPCId: Swift.String? = nil,
            id: Swift.String? = nil,
            ipAddressCount: Swift.Int? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            outpostArn: Swift.String? = nil,
            preferredInstanceType: Swift.String? = nil,
            protocols: [Route53ResolverClientTypes.ModelProtocol]? = nil,
            resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: Route53ResolverClientTypes.ResolverEndpointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.direction = direction
            self.hostVPCId = hostVPCId
            self.id = id
            self.ipAddressCount = ipAddressCount
            self.modificationTime = modificationTime
            self.name = name
            self.outpostArn = outpostArn
            self.preferredInstanceType = preferredInstanceType
            self.protocols = protocols
            self.resolverEndpointType = resolverEndpointType
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

public struct AssociateResolverEndpointIpAddressOutput {
    /// The response to an AssociateResolverEndpointIpAddress request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

public struct AssociateResolverQueryLogConfigInput {
    /// The ID of the query logging configuration that you want to associate a VPC with.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?
    /// The ID of an Amazon VPC that you want this query logging configuration to log queries for. The VPCs and the query logging configuration must be in the same Region.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverQueryLogConfigAssociationError: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdenied
        case destinationnotfound
        case internalserviceerror
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigAssociationError] {
            return [
                .accessdenied,
                .destinationnotfound,
                .internalserviceerror,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "ACCESS_DENIED"
            case .destinationnotfound: return "DESTINATION_NOT_FOUND"
            case .internalserviceerror: return "INTERNAL_SERVICE_ERROR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverQueryLogConfigAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionneeded
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigAssociationStatus] {
            return [
                .actionneeded,
                .active,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionneeded: return "ACTION_NEEDED"
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// In the response to an [AssociateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html), [DisassociateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html), [GetResolverQueryLogConfigAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfigAssociation.html), or [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html), request, a complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.
    public struct ResolverQueryLogConfigAssociation {
        /// The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// If the value of Status is FAILED, the value of Error indicates the cause:
        ///
        /// * DESTINATION_NOT_FOUND: The specified destination (for example, an Amazon S3 bucket) was deleted.
        ///
        /// * ACCESS_DENIED: Permissions don't allow sending logs to the destination.
        ///
        ///
        /// If the value of Status is a value other than FAILED, Error is null.
        public var error: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError?
        /// Contains additional information about the error. If the value or Error is null, the value of ErrorMessage also is null.
        public var errorMessage: Swift.String?
        /// The ID of the query logging association.
        public var id: Swift.String?
        /// The ID of the query logging configuration that a VPC is associated with.
        public var resolverQueryLogConfigId: Swift.String?
        /// The ID of the Amazon VPC that is associated with the query logging configuration.
        public var resourceId: Swift.String?
        /// The status of the specified query logging association. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating an association between an Amazon VPC and a query logging configuration.
        ///
        /// * CREATED: The association between an Amazon VPC and a query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
        ///
        /// * DELETING: Resolver is deleting this query logging association.
        ///
        /// * FAILED: Resolver either couldn't create or couldn't delete the query logging association.
        public var status: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus?

        public init(
            creationTime: Swift.String? = nil,
            error: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            resolverQueryLogConfigId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            status: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.error = error
            self.errorMessage = errorMessage
            self.id = id
            self.resolverQueryLogConfigId = resolverQueryLogConfigId
            self.resourceId = resourceId
            self.status = status
        }
    }

}

public struct AssociateResolverQueryLogConfigOutput {
    /// A complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init(
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

/// The specified resource isn't available.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceUnavailableException error, the type of resource that isn't available.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

public struct AssociateResolverRuleInput {
    /// A name for the association that you're creating between a Resolver rule and a VPC.
    public var name: Swift.String?
    /// The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html).
    /// This member is required.
    public var resolverRuleId: Swift.String?
    /// The ID of the VPC that you want to associate the Resolver rule with.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        name: Swift.String? = nil,
        resolverRuleId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.name = name
        self.resolverRuleId = resolverRuleId
        self.vpcId = vpcId
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverRuleAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case creating
        case deleting
        case failed
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverRuleAssociationStatus] {
            return [
                .complete,
                .creating,
                .deleting,
                .failed,
                .overridden
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// In the response to an [AssociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html), [DisassociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html), or [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html) request, provides information about an association between a Resolver rule and a VPC. The association determines which DNS queries that originate in the VPC are forwarded to your network.
    public struct ResolverRuleAssociation {
        /// The ID of the association between a Resolver rule and a VPC. Resolver assigns this value when you submit an [AssociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html) request.
        public var id: Swift.String?
        /// The name of an association between a Resolver rule and a VPC.
        public var name: Swift.String?
        /// The ID of the Resolver rule that you associated with the VPC that is specified by VPCId.
        public var resolverRuleId: Swift.String?
        /// A code that specifies the current status of the association between a Resolver rule and a VPC.
        public var status: Route53ResolverClientTypes.ResolverRuleAssociationStatus?
        /// A detailed description of the status of the association between a Resolver rule and a VPC.
        public var statusMessage: Swift.String?
        /// The ID of the VPC that you associated the Resolver rule with.
        public var vpcId: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resolverRuleId: Swift.String? = nil,
            status: Route53ResolverClientTypes.ResolverRuleAssociationStatus? = nil,
            statusMessage: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.resolverRuleId = resolverRuleId
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }
    }

}

public struct AssociateResolverRuleOutput {
    /// Information about the AssociateResolverRule request, including the status of the request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init(
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

extension Route53ResolverClientTypes {

    public enum AutodefinedReverseFlag: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disable
        case enable
        case useLocalResourceSetting
        case sdkUnknown(Swift.String)

        public static var allCases: [AutodefinedReverseFlag] {
            return [
                .disable,
                .enable,
                .useLocalResourceSetting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .useLocalResourceSetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {

    public enum BlockOverrideDnsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cname
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockOverrideDnsType] {
            return [
                .cname
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cname: return "CNAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {

    public enum BlockResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nodata
        case nxdomain
        case `override`
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockResponse] {
            return [
                .nodata,
                .nxdomain,
                .override
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nodata: return "NODATA"
            case .nxdomain: return "NXDOMAIN"
            case .override: return "OVERRIDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFirewallDomainListInput {
    /// A unique string that identifies the request and that allows you to retry failed requests without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// A name that lets you identify the domain list to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the domain list.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

extension Route53ResolverClientTypes {

    public enum FirewallDomainListStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case completeImportFailed
        case deleting
        case importing
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainListStatus] {
            return [
                .complete,
                .completeImportFailed,
                .deleting,
                .importing,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .completeImportFailed: return "COMPLETE_IMPORT_FAILED"
            case .deleting: return "DELETING"
            case .importing: return "IMPORTING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// High-level information about a list of firewall domains for use in a [FirewallRule]. This is returned by [GetFirewallDomainList]. To retrieve the domains that are defined for this domain list, call [ListFirewallDomains].
    public struct FirewallDomainList {
        /// The Amazon Resource Name (ARN) of the firewall domain list.
        public var arn: Swift.String?
        /// The date and time that the domain list was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The number of domain names that are specified in the domain list.
        public var domainCount: Swift.Int?
        /// The ID of the domain list.
        public var id: Swift.String?
        /// The owner of the list, used only for lists that are not managed by you. For example, the managed domain list AWSManagedDomainsMalwareDomainList has the managed owner name Route 53 Resolver DNS Firewall.
        public var managedOwnerName: Swift.String?
        /// The date and time that the domain list was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the domain list.
        public var name: Swift.String?
        /// The status of the domain list.
        public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
        /// Additional information about the status of the list, if available.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            domainCount: Swift.Int? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.domainCount = domainCount
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.modificationTime = modificationTime
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

public struct CreateFirewallDomainListOutput {
    /// The domain list that you just created.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init(
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

extension Route53ResolverClientTypes {

    public enum FirewallDomainRedirectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inspectRedirectionDomain
        case trustRedirectionDomain
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainRedirectionAction] {
            return [
                .inspectRedirectionDomain,
                .trustRedirectionDomain
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inspectRedirectionDomain: return "INSPECT_REDIRECTION_DOMAIN"
            case .trustRedirectionDomain: return "TRUST_REDIRECTION_DOMAIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFirewallRuleInput {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request and send metrics and logs to Cloud Watch.
    ///
    /// * BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    /// This member is required.
    public var action: Route53ResolverClientTypes.Action?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request, used with the rule action setting BLOCK.
    ///
    /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
    ///
    /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
    ///
    /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
    ///
    ///
    /// This setting is required if the rule action setting is BLOCK.
    public var blockResponse: Route53ResolverClientTypes.BlockResponse?
    /// A unique string that identifies the request and that allows you to retry failed requests without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The ID of the domain list that you want to use in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// How you want the the rule to evaluate DNS redirection in the DNS redirection chain, such as CNAME or DNAME. Inspect_Redirection_Domain (Default) inspects all domains in the redirection chain. The individual domains in the redirection chain must be added to the domain list. Trust_Redirection_Domain  inspects only the first domain in the redirection chain. You don't need to add the subsequent domains in the domain in the redirection list to the domain list.
    public var firewallDomainRedirectionAction: Route53ResolverClientTypes.FirewallDomainRedirectionAction?
    /// The unique identifier of the firewall rule group where you want to create the rule.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// A name that lets you identify the rule in the rule group.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group. To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for the rules in a rule group at any time.
    /// This member is required.
    public var priority: Swift.Int?
    /// The DNS query type you want the rule to evaluate. Allowed values are;
    ///
    /// * A: Returns an IPv4 address.
    ///
    /// * AAAA: Returns an Ipv6 address.
    ///
    /// * CAA: Restricts CAs that can create SSL/TLS certifications for the domain.
    ///
    /// * CNAME: Returns another domain name.
    ///
    /// * DS: Record that identifies the DNSSEC signing key of a delegated zone.
    ///
    /// * MX: Specifies mail servers.
    ///
    /// * NAPTR: Regular-expression-based rewriting of domain names.
    ///
    /// * NS: Authoritative name servers.
    ///
    /// * PTR: Maps an IP address to a domain name.
    ///
    /// * SOA: Start of authority record for the zone.
    ///
    /// * SPF: Lists the servers authorized to send emails from a domain.
    ///
    /// * SRV: Application specific values that identify servers.
    ///
    /// * TXT: Verifies email senders and application-specific values.
    ///
    /// * A query type you define by using the DNS type ID, for example 28 for AAAA. The values must be defined as TYPENUMBER, where the NUMBER can be 1-65334, for example, TYPE28. For more information, see [List of DNS record types](https://en.wikipedia.org/wiki/List_of_DNS_record_types).
    public var qtype: Swift.String?

    public init(
        action: Route53ResolverClientTypes.Action? = nil,
        blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
        creatorRequestId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        firewallDomainRedirectionAction: Route53ResolverClientTypes.FirewallDomainRedirectionAction? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        qtype: Swift.String? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.creatorRequestId = creatorRequestId
        self.firewallDomainListId = firewallDomainListId
        self.firewallDomainRedirectionAction = firewallDomainRedirectionAction
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
        self.qtype = qtype
    }
}

extension Route53ResolverClientTypes {
    /// A single firewall rule in a rule group.
    public struct FirewallRule {
        /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
        ///
        /// * ALLOW - Permit the request to go through.
        ///
        /// * ALERT - Permit the request to go through but send an alert to the logs.
        ///
        /// * BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
        public var action: Route53ResolverClientTypes.Action?
        /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
        /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideDomain: Swift.String?
        /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideTtl: Swift.Int?
        /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
        ///
        /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
        ///
        /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
        ///
        /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
        public var blockResponse: Route53ResolverClientTypes.BlockResponse?
        /// The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of executing the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the domain list that's used in the rule.
        public var firewallDomainListId: Swift.String?
        /// How you want the the rule to evaluate DNS redirection in the DNS redirection chain, such as CNAME or DNAME. Inspect_Redirection_Domain (Default) inspects all domains in the redirection chain. The individual domains in the redirection chain must be added to the domain list. Trust_Redirection_Domain  inspects only the first domain in the redirection chain. You don't need to add the subsequent domains in the domain in the redirection list to the domain list.
        public var firewallDomainRedirectionAction: Route53ResolverClientTypes.FirewallDomainRedirectionAction?
        /// The unique identifier of the firewall rule group of the rule.
        public var firewallRuleGroupId: Swift.String?
        /// The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule in the rule group. This value must be unique within the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
        public var priority: Swift.Int?
        /// The DNS query type you want the rule to evaluate. Allowed values are;
        ///
        /// * A: Returns an IPv4 address.
        ///
        /// * AAAA: Returns an Ipv6 address.
        ///
        /// * CAA: Restricts CAs that can create SSL/TLS certifications for the domain.
        ///
        /// * CNAME: Returns another domain name.
        ///
        /// * DS: Record that identifies the DNSSEC signing key of a delegated zone.
        ///
        /// * MX: Specifies mail servers.
        ///
        /// * NAPTR: Regular-expression-based rewriting of domain names.
        ///
        /// * NS: Authoritative name servers.
        ///
        /// * PTR: Maps an IP address to a domain name.
        ///
        /// * SOA: Start of authority record for the zone.
        ///
        /// * SPF: Lists the servers authorized to send emails from a domain.
        ///
        /// * SRV: Application specific values that identify servers.
        ///
        /// * TXT: Verifies email senders and application-specific values.
        ///
        /// * A query type you define by using the DNS type ID, for example 28 for AAAA. The values must be defined as TYPENUMBER, where the NUMBER can be 1-65334, for example, TYPE28. For more information, see [List of DNS record types](https://en.wikipedia.org/wiki/List_of_DNS_record_types).
        public var qtype: Swift.String?

        public init(
            action: Route53ResolverClientTypes.Action? = nil,
            blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            firewallDomainListId: Swift.String? = nil,
            firewallDomainRedirectionAction: Route53ResolverClientTypes.FirewallDomainRedirectionAction? = nil,
            firewallRuleGroupId: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            qtype: Swift.String? = nil
        )
        {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.firewallDomainListId = firewallDomainListId
            self.firewallDomainRedirectionAction = firewallDomainRedirectionAction
            self.firewallRuleGroupId = firewallRuleGroupId
            self.modificationTime = modificationTime
            self.name = name
            self.priority = priority
            self.qtype = qtype
        }
    }

}

public struct CreateFirewallRuleOutput {
    /// The firewall rule that you just created.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init(
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

public struct CreateFirewallRuleGroupInput {
    /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// A name that lets you identify the rule group, to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the rule group.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

extension Route53ResolverClientTypes {

    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notshared
        case sharedbyme
        case sharedwithme
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .notshared,
                .sharedbyme,
                .sharedwithme
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notshared: return "NOT_SHARED"
            case .sharedbyme: return "SHARED_BY_ME"
            case .sharedwithme: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {

    public enum FirewallRuleGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRuleGroupStatus] {
            return [
                .complete,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// High-level information for a firewall rule group. A firewall rule group is a collection of rules that DNS Firewall uses to filter DNS network traffic for a VPC. To retrieve the rules for the rule group, call [ListFirewallRules].
    public struct FirewallRuleGroup {
        /// The ARN (Amazon Resource Name) of the rule group.
        public var arn: Swift.String?
        /// The date and time that the rule group was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the rule group.
        public var id: Swift.String?
        /// The date and time that the rule group was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account, this is the account that has shared the rule group with you.
        public var ownerId: Swift.String?
        /// The number of rules in the rule group.
        public var ruleCount: Swift.Int?
        /// Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// The status of the domain list.
        public var status: Route53ResolverClientTypes.FirewallRuleGroupStatus?
        /// Additional information about the status of the rule group, if available.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            ruleCount: Swift.Int? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.FirewallRuleGroupStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.modificationTime = modificationTime
            self.name = name
            self.ownerId = ownerId
            self.ruleCount = ruleCount
            self.shareStatus = shareStatus
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

public struct CreateFirewallRuleGroupOutput {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init(
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

/// Fulfilling the request would cause one or more quotas to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateOutpostResolverInput {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// Number of Amazon EC2 instances for the Resolver on Outpost. The default and minimal value is 4.
    public var instanceCount: Swift.Int?
    /// A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost. If you specify this, you must also specify a value for the PreferredInstanceType.
    /// This member is required.
    public var outpostArn: Swift.String?
    /// The Amazon EC2 instance type. If you specify this, you must also specify a value for the OutpostArn.
    /// This member is required.
    public var preferredInstanceType: Swift.String?
    /// A string that helps identify the Route 53 Resolvers on Outpost.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        instanceCount: Swift.Int? = nil,
        name: Swift.String? = nil,
        outpostArn: Swift.String? = nil,
        preferredInstanceType: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.instanceCount = instanceCount
        self.name = name
        self.outpostArn = outpostArn
        self.preferredInstanceType = preferredInstanceType
        self.tags = tags
    }
}

extension Route53ResolverClientTypes {

    public enum OutpostResolverStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionNeeded
        case creating
        case deleting
        case failedCreation
        case failedDeletion
        case operational
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [OutpostResolverStatus] {
            return [
                .actionNeeded,
                .creating,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .operational,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionNeeded: return "ACTION_NEEDED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .operational: return "OPERATIONAL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains settings for an existing Resolver on an Outpost.
    public struct OutpostResolver {
        /// The ARN (Amazon Resource Name) for the Resolver on an Outpost.
        public var arn: Swift.String?
        /// The date and time that the Outpost Resolver was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the Resolver endpoint. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// The ID of the Resolver on Outpost.
        public var id: Swift.String?
        /// Amazon EC2 instance count for the Resolver on the Outpost.
        public var instanceCount: Swift.Int?
        /// The date and time that the Outpost Resolver was modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// Name of the Resolver.
        public var name: Swift.String?
        /// The ARN (Amazon Resource Name) for the Outpost.
        public var outpostArn: Swift.String?
        /// The Amazon EC2 instance type.
        public var preferredInstanceType: Swift.String?
        /// Status of the Resolver.
        public var status: Route53ResolverClientTypes.OutpostResolverStatus?
        /// A detailed description of the Resolver.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            outpostArn: Swift.String? = nil,
            preferredInstanceType: Swift.String? = nil,
            status: Route53ResolverClientTypes.OutpostResolverStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.instanceCount = instanceCount
            self.modificationTime = modificationTime
            self.name = name
            self.outpostArn = outpostArn
            self.preferredInstanceType = preferredInstanceType
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

public struct CreateOutpostResolverOutput {
    /// Information about the CreateOutpostResolver request, including the status of the request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

extension Route53ResolverClientTypes {
    /// In a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request, the IP address that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). IpAddressRequest also includes the ID of the subnet that contains the IP address.
    public struct IpAddressRequest {
        /// The IPv4 address that you want to use for DNS queries.
        public var ip: Swift.String?
        /// The IPv6 address that you want to use for DNS queries.
        public var ipv6: Swift.String?
        /// The ID of the subnet that contains the IP address.
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            ip: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.ip = ip
            self.ipv6 = ipv6
            self.subnetId = subnetId
        }
    }

}

public struct CreateResolverEndpointInput {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// Specify the applicable value:
    ///
    /// * INBOUND: Resolver forwards DNS queries to the DNS service for a VPC from your network
    ///
    /// * OUTBOUND: Resolver forwards DNS queries from the DNS service for a VPC to your network
    /// This member is required.
    public var direction: Route53ResolverClientTypes.ResolverEndpointDirection?
    /// The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC. Even though the minimum is 1, Route 53 requires that you create at least two.
    /// This member is required.
    public var ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]?
    /// A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost. If you specify this, you must also specify a value for the PreferredInstanceType.
    public var outpostArn: Swift.String?
    /// The instance type. If you specify this, you must also specify a value for the OutpostArn.
    public var preferredInstanceType: Swift.String?
    /// The protocols you want to use for the endpoint. DoH-FIPS is applicable for inbound endpoints only. For an inbound endpoint you can apply the protocols as follows:
    ///
    /// * Do53 and DoH in combination.
    ///
    /// * Do53 and DoH-FIPS in combination.
    ///
    /// * Do53 alone.
    ///
    /// * DoH alone.
    ///
    /// * DoH-FIPS alone.
    ///
    /// * None, which is treated as Do53.
    ///
    ///
    /// For an outbound endpoint you can apply the protocols as follows:
    ///
    /// * Do53 and DoH in combination.
    ///
    /// * Do53 alone.
    ///
    /// * DoH alone.
    ///
    /// * None, which is treated as Do53.
    public var protocols: [Route53ResolverClientTypes.ModelProtocol]?
    /// For the endpoint type you can choose either IPv4, IPv6, or dual-stack. A dual-stack endpoint means that it will resolve via both IPv4 and IPv6. This endpoint type is applied to all IP addresses.
    public var resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
    /// The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network. Some security group rules will cause your connection to be tracked. For outbound resolver endpoint, it can potentially impact the maximum queries per second from outbound endpoint to your target name server. For inbound resolver endpoint, it can bring down the overall maximum queries per second per IP address to as low as 1500. To avoid connection tracking caused by security group, see [Untracked connections](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#untracked-connectionsl).
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// A list of the tag keys and values that you want to associate with the endpoint.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        direction: Route53ResolverClientTypes.ResolverEndpointDirection? = nil,
        ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]? = nil,
        name: Swift.String? = nil,
        outpostArn: Swift.String? = nil,
        preferredInstanceType: Swift.String? = nil,
        protocols: [Route53ResolverClientTypes.ModelProtocol]? = nil,
        resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType? = nil,
        securityGroupIds: [Swift.String]? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.direction = direction
        self.ipAddresses = ipAddresses
        self.name = name
        self.outpostArn = outpostArn
        self.preferredInstanceType = preferredInstanceType
        self.protocols = protocols
        self.resolverEndpointType = resolverEndpointType
        self.securityGroupIds = securityGroupIds
        self.tags = tags
    }
}

public struct CreateResolverEndpointOutput {
    /// Information about the CreateResolverEndpoint request, including the status of the request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

public struct CreateResolverQueryLogConfigInput {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The ARN of the resource that you want Resolver to send query logs. You can send query logs to an S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream. Examples of valid values include the following:
    ///
    /// * S3 bucket: arn:aws:s3:::examplebucket You can optionally append a file prefix to the end of the ARN. arn:aws:s3:::examplebucket/development/
    ///
    /// * CloudWatch Logs log group: arn:aws:logs:us-west-1:123456789012:log-group:/mystack-testgroup-12ABC1AB12A1:*
    ///
    /// * Kinesis Data Firehose delivery stream: arn:aws:kinesis:us-east-2:0123456789:stream/my_stream_name
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The name that you want to give the query logging configuration.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the query logging configuration.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.destinationArn = destinationArn
        self.name = name
        self.tags = tags
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverQueryLogConfigStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigStatus] {
            return [
                .created,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [CreateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverQueryLogConfig.html), [DeleteResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverQueryLogConfig.html), [GetResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfig.html), or [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html) request, a complex type that contains settings for one query logging configuration.
    public struct ResolverQueryLogConfig {
        /// The ARN for the query logging configuration.
        public var arn: Swift.String?
        /// The number of VPCs that are associated with the query logging configuration.
        public var associationCount: Swift.Int
        /// The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the query logging configuration. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// The ARN of the resource that you want Resolver to send query logs: an Amazon S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.
        public var destinationArn: Swift.String?
        /// The ID for the query logging configuration.
        public var id: Swift.String?
        /// The name of the query logging configuration.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the query logging configuration.
        public var ownerId: Swift.String?
        /// An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// The status of the specified query logging configuration. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating the query logging configuration.
        ///
        /// * CREATED: The query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
        ///
        /// * DELETING: Resolver is deleting this query logging configuration.
        ///
        /// * FAILED: Resolver can't deliver logs to the location that is specified in the query logging configuration. Here are two common causes:
        ///
        /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
        ///
        /// * Permissions don't allow sending logs to the destination.
        public var status: Route53ResolverClientTypes.ResolverQueryLogConfigStatus?

        public init(
            arn: Swift.String? = nil,
            associationCount: Swift.Int = 0,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.ResolverQueryLogConfigStatus? = nil
        )
        {
            self.arn = arn
            self.associationCount = associationCount
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.destinationArn = destinationArn
            self.id = id
            self.name = name
            self.ownerId = ownerId
            self.shareStatus = shareStatus
            self.status = status
        }
    }

}

public struct CreateResolverQueryLogConfigOutput {
    /// Information about the CreateResolverQueryLogConfig request, including the status of the request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init(
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

extension Route53ResolverClientTypes {

    public enum RuleTypeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forward
        case recursive
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleTypeOption] {
            return [
                .forward,
                .recursive,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forward: return "FORWARD"
            case .recursive: return "RECURSIVE"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// In a [CreateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html) request, an array of the IPs that you want to forward DNS queries to.
    public struct TargetAddress {
        /// One IPv4 address that you want to forward DNS queries to.
        public var ip: Swift.String?
        /// One IPv6 address that you want to forward DNS queries to.
        public var ipv6: Swift.String?
        /// The port at Ip that you want to forward DNS queries to.
        public var port: Swift.Int?
        /// The protocols for the Resolver endpoints. DoH-FIPS is applicable for inbound endpoints only. For an inbound endpoint you can apply the protocols as follows:
        ///
        /// * Do53 and DoH in combination.
        ///
        /// * Do53 and DoH-FIPS in combination.
        ///
        /// * Do53 alone.
        ///
        /// * DoH alone.
        ///
        /// * DoH-FIPS alone.
        ///
        /// * None, which is treated as Do53.
        ///
        ///
        /// For an outbound endpoint you can apply the protocols as follows:
        ///
        /// * Do53 and DoH in combination.
        ///
        /// * Do53 alone.
        ///
        /// * DoH alone.
        ///
        /// * None, which is treated as Do53.
        public var `protocol`: Route53ResolverClientTypes.ModelProtocol?

        public init(
            ip: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: Route53ResolverClientTypes.ModelProtocol? = nil
        )
        {
            self.ip = ip
            self.ipv6 = ipv6
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

public struct CreateResolverRuleInput {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// DNS queries for this domain name are forwarded to the IP addresses that you specify in TargetIps. If a query matches multiple Resolver rules (example.com and www.example.com), outbound DNS queries are routed using the Resolver rule that contains the most specific domain name (www.example.com).
    public var domainName: Swift.String?
    /// A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.
    public var name: Swift.String?
    /// The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in TargetIps.
    public var resolverEndpointId: Swift.String?
    /// When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD. When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM. For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify FORWARD for RuleType. To then have Resolver process queries for apex.example.com, you create a rule and specify SYSTEM for RuleType. Currently, only Resolver can create rules that have a value of RECURSIVE for RuleType.
    /// This member is required.
    public var ruleType: Route53ResolverClientTypes.RuleTypeOption?
    /// A list of the tag keys and values that you want to associate with the endpoint.
    public var tags: [Route53ResolverClientTypes.Tag]?
    /// The IPs that you want Resolver to forward DNS queries to. You can specify either Ipv4 or Ipv6 addresses but not both in the same rule. Separate IP addresses with a space. TargetIps is available only when the value of Rule type is FORWARD.
    public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

    public init(
        creatorRequestId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        name: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil,
        ruleType: Route53ResolverClientTypes.RuleTypeOption? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil,
        targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.domainName = domainName
        self.name = name
        self.resolverEndpointId = resolverEndpointId
        self.ruleType = ruleType
        self.tags = tags
        self.targetIps = targetIps
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverRuleStatus] {
            return [
                .complete,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// For queries that originate in your VPC, detailed information about a Resolver rule, which specifies how to route DNS queries out of the VPC. The ResolverRule parameter appears in the response to a [CreateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html), [DeleteResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverRule.html), [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), or [UpdateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html) request.
    public struct ResolverRule {
        /// The ARN (Amazon Resource Name) for the Resolver rule specified by Id.
        public var arn: Swift.String?
        /// The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that you specified when you created the Resolver rule. CreatorRequestId identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// DNS queries for this domain name are forwarded to the IP addresses that are specified in TargetIps. If a query matches multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name (www.example.com).
        public var domainName: Swift.String?
        /// The ID that Resolver assigned to the Resolver rule when you created it.
        public var id: Swift.String?
        /// The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name for the Resolver rule, which you specified when you created the Resolver rule.
        public var name: Swift.String?
        /// When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.
        public var ownerId: Swift.String?
        /// The ID of the endpoint that the rule is associated with.
        public var resolverEndpointId: Swift.String?
        /// When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD. When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM. For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify FORWARD for RuleType. To then have Resolver process queries for apex.example.com, you create a rule and specify SYSTEM for RuleType. Currently, only Resolver can create rules that have a value of RECURSIVE for RuleType.
        public var ruleType: Route53ResolverClientTypes.RuleTypeOption?
        /// Whether the rule is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// A code that specifies the current status of the Resolver rule.
        public var status: Route53ResolverClientTypes.ResolverRuleStatus?
        /// A detailed description of the status of a Resolver rule.
        public var statusMessage: Swift.String?
        /// An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network.
        public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resolverEndpointId: Swift.String? = nil,
            ruleType: Route53ResolverClientTypes.RuleTypeOption? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.ResolverRuleStatus? = nil,
            statusMessage: Swift.String? = nil,
            targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.domainName = domainName
            self.id = id
            self.modificationTime = modificationTime
            self.name = name
            self.ownerId = ownerId
            self.resolverEndpointId = resolverEndpointId
            self.ruleType = ruleType
            self.shareStatus = shareStatus
            self.status = status
            self.statusMessage = statusMessage
            self.targetIps = targetIps
        }
    }

}

public struct CreateResolverRuleOutput {
    /// Information about the CreateResolverRule request, including the status of the request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

public struct DeleteFirewallDomainListInput {
    /// The ID of the domain list that you want to delete.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

public struct DeleteFirewallDomainListOutput {
    /// The domain list that you just deleted.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init(
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

public struct DeleteFirewallRuleInput {
    /// The ID of the domain list that's used in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the firewall rule group that you want to delete the rule from.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// The DNS query type that the rule you are deleting evaluates. Allowed values are;
    ///
    /// * A: Returns an IPv4 address.
    ///
    /// * AAAA: Returns an Ipv6 address.
    ///
    /// * CAA: Restricts CAs that can create SSL/TLS certifications for the domain.
    ///
    /// * CNAME: Returns another domain name.
    ///
    /// * DS: Record that identifies the DNSSEC signing key of a delegated zone.
    ///
    /// * MX: Specifies mail servers.
    ///
    /// * NAPTR: Regular-expression-based rewriting of domain names.
    ///
    /// * NS: Authoritative name servers.
    ///
    /// * PTR: Maps an IP address to a domain name.
    ///
    /// * SOA: Start of authority record for the zone.
    ///
    /// * SPF: Lists the servers authorized to send emails from a domain.
    ///
    /// * SRV: Application specific values that identify servers.
    ///
    /// * TXT: Verifies email senders and application-specific values.
    ///
    /// * A query type you define by using the DNS type ID, for example 28 for AAAA. The values must be defined as TYPENUMBER, where the NUMBER can be 1-65334, for example, TYPE28. For more information, see [List of DNS record types](https://en.wikipedia.org/wiki/List_of_DNS_record_types).
    public var qtype: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        qtype: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.qtype = qtype
    }
}

public struct DeleteFirewallRuleOutput {
    /// The specification for the firewall rule that you just deleted.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init(
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

public struct DeleteFirewallRuleGroupInput {
    /// The unique identifier of the firewall rule group that you want to delete.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init(
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

public struct DeleteFirewallRuleGroupOutput {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init(
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

public struct DeleteOutpostResolverInput {
    /// A unique string that identifies the Resolver on the Outpost.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteOutpostResolverOutput {
    /// Information about the DeleteOutpostResolver request, including the status of the request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

public struct DeleteResolverEndpointInput {
    /// The ID of the Resolver endpoint that you want to delete.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

public struct DeleteResolverEndpointOutput {
    /// Information about the DeleteResolverEndpoint request, including the status of the request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

public struct DeleteResolverQueryLogConfigInput {
    /// The ID of the query logging configuration that you want to delete.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

public struct DeleteResolverQueryLogConfigOutput {
    /// Information about the query logging configuration that you deleted, including the status of the request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init(
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

/// The resource that you tried to update or delete is currently in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceInUseException error, the type of resource that is currently in use.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

public struct DeleteResolverRuleInput {
    /// The ID of the Resolver rule that you want to delete.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init(
        resolverRuleId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

public struct DeleteResolverRuleOutput {
    /// Information about the DeleteResolverRule request, including the status of the request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

public struct DisassociateFirewallRuleGroupInput {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?

    public init(
        firewallRuleGroupAssociationId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

public struct DisassociateFirewallRuleGroupOutput {
    /// The firewall rule group association that you just removed.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

public struct DisassociateResolverEndpointIpAddressInput {
    /// The IPv4 address that you want to remove from a Resolver endpoint.
    /// This member is required.
    public var ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
    /// The ID of the Resolver endpoint that you want to disassociate an IP address from.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        ipAddress: Route53ResolverClientTypes.IpAddressUpdate? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

public struct DisassociateResolverEndpointIpAddressOutput {
    /// The response to an DisassociateResolverEndpointIpAddress request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

public struct DisassociateResolverQueryLogConfigInput {
    /// The ID of the query logging configuration that you want to disassociate a specified VPC from.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?
    /// The ID of the Amazon VPC that you want to disassociate from a specified query logging configuration.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

public struct DisassociateResolverQueryLogConfigOutput {
    /// A complex type that contains settings for the association that you deleted between an Amazon VPC and a query logging configuration.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init(
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

public struct DisassociateResolverRuleInput {
    /// The ID of the Resolver rule that you want to disassociate from the specified VPC.
    /// This member is required.
    public var resolverRuleId: Swift.String?
    /// The ID of the VPC that you want to disassociate the Resolver rule from.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        resolverRuleId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
        self.vpcId = vpcId
    }
}

public struct DisassociateResolverRuleOutput {
    /// Information about the DisassociateResolverRule request, including the status of the request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init(
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

extension Route53ResolverClientTypes {
    /// For Resolver list operations ([ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html), [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html), [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html)), and [ListResolverDnssecConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverDnssecConfigs.html)), an optional specification to return a subset of objects. To filter objects, such as Resolver endpoints or Resolver rules, you specify Name and Values. For example, to list only inbound Resolver endpoints, specify Direction for Name and specify INBOUND for Values.
    public struct Filter {
        /// The name of the parameter that you want to use to filter objects. The valid values for Name depend on the action that you're including the filter in, [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html), [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html), or [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html). In early versions of Resolver, values for Name were listed as uppercase, with underscore (_) delimiters. For example, CreatorRequestId was originally listed as CREATOR_REQUEST_ID. Uppercase values for Name are still supported. ListResolverEndpoints Valid values for Name include the following:
        ///
        /// * CreatorRequestId: The value that you specified when you created the Resolver endpoint.
        ///
        /// * Direction: Whether you want to return inbound or outbound Resolver endpoints. If you specify DIRECTION for Name, specify INBOUND or OUTBOUND for Values.
        ///
        /// * HostVPCId: The ID of the VPC that inbound DNS queries pass through on the way from your network to your VPCs in a region, or the VPC that outbound queries pass through on the way from your VPCs to your network. In a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request, SubnetId indirectly identifies the VPC. In a [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html) request, the VPC ID for a Resolver endpoint is returned in the HostVPCId element.
        ///
        /// * IpAddressCount: The number of IP addresses that you have associated with the Resolver endpoint.
        ///
        /// * Name: The name of the Resolver endpoint.
        ///
        /// * SecurityGroupIds: The IDs of the VPC security groups that you specified when you created the Resolver endpoint.
        ///
        /// * Status: The status of the Resolver endpoint. If you specify Status for Name, specify one of the following status codes for Values: CREATING, OPERATIONAL, UPDATING, AUTO_RECOVERING, ACTION_NEEDED, or DELETING. For more information, see Status in [ResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverEndpoint.html).
        ///
        ///
        /// ListResolverRules Valid values for Name include the following:
        ///
        /// * CreatorRequestId: The value that you specified when you created the Resolver rule.
        ///
        /// * DomainName: The domain name for which Resolver is forwarding DNS queries to your network. In the value that you specify for Values, include a trailing dot (.) after the domain name. For example, if the domain name is example.com, specify the following value. Note the "." after com: example.com.
        ///
        /// * Name: The name of the Resolver rule.
        ///
        /// * ResolverEndpointId: The ID of the Resolver endpoint that the Resolver rule is associated with. You can filter on the Resolver endpoint only for rules that have a value of FORWARD for RuleType.
        ///
        /// * Status: The status of the Resolver rule. If you specify Status for Name, specify one of the following status codes for Values: COMPLETE, DELETING, UPDATING, or FAILED.
        ///
        /// * Type: The type of the Resolver rule. If you specify TYPE for Name, specify FORWARD or SYSTEM for Values.
        ///
        ///
        /// ListResolverRuleAssociations Valid values for Name include the following:
        ///
        /// * Name: The name of the Resolver rule association.
        ///
        /// * ResolverRuleId: The ID of the Resolver rule that is associated with one or more VPCs.
        ///
        /// * Status: The status of the Resolver rule association. If you specify Status for Name, specify one of the following status codes for Values: CREATING, COMPLETE, DELETING, or FAILED.
        ///
        /// * VPCId: The ID of the VPC that the Resolver rule is associated with.
        ///
        ///
        /// ListResolverQueryLogConfigs Valid values for Name include the following:
        ///
        /// * Arn: The ARN for the query logging configuration.
        ///
        /// * AssociationCount: The number of VPCs that are associated with the query logging configuration.
        ///
        /// * CreationTime: The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).
        ///
        /// * CreatorRequestId: A unique string that identifies the request that created the query logging configuration.
        ///
        /// * Destination: The Amazon Web Services service that you want to forward query logs to. Valid values include the following:
        ///
        /// * S3
        ///
        /// * CloudWatchLogs
        ///
        /// * KinesisFirehose
        ///
        ///
        ///
        ///
        /// * DestinationArn: The ARN of the location that Resolver is sending query logs to. This value can be the ARN for an S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.
        ///
        /// * Id: The ID of the query logging configuration
        ///
        /// * Name: The name of the query logging configuration
        ///
        /// * OwnerId: The Amazon Web Services account ID for the account that created the query logging configuration.
        ///
        /// * ShareStatus: An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Valid values include: NOT_SHARED, SHARED_WITH_ME, or SHARED_BY_ME.
        ///
        /// * Status: The status of the query logging configuration. If you specify Status for Name, specify the applicable status code for Values: CREATING, CREATED, DELETING, or FAILED. For more information, see [Status](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfig.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfig-Status).
        ///
        ///
        /// ListResolverQueryLogConfigAssociations Valid values for Name include the following:
        ///
        /// * CreationTime: The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).
        ///
        /// * Error: If the value of Status is FAILED, specify the cause: DESTINATION_NOT_FOUND or ACCESS_DENIED.
        ///
        /// * Id: The ID of the query logging association.
        ///
        /// * ResolverQueryLogConfigId: The ID of the query logging configuration that a VPC is associated with.
        ///
        /// * ResourceId: The ID of the Amazon VPC that is associated with the query logging configuration.
        ///
        /// * Status: The status of the query logging association. If you specify Status for Name, specify the applicable status code for Values: CREATING, CREATED, DELETING, or FAILED. For more information, see [Status](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfigAssociation.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfigAssociation-Status).
        public var name: Swift.String?
        /// When you're using a List operation and you want the operation to return a subset of objects, such as Resolver endpoints or Resolver rules, the value of the parameter that you want to use to filter objects. For example, to list only inbound Resolver endpoints, specify Direction for Name and specify INBOUND for Values.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension Route53ResolverClientTypes {

    public enum FirewallFailOpenStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case useLocalResourceSetting
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallFailOpenStatus] {
            return [
                .disabled,
                .enabled,
                .useLocalResourceSetting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .useLocalResourceSetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC from Amazon Virtual Private Cloud (Amazon VPC).
    public struct FirewallConfig {
        /// Determines how DNS Firewall operates during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply.
        ///
        /// * By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall returns a failure error when it is unable to properly evaluate a query.
        ///
        /// * If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it is unable to properly evaluate them.
        ///
        ///
        /// This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association.
        public var firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
        /// The ID of the firewall configuration.
        public var id: Swift.String?
        /// The Amazon Web Services account ID of the owner of the VPC that this firewall configuration applies to.
        public var ownerId: Swift.String?
        /// The ID of the VPC that this firewall configuration applies to.
        public var resourceId: Swift.String?

        public init(
            firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus? = nil,
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.firewallFailOpen = firewallFailOpen
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
        }
    }

}

extension Route53ResolverClientTypes {

    public enum FirewallDomainImportOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainImportOperation] {
            return [
                .replace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// Minimal high-level information for a firewall domain list. The action [ListFirewallDomainLists] returns an array of these objects. To retrieve full information for a firewall domain list, call [GetFirewallDomainList] and [ListFirewallDomains].
    public struct FirewallDomainListMetadata {
        /// The Amazon Resource Name (ARN) of the firewall domain list metadata.
        public var arn: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the domain list.
        public var id: Swift.String?
        /// The owner of the list, used only for lists that are not managed by you. For example, the managed domain list AWSManagedDomainsMalwareDomainList has the managed owner name Route 53 Resolver DNS Firewall.
        public var managedOwnerName: Swift.String?
        /// The name of the domain list.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.name = name
        }
    }

}

extension Route53ResolverClientTypes {

    public enum FirewallDomainUpdateOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainUpdateOperation] {
            return [
                .add,
                .remove,
                .replace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// Minimal high-level information for a firewall rule group. The action [ListFirewallRuleGroups] returns an array of these objects. To retrieve full information for a firewall rule group, call [GetFirewallRuleGroup] and [ListFirewallRules].
    public struct FirewallRuleGroupMetadata {
        /// The ARN (Amazon Resource Name) of the rule group.
        public var arn: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the rule group.
        public var id: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account, this is the account that has shared the rule group with you.
        public var ownerId: Swift.String?
        /// Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?

        public init(
            arn: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil
        )
        {
            self.arn = arn
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.name = name
            self.ownerId = ownerId
            self.shareStatus = shareStatus
        }
    }

}

public struct GetFirewallConfigInput {
    /// The ID of the VPC from Amazon VPC that the configuration is for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

public struct GetFirewallConfigOutput {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC from AmazonVPC.
    public var firewallConfig: Route53ResolverClientTypes.FirewallConfig?

    public init(
        firewallConfig: Route53ResolverClientTypes.FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

public struct GetFirewallDomainListInput {
    /// The ID of the domain list.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

public struct GetFirewallDomainListOutput {
    /// The domain list that you requested.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init(
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

public struct GetFirewallRuleGroupInput {
    /// The unique identifier of the firewall rule group.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init(
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

public struct GetFirewallRuleGroupOutput {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init(
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

public struct GetFirewallRuleGroupAssociationInput {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?

    public init(
        firewallRuleGroupAssociationId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

public struct GetFirewallRuleGroupAssociationOutput {
    /// The association that you requested.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

public struct GetFirewallRuleGroupPolicyInput {
    /// The ARN (Amazon Resource Name) for the rule group.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetFirewallRuleGroupPolicyOutput {
    /// The Identity and Access Management (Amazon Web Services IAM) policy for sharing the specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM).
    public var firewallRuleGroupPolicy: Swift.String?

    public init(
        firewallRuleGroupPolicy: Swift.String? = nil
    )
    {
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

public struct GetOutpostResolverInput {
    /// The ID of the Resolver on the Outpost.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetOutpostResolverOutput {
    /// Information about the GetOutpostResolver request, including the status of the request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

public struct GetResolverConfigInput {
    /// Resource ID of the Amazon VPC that you want to get information about.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverAutodefinedReverseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case updatingtouselocalresourcesetting
        case uselocalresourcesetting
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverAutodefinedReverseStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .updatingtouselocalresourcesetting,
                .uselocalresourcesetting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .updatingtouselocalresourcesetting: return "UPDATING_TO_USE_LOCAL_RESOURCE_SETTING"
            case .uselocalresourcesetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains information about a Resolver configuration for a VPC.
    public struct ResolverConfig {
        /// The status of whether or not the Resolver will create autodefined rules for reverse DNS lookups. This is enabled by default. The status can be one of following:
        ///
        /// * ENABLING: Autodefined rules for reverse DNS lookups are being enabled but are not complete.
        ///
        /// * ENABLED: Autodefined rules for reverse DNS lookups are enabled.
        ///
        /// * DISABLING: Autodefined rules for reverse DNS lookups are being disabled but are not complete.
        ///
        /// * DISABLED: Autodefined rules for reverse DNS lookups are disabled.
        public var autodefinedReverse: Route53ResolverClientTypes.ResolverAutodefinedReverseStatus?
        /// ID for the Resolver configuration.
        public var id: Swift.String?
        /// The owner account ID of the Amazon Virtual Private Cloud VPC.
        public var ownerId: Swift.String?
        /// The ID of the Amazon Virtual Private Cloud VPC that you're configuring Resolver for.
        public var resourceId: Swift.String?

        public init(
            autodefinedReverse: Route53ResolverClientTypes.ResolverAutodefinedReverseStatus? = nil,
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.autodefinedReverse = autodefinedReverse
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
        }
    }

}

public struct GetResolverConfigOutput {
    /// Information about the behavior configuration of Route 53 Resolver behavior for the VPC you specified in the GetResolverConfig request.
    public var resolverConfig: Route53ResolverClientTypes.ResolverConfig?

    public init(
        resolverConfig: Route53ResolverClientTypes.ResolverConfig? = nil
    )
    {
        self.resolverConfig = resolverConfig
    }
}

public struct GetResolverDnssecConfigInput {
    /// The ID of the virtual private cloud (VPC) for the DNSSEC validation status.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

extension Route53ResolverClientTypes {

    public enum ResolverDNSSECValidationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case updatetouselocalresourcesetting
        case uselocalresourcesetting
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverDNSSECValidationStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .updatetouselocalresourcesetting,
                .uselocalresourcesetting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .updatetouselocalresourcesetting: return "UPDATING_TO_USE_LOCAL_RESOURCE_SETTING"
            case .uselocalresourcesetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains information about a configuration for DNSSEC validation.
    public struct ResolverDnssecConfig {
        /// The ID for a configuration for DNSSEC validation.
        public var id: Swift.String?
        /// The owner account ID of the virtual private cloud (VPC) for a configuration for DNSSEC validation.
        public var ownerId: Swift.String?
        /// The ID of the virtual private cloud (VPC) that you're configuring the DNSSEC validation status for.
        public var resourceId: Swift.String?
        /// The validation status for a DNSSEC configuration. The status can be one of the following:
        ///
        /// * ENABLING: DNSSEC validation is being enabled but is not complete.
        ///
        /// * ENABLED: DNSSEC validation is enabled.
        ///
        /// * DISABLING: DNSSEC validation is being disabled but is not complete.
        ///
        /// * DISABLED DNSSEC validation is disabled.
        public var validationStatus: Route53ResolverClientTypes.ResolverDNSSECValidationStatus?

        public init(
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            validationStatus: Route53ResolverClientTypes.ResolverDNSSECValidationStatus? = nil
        )
        {
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
            self.validationStatus = validationStatus
        }
    }

}

public struct GetResolverDnssecConfigOutput {
    /// The information about a configuration for DNSSEC validation.
    public var resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?

    public init(
        resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

public struct GetResolverEndpointInput {
    /// The ID of the Resolver endpoint that you want to get information about.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

public struct GetResolverEndpointOutput {
    /// Information about the Resolver endpoint that you specified in a GetResolverEndpoint request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

public struct GetResolverQueryLogConfigInput {
    /// The ID of the Resolver query logging configuration that you want to get information about.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

public struct GetResolverQueryLogConfigOutput {
    /// Information about the Resolver query logging configuration that you specified in a GetQueryLogConfig request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init(
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

public struct GetResolverQueryLogConfigAssociationInput {
    /// The ID of the Resolver query logging configuration association that you want to get information about.
    /// This member is required.
    public var resolverQueryLogConfigAssociationId: Swift.String?

    public init(
        resolverQueryLogConfigAssociationId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationId
    }
}

public struct GetResolverQueryLogConfigAssociationOutput {
    /// Information about the Resolver query logging configuration association that you specified in a GetQueryLogConfigAssociation request.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init(
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

/// The specified resource doesn't exist.
public struct UnknownResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnknownResourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetResolverQueryLogConfigPolicyInput {
    /// The ARN of the query logging configuration that you want to get the query logging policy for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetResolverQueryLogConfigPolicyOutput {
    /// Information about the query logging policy for the query logging configuration that you specified in a GetResolverQueryLogConfigPolicy request.
    public var resolverQueryLogConfigPolicy: Swift.String?

    public init(
        resolverQueryLogConfigPolicy: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

public struct GetResolverRuleInput {
    /// The ID of the Resolver rule that you want to get information about.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init(
        resolverRuleId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

public struct GetResolverRuleOutput {
    /// Information about the Resolver rule that you specified in a GetResolverRule request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

public struct GetResolverRuleAssociationInput {
    /// The ID of the Resolver rule association that you want to get information about.
    /// This member is required.
    public var resolverRuleAssociationId: Swift.String?

    public init(
        resolverRuleAssociationId: Swift.String? = nil
    )
    {
        self.resolverRuleAssociationId = resolverRuleAssociationId
    }
}

public struct GetResolverRuleAssociationOutput {
    /// Information about the Resolver rule association that you specified in a GetResolverRuleAssociation request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init(
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

public struct GetResolverRulePolicyInput {
    /// The ID of the Resolver rule that you want to get the Resolver rule policy for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetResolverRulePolicyOutput {
    /// The Resolver rule policy for the rule that you specified in a GetResolverRulePolicy request.
    public var resolverRulePolicy: Swift.String?

    public init(
        resolverRulePolicy: Swift.String? = nil
    )
    {
        self.resolverRulePolicy = resolverRulePolicy
    }
}

public struct ImportFirewallDomainsInput {
    /// The fully qualified URL or URI of the file stored in Amazon Simple Storage Service (Amazon S3) that contains the list of domains to import. The file must be in an S3 bucket that's in the same Region as your DNS Firewall. The file must be a text file and must contain a single domain per line.
    /// This member is required.
    public var domainFileUrl: Swift.String?
    /// The ID of the domain list that you want to modify with the import operation.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// What you want DNS Firewall to do with the domains that are listed in the file. This must be set to REPLACE, which updates the domain list to exactly match the list in the file.
    /// This member is required.
    public var operation: Route53ResolverClientTypes.FirewallDomainImportOperation?

    public init(
        domainFileUrl: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Route53ResolverClientTypes.FirewallDomainImportOperation? = nil
    )
    {
        self.domainFileUrl = domainFileUrl
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

public struct ImportFirewallDomainsOutput {
    /// The Id of the firewall domain list that DNS Firewall just updated.
    public var id: Swift.String?
    /// The name of the domain list.
    public var name: Swift.String?
    /// Status of the import request.
    public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
    /// Additional information about the status of the list, if available.
    public var statusMessage: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

/// The value that you specified for NextToken in a List request isn't valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified Resolver rule policy is invalid.
public struct InvalidPolicyDocument: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicyDocument" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified tag is invalid.
public struct InvalidTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Route53ResolverClientTypes {

    public enum IpAddressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attached
        case attaching
        case creating
        case deletefailedfasexpired
        case deleting
        case detaching
        case failedcreation
        case failedresourcegone
        case remapattaching
        case remapdetaching
        case updatefailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressStatus] {
            return [
                .attached,
                .attaching,
                .creating,
                .deletefailedfasexpired,
                .deleting,
                .detaching,
                .failedcreation,
                .failedresourcegone,
                .remapattaching,
                .remapdetaching,
                .updatefailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attached: return "ATTACHED"
            case .attaching: return "ATTACHING"
            case .creating: return "CREATING"
            case .deletefailedfasexpired: return "DELETE_FAILED_FAS_EXPIRED"
            case .deleting: return "DELETING"
            case .detaching: return "DETACHING"
            case .failedcreation: return "FAILED_CREATION"
            case .failedresourcegone: return "FAILED_RESOURCE_GONE"
            case .remapattaching: return "REMAP_ATTACHING"
            case .remapdetaching: return "REMAP_DETACHING"
            case .updatefailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html) request, information about the IP addresses that the Resolver endpoint uses for DNS queries.
    public struct IpAddressResponse {
        /// The date and time that the IP address was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// One IPv4 address that the Resolver endpoint uses for DNS queries.
        public var ip: Swift.String?
        /// The ID of one IP address.
        public var ipId: Swift.String?
        /// One IPv6 address that the Resolver endpoint uses for DNS queries.
        public var ipv6: Swift.String?
        /// The date and time that the IP address was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// A status code that gives the current status of the request.
        public var status: Route53ResolverClientTypes.IpAddressStatus?
        /// A message that provides additional information about the status of the request.
        public var statusMessage: Swift.String?
        /// The ID of one subnet.
        public var subnetId: Swift.String?

        public init(
            creationTime: Swift.String? = nil,
            ip: Swift.String? = nil,
            ipId: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            status: Route53ResolverClientTypes.IpAddressStatus? = nil,
            statusMessage: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.ip = ip
            self.ipId = ipId
            self.ipv6 = ipv6
            self.modificationTime = modificationTime
            self.status = status
            self.statusMessage = statusMessage
            self.subnetId = subnetId
        }
    }

}

public struct ListFirewallConfigsInput {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFirewallConfigsOutput {
    /// The configurations for the firewall behavior provided by DNS Firewall for VPCs from Amazon Virtual Private Cloud (Amazon VPC).
    public var firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallConfigs = firewallConfigs
        self.nextToken = nextToken
    }
}

public struct ListFirewallDomainListsInput {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFirewallDomainListsOutput {
    /// A list of the domain lists that you have defined. This might be a partial list of the domain lists that you've defined. For information, see MaxResults.
    public var firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallDomainLists = firewallDomainLists
        self.nextToken = nextToken
    }
}

public struct ListFirewallDomainsInput {
    /// The ID of the domain list whose domains you want to retrieve.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFirewallDomainsOutput {
    /// A list of the domains in the firewall domain list. This might be a partial list of the domains that you've defined in the domain list. For information, see MaxResults.
    public var domains: [Swift.String]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        domains: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

public struct ListFirewallRuleGroupAssociationsInput {
    /// The unique identifier of the firewall rule group that you want to retrieve the associations for. Leave this blank to retrieve associations for any rule group.
    public var firewallRuleGroupId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting.
    public var priority: Swift.Int?
    /// The association Status setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.
    public var status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
    /// The unique identifier of the VPC that you want to retrieve the associations for. Leave this blank to retrieve associations for any VPC.
    public var vpcId: Swift.String?

    public init(
        firewallRuleGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        priority: Swift.Int? = nil,
        status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
        self.status = status
        self.vpcId = vpcId
    }
}

public struct ListFirewallRuleGroupAssociationsOutput {
    /// A list of your firewall rule group associations. This might be a partial list of the associations that you have defined. For information, see MaxResults.
    public var firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociations = firewallRuleGroupAssociations
        self.nextToken = nextToken
    }
}

public struct ListFirewallRuleGroupsInput {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFirewallRuleGroupsOutput {
    /// A list of your firewall rule groups. This might be a partial list of the rule groups that you have defined. For information, see MaxResults.
    public var firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRuleGroups = firewallRuleGroups
        self.nextToken = nextToken
    }
}

public struct ListFirewallRulesInput {
    /// Optional additional filter for the rules to retrieve. The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request to go through but send an alert to the logs.
    ///
    /// * BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
    public var action: Route53ResolverClientTypes.Action?
    /// The unique identifier of the firewall rule group that you want to retrieve the rules for.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?
    /// Optional additional filter for the rules to retrieve. The setting that determines the processing order of the rules in a rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
    public var priority: Swift.Int?

    public init(
        action: Route53ResolverClientTypes.Action? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
    }
}

public struct ListFirewallRulesOutput {
    /// A list of the rules that you have defined. This might be a partial list of the firewall rules that you've defined. For information, see MaxResults.
    public var firewallRules: [Route53ResolverClientTypes.FirewallRule]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallRules: [Route53ResolverClientTypes.FirewallRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRules = firewallRules
        self.nextToken = nextToken
    }
}

public struct ListOutpostResolversInput {
    /// The maximum number of Resolvers on the Outpost that you want to return in the response to a ListOutpostResolver request. If you don't specify a value for MaxResults, the request returns up to 100 Resolvers.
    public var maxResults: Swift.Int?
    /// For the first ListOutpostResolver request, omit this value.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost.
    public var outpostArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostArn = outpostArn
    }
}

public struct ListOutpostResolversOutput {
    /// If more than MaxResults Resolvers match the specified criteria, you can submit another ListOutpostResolver request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolvers on Outposts that were created by using the current Amazon Web Services account, and that match the specified filters, if any.
    public var outpostResolvers: [Route53ResolverClientTypes.OutpostResolver]?

    public init(
        nextToken: Swift.String? = nil,
        outpostResolvers: [Route53ResolverClientTypes.OutpostResolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.outpostResolvers = outpostResolvers
    }
}

public struct ListResolverConfigsInput {
    /// The maximum number of Resolver configurations that you want to return in the response to a ListResolverConfigs request. If you don't specify a value for MaxResults, up to 100 Resolver configurations are returned.
    public var maxResults: Swift.Int?
    /// (Optional) If the current Amazon Web Services account has more than MaxResults Resolver configurations, use NextToken to get the second and subsequent pages of results. For the first ListResolverConfigs request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResolverConfigsOutput {
    /// If a response includes the last of the Resolver configurations that are associated with the current Amazon Web Services account, NextToken doesn't appear in the response. If a response doesn't include the last of the configurations, you can get more configurations by submitting another ListResolverConfigs request. Get the value of NextToken that Amazon Route 53 returned in the previous response and include it in NextToken in the next request.
    public var nextToken: Swift.String?
    /// An array that contains one ResolverConfigs element for each Resolver configuration that is associated with the current Amazon Web Services account.
    public var resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]?

    public init(
        nextToken: Swift.String? = nil,
        resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolverConfigs = resolverConfigs
    }
}

public struct ListResolverDnssecConfigsInput {
    /// An optional specification to return a subset of objects.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// Optional: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return. If you don't specify a value for MaxResults, Route 53 returns up to 100 configuration per page.
    public var maxResults: Swift.Int?
    /// (Optional) If the current Amazon Web Services account has more than MaxResults DNSSEC configurations, use NextToken to get the second and subsequent pages of results. For the first ListResolverDnssecConfigs request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResolverDnssecConfigsOutput {
    /// If a response includes the last of the DNSSEC configurations that are associated with the current Amazon Web Services account, NextToken doesn't appear in the response. If a response doesn't include the last of the configurations, you can get more configurations by submitting another [ListResolverDnssecConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListResolverDnssecConfigs.html) request. Get the value of NextToken that Amazon Route 53 returned in the previous response and include it in NextToken in the next request.
    public var nextToken: Swift.String?
    /// An array that contains one [ResolverDnssecConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResolverDnssecConfig.html) element for each configuration for DNSSEC validation that is associated with the current Amazon Web Services account. It doesn't contain disabled DNSSEC configurations for the resource.
    public var resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]?

    public init(
        nextToken: Swift.String? = nil,
        resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolverDnssecConfigs = resolverDnssecConfigs
    }
}

public struct ListResolverEndpointIpAddressesInput {
    /// The maximum number of IP addresses that you want to return in the response to a ListResolverEndpointIpAddresses request. If you don't specify a value for MaxResults, Resolver returns up to 100 IP addresses.
    public var maxResults: Swift.Int?
    /// For the first ListResolverEndpointIpAddresses request, omit this value. If the specified Resolver endpoint has more than MaxResults IP addresses, you can submit another ListResolverEndpointIpAddresses request to get the next group of IP addresses. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The ID of the Resolver endpoint that you want to get IP addresses for.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpointId = resolverEndpointId
    }
}

public struct ListResolverEndpointIpAddressesOutput {
    /// Information about the IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints).
    public var ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]?
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If the specified endpoint has more than MaxResults IP addresses, you can submit another ListResolverEndpointIpAddresses request to get the next group of IP addresses. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipAddresses = ipAddresses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResolverEndpointsInput {
    /// An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints. If you submit a second or subsequent ListResolverEndpoints request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of Resolver endpoints that you want to return in the response to a ListResolverEndpoints request. If you don't specify a value for MaxResults, Resolver returns up to 100 Resolver endpoints.
    public var maxResults: Swift.Int?
    /// For the first ListResolverEndpoints request, omit this value. If you have more than MaxResults Resolver endpoints, you can submit another ListResolverEndpoints request to get the next group of Resolver endpoints. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResolverEndpointsOutput {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults IP addresses match the specified criteria, you can submit another ListResolverEndpoint request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolver endpoints that were created by using the current Amazon Web Services account, and that match the specified filters, if any.
    public var resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpoints = resolverEndpoints
    }
}

extension Route53ResolverClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListResolverQueryLogConfigAssociationsInput {
    /// An optional specification to return a subset of query logging associations. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of query logging associations that you want to return in the response to a ListResolverQueryLogConfigAssociations request. If you don't specify a value for MaxResults, Resolver returns up to 100 query logging associations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverQueryLogConfigAssociations request, omit this value. If there are more than MaxResults query logging associations that match the values that you specify for Filters, you can submit another ListResolverQueryLogConfigAssociations request to get the next group of associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The element that you want Resolver to sort query logging associations by. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same value for SortBy, if any, as in the previous request. Valid values include the following elements:
    ///
    /// * CreationTime: The ID of the query logging association.
    ///
    /// * Error: If the value of Status is FAILED, the value of Error indicates the cause:
    ///
    /// * DESTINATION_NOT_FOUND: The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * ACCESS_DENIED: Permissions don't allow sending logs to the destination.
    ///
    ///
    /// If Status is a value other than FAILED, ERROR is null.
    ///
    /// * Id: The ID of the query logging association
    ///
    /// * ResolverQueryLogConfigId: The ID of the query logging configuration
    ///
    /// * ResourceId: The ID of the VPC that is associated with the query logging configuration
    ///
    /// * Status: The current status of the configuration. Valid values include the following:
    ///
    /// * CREATING: Resolver is creating an association between an Amazon VPC and a query logging configuration.
    ///
    /// * CREATED: The association between an Amazon VPC and a query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
    ///
    /// * DELETING: Resolver is deleting this query logging association.
    ///
    /// * FAILED: Resolver either couldn't create or couldn't delete the query logging association. Here are two common causes:
    ///
    /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * Permissions don't allow sending logs to the destination.
    public var sortBy: Swift.String?
    /// If you specified a value for SortBy, the order that you want query logging associations to be listed in, ASCENDING or DESCENDING. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same value for SortOrder, if any, as in the previous request.
    public var sortOrder: Route53ResolverClientTypes.SortOrder?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: Route53ResolverClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListResolverQueryLogConfigAssociationsOutput {
    /// If there are more than MaxResults query logging associations, you can submit another ListResolverQueryLogConfigAssociations request to get the next group of associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// A list that contains one ResolverQueryLogConfigAssociations element for each query logging association that matches the values that you specified for Filter.
    public var resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]?
    /// The total number of query logging associations that were created by the current account in the specified Region. This count can differ from the number of associations that are returned in a ListResolverQueryLogConfigAssociations response, depending on the values that you specify in the request.
    public var totalCount: Swift.Int
    /// The total number of query logging associations that were created by the current account in the specified Region and that match the filters that were specified in the ListResolverQueryLogConfigAssociations request. For the total number of associations that were created by the current account in the specified Region, see TotalCount.
    public var totalFilteredCount: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]? = nil,
        totalCount: Swift.Int = 0,
        totalFilteredCount: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigAssociations = resolverQueryLogConfigAssociations
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

public struct ListResolverQueryLogConfigsInput {
    /// An optional specification to return a subset of query logging configurations. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of query logging configurations that you want to return in the response to a ListResolverQueryLogConfigs request. If you don't specify a value for MaxResults, Resolver returns up to 100 query logging configurations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverQueryLogConfigs request, omit this value. If there are more than MaxResults query logging configurations that match the values that you specify for Filters, you can submit another ListResolverQueryLogConfigs request to get the next group of configurations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The element that you want Resolver to sort query logging configurations by. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same value for SortBy, if any, as in the previous request. Valid values include the following elements:
    ///
    /// * Arn: The ARN of the query logging configuration
    ///
    /// * AssociationCount: The number of VPCs that are associated with the specified configuration
    ///
    /// * CreationTime: The date and time that Resolver returned when the configuration was created
    ///
    /// * CreatorRequestId: The value that was specified for CreatorRequestId when the configuration was created
    ///
    /// * DestinationArn: The location that logs are sent to
    ///
    /// * Id: The ID of the configuration
    ///
    /// * Name: The name of the configuration
    ///
    /// * OwnerId: The Amazon Web Services account number of the account that created the configuration
    ///
    /// * ShareStatus: Whether the configuration is shared with other Amazon Web Services accounts or shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
    ///
    /// * Status: The current status of the configuration. Valid values include the following:
    ///
    /// * CREATING: Resolver is creating the query logging configuration.
    ///
    /// * CREATED: The query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
    ///
    /// * DELETING: Resolver is deleting this query logging configuration.
    ///
    /// * FAILED: Resolver either couldn't create or couldn't delete the query logging configuration. Here are two common causes:
    ///
    /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * Permissions don't allow sending logs to the destination.
    public var sortBy: Swift.String?
    /// If you specified a value for SortBy, the order that you want query logging configurations to be listed in, ASCENDING or DESCENDING. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same value for SortOrder, if any, as in the previous request.
    public var sortOrder: Route53ResolverClientTypes.SortOrder?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: Route53ResolverClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListResolverQueryLogConfigsOutput {
    /// If there are more than MaxResults query logging configurations, you can submit another ListResolverQueryLogConfigs request to get the next group of configurations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// A list that contains one ResolverQueryLogConfig element for each query logging configuration that matches the values that you specified for Filter.
    public var resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]?
    /// The total number of query logging configurations that were created by the current account in the specified Region. This count can differ from the number of query logging configurations that are returned in a ListResolverQueryLogConfigs response, depending on the values that you specify in the request.
    public var totalCount: Swift.Int
    /// The total number of query logging configurations that were created by the current account in the specified Region and that match the filters that were specified in the ListResolverQueryLogConfigs request. For the total number of query logging configurations that were created by the current account in the specified Region, see TotalCount.
    public var totalFilteredCount: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]? = nil,
        totalCount: Swift.Int = 0,
        totalFilteredCount: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigs = resolverQueryLogConfigs
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

public struct ListResolverRuleAssociationsInput {
    /// An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID. If you submit a second or subsequent ListResolverRuleAssociations request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of rule associations that you want to return in the response to a ListResolverRuleAssociations request. If you don't specify a value for MaxResults, Resolver returns up to 100 rule associations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverRuleAssociation request, omit this value. If you have more than MaxResults rule associations, you can submit another ListResolverRuleAssociation request to get the next group of rule associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResolverRuleAssociationsOutput {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults rule associations match the specified criteria, you can submit another ListResolverRuleAssociation request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The associations that were created between Resolver rules and VPCs using the current Amazon Web Services account, and that match the specified filters, if any.
    public var resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRuleAssociations = resolverRuleAssociations
    }
}

public struct ListResolverRulesInput {
    /// An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint. If you submit a second or subsequent ListResolverRules request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of Resolver rules that you want to return in the response to a ListResolverRules request. If you don't specify a value for MaxResults, Resolver returns up to 100 Resolver rules.
    public var maxResults: Swift.Int?
    /// For the first ListResolverRules request, omit this value. If you have more than MaxResults Resolver rules, you can submit another ListResolverRules request to get the next group of Resolver rules. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResolverRulesOutput {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults Resolver rules match the specified criteria, you can submit another ListResolverRules request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolver rules that were created using the current Amazon Web Services account and that match the specified filters, if any.
    public var resolverRules: [Route53ResolverClientTypes.ResolverRule]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverRules: [Route53ResolverClientTypes.ResolverRule]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRules = resolverRules
    }
}

public struct ListTagsForResourceInput {
    /// The maximum number of tags that you want to return in the response to a ListTagsForResource request. If you don't specify a value for MaxResults, Resolver returns up to 100 tags.
    public var maxResults: Swift.Int?
    /// For the first ListTagsForResource request, omit this value. If you have more than MaxResults tags, you can submit another ListTagsForResource request to get the next group of tags for the resource. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the resource that you want to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// If more than MaxResults tags match the specified criteria, you can submit another ListTagsForResource request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The tags that are associated with the resource that you specified in the ListTagsForResource request.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct PutFirewallRuleGroupPolicyInput {
    /// The ARN (Amazon Resource Name) for the rule group that you want to share.
    /// This member is required.
    public var arn: Swift.String?
    /// The Identity and Access Management (Amazon Web Services IAM) policy to attach to the rule group.
    /// This member is required.
    public var firewallRuleGroupPolicy: Swift.String?

    public init(
        arn: Swift.String? = nil,
        firewallRuleGroupPolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

public struct PutFirewallRuleGroupPolicyOutput {
    ///
    public var returnValue: Swift.Bool

    public init(
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

public struct PutResolverQueryLogConfigPolicyInput {
    /// The Amazon Resource Name (ARN) of the account that you want to share rules with.
    /// This member is required.
    public var arn: Swift.String?
    /// An Identity and Access Management policy statement that lists the query logging configurations that you want to share with another Amazon Web Services account and the operations that you want the account to be able to perform. You can specify the following operations in the Actions section of the statement:
    ///
    /// * route53resolver:AssociateResolverQueryLogConfig
    ///
    /// * route53resolver:DisassociateResolverQueryLogConfig
    ///
    /// * route53resolver:ListResolverQueryLogConfigs
    ///
    ///
    /// In the Resource section of the statement, you specify the ARNs for the query logging configurations that you want to share with the account that you specified in Arn.
    /// This member is required.
    public var resolverQueryLogConfigPolicy: Swift.String?

    public init(
        arn: Swift.String? = nil,
        resolverQueryLogConfigPolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

/// The response to a PutResolverQueryLogConfigPolicy request.
public struct PutResolverQueryLogConfigPolicyOutput {
    /// Whether the PutResolverQueryLogConfigPolicy request was successful.
    public var returnValue: Swift.Bool

    public init(
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

public struct PutResolverRulePolicyInput {
    /// The Amazon Resource Name (ARN) of the rule that you want to share with another account.
    /// This member is required.
    public var arn: Swift.String?
    /// An Identity and Access Management policy statement that lists the rules that you want to share with another Amazon Web Services account and the operations that you want the account to be able to perform. You can specify the following operations in the Action section of the statement:
    ///
    /// * route53resolver:GetResolverRule
    ///
    /// * route53resolver:AssociateResolverRule
    ///
    /// * route53resolver:DisassociateResolverRule
    ///
    /// * route53resolver:ListResolverRules
    ///
    /// * route53resolver:ListResolverRuleAssociations
    ///
    ///
    /// In the Resource section of the statement, specify the ARN for the rule that you want to share with another account. Specify the same ARN that you specified in Arn.
    /// This member is required.
    public var resolverRulePolicy: Swift.String?

    public init(
        arn: Swift.String? = nil,
        resolverRulePolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.resolverRulePolicy = resolverRulePolicy
    }
}

/// The response to a PutResolverRulePolicy request.
public struct PutResolverRulePolicyOutput {
    /// Whether the PutResolverRulePolicy request was successful.
    public var returnValue: Swift.Bool

    public init(
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

extension Route53ResolverClientTypes {
    /// In an [UpdateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html) request, information about the changes that you want to make.
    public struct ResolverRuleConfig {
        /// The new name for the Resolver rule. The name that you specify appears in the Resolver dashboard in the Route 53 console.
        public var name: Swift.String?
        /// The ID of the new outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in TargetIps.
        public var resolverEndpointId: Swift.String?
        /// For DNS queries that originate in your VPC, the new IP addresses that you want to route outbound DNS queries to.
        public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

        public init(
            name: Swift.String? = nil,
            resolverEndpointId: Swift.String? = nil,
            targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
        )
        {
            self.name = name
            self.resolverEndpointId = resolverEndpointId
            self.targetIps = targetIps
        }
    }

}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) for the resource that you want to add tags to. To get the ARN for a resource, use the applicable Get or List command:
    ///
    /// * [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html)
    ///
    /// * [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html)
    ///
    /// * [GetResolverRuleAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html)
    ///
    /// * [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html)
    ///
    /// * [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html)
    ///
    /// * [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html)
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that you want to add to the specified resource.
    /// This member is required.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) for the resource that you want to remove tags from. To get the ARN for a resource, use the applicable Get or List command:
    ///
    /// * [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html)
    ///
    /// * [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html)
    ///
    /// * [GetResolverRuleAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html)
    ///
    /// * [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html)
    ///
    /// * [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html)
    ///
    /// * [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html)
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that you want to remove to the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateFirewallConfigInput {
    /// Determines how Route 53 Resolver handles queries during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply.
    ///
    /// * By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall blocks queries that it is unable to evaluate properly.
    ///
    /// * If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it is unable to properly evaluate them.
    ///
    ///
    /// This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association.
    /// This member is required.
    public var firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
    /// The ID of the VPC that the configuration is for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.firewallFailOpen = firewallFailOpen
        self.resourceId = resourceId
    }
}

public struct UpdateFirewallConfigOutput {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC.
    public var firewallConfig: Route53ResolverClientTypes.FirewallConfig?

    public init(
        firewallConfig: Route53ResolverClientTypes.FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

public struct UpdateFirewallDomainsInput {
    /// A list of domains to use in the update operation. There is a limit of 1000 domains per request. Each domain specification in your domain list must satisfy the following requirements:
    ///
    /// * It can optionally start with * (asterisk).
    ///
    /// * With the exception of the optional starting asterisk, it must only contain the following characters: A-Z, a-z, 0-9, - (hyphen).
    ///
    /// * It must be from 1-255 characters in length.
    /// This member is required.
    public var domains: [Swift.String]?
    /// The ID of the domain list whose domains you want to update.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// What you want DNS Firewall to do with the domains that you are providing:
    ///
    /// * ADD - Add the domains to the ones that are already in the domain list.
    ///
    /// * REMOVE - Search the domain list for the domains and remove them from the list.
    ///
    /// * REPLACE - Update the domain list to exactly match the list that you are providing.
    /// This member is required.
    public var operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation?

    public init(
        domains: [Swift.String]? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation? = nil
    )
    {
        self.domains = domains
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

public struct UpdateFirewallDomainsOutput {
    /// The ID of the firewall domain list that DNS Firewall just updated.
    public var id: Swift.String?
    /// The name of the domain list.
    public var name: Swift.String?
    /// Status of the UpdateFirewallDomains request.
    public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
    /// Additional information about the status of the list, if available.
    public var statusMessage: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct UpdateFirewallRuleInput {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request to go through but send an alert to the logs.
    ///
    /// * BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    public var action: Route53ResolverClientTypes.Action?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
    ///
    /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
    ///
    /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
    ///
    /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
    public var blockResponse: Route53ResolverClientTypes.BlockResponse?
    /// The ID of the domain list to use in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// How you want the the rule to evaluate DNS redirection in the DNS redirection chain, such as CNAME or DNAME. Inspect_Redirection_Domain (Default) inspects all domains in the redirection chain. The individual domains in the redirection chain must be added to the domain list. Trust_Redirection_Domain  inspects only the first domain in the redirection chain. You don't need to add the subsequent domains in the domain in the redirection list to the domain list.
    public var firewallDomainRedirectionAction: Route53ResolverClientTypes.FirewallDomainRedirectionAction?
    /// The unique identifier of the firewall rule group for the rule.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// The name of the rule.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group. To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for the rules in a rule group at any time.
    public var priority: Swift.Int?
    /// The DNS query type you want the rule to evaluate. Allowed values are;
    ///
    /// * A: Returns an IPv4 address.
    ///
    /// * AAAA: Returns an Ipv6 address.
    ///
    /// * CAA: Restricts CAs that can create SSL/TLS certifications for the domain.
    ///
    /// * CNAME: Returns another domain name.
    ///
    /// * DS: Record that identifies the DNSSEC signing key of a delegated zone.
    ///
    /// * MX: Specifies mail servers.
    ///
    /// * NAPTR: Regular-expression-based rewriting of domain names.
    ///
    /// * NS: Authoritative name servers.
    ///
    /// * PTR: Maps an IP address to a domain name.
    ///
    /// * SOA: Start of authority record for the zone.
    ///
    /// * SPF: Lists the servers authorized to send emails from a domain.
    ///
    /// * SRV: Application specific values that identify servers.
    ///
    /// * TXT: Verifies email senders and application-specific values.
    ///
    /// * A query type you define by using the DNS type ID, for example 28 for AAAA. The values must be defined as TYPENUMBER, where the NUMBER can be 1-65334, for example, TYPE28. For more information, see [List of DNS record types](https://en.wikipedia.org/wiki/List_of_DNS_record_types).
    public var qtype: Swift.String?

    public init(
        action: Route53ResolverClientTypes.Action? = nil,
        blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
        firewallDomainListId: Swift.String? = nil,
        firewallDomainRedirectionAction: Route53ResolverClientTypes.FirewallDomainRedirectionAction? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        qtype: Swift.String? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.firewallDomainListId = firewallDomainListId
        self.firewallDomainRedirectionAction = firewallDomainRedirectionAction
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
        self.qtype = qtype
    }
}

public struct UpdateFirewallRuleOutput {
    /// The firewall rule that you just updated.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init(
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

public struct UpdateFirewallRuleGroupAssociationInput {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?
    /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
    public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    /// The name of the rule group association.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that you associate with the specified VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting. You must specify a unique priority for each rule group that you associate with a single VPC. To make it easier to insert rule groups later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for a rule group association after you create it.
    public var priority: Swift.Int?

    public init(
        firewallRuleGroupAssociationId: Swift.String? = nil,
        mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
    }
}

public struct UpdateFirewallRuleGroupAssociationOutput {
    /// The association that you just updated.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

public struct UpdateOutpostResolverInput {
    /// A unique string that identifies Resolver on an Outpost.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon EC2 instance count for a Resolver on the Outpost.
    public var instanceCount: Swift.Int?
    /// Name of the Resolver on the Outpost.
    public var name: Swift.String?
    /// Amazon EC2 instance type.
    public var preferredInstanceType: Swift.String?

    public init(
        id: Swift.String? = nil,
        instanceCount: Swift.Int? = nil,
        name: Swift.String? = nil,
        preferredInstanceType: Swift.String? = nil
    )
    {
        self.id = id
        self.instanceCount = instanceCount
        self.name = name
        self.preferredInstanceType = preferredInstanceType
    }
}

public struct UpdateOutpostResolverOutput {
    /// The response to an UpdateOutpostResolver request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

public struct UpdateResolverConfigInput {
    /// Indicates whether or not the Resolver will create autodefined rules for reverse DNS lookups. This is enabled by default. Disabling this option will also affect EC2-Classic instances using ClassicLink. For more information, see [ClassicLink](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html) in the Amazon EC2 guide. We are retiring EC2-Classic on August 15, 2022. We recommend that you migrate from EC2-Classic to a VPC. For more information, see [Migrate from EC2-Classic to a VPC](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-migrate.html) in the Amazon EC2 guide and the blog [EC2-Classic Networking is Retiring – Here’s How to Prepare](http://aws.amazon.com/blogs/aws/ec2-classic-is-retiring-heres-how-to-prepare/). It can take some time for the status change to be completed.
    /// This member is required.
    public var autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag?
    /// Resource ID of the Amazon VPC that you want to update the Resolver configuration for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.autodefinedReverseFlag = autodefinedReverseFlag
        self.resourceId = resourceId
    }
}

public struct UpdateResolverConfigOutput {
    /// An array that contains settings for the specified Resolver configuration.
    public var resolverConfig: Route53ResolverClientTypes.ResolverConfig?

    public init(
        resolverConfig: Route53ResolverClientTypes.ResolverConfig? = nil
    )
    {
        self.resolverConfig = resolverConfig
    }
}

extension Route53ResolverClientTypes {

    public enum Validation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disable
        case enable
        case useLocalResourceSetting
        case sdkUnknown(Swift.String)

        public static var allCases: [Validation] {
            return [
                .disable,
                .enable,
                .useLocalResourceSetting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .useLocalResourceSetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateResolverDnssecConfigInput {
    /// The ID of the virtual private cloud (VPC) that you're updating the DNSSEC validation status for.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The new value that you are specifying for DNSSEC validation for the VPC. The value can be ENABLE or DISABLE. Be aware that it can take time for a validation status change to be completed.
    /// This member is required.
    public var validation: Route53ResolverClientTypes.Validation?

    public init(
        resourceId: Swift.String? = nil,
        validation: Route53ResolverClientTypes.Validation? = nil
    )
    {
        self.resourceId = resourceId
        self.validation = validation
    }
}

public struct UpdateResolverDnssecConfigOutput {
    /// A complex type that contains settings for the specified DNSSEC configuration.
    public var resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?

    public init(
        resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

extension Route53ResolverClientTypes {
    /// Provides information about the IP address type in response to [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html).
    public struct UpdateIpAddress {
        /// The ID of the IP address, specified by the ResolverEndpointId.
        /// This member is required.
        public var ipId: Swift.String?
        /// The IPv6 address that you want to use for DNS queries.
        /// This member is required.
        public var ipv6: Swift.String?

        public init(
            ipId: Swift.String? = nil,
            ipv6: Swift.String? = nil
        )
        {
            self.ipId = ipId
            self.ipv6 = ipv6
        }
    }

}

public struct UpdateResolverEndpointInput {
    /// The name of the Resolver endpoint that you want to update.
    public var name: Swift.String?
    /// The protocols you want to use for the endpoint. DoH-FIPS is applicable for inbound endpoints only. For an inbound endpoint you can apply the protocols as follows:
    ///
    /// * Do53 and DoH in combination.
    ///
    /// * Do53 and DoH-FIPS in combination.
    ///
    /// * Do53 alone.
    ///
    /// * DoH alone.
    ///
    /// * DoH-FIPS alone.
    ///
    /// * None, which is treated as Do53.
    ///
    ///
    /// For an outbound endpoint you can apply the protocols as follows:
    ///
    /// * Do53 and DoH in combination.
    ///
    /// * Do53 alone.
    ///
    /// * DoH alone.
    ///
    /// * None, which is treated as Do53.
    ///
    ///
    /// You can't change the protocol of an inbound endpoint directly from only Do53 to only DoH, or DoH-FIPS. This is to prevent a sudden disruption to incoming traffic that relies on Do53. To change the protocol from Do53 to DoH, or DoH-FIPS, you must first enable both Do53 and DoH, or Do53 and DoH-FIPS, to make sure that all incoming traffic has transferred to using the DoH protocol, or DoH-FIPS, and then remove the Do53.
    public var protocols: [Route53ResolverClientTypes.ModelProtocol]?
    /// The ID of the Resolver endpoint that you want to update.
    /// This member is required.
    public var resolverEndpointId: Swift.String?
    /// Specifies the endpoint type for what type of IP address the endpoint uses to forward DNS queries. Updating to IPV6 type isn't currently supported.
    public var resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
    /// Specifies the IPv6 address when you update the Resolver endpoint from IPv4 to dual-stack. If you don't specify an IPv6 address, one will be automatically chosen from your subnet.
    public var updateIpAddresses: [Route53ResolverClientTypes.UpdateIpAddress]?

    public init(
        name: Swift.String? = nil,
        protocols: [Route53ResolverClientTypes.ModelProtocol]? = nil,
        resolverEndpointId: Swift.String? = nil,
        resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType? = nil,
        updateIpAddresses: [Route53ResolverClientTypes.UpdateIpAddress]? = nil
    )
    {
        self.name = name
        self.protocols = protocols
        self.resolverEndpointId = resolverEndpointId
        self.resolverEndpointType = resolverEndpointType
        self.updateIpAddresses = updateIpAddresses
    }
}

public struct UpdateResolverEndpointOutput {
    /// The response to an UpdateResolverEndpoint request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

public struct UpdateResolverRuleInput {
    /// The new settings for the Resolver rule.
    /// This member is required.
    public var config: Route53ResolverClientTypes.ResolverRuleConfig?
    /// The ID of the Resolver rule that you want to update.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init(
        config: Route53ResolverClientTypes.ResolverRuleConfig? = nil,
        resolverRuleId: Swift.String? = nil
    )
    {
        self.config = config
        self.resolverRuleId = resolverRuleId
    }
}

public struct UpdateResolverRuleOutput {
    /// The response to an UpdateResolverRule request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

extension AssociateFirewallRuleGroupInput {

    static func urlPathProvider(_ value: AssociateFirewallRuleGroupInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateResolverEndpointIpAddressInput {

    static func urlPathProvider(_ value: AssociateResolverEndpointIpAddressInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateResolverQueryLogConfigInput {

    static func urlPathProvider(_ value: AssociateResolverQueryLogConfigInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateResolverRuleInput {

    static func urlPathProvider(_ value: AssociateResolverRuleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFirewallDomainListInput {

    static func urlPathProvider(_ value: CreateFirewallDomainListInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFirewallRuleInput {

    static func urlPathProvider(_ value: CreateFirewallRuleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFirewallRuleGroupInput {

    static func urlPathProvider(_ value: CreateFirewallRuleGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOutpostResolverInput {

    static func urlPathProvider(_ value: CreateOutpostResolverInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResolverEndpointInput {

    static func urlPathProvider(_ value: CreateResolverEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResolverQueryLogConfigInput {

    static func urlPathProvider(_ value: CreateResolverQueryLogConfigInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResolverRuleInput {

    static func urlPathProvider(_ value: CreateResolverRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFirewallDomainListInput {

    static func urlPathProvider(_ value: DeleteFirewallDomainListInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFirewallRuleInput {

    static func urlPathProvider(_ value: DeleteFirewallRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFirewallRuleGroupInput {

    static func urlPathProvider(_ value: DeleteFirewallRuleGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOutpostResolverInput {

    static func urlPathProvider(_ value: DeleteOutpostResolverInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResolverEndpointInput {

    static func urlPathProvider(_ value: DeleteResolverEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResolverQueryLogConfigInput {

    static func urlPathProvider(_ value: DeleteResolverQueryLogConfigInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResolverRuleInput {

    static func urlPathProvider(_ value: DeleteResolverRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateFirewallRuleGroupInput {

    static func urlPathProvider(_ value: DisassociateFirewallRuleGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateResolverEndpointIpAddressInput {

    static func urlPathProvider(_ value: DisassociateResolverEndpointIpAddressInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateResolverQueryLogConfigInput {

    static func urlPathProvider(_ value: DisassociateResolverQueryLogConfigInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateResolverRuleInput {

    static func urlPathProvider(_ value: DisassociateResolverRuleInput) -> Swift.String? {
        return "/"
    }
}

extension GetFirewallConfigInput {

    static func urlPathProvider(_ value: GetFirewallConfigInput) -> Swift.String? {
        return "/"
    }
}

extension GetFirewallDomainListInput {

    static func urlPathProvider(_ value: GetFirewallDomainListInput) -> Swift.String? {
        return "/"
    }
}

extension GetFirewallRuleGroupInput {

    static func urlPathProvider(_ value: GetFirewallRuleGroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetFirewallRuleGroupAssociationInput {

    static func urlPathProvider(_ value: GetFirewallRuleGroupAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension GetFirewallRuleGroupPolicyInput {

    static func urlPathProvider(_ value: GetFirewallRuleGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetOutpostResolverInput {

    static func urlPathProvider(_ value: GetOutpostResolverInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverConfigInput {

    static func urlPathProvider(_ value: GetResolverConfigInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverDnssecConfigInput {

    static func urlPathProvider(_ value: GetResolverDnssecConfigInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverEndpointInput {

    static func urlPathProvider(_ value: GetResolverEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverQueryLogConfigInput {

    static func urlPathProvider(_ value: GetResolverQueryLogConfigInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverQueryLogConfigAssociationInput {

    static func urlPathProvider(_ value: GetResolverQueryLogConfigAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverQueryLogConfigPolicyInput {

    static func urlPathProvider(_ value: GetResolverQueryLogConfigPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverRuleInput {

    static func urlPathProvider(_ value: GetResolverRuleInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverRuleAssociationInput {

    static func urlPathProvider(_ value: GetResolverRuleAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension GetResolverRulePolicyInput {

    static func urlPathProvider(_ value: GetResolverRulePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ImportFirewallDomainsInput {

    static func urlPathProvider(_ value: ImportFirewallDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFirewallConfigsInput {

    static func urlPathProvider(_ value: ListFirewallConfigsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFirewallDomainListsInput {

    static func urlPathProvider(_ value: ListFirewallDomainListsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFirewallDomainsInput {

    static func urlPathProvider(_ value: ListFirewallDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFirewallRuleGroupAssociationsInput {

    static func urlPathProvider(_ value: ListFirewallRuleGroupAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFirewallRuleGroupsInput {

    static func urlPathProvider(_ value: ListFirewallRuleGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFirewallRulesInput {

    static func urlPathProvider(_ value: ListFirewallRulesInput) -> Swift.String? {
        return "/"
    }
}

extension ListOutpostResolversInput {

    static func urlPathProvider(_ value: ListOutpostResolversInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverConfigsInput {

    static func urlPathProvider(_ value: ListResolverConfigsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverDnssecConfigsInput {

    static func urlPathProvider(_ value: ListResolverDnssecConfigsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverEndpointIpAddressesInput {

    static func urlPathProvider(_ value: ListResolverEndpointIpAddressesInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverEndpointsInput {

    static func urlPathProvider(_ value: ListResolverEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverQueryLogConfigAssociationsInput {

    static func urlPathProvider(_ value: ListResolverQueryLogConfigAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverQueryLogConfigsInput {

    static func urlPathProvider(_ value: ListResolverQueryLogConfigsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverRuleAssociationsInput {

    static func urlPathProvider(_ value: ListResolverRuleAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResolverRulesInput {

    static func urlPathProvider(_ value: ListResolverRulesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutFirewallRuleGroupPolicyInput {

    static func urlPathProvider(_ value: PutFirewallRuleGroupPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutResolverQueryLogConfigPolicyInput {

    static func urlPathProvider(_ value: PutResolverQueryLogConfigPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutResolverRulePolicyInput {

    static func urlPathProvider(_ value: PutResolverRulePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFirewallConfigInput {

    static func urlPathProvider(_ value: UpdateFirewallConfigInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFirewallDomainsInput {

    static func urlPathProvider(_ value: UpdateFirewallDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFirewallRuleInput {

    static func urlPathProvider(_ value: UpdateFirewallRuleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFirewallRuleGroupAssociationInput {

    static func urlPathProvider(_ value: UpdateFirewallRuleGroupAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateOutpostResolverInput {

    static func urlPathProvider(_ value: UpdateOutpostResolverInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateResolverConfigInput {

    static func urlPathProvider(_ value: UpdateResolverConfigInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateResolverDnssecConfigInput {

    static func urlPathProvider(_ value: UpdateResolverDnssecConfigInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateResolverEndpointInput {

    static func urlPathProvider(_ value: UpdateResolverEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateResolverRuleInput {

    static func urlPathProvider(_ value: UpdateResolverRuleInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateFirewallRuleGroupInput {

    static func write(value: AssociateFirewallRuleGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
        try writer["MutationProtection"].write(value.mutationProtection)
        try writer["Name"].write(value.name)
        try writer["Priority"].write(value.priority)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcId"].write(value.vpcId)
    }
}

extension AssociateResolverEndpointIpAddressInput {

    static func write(value: AssociateResolverEndpointIpAddressInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpAddress"].write(value.ipAddress, with: Route53ResolverClientTypes.IpAddressUpdate.write(value:to:))
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
    }
}

extension AssociateResolverQueryLogConfigInput {

    static func write(value: AssociateResolverQueryLogConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverQueryLogConfigId"].write(value.resolverQueryLogConfigId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension AssociateResolverRuleInput {

    static func write(value: AssociateResolverRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ResolverRuleId"].write(value.resolverRuleId)
        try writer["VPCId"].write(value.vpcId)
    }
}

extension CreateFirewallDomainListInput {

    static func write(value: CreateFirewallDomainListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFirewallRuleInput {

    static func write(value: CreateFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["BlockOverrideDnsType"].write(value.blockOverrideDnsType)
        try writer["BlockOverrideDomain"].write(value.blockOverrideDomain)
        try writer["BlockOverrideTtl"].write(value.blockOverrideTtl)
        try writer["BlockResponse"].write(value.blockResponse)
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
        try writer["FirewallDomainRedirectionAction"].write(value.firewallDomainRedirectionAction)
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
        try writer["Name"].write(value.name)
        try writer["Priority"].write(value.priority)
        try writer["Qtype"].write(value.qtype)
    }
}

extension CreateFirewallRuleGroupInput {

    static func write(value: CreateFirewallRuleGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateOutpostResolverInput {

    static func write(value: CreateOutpostResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["InstanceCount"].write(value.instanceCount)
        try writer["Name"].write(value.name)
        try writer["OutpostArn"].write(value.outpostArn)
        try writer["PreferredInstanceType"].write(value.preferredInstanceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateResolverEndpointInput {

    static func write(value: CreateResolverEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["Direction"].write(value.direction)
        try writer["IpAddresses"].writeList(value.ipAddresses, memberWritingClosure: Route53ResolverClientTypes.IpAddressRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["OutpostArn"].write(value.outpostArn)
        try writer["PreferredInstanceType"].write(value.preferredInstanceType)
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<Route53ResolverClientTypes.ModelProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResolverEndpointType"].write(value.resolverEndpointType)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateResolverQueryLogConfigInput {

    static func write(value: CreateResolverQueryLogConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["DestinationArn"].write(value.destinationArn)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateResolverRuleInput {

    static func write(value: CreateResolverRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["DomainName"].write(value.domainName)
        try writer["Name"].write(value.name)
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
        try writer["RuleType"].write(value.ruleType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetIps"].writeList(value.targetIps, memberWritingClosure: Route53ResolverClientTypes.TargetAddress.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteFirewallDomainListInput {

    static func write(value: DeleteFirewallDomainListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
    }
}

extension DeleteFirewallRuleInput {

    static func write(value: DeleteFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
        try writer["Qtype"].write(value.qtype)
    }
}

extension DeleteFirewallRuleGroupInput {

    static func write(value: DeleteFirewallRuleGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
    }
}

extension DeleteOutpostResolverInput {

    static func write(value: DeleteOutpostResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension DeleteResolverEndpointInput {

    static func write(value: DeleteResolverEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
    }
}

extension DeleteResolverQueryLogConfigInput {

    static func write(value: DeleteResolverQueryLogConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverQueryLogConfigId"].write(value.resolverQueryLogConfigId)
    }
}

extension DeleteResolverRuleInput {

    static func write(value: DeleteResolverRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverRuleId"].write(value.resolverRuleId)
    }
}

extension DisassociateFirewallRuleGroupInput {

    static func write(value: DisassociateFirewallRuleGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallRuleGroupAssociationId"].write(value.firewallRuleGroupAssociationId)
    }
}

extension DisassociateResolverEndpointIpAddressInput {

    static func write(value: DisassociateResolverEndpointIpAddressInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpAddress"].write(value.ipAddress, with: Route53ResolverClientTypes.IpAddressUpdate.write(value:to:))
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
    }
}

extension DisassociateResolverQueryLogConfigInput {

    static func write(value: DisassociateResolverQueryLogConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverQueryLogConfigId"].write(value.resolverQueryLogConfigId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DisassociateResolverRuleInput {

    static func write(value: DisassociateResolverRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverRuleId"].write(value.resolverRuleId)
        try writer["VPCId"].write(value.vpcId)
    }
}

extension GetFirewallConfigInput {

    static func write(value: GetFirewallConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension GetFirewallDomainListInput {

    static func write(value: GetFirewallDomainListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
    }
}

extension GetFirewallRuleGroupInput {

    static func write(value: GetFirewallRuleGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
    }
}

extension GetFirewallRuleGroupAssociationInput {

    static func write(value: GetFirewallRuleGroupAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallRuleGroupAssociationId"].write(value.firewallRuleGroupAssociationId)
    }
}

extension GetFirewallRuleGroupPolicyInput {

    static func write(value: GetFirewallRuleGroupPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension GetOutpostResolverInput {

    static func write(value: GetOutpostResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension GetResolverConfigInput {

    static func write(value: GetResolverConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension GetResolverDnssecConfigInput {

    static func write(value: GetResolverDnssecConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension GetResolverEndpointInput {

    static func write(value: GetResolverEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
    }
}

extension GetResolverQueryLogConfigInput {

    static func write(value: GetResolverQueryLogConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverQueryLogConfigId"].write(value.resolverQueryLogConfigId)
    }
}

extension GetResolverQueryLogConfigAssociationInput {

    static func write(value: GetResolverQueryLogConfigAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverQueryLogConfigAssociationId"].write(value.resolverQueryLogConfigAssociationId)
    }
}

extension GetResolverQueryLogConfigPolicyInput {

    static func write(value: GetResolverQueryLogConfigPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension GetResolverRuleInput {

    static func write(value: GetResolverRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverRuleId"].write(value.resolverRuleId)
    }
}

extension GetResolverRuleAssociationInput {

    static func write(value: GetResolverRuleAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResolverRuleAssociationId"].write(value.resolverRuleAssociationId)
    }
}

extension GetResolverRulePolicyInput {

    static func write(value: GetResolverRulePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension ImportFirewallDomainsInput {

    static func write(value: ImportFirewallDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainFileUrl"].write(value.domainFileUrl)
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
        try writer["Operation"].write(value.operation)
    }
}

extension ListFirewallConfigsInput {

    static func write(value: ListFirewallConfigsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFirewallDomainListsInput {

    static func write(value: ListFirewallDomainListsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFirewallDomainsInput {

    static func write(value: ListFirewallDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFirewallRuleGroupAssociationsInput {

    static func write(value: ListFirewallRuleGroupAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Priority"].write(value.priority)
        try writer["Status"].write(value.status)
        try writer["VpcId"].write(value.vpcId)
    }
}

extension ListFirewallRuleGroupsInput {

    static func write(value: ListFirewallRuleGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFirewallRulesInput {

    static func write(value: ListFirewallRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Priority"].write(value.priority)
    }
}

extension ListOutpostResolversInput {

    static func write(value: ListOutpostResolversInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OutpostArn"].write(value.outpostArn)
    }
}

extension ListResolverConfigsInput {

    static func write(value: ListResolverConfigsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResolverDnssecConfigsInput {

    static func write(value: ListResolverDnssecConfigsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: Route53ResolverClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResolverEndpointIpAddressesInput {

    static func write(value: ListResolverEndpointIpAddressesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
    }
}

extension ListResolverEndpointsInput {

    static func write(value: ListResolverEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: Route53ResolverClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResolverQueryLogConfigAssociationsInput {

    static func write(value: ListResolverQueryLogConfigAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: Route53ResolverClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension ListResolverQueryLogConfigsInput {

    static func write(value: ListResolverQueryLogConfigsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: Route53ResolverClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension ListResolverRuleAssociationsInput {

    static func write(value: ListResolverRuleAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: Route53ResolverClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResolverRulesInput {

    static func write(value: ListResolverRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: Route53ResolverClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutFirewallRuleGroupPolicyInput {

    static func write(value: PutFirewallRuleGroupPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["FirewallRuleGroupPolicy"].write(value.firewallRuleGroupPolicy)
    }
}

extension PutResolverQueryLogConfigPolicyInput {

    static func write(value: PutResolverQueryLogConfigPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["ResolverQueryLogConfigPolicy"].write(value.resolverQueryLogConfigPolicy)
    }
}

extension PutResolverRulePolicyInput {

    static func write(value: PutResolverRulePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["ResolverRulePolicy"].write(value.resolverRulePolicy)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: Route53ResolverClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFirewallConfigInput {

    static func write(value: UpdateFirewallConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallFailOpen"].write(value.firewallFailOpen)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension UpdateFirewallDomainsInput {

    static func write(value: UpdateFirewallDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domains"].writeList(value.domains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
        try writer["Operation"].write(value.operation)
    }
}

extension UpdateFirewallRuleInput {

    static func write(value: UpdateFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["BlockOverrideDnsType"].write(value.blockOverrideDnsType)
        try writer["BlockOverrideDomain"].write(value.blockOverrideDomain)
        try writer["BlockOverrideTtl"].write(value.blockOverrideTtl)
        try writer["BlockResponse"].write(value.blockResponse)
        try writer["FirewallDomainListId"].write(value.firewallDomainListId)
        try writer["FirewallDomainRedirectionAction"].write(value.firewallDomainRedirectionAction)
        try writer["FirewallRuleGroupId"].write(value.firewallRuleGroupId)
        try writer["Name"].write(value.name)
        try writer["Priority"].write(value.priority)
        try writer["Qtype"].write(value.qtype)
    }
}

extension UpdateFirewallRuleGroupAssociationInput {

    static func write(value: UpdateFirewallRuleGroupAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallRuleGroupAssociationId"].write(value.firewallRuleGroupAssociationId)
        try writer["MutationProtection"].write(value.mutationProtection)
        try writer["Name"].write(value.name)
        try writer["Priority"].write(value.priority)
    }
}

extension UpdateOutpostResolverInput {

    static func write(value: UpdateOutpostResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["InstanceCount"].write(value.instanceCount)
        try writer["Name"].write(value.name)
        try writer["PreferredInstanceType"].write(value.preferredInstanceType)
    }
}

extension UpdateResolverConfigInput {

    static func write(value: UpdateResolverConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutodefinedReverseFlag"].write(value.autodefinedReverseFlag)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension UpdateResolverDnssecConfigInput {

    static func write(value: UpdateResolverDnssecConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["Validation"].write(value.validation)
    }
}

extension UpdateResolverEndpointInput {

    static func write(value: UpdateResolverEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<Route53ResolverClientTypes.ModelProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
        try writer["ResolverEndpointType"].write(value.resolverEndpointType)
        try writer["UpdateIpAddresses"].writeList(value.updateIpAddresses, memberWritingClosure: Route53ResolverClientTypes.UpdateIpAddress.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateResolverRuleInput {

    static func write(value: UpdateResolverRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Config"].write(value.config, with: Route53ResolverClientTypes.ResolverRuleConfig.write(value:to:))
        try writer["ResolverRuleId"].write(value.resolverRuleId)
    }
}

extension AssociateFirewallRuleGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateFirewallRuleGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateFirewallRuleGroupOutput()
        value.firewallRuleGroupAssociation = try reader["FirewallRuleGroupAssociation"].readIfPresent(with: Route53ResolverClientTypes.FirewallRuleGroupAssociation.read(from:))
        return value
    }
}

extension AssociateResolverEndpointIpAddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateResolverEndpointIpAddressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateResolverEndpointIpAddressOutput()
        value.resolverEndpoint = try reader["ResolverEndpoint"].readIfPresent(with: Route53ResolverClientTypes.ResolverEndpoint.read(from:))
        return value
    }
}

extension AssociateResolverQueryLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateResolverQueryLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateResolverQueryLogConfigOutput()
        value.resolverQueryLogConfigAssociation = try reader["ResolverQueryLogConfigAssociation"].readIfPresent(with: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.read(from:))
        return value
    }
}

extension AssociateResolverRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateResolverRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateResolverRuleOutput()
        value.resolverRuleAssociation = try reader["ResolverRuleAssociation"].readIfPresent(with: Route53ResolverClientTypes.ResolverRuleAssociation.read(from:))
        return value
    }
}

extension CreateFirewallDomainListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFirewallDomainListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFirewallDomainListOutput()
        value.firewallDomainList = try reader["FirewallDomainList"].readIfPresent(with: Route53ResolverClientTypes.FirewallDomainList.read(from:))
        return value
    }
}

extension CreateFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFirewallRuleOutput()
        value.firewallRule = try reader["FirewallRule"].readIfPresent(with: Route53ResolverClientTypes.FirewallRule.read(from:))
        return value
    }
}

extension CreateFirewallRuleGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFirewallRuleGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFirewallRuleGroupOutput()
        value.firewallRuleGroup = try reader["FirewallRuleGroup"].readIfPresent(with: Route53ResolverClientTypes.FirewallRuleGroup.read(from:))
        return value
    }
}

extension CreateOutpostResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOutpostResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOutpostResolverOutput()
        value.outpostResolver = try reader["OutpostResolver"].readIfPresent(with: Route53ResolverClientTypes.OutpostResolver.read(from:))
        return value
    }
}

extension CreateResolverEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResolverEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResolverEndpointOutput()
        value.resolverEndpoint = try reader["ResolverEndpoint"].readIfPresent(with: Route53ResolverClientTypes.ResolverEndpoint.read(from:))
        return value
    }
}

extension CreateResolverQueryLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResolverQueryLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResolverQueryLogConfigOutput()
        value.resolverQueryLogConfig = try reader["ResolverQueryLogConfig"].readIfPresent(with: Route53ResolverClientTypes.ResolverQueryLogConfig.read(from:))
        return value
    }
}

extension CreateResolverRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResolverRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResolverRuleOutput()
        value.resolverRule = try reader["ResolverRule"].readIfPresent(with: Route53ResolverClientTypes.ResolverRule.read(from:))
        return value
    }
}

extension DeleteFirewallDomainListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFirewallDomainListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFirewallDomainListOutput()
        value.firewallDomainList = try reader["FirewallDomainList"].readIfPresent(with: Route53ResolverClientTypes.FirewallDomainList.read(from:))
        return value
    }
}

extension DeleteFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFirewallRuleOutput()
        value.firewallRule = try reader["FirewallRule"].readIfPresent(with: Route53ResolverClientTypes.FirewallRule.read(from:))
        return value
    }
}

extension DeleteFirewallRuleGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFirewallRuleGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFirewallRuleGroupOutput()
        value.firewallRuleGroup = try reader["FirewallRuleGroup"].readIfPresent(with: Route53ResolverClientTypes.FirewallRuleGroup.read(from:))
        return value
    }
}

extension DeleteOutpostResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOutpostResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteOutpostResolverOutput()
        value.outpostResolver = try reader["OutpostResolver"].readIfPresent(with: Route53ResolverClientTypes.OutpostResolver.read(from:))
        return value
    }
}

extension DeleteResolverEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResolverEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResolverEndpointOutput()
        value.resolverEndpoint = try reader["ResolverEndpoint"].readIfPresent(with: Route53ResolverClientTypes.ResolverEndpoint.read(from:))
        return value
    }
}

extension DeleteResolverQueryLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResolverQueryLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResolverQueryLogConfigOutput()
        value.resolverQueryLogConfig = try reader["ResolverQueryLogConfig"].readIfPresent(with: Route53ResolverClientTypes.ResolverQueryLogConfig.read(from:))
        return value
    }
}

extension DeleteResolverRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResolverRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResolverRuleOutput()
        value.resolverRule = try reader["ResolverRule"].readIfPresent(with: Route53ResolverClientTypes.ResolverRule.read(from:))
        return value
    }
}

extension DisassociateFirewallRuleGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateFirewallRuleGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateFirewallRuleGroupOutput()
        value.firewallRuleGroupAssociation = try reader["FirewallRuleGroupAssociation"].readIfPresent(with: Route53ResolverClientTypes.FirewallRuleGroupAssociation.read(from:))
        return value
    }
}

extension DisassociateResolverEndpointIpAddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateResolverEndpointIpAddressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateResolverEndpointIpAddressOutput()
        value.resolverEndpoint = try reader["ResolverEndpoint"].readIfPresent(with: Route53ResolverClientTypes.ResolverEndpoint.read(from:))
        return value
    }
}

extension DisassociateResolverQueryLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateResolverQueryLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateResolverQueryLogConfigOutput()
        value.resolverQueryLogConfigAssociation = try reader["ResolverQueryLogConfigAssociation"].readIfPresent(with: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.read(from:))
        return value
    }
}

extension DisassociateResolverRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateResolverRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateResolverRuleOutput()
        value.resolverRuleAssociation = try reader["ResolverRuleAssociation"].readIfPresent(with: Route53ResolverClientTypes.ResolverRuleAssociation.read(from:))
        return value
    }
}

extension GetFirewallConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFirewallConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFirewallConfigOutput()
        value.firewallConfig = try reader["FirewallConfig"].readIfPresent(with: Route53ResolverClientTypes.FirewallConfig.read(from:))
        return value
    }
}

extension GetFirewallDomainListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFirewallDomainListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFirewallDomainListOutput()
        value.firewallDomainList = try reader["FirewallDomainList"].readIfPresent(with: Route53ResolverClientTypes.FirewallDomainList.read(from:))
        return value
    }
}

extension GetFirewallRuleGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFirewallRuleGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFirewallRuleGroupOutput()
        value.firewallRuleGroup = try reader["FirewallRuleGroup"].readIfPresent(with: Route53ResolverClientTypes.FirewallRuleGroup.read(from:))
        return value
    }
}

extension GetFirewallRuleGroupAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFirewallRuleGroupAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFirewallRuleGroupAssociationOutput()
        value.firewallRuleGroupAssociation = try reader["FirewallRuleGroupAssociation"].readIfPresent(with: Route53ResolverClientTypes.FirewallRuleGroupAssociation.read(from:))
        return value
    }
}

extension GetFirewallRuleGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFirewallRuleGroupPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFirewallRuleGroupPolicyOutput()
        value.firewallRuleGroupPolicy = try reader["FirewallRuleGroupPolicy"].readIfPresent()
        return value
    }
}

extension GetOutpostResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOutpostResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOutpostResolverOutput()
        value.outpostResolver = try reader["OutpostResolver"].readIfPresent(with: Route53ResolverClientTypes.OutpostResolver.read(from:))
        return value
    }
}

extension GetResolverConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverConfigOutput()
        value.resolverConfig = try reader["ResolverConfig"].readIfPresent(with: Route53ResolverClientTypes.ResolverConfig.read(from:))
        return value
    }
}

extension GetResolverDnssecConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverDnssecConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverDnssecConfigOutput()
        value.resolverDNSSECConfig = try reader["ResolverDNSSECConfig"].readIfPresent(with: Route53ResolverClientTypes.ResolverDnssecConfig.read(from:))
        return value
    }
}

extension GetResolverEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverEndpointOutput()
        value.resolverEndpoint = try reader["ResolverEndpoint"].readIfPresent(with: Route53ResolverClientTypes.ResolverEndpoint.read(from:))
        return value
    }
}

extension GetResolverQueryLogConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverQueryLogConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverQueryLogConfigOutput()
        value.resolverQueryLogConfig = try reader["ResolverQueryLogConfig"].readIfPresent(with: Route53ResolverClientTypes.ResolverQueryLogConfig.read(from:))
        return value
    }
}

extension GetResolverQueryLogConfigAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverQueryLogConfigAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverQueryLogConfigAssociationOutput()
        value.resolverQueryLogConfigAssociation = try reader["ResolverQueryLogConfigAssociation"].readIfPresent(with: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.read(from:))
        return value
    }
}

extension GetResolverQueryLogConfigPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverQueryLogConfigPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverQueryLogConfigPolicyOutput()
        value.resolverQueryLogConfigPolicy = try reader["ResolverQueryLogConfigPolicy"].readIfPresent()
        return value
    }
}

extension GetResolverRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverRuleOutput()
        value.resolverRule = try reader["ResolverRule"].readIfPresent(with: Route53ResolverClientTypes.ResolverRule.read(from:))
        return value
    }
}

extension GetResolverRuleAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverRuleAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverRuleAssociationOutput()
        value.resolverRuleAssociation = try reader["ResolverRuleAssociation"].readIfPresent(with: Route53ResolverClientTypes.ResolverRuleAssociation.read(from:))
        return value
    }
}

extension GetResolverRulePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResolverRulePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResolverRulePolicyOutput()
        value.resolverRulePolicy = try reader["ResolverRulePolicy"].readIfPresent()
        return value
    }
}

extension ImportFirewallDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportFirewallDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportFirewallDomainsOutput()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension ListFirewallConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallConfigsOutput()
        value.firewallConfigs = try reader["FirewallConfigs"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.FirewallConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallDomainListsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallDomainListsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallDomainListsOutput()
        value.firewallDomainLists = try reader["FirewallDomainLists"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.FirewallDomainListMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallDomainsOutput()
        value.domains = try reader["Domains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallRuleGroupAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallRuleGroupAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallRuleGroupAssociationsOutput()
        value.firewallRuleGroupAssociations = try reader["FirewallRuleGroupAssociations"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.FirewallRuleGroupAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallRuleGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallRuleGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallRuleGroupsOutput()
        value.firewallRuleGroups = try reader["FirewallRuleGroups"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.FirewallRuleGroupMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallRulesOutput()
        value.firewallRules = try reader["FirewallRules"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.FirewallRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOutpostResolversOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOutpostResolversOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOutpostResolversOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.outpostResolvers = try reader["OutpostResolvers"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.OutpostResolver.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResolverConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverConfigsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resolverConfigs = try reader["ResolverConfigs"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.ResolverConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResolverDnssecConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverDnssecConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverDnssecConfigsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resolverDnssecConfigs = try reader["ResolverDnssecConfigs"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.ResolverDnssecConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResolverEndpointIpAddressesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverEndpointIpAddressesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverEndpointIpAddressesOutput()
        value.ipAddresses = try reader["IpAddresses"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.IpAddressResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListResolverEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverEndpointsOutput()
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resolverEndpoints = try reader["ResolverEndpoints"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.ResolverEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResolverQueryLogConfigAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverQueryLogConfigAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverQueryLogConfigAssociationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resolverQueryLogConfigAssociations = try reader["ResolverQueryLogConfigAssociations"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["TotalCount"].readIfPresent() ?? 0
        value.totalFilteredCount = try reader["TotalFilteredCount"].readIfPresent() ?? 0
        return value
    }
}

extension ListResolverQueryLogConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverQueryLogConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverQueryLogConfigsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resolverQueryLogConfigs = try reader["ResolverQueryLogConfigs"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.ResolverQueryLogConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["TotalCount"].readIfPresent() ?? 0
        value.totalFilteredCount = try reader["TotalFilteredCount"].readIfPresent() ?? 0
        return value
    }
}

extension ListResolverRuleAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverRuleAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverRuleAssociationsOutput()
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resolverRuleAssociations = try reader["ResolverRuleAssociations"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.ResolverRuleAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResolverRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResolverRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResolverRulesOutput()
        value.maxResults = try reader["MaxResults"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resolverRules = try reader["ResolverRules"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.ResolverRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutFirewallRuleGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFirewallRuleGroupPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutFirewallRuleGroupPolicyOutput()
        value.returnValue = try reader["ReturnValue"].readIfPresent() ?? false
        return value
    }
}

extension PutResolverQueryLogConfigPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResolverQueryLogConfigPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResolverQueryLogConfigPolicyOutput()
        value.returnValue = try reader["ReturnValue"].readIfPresent() ?? false
        return value
    }
}

extension PutResolverRulePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResolverRulePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResolverRulePolicyOutput()
        value.returnValue = try reader["ReturnValue"].readIfPresent() ?? false
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateFirewallConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFirewallConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFirewallConfigOutput()
        value.firewallConfig = try reader["FirewallConfig"].readIfPresent(with: Route53ResolverClientTypes.FirewallConfig.read(from:))
        return value
    }
}

extension UpdateFirewallDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFirewallDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFirewallDomainsOutput()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension UpdateFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFirewallRuleOutput()
        value.firewallRule = try reader["FirewallRule"].readIfPresent(with: Route53ResolverClientTypes.FirewallRule.read(from:))
        return value
    }
}

extension UpdateFirewallRuleGroupAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFirewallRuleGroupAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFirewallRuleGroupAssociationOutput()
        value.firewallRuleGroupAssociation = try reader["FirewallRuleGroupAssociation"].readIfPresent(with: Route53ResolverClientTypes.FirewallRuleGroupAssociation.read(from:))
        return value
    }
}

extension UpdateOutpostResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOutpostResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOutpostResolverOutput()
        value.outpostResolver = try reader["OutpostResolver"].readIfPresent(with: Route53ResolverClientTypes.OutpostResolver.read(from:))
        return value
    }
}

extension UpdateResolverConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResolverConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResolverConfigOutput()
        value.resolverConfig = try reader["ResolverConfig"].readIfPresent(with: Route53ResolverClientTypes.ResolverConfig.read(from:))
        return value
    }
}

extension UpdateResolverDnssecConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResolverDnssecConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResolverDnssecConfigOutput()
        value.resolverDNSSECConfig = try reader["ResolverDNSSECConfig"].readIfPresent(with: Route53ResolverClientTypes.ResolverDnssecConfig.read(from:))
        return value
    }
}

extension UpdateResolverEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResolverEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResolverEndpointOutput()
        value.resolverEndpoint = try reader["ResolverEndpoint"].readIfPresent(with: Route53ResolverClientTypes.ResolverEndpoint.read(from:))
        return value
    }
}

extension UpdateResolverRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResolverRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResolverRuleOutput()
        value.resolverRule = try reader["ResolverRule"].readIfPresent(with: Route53ResolverClientTypes.ResolverRule.read(from:))
        return value
    }
}

enum AssociateFirewallRuleGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateResolverEndpointIpAddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateResolverQueryLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateResolverRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFirewallDomainListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFirewallRuleGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOutpostResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResolverEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResolverQueryLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResolverRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFirewallDomainListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFirewallRuleGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOutpostResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResolverEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResolverQueryLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResolverRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateFirewallRuleGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateResolverEndpointIpAddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateResolverQueryLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateResolverRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFirewallConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFirewallDomainListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFirewallRuleGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFirewallRuleGroupAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFirewallRuleGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOutpostResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverDnssecConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverQueryLogConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverQueryLogConfigAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverQueryLogConfigPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "UnknownResourceException": return try UnknownResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverRuleAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResolverRulePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "UnknownResourceException": return try UnknownResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportFirewallDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallDomainListsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallRuleGroupAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallRuleGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOutpostResolversOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverDnssecConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverEndpointIpAddressesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverQueryLogConfigAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverQueryLogConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverRuleAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResolverRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFirewallRuleGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResolverQueryLogConfigPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidPolicyDocument": return try InvalidPolicyDocument.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "UnknownResourceException": return try UnknownResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResolverRulePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidPolicyDocument": return try InvalidPolicyDocument.makeError(baseError: baseError)
            case "UnknownResourceException": return try UnknownResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidTagException": return try InvalidTagException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFirewallConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFirewallDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFirewallRuleGroupAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOutpostResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResolverConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResolverDnssecConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResolverEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResolverRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.fieldName = try reader["FieldName"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ResourceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnknownResourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnknownResourceException {
        let reader = baseError.errorBodyReader
        var value = UnknownResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPolicyDocument {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPolicyDocument {
        let reader = baseError.errorBodyReader
        var value = InvalidPolicyDocument()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTagException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTagException {
        let reader = baseError.errorBodyReader
        var value = InvalidTagException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension Route53ResolverClientTypes.FirewallRuleGroupAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.FirewallRuleGroupAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.FirewallRuleGroupAssociation()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.firewallRuleGroupId = try reader["FirewallRuleGroupId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        value.mutationProtection = try reader["MutationProtection"].readIfPresent()
        value.managedOwnerName = try reader["ManagedOwnerName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.ResolverEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.ResolverEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.ResolverEndpoint()
        value.id = try reader["Id"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.direction = try reader["Direction"].readIfPresent()
        value.ipAddressCount = try reader["IpAddressCount"].readIfPresent()
        value.hostVPCId = try reader["HostVPCId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        value.outpostArn = try reader["OutpostArn"].readIfPresent()
        value.preferredInstanceType = try reader["PreferredInstanceType"].readIfPresent()
        value.resolverEndpointType = try reader["ResolverEndpointType"].readIfPresent()
        value.protocols = try reader["Protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<Route53ResolverClientTypes.ModelProtocol>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension Route53ResolverClientTypes.ResolverQueryLogConfigAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.ResolverQueryLogConfigAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.ResolverQueryLogConfigAssociation()
        value.id = try reader["Id"].readIfPresent()
        value.resolverQueryLogConfigId = try reader["ResolverQueryLogConfigId"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.error = try reader["Error"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.ResolverRuleAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.ResolverRuleAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.ResolverRuleAssociation()
        value.id = try reader["Id"].readIfPresent()
        value.resolverRuleId = try reader["ResolverRuleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.vpcId = try reader["VPCId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.FirewallDomainList {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.FirewallDomainList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.FirewallDomainList()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.domainCount = try reader["DomainCount"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.managedOwnerName = try reader["ManagedOwnerName"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.FirewallRule {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.FirewallRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.FirewallRule()
        value.firewallRuleGroupId = try reader["FirewallRuleGroupId"].readIfPresent()
        value.firewallDomainListId = try reader["FirewallDomainListId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.blockResponse = try reader["BlockResponse"].readIfPresent()
        value.blockOverrideDomain = try reader["BlockOverrideDomain"].readIfPresent()
        value.blockOverrideDnsType = try reader["BlockOverrideDnsType"].readIfPresent()
        value.blockOverrideTtl = try reader["BlockOverrideTtl"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        value.firewallDomainRedirectionAction = try reader["FirewallDomainRedirectionAction"].readIfPresent()
        value.qtype = try reader["Qtype"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.FirewallRuleGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.FirewallRuleGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.FirewallRuleGroup()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ruleCount = try reader["RuleCount"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.shareStatus = try reader["ShareStatus"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.OutpostResolver {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.OutpostResolver {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.OutpostResolver()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        value.preferredInstanceType = try reader["PreferredInstanceType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.outpostArn = try reader["OutpostArn"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.ResolverQueryLogConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.ResolverQueryLogConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.ResolverQueryLogConfig()
        value.id = try reader["Id"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.shareStatus = try reader["ShareStatus"].readIfPresent()
        value.associationCount = try reader["AssociationCount"].readIfPresent() ?? 0
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.destinationArn = try reader["DestinationArn"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.ResolverRule {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.ResolverRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.ResolverRule()
        value.id = try reader["Id"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.ruleType = try reader["RuleType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.targetIps = try reader["TargetIps"].readListIfPresent(memberReadingClosure: Route53ResolverClientTypes.TargetAddress.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resolverEndpointId = try reader["ResolverEndpointId"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.shareStatus = try reader["ShareStatus"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.TargetAddress {

    static func write(value: Route53ResolverClientTypes.TargetAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ip"].write(value.ip)
        try writer["Ipv6"].write(value.ipv6)
        try writer["Port"].write(value.port)
        try writer["Protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.TargetAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.TargetAddress()
        value.ip = try reader["Ip"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.ipv6 = try reader["Ipv6"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.FirewallConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.FirewallConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.FirewallConfig()
        value.id = try reader["Id"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.firewallFailOpen = try reader["FirewallFailOpen"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.ResolverConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.ResolverConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.ResolverConfig()
        value.id = try reader["Id"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.autodefinedReverse = try reader["AutodefinedReverse"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.ResolverDnssecConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.ResolverDnssecConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.ResolverDnssecConfig()
        value.id = try reader["Id"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.validationStatus = try reader["ValidationStatus"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.FirewallDomainListMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.FirewallDomainListMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.FirewallDomainListMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.managedOwnerName = try reader["ManagedOwnerName"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.FirewallRuleGroupMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.FirewallRuleGroupMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.FirewallRuleGroupMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.shareStatus = try reader["ShareStatus"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.IpAddressResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.IpAddressResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.IpAddressResponse()
        value.ipId = try reader["IpId"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.ip = try reader["Ip"].readIfPresent()
        value.ipv6 = try reader["Ipv6"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.modificationTime = try reader["ModificationTime"].readIfPresent()
        return value
    }
}

extension Route53ResolverClientTypes.Tag {

    static func write(value: Route53ResolverClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Route53ResolverClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53ResolverClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension Route53ResolverClientTypes.IpAddressUpdate {

    static func write(value: Route53ResolverClientTypes.IpAddressUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ip"].write(value.ip)
        try writer["IpId"].write(value.ipId)
        try writer["Ipv6"].write(value.ipv6)
        try writer["SubnetId"].write(value.subnetId)
    }
}

extension Route53ResolverClientTypes.IpAddressRequest {

    static func write(value: Route53ResolverClientTypes.IpAddressRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ip"].write(value.ip)
        try writer["Ipv6"].write(value.ipv6)
        try writer["SubnetId"].write(value.subnetId)
    }
}

extension Route53ResolverClientTypes.Filter {

    static func write(value: Route53ResolverClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension Route53ResolverClientTypes.UpdateIpAddress {

    static func write(value: Route53ResolverClientTypes.UpdateIpAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpId"].write(value.ipId)
        try writer["Ipv6"].write(value.ipv6)
    }
}

extension Route53ResolverClientTypes.ResolverRuleConfig {

    static func write(value: Route53ResolverClientTypes.ResolverRuleConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ResolverEndpointId"].write(value.resolverEndpointId)
        try writer["TargetIps"].writeList(value.targetIps, memberWritingClosure: Route53ResolverClientTypes.TargetAddress.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum Route53ResolverClientTypes {}
