// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The current account doesn't have the IAM permissions required to perform the specified Resolver operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alert
        case allow
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .alert,
                .allow,
                .block,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alert: return "ALERT"
            case .allow: return "ALLOW"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
        }
    }
}

extension AssociateFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let mutationProtection = self.mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension AssociateFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateFirewallRuleGroupInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The unique identifier of the firewall rule group.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. When you create the association, the default setting is DISABLED.
    public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    /// A name that lets you identify the association, to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that you associate with the specified VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting. You must specify a unique priority for each rule group that you associate with a single VPC. To make it easier to insert rule groups later, leave space between the numbers, for example, use 101, 200, and so on. You can change the priority setting for a rule group association after you create it. The allowed values for Priority are between 100 and 9900.
    /// This member is required.
    public var priority: Swift.Int?
    /// A list of the tag keys and values that you want to associate with the rule group association.
    public var tags: [Route53ResolverClientTypes.Tag]?
    /// The unique identifier of the VPC that you want to associate with the rule group.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        creatorRequestId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct AssociateFirewallRuleGroupInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let firewallRuleGroupId: Swift.String?
    let vpcId: Swift.String?
    let priority: Swift.Int?
    let name: Swift.String?
    let mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension AssociateFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateFirewallRuleGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateFirewallRuleGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct AssociateFirewallRuleGroupOutput: Swift.Equatable {
    /// The association that you just created. The association has an ID that you can use to identify it in other requests, like update and delete.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct AssociateFirewallRuleGroupOutputBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension AssociateFirewallRuleGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

enum AssociateFirewallRuleGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateResolverEndpointIpAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension AssociateResolverEndpointIpAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateResolverEndpointIpAddressInput: Swift.Equatable {
    /// Either the IPv4 address that you want to add to a Resolver endpoint or a subnet ID. If you specify a subnet ID, Resolver chooses an IP address for you from the available IPs in the specified subnet.
    /// This member is required.
    public var ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
    /// The ID of the Resolver endpoint that you want to associate IP addresses with.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        ipAddress: Route53ResolverClientTypes.IpAddressUpdate? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

struct AssociateResolverEndpointIpAddressInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
}

extension AssociateResolverEndpointIpAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.IpAddressUpdate.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension AssociateResolverEndpointIpAddressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateResolverEndpointIpAddressOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct AssociateResolverEndpointIpAddressOutput: Swift.Equatable {
    /// The response to an AssociateResolverEndpointIpAddress request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct AssociateResolverEndpointIpAddressOutputBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension AssociateResolverEndpointIpAddressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

enum AssociateResolverEndpointIpAddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = self.resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the query logging configuration that you want to associate a VPC with.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?
    /// The ID of an Amazon VPC that you want this query logging configuration to log queries for. The VPCs and the query logging configuration must be in the same Region.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

struct AssociateResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
    let resourceId: Swift.String?
}

extension AssociateResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateResolverQueryLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateResolverQueryLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct AssociateResolverQueryLogConfigOutput: Swift.Equatable {
    /// A complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init(
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct AssociateResolverQueryLogConfigOutputBody: Swift.Equatable {
    let resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?
}

extension AssociateResolverQueryLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

enum AssociateResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case vpcId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverRuleId = self.resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension AssociateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateResolverRuleInput: Swift.Equatable {
    /// A name for the association that you're creating between a Resolver rule and a VPC.
    public var name: Swift.String?
    /// The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html).
    /// This member is required.
    public var resolverRuleId: Swift.String?
    /// The ID of the VPC that you want to associate the Resolver rule with.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        name: Swift.String? = nil,
        resolverRuleId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.name = name
        self.resolverRuleId = resolverRuleId
        self.vpcId = vpcId
    }
}

struct AssociateResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
    let name: Swift.String?
    let vpcId: Swift.String?
}

extension AssociateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case vpcId = "VPCId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension AssociateResolverRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateResolverRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct AssociateResolverRuleOutput: Swift.Equatable {
    /// Information about the AssociateResolverRule request, including the status of the request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init(
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct AssociateResolverRuleOutputBody: Swift.Equatable {
    let resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?
}

extension AssociateResolverRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

enum AssociateResolverRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum AutodefinedReverseFlag: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case useLocalResourceSetting
        case sdkUnknown(Swift.String)

        public static var allCases: [AutodefinedReverseFlag] {
            return [
                .disable,
                .enable,
                .useLocalResourceSetting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .useLocalResourceSetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutodefinedReverseFlag(rawValue: rawValue) ?? AutodefinedReverseFlag.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum BlockOverrideDnsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cname
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockOverrideDnsType] {
            return [
                .cname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cname: return "CNAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockOverrideDnsType(rawValue: rawValue) ?? BlockOverrideDnsType.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum BlockResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nodata
        case nxdomain
        case `override`
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockResponse] {
            return [
                .nodata,
                .nxdomain,
                .override,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nodata: return "NODATA"
            case .nxdomain: return "NXDOMAIN"
            case .override: return "OVERRIDE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockResponse(rawValue: rawValue) ?? BlockResponse.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested state transition isn't valid. For example, you can't delete a firewall domain list if it is in the process of being deleted, or you can't import domains into a domain list that is in the process of being deleted.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateFirewallDomainListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFirewallDomainListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFirewallDomainListInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows you to retry failed requests without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// A name that lets you identify the domain list to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the domain list.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

struct CreateFirewallDomainListInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateFirewallDomainListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFirewallDomainListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFirewallDomainListOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct CreateFirewallDomainListOutput: Swift.Equatable {
    /// The domain list that you just created.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init(
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct CreateFirewallDomainListOutputBody: Swift.Equatable {
    let firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?
}

extension CreateFirewallDomainListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

enum CreateFirewallDomainListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFirewallRuleGroupInput: Swift.Equatable {
    /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// A name that lets you identify the rule group, to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the rule group.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

struct CreateFirewallRuleGroupInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFirewallRuleGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFirewallRuleGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct CreateFirewallRuleGroupOutput: Swift.Equatable {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init(
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct CreateFirewallRuleGroupOutputBody: Swift.Equatable {
    let firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?
}

extension CreateFirewallRuleGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

enum CreateFirewallRuleGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFirewallRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = self.blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = self.blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = self.blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = self.blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension CreateFirewallRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFirewallRuleInput: Swift.Equatable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request and send metrics and logs to Cloud Watch.
    ///
    /// * BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    /// This member is required.
    public var action: Route53ResolverClientTypes.Action?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request, used with the rule action setting BLOCK.
    ///
    /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
    ///
    /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
    ///
    /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
    ///
    ///
    /// This setting is required if the rule action setting is BLOCK.
    public var blockResponse: Route53ResolverClientTypes.BlockResponse?
    /// A unique string that identifies the request and that allows you to retry failed requests without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The ID of the domain list that you want to use in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the firewall rule group where you want to create the rule.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// A name that lets you identify the rule in the rule group.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group. To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for the rules in a rule group at any time.
    /// This member is required.
    public var priority: Swift.Int?

    public init(
        action: Route53ResolverClientTypes.Action? = nil,
        blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
        creatorRequestId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.creatorRequestId = creatorRequestId
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
    }
}

struct CreateFirewallRuleInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let firewallRuleGroupId: Swift.String?
    let firewallDomainListId: Swift.String?
    let priority: Swift.Int?
    let action: Route53ResolverClientTypes.Action?
    let blockResponse: Route53ResolverClientTypes.BlockResponse?
    let blockOverrideDomain: Swift.String?
    let blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    let blockOverrideTtl: Swift.Int?
    let name: Swift.String?
}

extension CreateFirewallRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateFirewallRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFirewallRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct CreateFirewallRuleOutput: Swift.Equatable {
    /// The firewall rule that you just created.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init(
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct CreateFirewallRuleOutputBody: Swift.Equatable {
    let firewallRule: Route53ResolverClientTypes.FirewallRule?
}

extension CreateFirewallRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

enum CreateFirewallRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateOutpostResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case preferredInstanceType = "PreferredInstanceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let preferredInstanceType = self.preferredInstanceType {
            try encodeContainer.encode(preferredInstanceType, forKey: .preferredInstanceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateOutpostResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOutpostResolverInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// Number of Amazon EC2 instances for the Resolver on Outpost. The default and minimal value is 4.
    public var instanceCount: Swift.Int?
    /// A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost. If you specify this, you must also specify a value for the PreferredInstanceType.
    /// This member is required.
    public var outpostArn: Swift.String?
    /// The Amazon EC2 instance type. If you specify this, you must also specify a value for the OutpostArn.
    /// This member is required.
    public var preferredInstanceType: Swift.String?
    /// A string that helps identify the Route 53 Resolvers on Outpost.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        instanceCount: Swift.Int? = nil,
        name: Swift.String? = nil,
        outpostArn: Swift.String? = nil,
        preferredInstanceType: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.instanceCount = instanceCount
        self.name = name
        self.outpostArn = outpostArn
        self.preferredInstanceType = preferredInstanceType
        self.tags = tags
    }
}

struct CreateOutpostResolverInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let instanceCount: Swift.Int?
    let preferredInstanceType: Swift.String?
    let outpostArn: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateOutpostResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case preferredInstanceType = "PreferredInstanceType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let preferredInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredInstanceType)
        preferredInstanceType = preferredInstanceTypeDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOutpostResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOutpostResolverOutputBody = try responseDecoder.decode(responseBody: data)
            self.outpostResolver = output.outpostResolver
        } else {
            self.outpostResolver = nil
        }
    }
}

public struct CreateOutpostResolverOutput: Swift.Equatable {
    /// Information about the CreateOutpostResolver request, including the status of the request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

struct CreateOutpostResolverOutputBody: Swift.Equatable {
    let outpostResolver: Route53ResolverClientTypes.OutpostResolver?
}

extension CreateOutpostResolverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpostResolver = "OutpostResolver"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostResolverDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.OutpostResolver.self, forKey: .outpostResolver)
        outpostResolver = outpostResolverDecoded
    }
}

enum CreateOutpostResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case preferredInstanceType = "PreferredInstanceType"
        case resolverEndpointType = "ResolverEndpointType"
        case securityGroupIds = "SecurityGroupIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddressrequest0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddressrequest0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let preferredInstanceType = self.preferredInstanceType {
            try encodeContainer.encode(preferredInstanceType, forKey: .preferredInstanceType)
        }
        if let resolverEndpointType = self.resolverEndpointType {
            try encodeContainer.encode(resolverEndpointType.rawValue, forKey: .resolverEndpointType)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for resourceid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(resourceid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResolverEndpointInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// Specify the applicable value:
    ///
    /// * INBOUND: Resolver forwards DNS queries to the DNS service for a VPC from your network
    ///
    /// * OUTBOUND: Resolver forwards DNS queries from the DNS service for a VPC to your network
    /// This member is required.
    public var direction: Route53ResolverClientTypes.ResolverEndpointDirection?
    /// The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC.
    /// This member is required.
    public var ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]?
    /// A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost. If you specify this, you must also specify a value for the PreferredInstanceType.
    public var outpostArn: Swift.String?
    /// The instance type. If you specify this, you must also specify a value for the OutpostArn.
    public var preferredInstanceType: Swift.String?
    /// For the endpoint type you can choose either IPv4, IPv6, or dual-stack. A dual-stack endpoint means that it will resolve via both IPv4 and IPv6. This endpoint type is applied to all IP addresses.
    public var resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
    /// The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// A list of the tag keys and values that you want to associate with the endpoint.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        direction: Route53ResolverClientTypes.ResolverEndpointDirection? = nil,
        ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]? = nil,
        name: Swift.String? = nil,
        outpostArn: Swift.String? = nil,
        preferredInstanceType: Swift.String? = nil,
        resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType? = nil,
        securityGroupIds: [Swift.String]? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.direction = direction
        self.ipAddresses = ipAddresses
        self.name = name
        self.outpostArn = outpostArn
        self.preferredInstanceType = preferredInstanceType
        self.resolverEndpointType = resolverEndpointType
        self.securityGroupIds = securityGroupIds
        self.tags = tags
    }
}

struct CreateResolverEndpointInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let direction: Route53ResolverClientTypes.ResolverEndpointDirection?
    let ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]?
    let tags: [Route53ResolverClientTypes.Tag]?
    let resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
    let outpostArn: Swift.String?
    let preferredInstanceType: Swift.String?
}

extension CreateResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case preferredInstanceType = "PreferredInstanceType"
        case resolverEndpointType = "ResolverEndpointType"
        case securityGroupIds = "SecurityGroupIds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let directionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointDirection.self, forKey: .direction)
        direction = directionDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.IpAddressRequest?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Route53ResolverClientTypes.IpAddressRequest]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Route53ResolverClientTypes.IpAddressRequest]()
            for structure0 in ipAddressesContainer {
                if let structure0 = structure0 {
                    ipAddressesDecoded0?.append(structure0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resolverEndpointTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointType.self, forKey: .resolverEndpointType)
        resolverEndpointType = resolverEndpointTypeDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let preferredInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredInstanceType)
        preferredInstanceType = preferredInstanceTypeDecoded
    }
}

extension CreateResolverEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResolverEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct CreateResolverEndpointOutput: Swift.Equatable {
    /// Information about the CreateResolverEndpoint request, including the status of the request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct CreateResolverEndpointOutputBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension CreateResolverEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

enum CreateResolverEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResolverQueryLogConfigInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The ARN of the resource that you want Resolver to send query logs. You can send query logs to an S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream. Examples of valid values include the following:
    ///
    /// * S3 bucket: arn:aws:s3:::examplebucket You can optionally append a file prefix to the end of the ARN. arn:aws:s3:::examplebucket/development/
    ///
    /// * CloudWatch Logs log group: arn:aws:logs:us-west-1:123456789012:log-group:/mystack-testgroup-12ABC1AB12A1:*
    ///
    /// * Kinesis Data Firehose delivery stream: arn:aws:kinesis:us-east-2:0123456789:stream/my_stream_name
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The name that you want to give the query logging configuration.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the query logging configuration.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.destinationArn = destinationArn
        self.name = name
        self.tags = tags
    }
}

struct CreateResolverQueryLogConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let destinationArn: Swift.String?
    let creatorRequestId: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverQueryLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResolverQueryLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct CreateResolverQueryLogConfigOutput: Swift.Equatable {
    /// Information about the CreateResolverQueryLogConfig request, including the status of the request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init(
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct CreateResolverQueryLogConfigOutputBody: Swift.Equatable {
    let resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?
}

extension CreateResolverQueryLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

enum CreateResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case tags = "Tags"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let ruleType = self.ruleType {
            try encodeContainer.encode(ruleType.rawValue, forKey: .ruleType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetaddress0 in targetIps {
                try targetIpsContainer.encode(targetaddress0)
            }
        }
    }
}

extension CreateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResolverRuleInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// DNS queries for this domain name are forwarded to the IP addresses that you specify in TargetIps. If a query matches multiple Resolver rules (example.com and www.example.com), outbound DNS queries are routed using the Resolver rule that contains the most specific domain name (www.example.com).
    /// This member is required.
    public var domainName: Swift.String?
    /// A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.
    public var name: Swift.String?
    /// The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in TargetIps.
    public var resolverEndpointId: Swift.String?
    /// When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD. When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM. For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify FORWARD for RuleType. To then have Resolver process queries for apex.example.com, you create a rule and specify SYSTEM for RuleType. Currently, only Resolver can create rules that have a value of RECURSIVE for RuleType.
    /// This member is required.
    public var ruleType: Route53ResolverClientTypes.RuleTypeOption?
    /// A list of the tag keys and values that you want to associate with the endpoint.
    public var tags: [Route53ResolverClientTypes.Tag]?
    /// The IPs that you want Resolver to forward DNS queries to. You can specify either Ipv4 or Ipv6 addresses but not both in the same rule. Separate IP addresses with a space. TargetIps is available only when the value of Rule type is FORWARD.
    public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

    public init(
        creatorRequestId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        name: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil,
        ruleType: Route53ResolverClientTypes.RuleTypeOption? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil,
        targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.domainName = domainName
        self.name = name
        self.resolverEndpointId = resolverEndpointId
        self.ruleType = ruleType
        self.tags = tags
        self.targetIps = targetIps
    }
}

struct CreateResolverRuleInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let ruleType: Route53ResolverClientTypes.RuleTypeOption?
    let domainName: Swift.String?
    let targetIps: [Route53ResolverClientTypes.TargetAddress]?
    let resolverEndpointId: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case tags = "Tags"
        case targetIps = "TargetIps"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.RuleTypeOption.self, forKey: .ruleType)
        ruleType = ruleTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[Route53ResolverClientTypes.TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [Route53ResolverClientTypes.TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResolverRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct CreateResolverRuleOutput: Swift.Equatable {
    /// Information about the CreateResolverRule request, including the status of the request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct CreateResolverRuleOutputBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension CreateResolverRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

enum CreateResolverRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFirewallDomainListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
    }
}

extension DeleteFirewallDomainListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFirewallDomainListInput: Swift.Equatable {
    /// The ID of the domain list that you want to delete.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

struct DeleteFirewallDomainListInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
}

extension DeleteFirewallDomainListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension DeleteFirewallDomainListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFirewallDomainListOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct DeleteFirewallDomainListOutput: Swift.Equatable {
    /// The domain list that you just deleted.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init(
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct DeleteFirewallDomainListOutputBody: Swift.Equatable {
    let firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?
}

extension DeleteFirewallDomainListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

enum DeleteFirewallDomainListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

extension DeleteFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFirewallRuleGroupInput: Swift.Equatable {
    /// The unique identifier of the firewall rule group that you want to delete.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init(
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct DeleteFirewallRuleGroupInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
}

extension DeleteFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
    }
}

extension DeleteFirewallRuleGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFirewallRuleGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct DeleteFirewallRuleGroupOutput: Swift.Equatable {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init(
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct DeleteFirewallRuleGroupOutputBody: Swift.Equatable {
    let firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?
}

extension DeleteFirewallRuleGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

enum DeleteFirewallRuleGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFirewallRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

extension DeleteFirewallRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFirewallRuleInput: Swift.Equatable {
    /// The ID of the domain list that's used in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the firewall rule group that you want to delete the rule from.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct DeleteFirewallRuleInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let firewallDomainListId: Swift.String?
}

extension DeleteFirewallRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension DeleteFirewallRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFirewallRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct DeleteFirewallRuleOutput: Swift.Equatable {
    /// The specification for the firewall rule that you just deleted.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init(
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct DeleteFirewallRuleOutputBody: Swift.Equatable {
    let firewallRule: Route53ResolverClientTypes.FirewallRule?
}

extension DeleteFirewallRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

enum DeleteFirewallRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOutpostResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteOutpostResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOutpostResolverInput: Swift.Equatable {
    /// A unique string that identifies the Resolver on the Outpost.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteOutpostResolverInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteOutpostResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteOutpostResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteOutpostResolverOutputBody = try responseDecoder.decode(responseBody: data)
            self.outpostResolver = output.outpostResolver
        } else {
            self.outpostResolver = nil
        }
    }
}

public struct DeleteOutpostResolverOutput: Swift.Equatable {
    /// Information about the DeleteOutpostResolver request, including the status of the request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

struct DeleteOutpostResolverOutputBody: Swift.Equatable {
    let outpostResolver: Route53ResolverClientTypes.OutpostResolver?
}

extension DeleteOutpostResolverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpostResolver = "OutpostResolver"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostResolverDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.OutpostResolver.self, forKey: .outpostResolver)
        outpostResolver = outpostResolverDecoded
    }
}

enum DeleteOutpostResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension DeleteResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResolverEndpointInput: Swift.Equatable {
    /// The ID of the Resolver endpoint that you want to delete.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

struct DeleteResolverEndpointInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
}

extension DeleteResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension DeleteResolverEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResolverEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct DeleteResolverEndpointOutput: Swift.Equatable {
    /// Information about the DeleteResolverEndpoint request, including the status of the request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct DeleteResolverEndpointOutputBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension DeleteResolverEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

enum DeleteResolverEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = self.resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
    }
}

extension DeleteResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the query logging configuration that you want to delete.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

struct DeleteResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
}

extension DeleteResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
    }
}

extension DeleteResolverQueryLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResolverQueryLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct DeleteResolverQueryLogConfigOutput: Swift.Equatable {
    /// Information about the query logging configuration that you deleted, including the status of the request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init(
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct DeleteResolverQueryLogConfigOutputBody: Swift.Equatable {
    let resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?
}

extension DeleteResolverQueryLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

enum DeleteResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = self.resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

extension DeleteResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResolverRuleInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to delete.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init(
        resolverRuleId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

struct DeleteResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
}

extension DeleteResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension DeleteResolverRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResolverRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct DeleteResolverRuleOutput: Swift.Equatable {
    /// Information about the DeleteResolverRule request, including the status of the request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct DeleteResolverRuleOutputBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension DeleteResolverRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

enum DeleteResolverRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = self.firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
    }
}

extension DisassociateFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateFirewallRuleGroupInput: Swift.Equatable {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?

    public init(
        firewallRuleGroupAssociationId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

struct DisassociateFirewallRuleGroupInputBody: Swift.Equatable {
    let firewallRuleGroupAssociationId: Swift.String?
}

extension DisassociateFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
    }
}

extension DisassociateFirewallRuleGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateFirewallRuleGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct DisassociateFirewallRuleGroupOutput: Swift.Equatable {
    /// The firewall rule group association that you just removed.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct DisassociateFirewallRuleGroupOutputBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension DisassociateFirewallRuleGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

enum DisassociateFirewallRuleGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateResolverEndpointIpAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension DisassociateResolverEndpointIpAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateResolverEndpointIpAddressInput: Swift.Equatable {
    /// The IPv4 address that you want to remove from a Resolver endpoint.
    /// This member is required.
    public var ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
    /// The ID of the Resolver endpoint that you want to disassociate an IP address from.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        ipAddress: Route53ResolverClientTypes.IpAddressUpdate? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

struct DisassociateResolverEndpointIpAddressInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
}

extension DisassociateResolverEndpointIpAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.IpAddressUpdate.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension DisassociateResolverEndpointIpAddressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateResolverEndpointIpAddressOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct DisassociateResolverEndpointIpAddressOutput: Swift.Equatable {
    /// The response to an DisassociateResolverEndpointIpAddress request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct DisassociateResolverEndpointIpAddressOutputBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension DisassociateResolverEndpointIpAddressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

enum DisassociateResolverEndpointIpAddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceExistsException": return try await ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = self.resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DisassociateResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the query logging configuration that you want to disassociate a specified VPC from.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?
    /// The ID of the Amazon VPC that you want to disassociate from a specified query logging configuration.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

struct DisassociateResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
    let resourceId: Swift.String?
}

extension DisassociateResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DisassociateResolverQueryLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateResolverQueryLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct DisassociateResolverQueryLogConfigOutput: Swift.Equatable {
    /// A complex type that contains settings for the association that you deleted between an Amazon VPC and a query logging configuration.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init(
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct DisassociateResolverQueryLogConfigOutputBody: Swift.Equatable {
    let resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?
}

extension DisassociateResolverQueryLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

enum DisassociateResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
        case vpcId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = self.resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension DisassociateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateResolverRuleInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to disassociate from the specified VPC.
    /// This member is required.
    public var resolverRuleId: Swift.String?
    /// The ID of the VPC that you want to disassociate the Resolver rule from.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        resolverRuleId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
        self.vpcId = vpcId
    }
}

struct DisassociateResolverRuleInputBody: Swift.Equatable {
    let vpcId: Swift.String?
    let resolverRuleId: Swift.String?
}

extension DisassociateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
        case vpcId = "VPCId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension DisassociateResolverRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateResolverRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct DisassociateResolverRuleOutput: Swift.Equatable {
    /// Information about the DisassociateResolverRule request, including the status of the request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init(
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct DisassociateResolverRuleOutputBody: Swift.Equatable {
    let resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?
}

extension DisassociateResolverRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

enum DisassociateResolverRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53ResolverClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Route53ResolverClientTypes {
    /// For Resolver list operations ([ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html), [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html), [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html)), and [ListResolverDnssecConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverDnssecConfigs.html)), an optional specification to return a subset of objects. To filter objects, such as Resolver endpoints or Resolver rules, you specify Name and Values. For example, to list only inbound Resolver endpoints, specify Direction for Name and specify INBOUND for Values.
    public struct Filter: Swift.Equatable {
        /// The name of the parameter that you want to use to filter objects. The valid values for Name depend on the action that you're including the filter in, [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html), [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html), or [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html). In early versions of Resolver, values for Name were listed as uppercase, with underscore (_) delimiters. For example, CreatorRequestId was originally listed as CREATOR_REQUEST_ID. Uppercase values for Name are still supported. ListResolverEndpoints Valid values for Name include the following:
        ///
        /// * CreatorRequestId: The value that you specified when you created the Resolver endpoint.
        ///
        /// * Direction: Whether you want to return inbound or outbound Resolver endpoints. If you specify DIRECTION for Name, specify INBOUND or OUTBOUND for Values.
        ///
        /// * HostVPCId: The ID of the VPC that inbound DNS queries pass through on the way from your network to your VPCs in a region, or the VPC that outbound queries pass through on the way from your VPCs to your network. In a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request, SubnetId indirectly identifies the VPC. In a [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html) request, the VPC ID for a Resolver endpoint is returned in the HostVPCId element.
        ///
        /// * IpAddressCount: The number of IP addresses that you have associated with the Resolver endpoint.
        ///
        /// * Name: The name of the Resolver endpoint.
        ///
        /// * SecurityGroupIds: The IDs of the VPC security groups that you specified when you created the Resolver endpoint.
        ///
        /// * Status: The status of the Resolver endpoint. If you specify Status for Name, specify one of the following status codes for Values: CREATING, OPERATIONAL, UPDATING, AUTO_RECOVERING, ACTION_NEEDED, or DELETING. For more information, see Status in [ResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverEndpoint.html).
        ///
        ///
        /// ListResolverRules Valid values for Name include the following:
        ///
        /// * CreatorRequestId: The value that you specified when you created the Resolver rule.
        ///
        /// * DomainName: The domain name for which Resolver is forwarding DNS queries to your network. In the value that you specify for Values, include a trailing dot (.) after the domain name. For example, if the domain name is example.com, specify the following value. Note the "." after com: example.com.
        ///
        /// * Name: The name of the Resolver rule.
        ///
        /// * ResolverEndpointId: The ID of the Resolver endpoint that the Resolver rule is associated with. You can filter on the Resolver endpoint only for rules that have a value of FORWARD for RuleType.
        ///
        /// * Status: The status of the Resolver rule. If you specify Status for Name, specify one of the following status codes for Values: COMPLETE, DELETING, UPDATING, or FAILED.
        ///
        /// * Type: The type of the Resolver rule. If you specify TYPE for Name, specify FORWARD or SYSTEM for Values.
        ///
        ///
        /// ListResolverRuleAssociations Valid values for Name include the following:
        ///
        /// * Name: The name of the Resolver rule association.
        ///
        /// * ResolverRuleId: The ID of the Resolver rule that is associated with one or more VPCs.
        ///
        /// * Status: The status of the Resolver rule association. If you specify Status for Name, specify one of the following status codes for Values: CREATING, COMPLETE, DELETING, or FAILED.
        ///
        /// * VPCId: The ID of the VPC that the Resolver rule is associated with.
        ///
        ///
        /// ListResolverQueryLogConfigs Valid values for Name include the following:
        ///
        /// * Arn: The ARN for the query logging configuration.
        ///
        /// * AssociationCount: The number of VPCs that are associated with the query logging configuration.
        ///
        /// * CreationTime: The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).
        ///
        /// * CreatorRequestId: A unique string that identifies the request that created the query logging configuration.
        ///
        /// * Destination: The Amazon Web Services service that you want to forward query logs to. Valid values include the following:
        ///
        /// * S3
        ///
        /// * CloudWatchLogs
        ///
        /// * KinesisFirehose
        ///
        ///
        ///
        ///
        /// * DestinationArn: The ARN of the location that Resolver is sending query logs to. This value can be the ARN for an S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.
        ///
        /// * Id: The ID of the query logging configuration
        ///
        /// * Name: The name of the query logging configuration
        ///
        /// * OwnerId: The Amazon Web Services account ID for the account that created the query logging configuration.
        ///
        /// * ShareStatus: An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Valid values include: NOT_SHARED, SHARED_WITH_ME, or SHARED_BY_ME.
        ///
        /// * Status: The status of the query logging configuration. If you specify Status for Name, specify the applicable status code for Values: CREATING, CREATED, DELETING, or FAILED. For more information, see [Status](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfig.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfig-Status).
        ///
        ///
        /// ListResolverQueryLogConfigAssociations Valid values for Name include the following:
        ///
        /// * CreationTime: The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).
        ///
        /// * Error: If the value of Status is FAILED, specify the cause: DESTINATION_NOT_FOUND or ACCESS_DENIED.
        ///
        /// * Id: The ID of the query logging association.
        ///
        /// * ResolverQueryLogConfigId: The ID of the query logging configuration that a VPC is associated with.
        ///
        /// * ResourceId: The ID of the Amazon VPC that is associated with the query logging configuration.
        ///
        /// * Status: The status of the query logging association. If you specify Status for Name, specify the applicable status code for Values: CREATING, CREATED, DELETING, or FAILED. For more information, see [Status](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfigAssociation.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfigAssociation-Status).
        public var name: Swift.String?
        /// When you're using a List operation and you want the operation to return a subset of objects, such as Resolver endpoints or Resolver rules, the value of the parameter that you want to use to filter objects. For example, to list only inbound Resolver endpoints, specify Direction for Name and specify INBOUND for Values.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension Route53ResolverClientTypes.FirewallConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallFailOpen = self.firewallFailOpen {
            try encodeContainer.encode(firewallFailOpen.rawValue, forKey: .firewallFailOpen)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let firewallFailOpenDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallFailOpenStatus.self, forKey: .firewallFailOpen)
        firewallFailOpen = firewallFailOpenDecoded
    }
}

extension Route53ResolverClientTypes {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC from Amazon Virtual Private Cloud (Amazon VPC).
    public struct FirewallConfig: Swift.Equatable {
        /// Determines how DNS Firewall operates during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply.
        ///
        /// * By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall returns a failure error when it is unable to properly evaluate a query.
        ///
        /// * If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it is unable to properly evaluate them.
        ///
        ///
        /// This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association.
        public var firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
        /// The ID of the firewall configuration.
        public var id: Swift.String?
        /// The Amazon Web Services account ID of the owner of the VPC that this firewall configuration applies to.
        public var ownerId: Swift.String?
        /// The ID of the VPC that this firewall configuration applies to.
        public var resourceId: Swift.String?

        public init(
            firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus? = nil,
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.firewallFailOpen = firewallFailOpen
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallDomainImportOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainImportOperation] {
            return [
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallDomainImportOperation(rawValue: rawValue) ?? FirewallDomainImportOperation.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.FirewallDomainList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case domainCount = "DomainCount"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainCount = self.domainCount {
            try encodeContainer.encode(domainCount, forKey: .domainCount)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = self.managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .domainCount)
        domainCount = domainCountDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// High-level information about a list of firewall domains for use in a [FirewallRule]. This is returned by [GetFirewallDomainList]. To retrieve the domains that are defined for this domain list, call [ListFirewallDomains].
    public struct FirewallDomainList: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the firewall domain list.
        public var arn: Swift.String?
        /// The date and time that the domain list was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The number of domain names that are specified in the domain list.
        public var domainCount: Swift.Int?
        /// The ID of the domain list.
        public var id: Swift.String?
        /// The owner of the list, used only for lists that are not managed by you. For example, the managed domain list AWSManagedDomainsMalwareDomainList has the managed owner name Route 53 Resolver DNS Firewall.
        public var managedOwnerName: Swift.String?
        /// The date and time that the domain list was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the domain list.
        public var name: Swift.String?
        /// The status of the domain list.
        public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
        /// Additional information about the status of the list, if available.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            domainCount: Swift.Int? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.domainCount = domainCount
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.modificationTime = modificationTime
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension Route53ResolverClientTypes.FirewallDomainListMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = self.managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
    }
}

extension Route53ResolverClientTypes {
    /// Minimal high-level information for a firewall domain list. The action [ListFirewallDomainLists] returns an array of these objects. To retrieve full information for a firewall domain list, call [GetFirewallDomainList] and [ListFirewallDomains].
    public struct FirewallDomainListMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the firewall domain list metadata.
        public var arn: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the domain list.
        public var id: Swift.String?
        /// The owner of the list, used only for lists that are not managed by you. For example, the managed domain list AWSManagedDomainsMalwareDomainList has the managed owner name Route 53 Resolver DNS Firewall.
        public var managedOwnerName: Swift.String?
        /// The name of the domain list.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.name = name
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallDomainListStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case completeImportFailed
        case deleting
        case importing
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainListStatus] {
            return [
                .complete,
                .completeImportFailed,
                .deleting,
                .importing,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .completeImportFailed: return "COMPLETE_IMPORT_FAILED"
            case .deleting: return "DELETING"
            case .importing: return "IMPORTING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallDomainListStatus(rawValue: rawValue) ?? FirewallDomainListStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum FirewallDomainUpdateOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainUpdateOperation] {
            return [
                .add,
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallDomainUpdateOperation(rawValue: rawValue) ?? FirewallDomainUpdateOperation.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum FirewallFailOpenStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case useLocalResourceSetting
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallFailOpenStatus] {
            return [
                .disabled,
                .enabled,
                .useLocalResourceSetting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .useLocalResourceSetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallFailOpenStatus(rawValue: rawValue) ?? FirewallFailOpenStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.FirewallRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = self.blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = self.blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = self.blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = self.blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// A single firewall rule in a rule group.
    public struct FirewallRule: Swift.Equatable {
        /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
        ///
        /// * ALLOW - Permit the request to go through.
        ///
        /// * ALERT - Permit the request to go through but send an alert to the logs.
        ///
        /// * BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
        public var action: Route53ResolverClientTypes.Action?
        /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
        /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideDomain: Swift.String?
        /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideTtl: Swift.Int?
        /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
        ///
        /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
        ///
        /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
        ///
        /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
        public var blockResponse: Route53ResolverClientTypes.BlockResponse?
        /// The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of executing the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the domain list that's used in the rule.
        public var firewallDomainListId: Swift.String?
        /// The unique identifier of the firewall rule group of the rule.
        public var firewallRuleGroupId: Swift.String?
        /// The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule in the rule group. This value must be unique within the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
        public var priority: Swift.Int?

        public init(
            action: Route53ResolverClientTypes.Action? = nil,
            blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            firewallDomainListId: Swift.String? = nil,
            firewallRuleGroupId: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.firewallDomainListId = firewallDomainListId
            self.firewallRuleGroupId = firewallRuleGroupId
            self.modificationTime = modificationTime
            self.name = name
            self.priority = priority
        }
    }

}

extension Route53ResolverClientTypes.FirewallRuleGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case ownerId = "OwnerId"
        case ruleCount = "RuleCount"
        case shareStatus = "ShareStatus"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let ruleCount = self.ruleCount {
            try encodeContainer.encode(ruleCount, forKey: .ruleCount)
        }
        if let shareStatus = self.shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ruleCount)
        ruleCount = ruleCountDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// High-level information for a firewall rule group. A firewall rule group is a collection of rules that DNS Firewall uses to filter DNS network traffic for a VPC. To retrieve the rules for the rule group, call [ListFirewallRules].
    public struct FirewallRuleGroup: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the rule group.
        public var arn: Swift.String?
        /// The date and time that the rule group was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the rule group.
        public var id: Swift.String?
        /// The date and time that the rule group was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account, this is the account that has shared the rule group with you.
        public var ownerId: Swift.String?
        /// The number of rules in the rule group.
        public var ruleCount: Swift.Int?
        /// Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// The status of the domain list.
        public var status: Route53ResolverClientTypes.FirewallRuleGroupStatus?
        /// Additional information about the status of the rule group, if available.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            ruleCount: Swift.Int? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.FirewallRuleGroupStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.modificationTime = modificationTime
            self.name = name
            self.ownerId = ownerId
            self.ruleCount = ruleCount
            self.shareStatus = shareStatus
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension Route53ResolverClientTypes.FirewallRuleGroupAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case modificationTime = "ModificationTime"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = self.managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let mutationProtection = self.mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// An association between a firewall rule group and a VPC, which enables DNS filtering for the VPC.
    public struct FirewallRuleGroupAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the firewall rule group association.
        public var arn: Swift.String?
        /// The date and time that the association was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The unique identifier of the firewall rule group.
        public var firewallRuleGroupId: Swift.String?
        /// The identifier for the association.
        public var id: Swift.String?
        /// The owner of the association, used only for associations that are not managed by you. If you use Firewall Manager to manage your DNS Firewalls, then this reports Firewall Manager as the managed owner.
        public var managedOwnerName: Swift.String?
        /// The date and time that the association was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
        public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
        /// The name of the association.
        public var name: Swift.String?
        /// The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting from rule group with the lowest numeric priority setting.
        public var priority: Swift.Int?
        /// The current status of the association.
        public var status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
        /// Additional information about the status of the response, if available.
        public var statusMessage: Swift.String?
        /// The unique identifier of the VPC that is associated with the rule group.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            firewallRuleGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus? = nil,
            statusMessage: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.firewallRuleGroupId = firewallRuleGroupId
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.modificationTime = modificationTime
            self.mutationProtection = mutationProtection
            self.name = name
            self.priority = priority
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallRuleGroupAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRuleGroupAssociationStatus] {
            return [
                .complete,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallRuleGroupAssociationStatus(rawValue: rawValue) ?? FirewallRuleGroupAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.FirewallRuleGroupMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case name = "Name"
        case ownerId = "OwnerId"
        case shareStatus = "ShareStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let shareStatus = self.shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
    }
}

extension Route53ResolverClientTypes {
    /// Minimal high-level information for a firewall rule group. The action [ListFirewallRuleGroups] returns an array of these objects. To retrieve full information for a firewall rule group, call [GetFirewallRuleGroup] and [ListFirewallRules].
    public struct FirewallRuleGroupMetadata: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the rule group.
        public var arn: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the rule group.
        public var id: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account, this is the account that has shared the rule group with you.
        public var ownerId: Swift.String?
        /// Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?

        public init(
            arn: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil
        )
        {
            self.arn = arn
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.name = name
            self.ownerId = ownerId
            self.shareStatus = shareStatus
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallRuleGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRuleGroupStatus] {
            return [
                .complete,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallRuleGroupStatus(rawValue: rawValue) ?? FirewallRuleGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetFirewallConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension GetFirewallConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallConfigInput: Swift.Equatable {
    /// The ID of the VPC from Amazon VPC that the configuration is for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetFirewallConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension GetFirewallConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetFirewallConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFirewallConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallConfig = output.firewallConfig
        } else {
            self.firewallConfig = nil
        }
    }
}

public struct GetFirewallConfigOutput: Swift.Equatable {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC from AmazonVPC.
    public var firewallConfig: Route53ResolverClientTypes.FirewallConfig?

    public init(
        firewallConfig: Route53ResolverClientTypes.FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

struct GetFirewallConfigOutputBody: Swift.Equatable {
    let firewallConfig: Route53ResolverClientTypes.FirewallConfig?
}

extension GetFirewallConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallConfig = "FirewallConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallConfig.self, forKey: .firewallConfig)
        firewallConfig = firewallConfigDecoded
    }
}

enum GetFirewallConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFirewallDomainListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
    }
}

extension GetFirewallDomainListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallDomainListInput: Swift.Equatable {
    /// The ID of the domain list.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

struct GetFirewallDomainListInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
}

extension GetFirewallDomainListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension GetFirewallDomainListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFirewallDomainListOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct GetFirewallDomainListOutput: Swift.Equatable {
    /// The domain list that you requested.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init(
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct GetFirewallDomainListOutputBody: Swift.Equatable {
    let firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?
}

extension GetFirewallDomainListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

enum GetFirewallDomainListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFirewallRuleGroupAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = self.firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
    }
}

extension GetFirewallRuleGroupAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallRuleGroupAssociationInput: Swift.Equatable {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?

    public init(
        firewallRuleGroupAssociationId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

struct GetFirewallRuleGroupAssociationInputBody: Swift.Equatable {
    let firewallRuleGroupAssociationId: Swift.String?
}

extension GetFirewallRuleGroupAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
    }
}

extension GetFirewallRuleGroupAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFirewallRuleGroupAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct GetFirewallRuleGroupAssociationOutput: Swift.Equatable {
    /// The association that you requested.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct GetFirewallRuleGroupAssociationOutputBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension GetFirewallRuleGroupAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

enum GetFirewallRuleGroupAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

extension GetFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallRuleGroupInput: Swift.Equatable {
    /// The unique identifier of the firewall rule group.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init(
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct GetFirewallRuleGroupInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
}

extension GetFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
    }
}

extension GetFirewallRuleGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFirewallRuleGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct GetFirewallRuleGroupOutput: Swift.Equatable {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init(
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct GetFirewallRuleGroupOutputBody: Swift.Equatable {
    let firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?
}

extension GetFirewallRuleGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

enum GetFirewallRuleGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFirewallRuleGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetFirewallRuleGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallRuleGroupPolicyInput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) for the rule group.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetFirewallRuleGroupPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetFirewallRuleGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetFirewallRuleGroupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFirewallRuleGroupPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupPolicy = output.firewallRuleGroupPolicy
        } else {
            self.firewallRuleGroupPolicy = nil
        }
    }
}

public struct GetFirewallRuleGroupPolicyOutput: Swift.Equatable {
    /// The Identity and Access Management (Amazon Web Services IAM) policy for sharing the specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM).
    public var firewallRuleGroupPolicy: Swift.String?

    public init(
        firewallRuleGroupPolicy: Swift.String? = nil
    )
    {
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

struct GetFirewallRuleGroupPolicyOutputBody: Swift.Equatable {
    let firewallRuleGroupPolicy: Swift.String?
}

extension GetFirewallRuleGroupPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupPolicy)
        firewallRuleGroupPolicy = firewallRuleGroupPolicyDecoded
    }
}

enum GetFirewallRuleGroupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOutpostResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetOutpostResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOutpostResolverInput: Swift.Equatable {
    /// The ID of the Resolver on the Outpost.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOutpostResolverInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetOutpostResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetOutpostResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOutpostResolverOutputBody = try responseDecoder.decode(responseBody: data)
            self.outpostResolver = output.outpostResolver
        } else {
            self.outpostResolver = nil
        }
    }
}

public struct GetOutpostResolverOutput: Swift.Equatable {
    /// Information about the GetOutpostResolver request, including the status of the request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

struct GetOutpostResolverOutputBody: Swift.Equatable {
    let outpostResolver: Route53ResolverClientTypes.OutpostResolver?
}

extension GetOutpostResolverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpostResolver = "OutpostResolver"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostResolverDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.OutpostResolver.self, forKey: .outpostResolver)
        outpostResolver = outpostResolverDecoded
    }
}

enum GetOutpostResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension GetResolverConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverConfigInput: Swift.Equatable {
    /// Resource ID of the Amazon VPC that you want to get information about.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetResolverConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension GetResolverConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetResolverConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverConfig = output.resolverConfig
        } else {
            self.resolverConfig = nil
        }
    }
}

public struct GetResolverConfigOutput: Swift.Equatable {
    /// Information about the behavior configuration of Route 53 Resolver behavior for the VPC you specified in the GetResolverConfig request.
    public var resolverConfig: Route53ResolverClientTypes.ResolverConfig?

    public init(
        resolverConfig: Route53ResolverClientTypes.ResolverConfig? = nil
    )
    {
        self.resolverConfig = resolverConfig
    }
}

struct GetResolverConfigOutputBody: Swift.Equatable {
    let resolverConfig: Route53ResolverClientTypes.ResolverConfig?
}

extension GetResolverConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverConfig = "ResolverConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverConfig.self, forKey: .resolverConfig)
        resolverConfig = resolverConfigDecoded
    }
}

enum GetResolverConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverDnssecConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension GetResolverDnssecConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverDnssecConfigInput: Swift.Equatable {
    /// The ID of the virtual private cloud (VPC) for the DNSSEC validation status.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetResolverDnssecConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension GetResolverDnssecConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetResolverDnssecConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverDnssecConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverDNSSECConfig = output.resolverDNSSECConfig
        } else {
            self.resolverDNSSECConfig = nil
        }
    }
}

public struct GetResolverDnssecConfigOutput: Swift.Equatable {
    /// The information about a configuration for DNSSEC validation.
    public var resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?

    public init(
        resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

struct GetResolverDnssecConfigOutputBody: Swift.Equatable {
    let resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?
}

extension GetResolverDnssecConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverDNSSECConfig = "ResolverDNSSECConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDNSSECConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverDnssecConfig.self, forKey: .resolverDNSSECConfig)
        resolverDNSSECConfig = resolverDNSSECConfigDecoded
    }
}

enum GetResolverDnssecConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension GetResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverEndpointInput: Swift.Equatable {
    /// The ID of the Resolver endpoint that you want to get information about.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

struct GetResolverEndpointInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
}

extension GetResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension GetResolverEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct GetResolverEndpointOutput: Swift.Equatable {
    /// Information about the Resolver endpoint that you specified in a GetResolverEndpoint request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct GetResolverEndpointOutputBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension GetResolverEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

enum GetResolverEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverQueryLogConfigAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociationId = "ResolverQueryLogConfigAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigAssociationId = self.resolverQueryLogConfigAssociationId {
            try encodeContainer.encode(resolverQueryLogConfigAssociationId, forKey: .resolverQueryLogConfigAssociationId)
        }
    }
}

extension GetResolverQueryLogConfigAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverQueryLogConfigAssociationInput: Swift.Equatable {
    /// The ID of the Resolver query logging configuration association that you want to get information about.
    /// This member is required.
    public var resolverQueryLogConfigAssociationId: Swift.String?

    public init(
        resolverQueryLogConfigAssociationId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationId
    }
}

struct GetResolverQueryLogConfigAssociationInputBody: Swift.Equatable {
    let resolverQueryLogConfigAssociationId: Swift.String?
}

extension GetResolverQueryLogConfigAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociationId = "ResolverQueryLogConfigAssociationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigAssociationId)
        resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationIdDecoded
    }
}

extension GetResolverQueryLogConfigAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverQueryLogConfigAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct GetResolverQueryLogConfigAssociationOutput: Swift.Equatable {
    /// Information about the Resolver query logging configuration association that you specified in a GetQueryLogConfigAssociation request.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init(
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct GetResolverQueryLogConfigAssociationOutputBody: Swift.Equatable {
    let resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?
}

extension GetResolverQueryLogConfigAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

enum GetResolverQueryLogConfigAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = self.resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
    }
}

extension GetResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the Resolver query logging configuration that you want to get information about.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?

    public init(
        resolverQueryLogConfigId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

struct GetResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
}

extension GetResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
    }
}

extension GetResolverQueryLogConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverQueryLogConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct GetResolverQueryLogConfigOutput: Swift.Equatable {
    /// Information about the Resolver query logging configuration that you specified in a GetQueryLogConfig request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init(
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct GetResolverQueryLogConfigOutputBody: Swift.Equatable {
    let resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?
}

extension GetResolverQueryLogConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

enum GetResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverQueryLogConfigPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetResolverQueryLogConfigPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverQueryLogConfigPolicyInput: Swift.Equatable {
    /// The ARN of the query logging configuration that you want to get the query logging policy for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResolverQueryLogConfigPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetResolverQueryLogConfigPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetResolverQueryLogConfigPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverQueryLogConfigPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigPolicy = output.resolverQueryLogConfigPolicy
        } else {
            self.resolverQueryLogConfigPolicy = nil
        }
    }
}

public struct GetResolverQueryLogConfigPolicyOutput: Swift.Equatable {
    /// Information about the query logging policy for the query logging configuration that you specified in a GetResolverQueryLogConfigPolicy request.
    public var resolverQueryLogConfigPolicy: Swift.String?

    public init(
        resolverQueryLogConfigPolicy: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

struct GetResolverQueryLogConfigPolicyOutputBody: Swift.Equatable {
    let resolverQueryLogConfigPolicy: Swift.String?
}

extension GetResolverQueryLogConfigPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigPolicy)
        resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicyDecoded
    }
}

enum GetResolverQueryLogConfigPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownResourceException": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverRuleAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociationId = "ResolverRuleAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleAssociationId = self.resolverRuleAssociationId {
            try encodeContainer.encode(resolverRuleAssociationId, forKey: .resolverRuleAssociationId)
        }
    }
}

extension GetResolverRuleAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverRuleAssociationInput: Swift.Equatable {
    /// The ID of the Resolver rule association that you want to get information about.
    /// This member is required.
    public var resolverRuleAssociationId: Swift.String?

    public init(
        resolverRuleAssociationId: Swift.String? = nil
    )
    {
        self.resolverRuleAssociationId = resolverRuleAssociationId
    }
}

struct GetResolverRuleAssociationInputBody: Swift.Equatable {
    let resolverRuleAssociationId: Swift.String?
}

extension GetResolverRuleAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociationId = "ResolverRuleAssociationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleAssociationId)
        resolverRuleAssociationId = resolverRuleAssociationIdDecoded
    }
}

extension GetResolverRuleAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverRuleAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct GetResolverRuleAssociationOutput: Swift.Equatable {
    /// Information about the Resolver rule association that you specified in a GetResolverRuleAssociation request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init(
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct GetResolverRuleAssociationOutputBody: Swift.Equatable {
    let resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?
}

extension GetResolverRuleAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

enum GetResolverRuleAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = self.resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

extension GetResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverRuleInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to get information about.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init(
        resolverRuleId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

struct GetResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
}

extension GetResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension GetResolverRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct GetResolverRuleOutput: Swift.Equatable {
    /// Information about the Resolver rule that you specified in a GetResolverRule request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct GetResolverRuleOutputBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension GetResolverRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

enum GetResolverRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResolverRulePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetResolverRulePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverRulePolicyInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to get the Resolver rule policy for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResolverRulePolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetResolverRulePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetResolverRulePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResolverRulePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRulePolicy = output.resolverRulePolicy
        } else {
            self.resolverRulePolicy = nil
        }
    }
}

public struct GetResolverRulePolicyOutput: Swift.Equatable {
    /// The Resolver rule policy for the rule that you specified in a GetResolverRulePolicy request.
    public var resolverRulePolicy: Swift.String?

    public init(
        resolverRulePolicy: Swift.String? = nil
    )
    {
        self.resolverRulePolicy = resolverRulePolicy
    }
}

struct GetResolverRulePolicyOutputBody: Swift.Equatable {
    let resolverRulePolicy: Swift.String?
}

extension GetResolverRulePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRulePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRulePolicy)
        resolverRulePolicy = resolverRulePolicyDecoded
    }
}

enum GetResolverRulePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownResourceException": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportFirewallDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainFileUrl = "DomainFileUrl"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainFileUrl = self.domainFileUrl {
            try encodeContainer.encode(domainFileUrl, forKey: .domainFileUrl)
        }
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
    }
}

extension ImportFirewallDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportFirewallDomainsInput: Swift.Equatable {
    /// The fully qualified URL or URI of the file stored in Amazon Simple Storage Service (Amazon S3) that contains the list of domains to import. The file must be in an S3 bucket that's in the same Region as your DNS Firewall. The file must be a text file and must contain a single domain per line.
    /// This member is required.
    public var domainFileUrl: Swift.String?
    /// The ID of the domain list that you want to modify with the import operation.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// What you want DNS Firewall to do with the domains that are listed in the file. This must be set to REPLACE, which updates the domain list to exactly match the list in the file.
    /// This member is required.
    public var operation: Route53ResolverClientTypes.FirewallDomainImportOperation?

    public init(
        domainFileUrl: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Route53ResolverClientTypes.FirewallDomainImportOperation? = nil
    )
    {
        self.domainFileUrl = domainFileUrl
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

struct ImportFirewallDomainsInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
    let operation: Route53ResolverClientTypes.FirewallDomainImportOperation?
    let domainFileUrl: Swift.String?
}

extension ImportFirewallDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainFileUrl = "DomainFileUrl"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainImportOperation.self, forKey: .operation)
        operation = operationDecoded
        let domainFileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainFileUrl)
        domainFileUrl = domainFileUrlDecoded
    }
}

extension ImportFirewallDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportFirewallDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct ImportFirewallDomainsOutput: Swift.Equatable {
    /// The Id of the firewall domain list that DNS Firewall just updated.
    public var id: Swift.String?
    /// The name of the domain list.
    public var name: Swift.String?
    /// Status of the import request.
    public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
    /// Additional information about the status of the list, if available.
    public var statusMessage: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct ImportFirewallDomainsOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let status: Route53ResolverClientTypes.FirewallDomainListStatus?
    let statusMessage: Swift.String?
}

extension ImportFirewallDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

enum ImportFirewallDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServiceErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We encountered an unknown error. Try again in a few minutes.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value that you specified for NextToken in a List request isn't valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldName = output.fieldName
            self.properties.message = output.message
        } else {
            self.properties.fieldName = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters in this request are not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// For an InvalidParameterException error, the name of the parameter that's invalid.
        public internal(set) var fieldName: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldName: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldName = fieldName
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let fieldName: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName = "FieldName"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
    }
}

extension InvalidPolicyDocument {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPolicyDocumentBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified Resolver rule policy is invalid.
public struct InvalidPolicyDocument: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicyDocument" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPolicyDocumentBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPolicyDocumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is invalid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified tag is invalid.
public struct InvalidTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTagExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53ResolverClientTypes.IpAddressRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ip = "Ip"
        case ipv6 = "Ipv6"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = self.ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipv6 = self.ipv6 {
            try encodeContainer.encode(ipv6, forKey: .ipv6)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let ipv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6)
        ipv6 = ipv6Decoded
    }
}

extension Route53ResolverClientTypes {
    /// In a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request, the IP address that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). IpAddressRequest also includes the ID of the subnet that contains the IP address.
    public struct IpAddressRequest: Swift.Equatable {
        /// The IPv4 address that you want to use for DNS queries.
        public var ip: Swift.String?
        /// The IPv6 address that you want to use for DNS queries.
        public var ipv6: Swift.String?
        /// The ID of the subnet that contains the IP address.
        /// This member is required.
        public var subnetId: Swift.String?

        public init(
            ip: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.ip = ip
            self.ipv6 = ipv6
            self.subnetId = subnetId
        }
    }

}

extension Route53ResolverClientTypes.IpAddressResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case ip = "Ip"
        case ipId = "IpId"
        case ipv6 = "Ipv6"
        case modificationTime = "ModificationTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let ip = self.ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipId = self.ipId {
            try encodeContainer.encode(ipId, forKey: .ipId)
        }
        if let ipv6 = self.ipv6 {
            try encodeContainer.encode(ipv6, forKey: .ipv6)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipId)
        ipId = ipIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let ipv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6)
        ipv6 = ipv6Decoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.IpAddressStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html) request, information about the IP addresses that the Resolver endpoint uses for DNS queries.
    public struct IpAddressResponse: Swift.Equatable {
        /// The date and time that the IP address was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// One IPv4 address that the Resolver endpoint uses for DNS queries.
        public var ip: Swift.String?
        /// The ID of one IP address.
        public var ipId: Swift.String?
        /// One IPv6 address that the Resolver endpoint uses for DNS queries.
        public var ipv6: Swift.String?
        /// The date and time that the IP address was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// A status code that gives the current status of the request.
        public var status: Route53ResolverClientTypes.IpAddressStatus?
        /// A message that provides additional information about the status of the request.
        public var statusMessage: Swift.String?
        /// The ID of one subnet.
        public var subnetId: Swift.String?

        public init(
            creationTime: Swift.String? = nil,
            ip: Swift.String? = nil,
            ipId: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            status: Route53ResolverClientTypes.IpAddressStatus? = nil,
            statusMessage: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.ip = ip
            self.ipId = ipId
            self.ipv6 = ipv6
            self.modificationTime = modificationTime
            self.status = status
            self.statusMessage = statusMessage
            self.subnetId = subnetId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum IpAddressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attached
        case attaching
        case creating
        case deletefailedfasexpired
        case deleting
        case detaching
        case failedcreation
        case failedresourcegone
        case remapattaching
        case remapdetaching
        case updatefailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressStatus] {
            return [
                .attached,
                .attaching,
                .creating,
                .deletefailedfasexpired,
                .deleting,
                .detaching,
                .failedcreation,
                .failedresourcegone,
                .remapattaching,
                .remapdetaching,
                .updatefailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attached: return "ATTACHED"
            case .attaching: return "ATTACHING"
            case .creating: return "CREATING"
            case .deletefailedfasexpired: return "DELETE_FAILED_FAS_EXPIRED"
            case .deleting: return "DELETING"
            case .detaching: return "DETACHING"
            case .failedcreation: return "FAILED_CREATION"
            case .failedresourcegone: return "FAILED_RESOURCE_GONE"
            case .remapattaching: return "REMAP_ATTACHING"
            case .remapdetaching: return "REMAP_DETACHING"
            case .updatefailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressStatus(rawValue: rawValue) ?? IpAddressStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.IpAddressUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ip = "Ip"
        case ipId = "IpId"
        case ipv6 = "Ipv6"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = self.ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipId = self.ipId {
            try encodeContainer.encode(ipId, forKey: .ipId)
        }
        if let ipv6 = self.ipv6 {
            try encodeContainer.encode(ipv6, forKey: .ipv6)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipId)
        ipId = ipIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let ipv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6)
        ipv6 = ipv6Decoded
    }
}

extension Route53ResolverClientTypes {
    /// In an [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html) request, information about an IP address to update.
    public struct IpAddressUpdate: Swift.Equatable {
        /// The new IPv4 address.
        public var ip: Swift.String?
        /// Only when removing an IP address from a Resolver endpoint: The ID of the IP address that you want to remove. To get this ID, use [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html).
        public var ipId: Swift.String?
        /// The new IPv6 address.
        public var ipv6: Swift.String?
        /// The ID of the subnet that includes the IP address that you want to update. To get this ID, use [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html).
        public var subnetId: Swift.String?

        public init(
            ip: Swift.String? = nil,
            ipId: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.ip = ip
            self.ipId = ipId
            self.ipv6 = ipv6
            self.subnetId = subnetId
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request caused one or more limits to be exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a LimitExceededException error, the type of resource that exceeded the current limit.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListFirewallConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallConfigsInput: Swift.Equatable {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFirewallConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallConfigs = output.firewallConfigs
            self.nextToken = output.nextToken
        } else {
            self.firewallConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallConfigsOutput: Swift.Equatable {
    /// The configurations for the firewall behavior provided by DNS Firewall for VPCs from Amazon Virtual Private Cloud (Amazon VPC).
    public var firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallConfigs = firewallConfigs
        self.nextToken = nextToken
    }
}

struct ListFirewallConfigsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]?
}

extension ListFirewallConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallConfigs = "FirewallConfigs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallConfig?].self, forKey: .firewallConfigs)
        var firewallConfigsDecoded0:[Route53ResolverClientTypes.FirewallConfig]? = nil
        if let firewallConfigsContainer = firewallConfigsContainer {
            firewallConfigsDecoded0 = [Route53ResolverClientTypes.FirewallConfig]()
            for structure0 in firewallConfigsContainer {
                if let structure0 = structure0 {
                    firewallConfigsDecoded0?.append(structure0)
                }
            }
        }
        firewallConfigs = firewallConfigsDecoded0
    }
}

enum ListFirewallConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFirewallDomainListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallDomainListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallDomainListsInput: Swift.Equatable {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainListsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallDomainListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallDomainListsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFirewallDomainListsOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainLists = output.firewallDomainLists
            self.nextToken = output.nextToken
        } else {
            self.firewallDomainLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallDomainListsOutput: Swift.Equatable {
    /// A list of the domain lists that you have defined. This might be a partial list of the domain lists that you've defined. For information, see MaxResults.
    public var firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallDomainLists = firewallDomainLists
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainListsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]?
}

extension ListFirewallDomainListsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainLists = "FirewallDomainLists"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallDomainListsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallDomainListMetadata?].self, forKey: .firewallDomainLists)
        var firewallDomainListsDecoded0:[Route53ResolverClientTypes.FirewallDomainListMetadata]? = nil
        if let firewallDomainListsContainer = firewallDomainListsContainer {
            firewallDomainListsDecoded0 = [Route53ResolverClientTypes.FirewallDomainListMetadata]()
            for structure0 in firewallDomainListsContainer {
                if let structure0 = structure0 {
                    firewallDomainListsDecoded0?.append(structure0)
                }
            }
        }
        firewallDomainLists = firewallDomainListsDecoded0
    }
}

enum ListFirewallDomainListsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFirewallDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallDomainsInput: Swift.Equatable {
    /// The ID of the domain list whose domains you want to retrieve.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainsInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFirewallDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallDomainsOutput: Swift.Equatable {
    /// A list of the domains in the firewall domain list. This might be a partial list of the domains that you've defined in the domain list. For information, see MaxResults.
    public var domains: [Swift.String]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        domains: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let domains: [Swift.String]?
}

extension ListFirewallDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

enum ListFirewallDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFirewallRuleGroupAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
        case status = "Status"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension ListFirewallRuleGroupAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallRuleGroupAssociationsInput: Swift.Equatable {
    /// The unique identifier of the firewall rule group that you want to retrieve the associations for. Leave this blank to retrieve associations for any rule group.
    public var firewallRuleGroupId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting.
    public var priority: Swift.Int?
    /// The association Status setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.
    public var status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
    /// The unique identifier of the VPC that you want to retrieve the associations for. Leave this blank to retrieve associations for any VPC.
    public var vpcId: Swift.String?

    public init(
        firewallRuleGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        priority: Swift.Int? = nil,
        status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
        self.status = status
        self.vpcId = vpcId
    }
}

struct ListFirewallRuleGroupAssociationsInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let vpcId: Swift.String?
    let priority: Swift.Int?
    let status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallRuleGroupAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
        case status = "Status"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRuleGroupAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFirewallRuleGroupAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociations = output.firewallRuleGroupAssociations
            self.nextToken = output.nextToken
        } else {
            self.firewallRuleGroupAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRuleGroupAssociationsOutput: Swift.Equatable {
    /// A list of your firewall rule group associations. This might be a partial list of the associations that you have defined. For information, see MaxResults.
    public var firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociations = firewallRuleGroupAssociations
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupAssociationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]?
}

extension ListFirewallRuleGroupAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociations = "FirewallRuleGroupAssociations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRuleGroupAssociationsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallRuleGroupAssociation?].self, forKey: .firewallRuleGroupAssociations)
        var firewallRuleGroupAssociationsDecoded0:[Route53ResolverClientTypes.FirewallRuleGroupAssociation]? = nil
        if let firewallRuleGroupAssociationsContainer = firewallRuleGroupAssociationsContainer {
            firewallRuleGroupAssociationsDecoded0 = [Route53ResolverClientTypes.FirewallRuleGroupAssociation]()
            for structure0 in firewallRuleGroupAssociationsContainer {
                if let structure0 = structure0 {
                    firewallRuleGroupAssociationsDecoded0?.append(structure0)
                }
            }
        }
        firewallRuleGroupAssociations = firewallRuleGroupAssociationsDecoded0
    }
}

enum ListFirewallRuleGroupAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFirewallRuleGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallRuleGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallRuleGroupsInput: Swift.Equatable {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallRuleGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRuleGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFirewallRuleGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroups = output.firewallRuleGroups
            self.nextToken = output.nextToken
        } else {
            self.firewallRuleGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRuleGroupsOutput: Swift.Equatable {
    /// A list of your firewall rule groups. This might be a partial list of the rule groups that you have defined. For information, see MaxResults.
    public var firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRuleGroups = firewallRuleGroups
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]?
}

extension ListFirewallRuleGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroups = "FirewallRuleGroups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRuleGroupsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallRuleGroupMetadata?].self, forKey: .firewallRuleGroups)
        var firewallRuleGroupsDecoded0:[Route53ResolverClientTypes.FirewallRuleGroupMetadata]? = nil
        if let firewallRuleGroupsContainer = firewallRuleGroupsContainer {
            firewallRuleGroupsDecoded0 = [Route53ResolverClientTypes.FirewallRuleGroupMetadata]()
            for structure0 in firewallRuleGroupsContainer {
                if let structure0 = structure0 {
                    firewallRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        firewallRuleGroups = firewallRuleGroupsDecoded0
    }
}

enum ListFirewallRuleGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFirewallRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension ListFirewallRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallRulesInput: Swift.Equatable {
    /// Optional additional filter for the rules to retrieve. The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request to go through but send an alert to the logs.
    ///
    /// * BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
    public var action: Route53ResolverClientTypes.Action?
    /// The unique identifier of the firewall rule group that you want to retrieve the rules for.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?
    /// Optional additional filter for the rules to retrieve. The setting that determines the processing order of the rules in a rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
    public var priority: Swift.Int?

    public init(
        action: Route53ResolverClientTypes.Action? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
    }
}

struct ListFirewallRulesInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let priority: Swift.Int?
    let action: Route53ResolverClientTypes.Action?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFirewallRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRules = output.firewallRules
            self.nextToken = output.nextToken
        } else {
            self.firewallRules = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRulesOutput: Swift.Equatable {
    /// A list of the rules that you have defined. This might be a partial list of the firewall rules that you've defined. For information, see MaxResults.
    public var firewallRules: [Route53ResolverClientTypes.FirewallRule]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        firewallRules: [Route53ResolverClientTypes.FirewallRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRules = firewallRules
        self.nextToken = nextToken
    }
}

struct ListFirewallRulesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallRules: [Route53ResolverClientTypes.FirewallRule]?
}

extension ListFirewallRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRules = "FirewallRules"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRulesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallRule?].self, forKey: .firewallRules)
        var firewallRulesDecoded0:[Route53ResolverClientTypes.FirewallRule]? = nil
        if let firewallRulesContainer = firewallRulesContainer {
            firewallRulesDecoded0 = [Route53ResolverClientTypes.FirewallRule]()
            for structure0 in firewallRulesContainer {
                if let structure0 = structure0 {
                    firewallRulesDecoded0?.append(structure0)
                }
            }
        }
        firewallRules = firewallRulesDecoded0
    }
}

enum ListFirewallRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOutpostResolversInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case outpostArn = "OutpostArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
    }
}

extension ListOutpostResolversInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOutpostResolversInput: Swift.Equatable {
    /// The maximum number of Resolvers on the Outpost that you want to return in the response to a ListOutpostResolver request. If you don't specify a value for MaxResults, the request returns up to 100 Resolvers.
    public var maxResults: Swift.Int?
    /// For the first ListOutpostResolver request, omit this value.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost.
    public var outpostArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostArn = outpostArn
    }
}

struct ListOutpostResolversInputBody: Swift.Equatable {
    let outpostArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListOutpostResolversInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case outpostArn = "OutpostArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOutpostResolversOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOutpostResolversOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outpostResolvers = output.outpostResolvers
        } else {
            self.nextToken = nil
            self.outpostResolvers = nil
        }
    }
}

public struct ListOutpostResolversOutput: Swift.Equatable {
    /// If more than MaxResults Resolvers match the specified criteria, you can submit another ListOutpostResolver request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolvers on Outposts that were created by using the current Amazon Web Services account, and that match the specified filters, if any.
    public var outpostResolvers: [Route53ResolverClientTypes.OutpostResolver]?

    public init(
        nextToken: Swift.String? = nil,
        outpostResolvers: [Route53ResolverClientTypes.OutpostResolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.outpostResolvers = outpostResolvers
    }
}

struct ListOutpostResolversOutputBody: Swift.Equatable {
    let outpostResolvers: [Route53ResolverClientTypes.OutpostResolver]?
    let nextToken: Swift.String?
}

extension ListOutpostResolversOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case outpostResolvers = "OutpostResolvers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostResolversContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.OutpostResolver?].self, forKey: .outpostResolvers)
        var outpostResolversDecoded0:[Route53ResolverClientTypes.OutpostResolver]? = nil
        if let outpostResolversContainer = outpostResolversContainer {
            outpostResolversDecoded0 = [Route53ResolverClientTypes.OutpostResolver]()
            for structure0 in outpostResolversContainer {
                if let structure0 = structure0 {
                    outpostResolversDecoded0?.append(structure0)
                }
            }
        }
        outpostResolvers = outpostResolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOutpostResolversOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverConfigsInput: Swift.Equatable {
    /// The maximum number of Resolver configurations that you want to return in the response to a ListResolverConfigs request. If you don't specify a value for MaxResults, up to 100 Resolver configurations are returned.
    public var maxResults: Swift.Int?
    /// (Optional) If the current Amazon Web Services account has more than MaxResults Resolver configurations, use NextToken to get the second and subsequent pages of results. For the first ListResolverConfigs request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListResolverConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolverConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverConfigs = output.resolverConfigs
        } else {
            self.nextToken = nil
            self.resolverConfigs = nil
        }
    }
}

public struct ListResolverConfigsOutput: Swift.Equatable {
    /// If a response includes the last of the Resolver configurations that are associated with the current Amazon Web Services account, NextToken doesn't appear in the response. If a response doesn't include the last of the configurations, you can get more configurations by submitting another ListResolverConfigs request. Get the value of NextToken that Amazon Route 53 returned in the previous response and include it in NextToken in the next request.
    public var nextToken: Swift.String?
    /// An array that contains one ResolverConfigs element for each Resolver configuration that is associated with the current Amazon Web Services account.
    public var resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]?

    public init(
        nextToken: Swift.String? = nil,
        resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolverConfigs = resolverConfigs
    }
}

struct ListResolverConfigsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]?
}

extension ListResolverConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverConfigs = "ResolverConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resolverConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverConfig?].self, forKey: .resolverConfigs)
        var resolverConfigsDecoded0:[Route53ResolverClientTypes.ResolverConfig]? = nil
        if let resolverConfigsContainer = resolverConfigsContainer {
            resolverConfigsDecoded0 = [Route53ResolverClientTypes.ResolverConfig]()
            for structure0 in resolverConfigsContainer {
                if let structure0 = structure0 {
                    resolverConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverConfigs = resolverConfigsDecoded0
    }
}

enum ListResolverConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverDnssecConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverDnssecConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverDnssecConfigsInput: Swift.Equatable {
    /// An optional specification to return a subset of objects.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// Optional: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return. If you don't specify a value for MaxResults, Route 53 returns up to 100 configuration per page.
    public var maxResults: Swift.Int?
    /// (Optional) If the current Amazon Web Services account has more than MaxResults DNSSEC configurations, use NextToken to get the second and subsequent pages of results. For the first ListResolverDnssecConfigs request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverDnssecConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverDnssecConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverDnssecConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverDnssecConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverDnssecConfigs = output.resolverDnssecConfigs
        } else {
            self.nextToken = nil
            self.resolverDnssecConfigs = nil
        }
    }
}

public struct ListResolverDnssecConfigsOutput: Swift.Equatable {
    /// If a response includes the last of the DNSSEC configurations that are associated with the current Amazon Web Services account, NextToken doesn't appear in the response. If a response doesn't include the last of the configurations, you can get more configurations by submitting another [ListResolverDnssecConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListResolverDnssecConfigs.html) request. Get the value of NextToken that Amazon Route 53 returned in the previous response and include it in NextToken in the next request.
    public var nextToken: Swift.String?
    /// An array that contains one [ResolverDnssecConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResolverDnssecConfig.html) element for each configuration for DNSSEC validation that is associated with the current Amazon Web Services account.
    public var resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]?

    public init(
        nextToken: Swift.String? = nil,
        resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolverDnssecConfigs = resolverDnssecConfigs
    }
}

struct ListResolverDnssecConfigsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]?
}

extension ListResolverDnssecConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverDnssecConfigs = "ResolverDnssecConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resolverDnssecConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverDnssecConfig?].self, forKey: .resolverDnssecConfigs)
        var resolverDnssecConfigsDecoded0:[Route53ResolverClientTypes.ResolverDnssecConfig]? = nil
        if let resolverDnssecConfigsContainer = resolverDnssecConfigsContainer {
            resolverDnssecConfigsDecoded0 = [Route53ResolverClientTypes.ResolverDnssecConfig]()
            for structure0 in resolverDnssecConfigsContainer {
                if let structure0 = structure0 {
                    resolverDnssecConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverDnssecConfigs = resolverDnssecConfigsDecoded0
    }
}

enum ListResolverDnssecConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverEndpointIpAddressesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension ListResolverEndpointIpAddressesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverEndpointIpAddressesInput: Swift.Equatable {
    /// The maximum number of IP addresses that you want to return in the response to a ListResolverEndpointIpAddresses request. If you don't specify a value for MaxResults, Resolver returns up to 100 IP addresses.
    public var maxResults: Swift.Int?
    /// For the first ListResolverEndpointIpAddresses request, omit this value. If the specified Resolver endpoint has more than MaxResults IP addresses, you can submit another ListResolverEndpointIpAddresses request to get the next group of IP addresses. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The ID of the Resolver endpoint that you want to get IP addresses for.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpointId = resolverEndpointId
    }
}

struct ListResolverEndpointIpAddressesInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListResolverEndpointIpAddressesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolverEndpointIpAddressesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverEndpointIpAddressesOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipAddresses = output.ipAddresses
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.ipAddresses = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct ListResolverEndpointIpAddressesOutput: Swift.Equatable {
    /// Information about the IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints).
    public var ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]?
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If the specified endpoint has more than MaxResults IP addresses, you can submit another ListResolverEndpointIpAddresses request to get the next group of IP addresses. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipAddresses = ipAddresses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverEndpointIpAddressesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]?
}

extension ListResolverEndpointIpAddressesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddresses = "IpAddresses"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.IpAddressResponse?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Route53ResolverClientTypes.IpAddressResponse]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Route53ResolverClientTypes.IpAddressResponse]()
            for structure0 in ipAddressesContainer {
                if let structure0 = structure0 {
                    ipAddressesDecoded0?.append(structure0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
    }
}

enum ListResolverEndpointIpAddressesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverEndpointsInput: Swift.Equatable {
    /// An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints. If you submit a second or subsequent ListResolverEndpoints request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of Resolver endpoints that you want to return in the response to a ListResolverEndpoints request. If you don't specify a value for MaxResults, Resolver returns up to 100 Resolver endpoints.
    public var maxResults: Swift.Int?
    /// For the first ListResolverEndpoints request, omit this value. If you have more than MaxResults Resolver endpoints, you can submit another ListResolverEndpoints request to get the next group of Resolver endpoints. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverEndpointsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverEndpoints = output.resolverEndpoints
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverEndpoints = nil
        }
    }
}

public struct ListResolverEndpointsOutput: Swift.Equatable {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults IP addresses match the specified criteria, you can submit another ListResolverEndpoint request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolver endpoints that were created by using the current Amazon Web Services account, and that match the specified filters, if any.
    public var resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpoints = resolverEndpoints
    }
}

struct ListResolverEndpointsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]?
}

extension ListResolverEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpoints = "ResolverEndpoints"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverEndpointsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverEndpoint?].self, forKey: .resolverEndpoints)
        var resolverEndpointsDecoded0:[Route53ResolverClientTypes.ResolverEndpoint]? = nil
        if let resolverEndpointsContainer = resolverEndpointsContainer {
            resolverEndpointsDecoded0 = [Route53ResolverClientTypes.ResolverEndpoint]()
            for structure0 in resolverEndpointsContainer {
                if let structure0 = structure0 {
                    resolverEndpointsDecoded0?.append(structure0)
                }
            }
        }
        resolverEndpoints = resolverEndpointsDecoded0
    }
}

enum ListResolverEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverQueryLogConfigAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListResolverQueryLogConfigAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverQueryLogConfigAssociationsInput: Swift.Equatable {
    /// An optional specification to return a subset of query logging associations. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of query logging associations that you want to return in the response to a ListResolverQueryLogConfigAssociations request. If you don't specify a value for MaxResults, Resolver returns up to 100 query logging associations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverQueryLogConfigAssociations request, omit this value. If there are more than MaxResults query logging associations that match the values that you specify for Filters, you can submit another ListResolverQueryLogConfigAssociations request to get the next group of associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The element that you want Resolver to sort query logging associations by. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same value for SortBy, if any, as in the previous request. Valid values include the following elements:
    ///
    /// * CreationTime: The ID of the query logging association.
    ///
    /// * Error: If the value of Status is FAILED, the value of Error indicates the cause:
    ///
    /// * DESTINATION_NOT_FOUND: The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * ACCESS_DENIED: Permissions don't allow sending logs to the destination.
    ///
    ///
    /// If Status is a value other than FAILED, ERROR is null.
    ///
    /// * Id: The ID of the query logging association
    ///
    /// * ResolverQueryLogConfigId: The ID of the query logging configuration
    ///
    /// * ResourceId: The ID of the VPC that is associated with the query logging configuration
    ///
    /// * Status: The current status of the configuration. Valid values include the following:
    ///
    /// * CREATING: Resolver is creating an association between an Amazon VPC and a query logging configuration.
    ///
    /// * CREATED: The association between an Amazon VPC and a query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
    ///
    /// * DELETING: Resolver is deleting this query logging association.
    ///
    /// * FAILED: Resolver either couldn't create or couldn't delete the query logging association. Here are two common causes:
    ///
    /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * Permissions don't allow sending logs to the destination.
    public var sortBy: Swift.String?
    /// If you specified a value for SortBy, the order that you want query logging associations to be listed in, ASCENDING or DESCENDING. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same value for SortOrder, if any, as in the previous request.
    public var sortOrder: Route53ResolverClientTypes.SortOrder?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: Route53ResolverClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListResolverQueryLogConfigAssociationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
    let sortBy: Swift.String?
    let sortOrder: Route53ResolverClientTypes.SortOrder?
}

extension ListResolverQueryLogConfigAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListResolverQueryLogConfigAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverQueryLogConfigAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverQueryLogConfigAssociations = output.resolverQueryLogConfigAssociations
            self.totalCount = output.totalCount
            self.totalFilteredCount = output.totalFilteredCount
        } else {
            self.nextToken = nil
            self.resolverQueryLogConfigAssociations = nil
            self.totalCount = 0
            self.totalFilteredCount = 0
        }
    }
}

public struct ListResolverQueryLogConfigAssociationsOutput: Swift.Equatable {
    /// If there are more than MaxResults query logging associations, you can submit another ListResolverQueryLogConfigAssociations request to get the next group of associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// A list that contains one ResolverQueryLogConfigAssociations element for each query logging association that matches the values that you specified for Filter.
    public var resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]?
    /// The total number of query logging associations that were created by the current account in the specified Region. This count can differ from the number of associations that are returned in a ListResolverQueryLogConfigAssociations response, depending on the values that you specify in the request.
    public var totalCount: Swift.Int
    /// The total number of query logging associations that were created by the current account in the specified Region and that match the filters that were specified in the ListResolverQueryLogConfigAssociations request. For the total number of associations that were created by the current account in the specified Region, see TotalCount.
    public var totalFilteredCount: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]? = nil,
        totalCount: Swift.Int = 0,
        totalFilteredCount: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigAssociations = resolverQueryLogConfigAssociations
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

struct ListResolverQueryLogConfigAssociationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let totalCount: Swift.Int
    let totalFilteredCount: Swift.Int
    let resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]?
}

extension ListResolverQueryLogConfigAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverQueryLogConfigAssociations = "ResolverQueryLogConfigAssociations"
        case totalCount = "TotalCount"
        case totalFilteredCount = "TotalFilteredCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount) ?? 0
        totalCount = totalCountDecoded
        let totalFilteredCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalFilteredCount) ?? 0
        totalFilteredCount = totalFilteredCountDecoded
        let resolverQueryLogConfigAssociationsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?].self, forKey: .resolverQueryLogConfigAssociations)
        var resolverQueryLogConfigAssociationsDecoded0:[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]? = nil
        if let resolverQueryLogConfigAssociationsContainer = resolverQueryLogConfigAssociationsContainer {
            resolverQueryLogConfigAssociationsDecoded0 = [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]()
            for structure0 in resolverQueryLogConfigAssociationsContainer {
                if let structure0 = structure0 {
                    resolverQueryLogConfigAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resolverQueryLogConfigAssociations = resolverQueryLogConfigAssociationsDecoded0
    }
}

enum ListResolverQueryLogConfigAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverQueryLogConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListResolverQueryLogConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverQueryLogConfigsInput: Swift.Equatable {
    /// An optional specification to return a subset of query logging configurations. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of query logging configurations that you want to return in the response to a ListResolverQueryLogConfigs request. If you don't specify a value for MaxResults, Resolver returns up to 100 query logging configurations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverQueryLogConfigs request, omit this value. If there are more than MaxResults query logging configurations that match the values that you specify for Filters, you can submit another ListResolverQueryLogConfigs request to get the next group of configurations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The element that you want Resolver to sort query logging configurations by. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same value for SortBy, if any, as in the previous request. Valid values include the following elements:
    ///
    /// * Arn: The ARN of the query logging configuration
    ///
    /// * AssociationCount: The number of VPCs that are associated with the specified configuration
    ///
    /// * CreationTime: The date and time that Resolver returned when the configuration was created
    ///
    /// * CreatorRequestId: The value that was specified for CreatorRequestId when the configuration was created
    ///
    /// * DestinationArn: The location that logs are sent to
    ///
    /// * Id: The ID of the configuration
    ///
    /// * Name: The name of the configuration
    ///
    /// * OwnerId: The Amazon Web Services account number of the account that created the configuration
    ///
    /// * ShareStatus: Whether the configuration is shared with other Amazon Web Services accounts or shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
    ///
    /// * Status: The current status of the configuration. Valid values include the following:
    ///
    /// * CREATING: Resolver is creating the query logging configuration.
    ///
    /// * CREATED: The query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
    ///
    /// * DELETING: Resolver is deleting this query logging configuration.
    ///
    /// * FAILED: Resolver either couldn't create or couldn't delete the query logging configuration. Here are two common causes:
    ///
    /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * Permissions don't allow sending logs to the destination.
    public var sortBy: Swift.String?
    /// If you specified a value for SortBy, the order that you want query logging configurations to be listed in, ASCENDING or DESCENDING. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same value for SortOrder, if any, as in the previous request.
    public var sortOrder: Route53ResolverClientTypes.SortOrder?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: Route53ResolverClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListResolverQueryLogConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
    let sortBy: Swift.String?
    let sortOrder: Route53ResolverClientTypes.SortOrder?
}

extension ListResolverQueryLogConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListResolverQueryLogConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverQueryLogConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverQueryLogConfigs = output.resolverQueryLogConfigs
            self.totalCount = output.totalCount
            self.totalFilteredCount = output.totalFilteredCount
        } else {
            self.nextToken = nil
            self.resolverQueryLogConfigs = nil
            self.totalCount = 0
            self.totalFilteredCount = 0
        }
    }
}

public struct ListResolverQueryLogConfigsOutput: Swift.Equatable {
    /// If there are more than MaxResults query logging configurations, you can submit another ListResolverQueryLogConfigs request to get the next group of configurations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// A list that contains one ResolverQueryLogConfig element for each query logging configuration that matches the values that you specified for Filter.
    public var resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]?
    /// The total number of query logging configurations that were created by the current account in the specified Region. This count can differ from the number of query logging configurations that are returned in a ListResolverQueryLogConfigs response, depending on the values that you specify in the request.
    public var totalCount: Swift.Int
    /// The total number of query logging configurations that were created by the current account in the specified Region and that match the filters that were specified in the ListResolverQueryLogConfigs request. For the total number of query logging configurations that were created by the current account in the specified Region, see TotalCount.
    public var totalFilteredCount: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]? = nil,
        totalCount: Swift.Int = 0,
        totalFilteredCount: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigs = resolverQueryLogConfigs
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

struct ListResolverQueryLogConfigsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let totalCount: Swift.Int
    let totalFilteredCount: Swift.Int
    let resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]?
}

extension ListResolverQueryLogConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverQueryLogConfigs = "ResolverQueryLogConfigs"
        case totalCount = "TotalCount"
        case totalFilteredCount = "TotalFilteredCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount) ?? 0
        totalCount = totalCountDecoded
        let totalFilteredCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalFilteredCount) ?? 0
        totalFilteredCount = totalFilteredCountDecoded
        let resolverQueryLogConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverQueryLogConfig?].self, forKey: .resolverQueryLogConfigs)
        var resolverQueryLogConfigsDecoded0:[Route53ResolverClientTypes.ResolverQueryLogConfig]? = nil
        if let resolverQueryLogConfigsContainer = resolverQueryLogConfigsContainer {
            resolverQueryLogConfigsDecoded0 = [Route53ResolverClientTypes.ResolverQueryLogConfig]()
            for structure0 in resolverQueryLogConfigsContainer {
                if let structure0 = structure0 {
                    resolverQueryLogConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverQueryLogConfigs = resolverQueryLogConfigsDecoded0
    }
}

enum ListResolverQueryLogConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverRuleAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverRuleAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverRuleAssociationsInput: Swift.Equatable {
    /// An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID. If you submit a second or subsequent ListResolverRuleAssociations request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of rule associations that you want to return in the response to a ListResolverRuleAssociations request. If you don't specify a value for MaxResults, Resolver returns up to 100 rule associations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverRuleAssociation request, omit this value. If you have more than MaxResults rule associations, you can submit another ListResolverRuleAssociation request to get the next group of rule associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverRuleAssociationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverRuleAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverRuleAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverRuleAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverRuleAssociations = output.resolverRuleAssociations
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverRuleAssociations = nil
        }
    }
}

public struct ListResolverRuleAssociationsOutput: Swift.Equatable {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults rule associations match the specified criteria, you can submit another ListResolverRuleAssociation request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The associations that were created between Resolver rules and VPCs using the current Amazon Web Services account, and that match the specified filters, if any.
    public var resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRuleAssociations = resolverRuleAssociations
    }
}

struct ListResolverRuleAssociationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]?
}

extension ListResolverRuleAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverRuleAssociations = "ResolverRuleAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverRuleAssociationsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverRuleAssociation?].self, forKey: .resolverRuleAssociations)
        var resolverRuleAssociationsDecoded0:[Route53ResolverClientTypes.ResolverRuleAssociation]? = nil
        if let resolverRuleAssociationsContainer = resolverRuleAssociationsContainer {
            resolverRuleAssociationsDecoded0 = [Route53ResolverClientTypes.ResolverRuleAssociation]()
            for structure0 in resolverRuleAssociationsContainer {
                if let structure0 = structure0 {
                    resolverRuleAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resolverRuleAssociations = resolverRuleAssociationsDecoded0
    }
}

enum ListResolverRuleAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResolverRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverRulesInput: Swift.Equatable {
    /// An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint. If you submit a second or subsequent ListResolverRules request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of Resolver rules that you want to return in the response to a ListResolverRules request. If you don't specify a value for MaxResults, Resolver returns up to 100 Resolver rules.
    public var maxResults: Swift.Int?
    /// For the first ListResolverRules request, omit this value. If you have more than MaxResults Resolver rules, you can submit another ListResolverRules request to get the next group of Resolver rules. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init(
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverRulesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResolverRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverRules = output.resolverRules
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverRules = nil
        }
    }
}

public struct ListResolverRulesOutput: Swift.Equatable {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults Resolver rules match the specified criteria, you can submit another ListResolverRules request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolver rules that were created using the current Amazon Web Services account and that match the specified filters, if any.
    public var resolverRules: [Route53ResolverClientTypes.ResolverRule]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverRules: [Route53ResolverClientTypes.ResolverRule]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRules = resolverRules
    }
}

struct ListResolverRulesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resolverRules: [Route53ResolverClientTypes.ResolverRule]?
}

extension ListResolverRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverRules = "ResolverRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverRulesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverRule?].self, forKey: .resolverRules)
        var resolverRulesDecoded0:[Route53ResolverClientTypes.ResolverRule]? = nil
        if let resolverRulesContainer = resolverRulesContainer {
            resolverRulesDecoded0 = [Route53ResolverClientTypes.ResolverRule]()
            for structure0 in resolverRulesContainer {
                if let structure0 = structure0 {
                    resolverRulesDecoded0?.append(structure0)
                }
            }
        }
        resolverRules = resolverRulesDecoded0
    }
}

enum ListResolverRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags that you want to return in the response to a ListTagsForResource request. If you don't specify a value for MaxResults, Resolver returns up to 100 tags.
    public var maxResults: Swift.Int?
    /// For the first ListTagsForResource request, omit this value. If you have more than MaxResults tags, you can submit another ListTagsForResource request to get the next group of tags for the resource. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the resource that you want to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// If more than MaxResults tags match the specified criteria, you can submit another ListTagsForResource request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The tags that are associated with the resource that you specified in the ListTagsForResource request.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Route53ResolverClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum MutationProtectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MutationProtectionStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MutationProtectionStatus(rawValue: rawValue) ?? MutationProtectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.OutpostResolver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case preferredInstanceType = "PreferredInstanceType"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let preferredInstanceType = self.preferredInstanceType {
            try encodeContainer.encode(preferredInstanceType, forKey: .preferredInstanceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let preferredInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredInstanceType)
        preferredInstanceType = preferredInstanceTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.OutpostResolverStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains settings for an existing Resolver on an Outpost.
    public struct OutpostResolver: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the Resolver on an Outpost.
        public var arn: Swift.String?
        /// The date and time that the Outpost Resolver was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the Resolver endpoint. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// The ID of the Resolver on Outpost.
        public var id: Swift.String?
        /// Amazon EC2 instance count for the Resolver on the Outpost.
        public var instanceCount: Swift.Int?
        /// The date and time that the Outpost Resolver was modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// Name of the Resolver.
        public var name: Swift.String?
        /// The ARN (Amazon Resource Name) for the Outpost.
        public var outpostArn: Swift.String?
        /// The Amazon EC2 instance type.
        public var preferredInstanceType: Swift.String?
        /// Status of the Resolver.
        public var status: Route53ResolverClientTypes.OutpostResolverStatus?
        /// A detailed description of the Resolver.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            outpostArn: Swift.String? = nil,
            preferredInstanceType: Swift.String? = nil,
            status: Route53ResolverClientTypes.OutpostResolverStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.instanceCount = instanceCount
            self.modificationTime = modificationTime
            self.name = name
            self.outpostArn = outpostArn
            self.preferredInstanceType = preferredInstanceType
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension Route53ResolverClientTypes {
    public enum OutpostResolverStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionNeeded
        case creating
        case deleting
        case failedCreation
        case failedDeletion
        case operational
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [OutpostResolverStatus] {
            return [
                .actionNeeded,
                .creating,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .operational,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionNeeded: return "ACTION_NEEDED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .operational: return "OPERATIONAL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutpostResolverStatus(rawValue: rawValue) ?? OutpostResolverStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutFirewallRuleGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let firewallRuleGroupPolicy = self.firewallRuleGroupPolicy {
            try encodeContainer.encode(firewallRuleGroupPolicy, forKey: .firewallRuleGroupPolicy)
        }
    }
}

extension PutFirewallRuleGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutFirewallRuleGroupPolicyInput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) for the rule group that you want to share.
    /// This member is required.
    public var arn: Swift.String?
    /// The Identity and Access Management (Amazon Web Services IAM) policy to attach to the rule group.
    /// This member is required.
    public var firewallRuleGroupPolicy: Swift.String?

    public init(
        arn: Swift.String? = nil,
        firewallRuleGroupPolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

struct PutFirewallRuleGroupPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
    let firewallRuleGroupPolicy: Swift.String?
}

extension PutFirewallRuleGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let firewallRuleGroupPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupPolicy)
        firewallRuleGroupPolicy = firewallRuleGroupPolicyDecoded
    }
}

extension PutFirewallRuleGroupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFirewallRuleGroupPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

public struct PutFirewallRuleGroupPolicyOutput: Swift.Equatable {
    ///
    public var returnValue: Swift.Bool

    public init(
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutFirewallRuleGroupPolicyOutputBody: Swift.Equatable {
    let returnValue: Swift.Bool
}

extension PutFirewallRuleGroupPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue = "ReturnValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue) ?? false
        returnValue = returnValueDecoded
    }
}

enum PutFirewallRuleGroupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutResolverQueryLogConfigPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let resolverQueryLogConfigPolicy = self.resolverQueryLogConfigPolicy {
            try encodeContainer.encode(resolverQueryLogConfigPolicy, forKey: .resolverQueryLogConfigPolicy)
        }
    }
}

extension PutResolverQueryLogConfigPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResolverQueryLogConfigPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the account that you want to share rules with.
    /// This member is required.
    public var arn: Swift.String?
    /// An Identity and Access Management policy statement that lists the query logging configurations that you want to share with another Amazon Web Services account and the operations that you want the account to be able to perform. You can specify the following operations in the Actions section of the statement:
    ///
    /// * route53resolver:AssociateResolverQueryLogConfig
    ///
    /// * route53resolver:DisassociateResolverQueryLogConfig
    ///
    /// * route53resolver:ListResolverQueryLogConfigs
    ///
    ///
    /// In the Resource section of the statement, you specify the ARNs for the query logging configurations that you want to share with the account that you specified in Arn.
    /// This member is required.
    public var resolverQueryLogConfigPolicy: Swift.String?

    public init(
        arn: Swift.String? = nil,
        resolverQueryLogConfigPolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

struct PutResolverQueryLogConfigPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
    let resolverQueryLogConfigPolicy: Swift.String?
}

extension PutResolverQueryLogConfigPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resolverQueryLogConfigPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigPolicy)
        resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicyDecoded
    }
}

extension PutResolverQueryLogConfigPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResolverQueryLogConfigPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

/// The response to a PutResolverQueryLogConfigPolicy request.
public struct PutResolverQueryLogConfigPolicyOutput: Swift.Equatable {
    /// Whether the PutResolverQueryLogConfigPolicy request was successful.
    public var returnValue: Swift.Bool

    public init(
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutResolverQueryLogConfigPolicyOutputBody: Swift.Equatable {
    let returnValue: Swift.Bool
}

extension PutResolverQueryLogConfigPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue = "ReturnValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue) ?? false
        returnValue = returnValueDecoded
    }
}

enum PutResolverQueryLogConfigPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPolicyDocument": return try await InvalidPolicyDocument(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownResourceException": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutResolverRulePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let resolverRulePolicy = self.resolverRulePolicy {
            try encodeContainer.encode(resolverRulePolicy, forKey: .resolverRulePolicy)
        }
    }
}

extension PutResolverRulePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResolverRulePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the rule that you want to share with another account.
    /// This member is required.
    public var arn: Swift.String?
    /// An Identity and Access Management policy statement that lists the rules that you want to share with another Amazon Web Services account and the operations that you want the account to be able to perform. You can specify the following operations in the Action section of the statement:
    ///
    /// * route53resolver:GetResolverRule
    ///
    /// * route53resolver:AssociateResolverRule
    ///
    /// * route53resolver:DisassociateResolverRule
    ///
    /// * route53resolver:ListResolverRules
    ///
    /// * route53resolver:ListResolverRuleAssociations
    ///
    ///
    /// In the Resource section of the statement, specify the ARN for the rule that you want to share with another account. Specify the same ARN that you specified in Arn.
    /// This member is required.
    public var resolverRulePolicy: Swift.String?

    public init(
        arn: Swift.String? = nil,
        resolverRulePolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.resolverRulePolicy = resolverRulePolicy
    }
}

struct PutResolverRulePolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
    let resolverRulePolicy: Swift.String?
}

extension PutResolverRulePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resolverRulePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRulePolicy)
        resolverRulePolicy = resolverRulePolicyDecoded
    }
}

extension PutResolverRulePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResolverRulePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

/// The response to a PutResolverRulePolicy request.
public struct PutResolverRulePolicyOutput: Swift.Equatable {
    /// Whether the PutResolverRulePolicy request was successful.
    public var returnValue: Swift.Bool

    public init(
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutResolverRulePolicyOutputBody: Swift.Equatable {
    let returnValue: Swift.Bool
}

extension PutResolverRulePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue = "ReturnValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue) ?? false
        returnValue = returnValueDecoded
    }
}

enum PutResolverRulePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPolicyDocument": return try await InvalidPolicyDocument(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownResourceException": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverAutodefinedReverseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case updatingtouselocalresourcesetting
        case uselocalresourcesetting
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverAutodefinedReverseStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .updatingtouselocalresourcesetting,
                .uselocalresourcesetting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .updatingtouselocalresourcesetting: return "UPDATING_TO_USE_LOCAL_RESOURCE_SETTING"
            case .uselocalresourcesetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverAutodefinedReverseStatus(rawValue: rawValue) ?? ResolverAutodefinedReverseStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autodefinedReverse = "AutodefinedReverse"
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autodefinedReverse = self.autodefinedReverse {
            try encodeContainer.encode(autodefinedReverse.rawValue, forKey: .autodefinedReverse)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let autodefinedReverseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverAutodefinedReverseStatus.self, forKey: .autodefinedReverse)
        autodefinedReverse = autodefinedReverseDecoded
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains information about a Resolver configuration for a VPC.
    public struct ResolverConfig: Swift.Equatable {
        /// The status of whether or not the Resolver will create autodefined rules for reverse DNS lookups. This is enabled by default. The status can be one of following:
        ///
        /// * ENABLING: Autodefined rules for reverse DNS lookups are being enabled but are not complete.
        ///
        /// * ENABLED: Autodefined rules for reverse DNS lookups are enabled.
        ///
        /// * DISABLING: Autodefined rules for reverse DNS lookups are being disabled but are not complete.
        ///
        /// * DISABLED: Autodefined rules for reverse DNS lookups are disabled.
        public var autodefinedReverse: Route53ResolverClientTypes.ResolverAutodefinedReverseStatus?
        /// ID for the Resolver configuration.
        public var id: Swift.String?
        /// The owner account ID of the Amazon Virtual Private Cloud VPC.
        public var ownerId: Swift.String?
        /// The ID of the Amazon Virtual Private Cloud VPC that you're configuring Resolver for.
        public var resourceId: Swift.String?

        public init(
            autodefinedReverse: Route53ResolverClientTypes.ResolverAutodefinedReverseStatus? = nil,
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.autodefinedReverse = autodefinedReverse
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverDNSSECValidationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case updatetouselocalresourcesetting
        case uselocalresourcesetting
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverDNSSECValidationStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .updatetouselocalresourcesetting,
                .uselocalresourcesetting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .updatetouselocalresourcesetting: return "UPDATING_TO_USE_LOCAL_RESOURCE_SETTING"
            case .uselocalresourcesetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverDNSSECValidationStatus(rawValue: rawValue) ?? ResolverDNSSECValidationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverDnssecConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
        case validationStatus = "ValidationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let validationStatus = self.validationStatus {
            try encodeContainer.encode(validationStatus.rawValue, forKey: .validationStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let validationStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverDNSSECValidationStatus.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains information about a configuration for DNSSEC validation.
    public struct ResolverDnssecConfig: Swift.Equatable {
        /// The ID for a configuration for DNSSEC validation.
        public var id: Swift.String?
        /// The owner account ID of the virtual private cloud (VPC) for a configuration for DNSSEC validation.
        public var ownerId: Swift.String?
        /// The ID of the virtual private cloud (VPC) that you're configuring the DNSSEC validation status for.
        public var resourceId: Swift.String?
        /// The validation status for a DNSSEC configuration. The status can be one of the following:
        ///
        /// * ENABLING: DNSSEC validation is being enabled but is not complete.
        ///
        /// * ENABLED: DNSSEC validation is enabled.
        ///
        /// * DISABLING: DNSSEC validation is being disabled but is not complete.
        ///
        /// * DISABLED DNSSEC validation is disabled.
        public var validationStatus: Route53ResolverClientTypes.ResolverDNSSECValidationStatus?

        public init(
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            validationStatus: Route53ResolverClientTypes.ResolverDNSSECValidationStatus? = nil
        )
        {
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
            self.validationStatus = validationStatus
        }
    }

}

extension Route53ResolverClientTypes.ResolverEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case hostVPCId = "HostVPCId"
        case id = "Id"
        case ipAddressCount = "IpAddressCount"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case preferredInstanceType = "PreferredInstanceType"
        case resolverEndpointType = "ResolverEndpointType"
        case securityGroupIds = "SecurityGroupIds"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let hostVPCId = self.hostVPCId {
            try encodeContainer.encode(hostVPCId, forKey: .hostVPCId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ipAddressCount = self.ipAddressCount {
            try encodeContainer.encode(ipAddressCount, forKey: .ipAddressCount)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let preferredInstanceType = self.preferredInstanceType {
            try encodeContainer.encode(preferredInstanceType, forKey: .preferredInstanceType)
        }
        if let resolverEndpointType = self.resolverEndpointType {
            try encodeContainer.encode(resolverEndpointType.rawValue, forKey: .resolverEndpointType)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for resourceid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(resourceid0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let directionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointDirection.self, forKey: .direction)
        direction = directionDecoded
        let ipAddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipAddressCount)
        ipAddressCount = ipAddressCountDecoded
        let hostVPCIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostVPCId)
        hostVPCId = hostVPCIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
        let resolverEndpointTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointType.self, forKey: .resolverEndpointType)
        resolverEndpointType = resolverEndpointTypeDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let preferredInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredInstanceType)
        preferredInstanceType = preferredInstanceTypeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html), [DeleteResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverEndpoint.html), [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html), Updates the name, or ResolverEndpointType for an endpoint, or [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html) request, a complex type that contains settings for an existing inbound or outbound Resolver endpoint.
    public struct ResolverEndpoint: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the Resolver endpoint.
        public var arn: Swift.String?
        /// The date and time that the endpoint was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the Resolver endpoint. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// Indicates whether the Resolver endpoint allows inbound or outbound DNS queries:
        ///
        /// * INBOUND: allows DNS queries to your VPC from your network
        ///
        /// * OUTBOUND: allows DNS queries from your VPC to your network
        public var direction: Route53ResolverClientTypes.ResolverEndpointDirection?
        /// The ID of the VPC that you want to create the Resolver endpoint in.
        public var hostVPCId: Swift.String?
        /// The ID of the Resolver endpoint.
        public var id: Swift.String?
        /// The number of IP addresses that the Resolver endpoint can use for DNS queries.
        public var ipAddressCount: Swift.Int?
        /// The date and time that the endpoint was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name that you assigned to the Resolver endpoint when you submitted a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request.
        public var name: Swift.String?
        /// The ARN (Amazon Resource Name) for the Outpost.
        public var outpostArn: Swift.String?
        /// The Amazon EC2 instance type.
        public var preferredInstanceType: Swift.String?
        /// The Resolver endpoint IP address type.
        public var resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
        /// The ID of one or more security groups that control access to this VPC. The security group must include one or more inbound rules (for inbound endpoints) or outbound rules (for outbound endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.
        public var securityGroupIds: [Swift.String]?
        /// A code that specifies the current status of the Resolver endpoint. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating and configuring one or more Amazon VPC network interfaces for this endpoint.
        ///
        /// * OPERATIONAL: The Amazon VPC network interfaces for this endpoint are correctly configured and able to pass inbound or outbound DNS queries between your network and Resolver.
        ///
        /// * UPDATING: Resolver is associating or disassociating one or more network interfaces with this endpoint.
        ///
        /// * AUTO_RECOVERING: Resolver is trying to recover one or more of the network interfaces that are associated with this endpoint. During the recovery process, the endpoint functions with limited capacity because of the limit on the number of DNS queries per IP address (per network interface). For the current limit, see [Limits on Route 53 Resolver](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html#limits-api-entities-resolver).
        ///
        /// * ACTION_NEEDED: This endpoint is unhealthy, and Resolver can't automatically recover it. To resolve the problem, we recommend that you check each IP address that you associated with the endpoint. For each IP address that isn't available, add another IP address and then delete the IP address that isn't available. (An endpoint must always include at least two IP addresses.) A status of ACTION_NEEDED can have a variety of causes. Here are two common causes:
        ///
        /// * One or more of the network interfaces that are associated with the endpoint were deleted using Amazon VPC.
        ///
        /// * The network interface couldn't be created for some reason that's outside the control of Resolver.
        ///
        ///
        ///
        ///
        /// * DELETING: Resolver is deleting this endpoint and the associated network interfaces.
        public var status: Route53ResolverClientTypes.ResolverEndpointStatus?
        /// A detailed description of the status of the Resolver endpoint.
        public var statusMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            direction: Route53ResolverClientTypes.ResolverEndpointDirection? = nil,
            hostVPCId: Swift.String? = nil,
            id: Swift.String? = nil,
            ipAddressCount: Swift.Int? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            outpostArn: Swift.String? = nil,
            preferredInstanceType: Swift.String? = nil,
            resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: Route53ResolverClientTypes.ResolverEndpointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.direction = direction
            self.hostVPCId = hostVPCId
            self.id = id
            self.ipAddressCount = ipAddressCount
            self.modificationTime = modificationTime
            self.name = name
            self.outpostArn = outpostArn
            self.preferredInstanceType = preferredInstanceType
            self.resolverEndpointType = resolverEndpointType
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverEndpointDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inbound
        case outbound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointDirection] {
            return [
                .inbound,
                .outbound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inbound: return "INBOUND"
            case .outbound: return "OUTBOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverEndpointDirection(rawValue: rawValue) ?? ResolverEndpointDirection.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionneeded
        case autorecovering
        case creating
        case deleting
        case operational
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointStatus] {
            return [
                .actionneeded,
                .autorecovering,
                .creating,
                .deleting,
                .operational,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionneeded: return "ACTION_NEEDED"
            case .autorecovering: return "AUTO_RECOVERING"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .operational: return "OPERATIONAL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverEndpointStatus(rawValue: rawValue) ?? ResolverEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dualstack
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointType] {
            return [
                .dualstack,
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dualstack: return "DUALSTACK"
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverEndpointType(rawValue: rawValue) ?? ResolverEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverQueryLogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associationCount = "AssociationCount"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case id = "Id"
        case name = "Name"
        case ownerId = "OwnerId"
        case shareStatus = "ShareStatus"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associationCount != 0 {
            try encodeContainer.encode(associationCount, forKey: .associationCount)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let shareStatus = self.shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigStatus.self, forKey: .status)
        status = statusDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let associationCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationCount) ?? 0
        associationCount = associationCountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [CreateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverQueryLogConfig.html), [DeleteResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverQueryLogConfig.html), [GetResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfig.html), or [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html) request, a complex type that contains settings for one query logging configuration.
    public struct ResolverQueryLogConfig: Swift.Equatable {
        /// The ARN for the query logging configuration.
        public var arn: Swift.String?
        /// The number of VPCs that are associated with the query logging configuration.
        public var associationCount: Swift.Int
        /// The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the query logging configuration. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// The ARN of the resource that you want Resolver to send query logs: an Amazon S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.
        public var destinationArn: Swift.String?
        /// The ID for the query logging configuration.
        public var id: Swift.String?
        /// The name of the query logging configuration.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the query logging configuration.
        public var ownerId: Swift.String?
        /// An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// The status of the specified query logging configuration. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating the query logging configuration.
        ///
        /// * CREATED: The query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
        ///
        /// * DELETING: Resolver is deleting this query logging configuration.
        ///
        /// * FAILED: Resolver can't deliver logs to the location that is specified in the query logging configuration. Here are two common causes:
        ///
        /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
        ///
        /// * Permissions don't allow sending logs to the destination.
        public var status: Route53ResolverClientTypes.ResolverQueryLogConfigStatus?

        public init(
            arn: Swift.String? = nil,
            associationCount: Swift.Int = 0,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.ResolverQueryLogConfigStatus? = nil
        )
        {
            self.arn = arn
            self.associationCount = associationCount
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.destinationArn = destinationArn
            self.id = id
            self.name = name
            self.ownerId = ownerId
            self.shareStatus = shareStatus
            self.status = status
        }
    }

}

extension Route53ResolverClientTypes.ResolverQueryLogConfigAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case error = "Error"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let error = self.error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resolverQueryLogConfigId = self.resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError.self, forKey: .error)
        error = errorDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to an [AssociateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html), [DisassociateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html), [GetResolverQueryLogConfigAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfigAssociation.html), or [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html), request, a complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.
    public struct ResolverQueryLogConfigAssociation: Swift.Equatable {
        /// The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// If the value of Status is FAILED, the value of Error indicates the cause:
        ///
        /// * DESTINATION_NOT_FOUND: The specified destination (for example, an Amazon S3 bucket) was deleted.
        ///
        /// * ACCESS_DENIED: Permissions don't allow sending logs to the destination.
        ///
        ///
        /// If the value of Status is a value other than FAILED, Error is null.
        public var error: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError?
        /// Contains additional information about the error. If the value or Error is null, the value of ErrorMessage also is null.
        public var errorMessage: Swift.String?
        /// The ID of the query logging association.
        public var id: Swift.String?
        /// The ID of the query logging configuration that a VPC is associated with.
        public var resolverQueryLogConfigId: Swift.String?
        /// The ID of the Amazon VPC that is associated with the query logging configuration.
        public var resourceId: Swift.String?
        /// The status of the specified query logging association. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating an association between an Amazon VPC and a query logging configuration.
        ///
        /// * CREATED: The association between an Amazon VPC and a query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
        ///
        /// * DELETING: Resolver is deleting this query logging association.
        ///
        /// * FAILED: Resolver either couldn't create or couldn't delete the query logging association.
        public var status: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus?

        public init(
            creationTime: Swift.String? = nil,
            error: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            resolverQueryLogConfigId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            status: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.error = error
            self.errorMessage = errorMessage
            self.id = id
            self.resolverQueryLogConfigId = resolverQueryLogConfigId
            self.resourceId = resourceId
            self.status = status
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverQueryLogConfigAssociationError: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case destinationnotfound
        case internalserviceerror
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigAssociationError] {
            return [
                .accessdenied,
                .destinationnotfound,
                .internalserviceerror,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "ACCESS_DENIED"
            case .destinationnotfound: return "DESTINATION_NOT_FOUND"
            case .internalserviceerror: return "INTERNAL_SERVICE_ERROR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverQueryLogConfigAssociationError(rawValue: rawValue) ?? ResolverQueryLogConfigAssociationError.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverQueryLogConfigAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionneeded
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigAssociationStatus] {
            return [
                .actionneeded,
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionneeded: return "ACTION_NEEDED"
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverQueryLogConfigAssociationStatus(rawValue: rawValue) ?? ResolverQueryLogConfigAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverQueryLogConfigStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigStatus] {
            return [
                .created,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverQueryLogConfigStatus(rawValue: rawValue) ?? ResolverQueryLogConfigStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case id = "Id"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case ownerId = "OwnerId"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case shareStatus = "ShareStatus"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = self.creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modificationTime = self.modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let ruleType = self.ruleType {
            try encodeContainer.encode(ruleType.rawValue, forKey: .ruleType)
        }
        if let shareStatus = self.shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetaddress0 in targetIps {
                try targetIpsContainer.encode(targetaddress0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let ruleTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.RuleTypeOption.self, forKey: .ruleType)
        ruleType = ruleTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[Route53ResolverClientTypes.TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [Route53ResolverClientTypes.TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// For queries that originate in your VPC, detailed information about a Resolver rule, which specifies how to route DNS queries out of the VPC. The ResolverRule parameter appears in the response to a [CreateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html), [DeleteResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverRule.html), [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), or [UpdateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html) request.
    public struct ResolverRule: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the Resolver rule specified by Id.
        public var arn: Swift.String?
        /// The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that you specified when you created the Resolver rule. CreatorRequestId identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// DNS queries for this domain name are forwarded to the IP addresses that are specified in TargetIps. If a query matches multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name (www.example.com).
        public var domainName: Swift.String?
        /// The ID that Resolver assigned to the Resolver rule when you created it.
        public var id: Swift.String?
        /// The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name for the Resolver rule, which you specified when you created the Resolver rule.
        public var name: Swift.String?
        /// When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.
        public var ownerId: Swift.String?
        /// The ID of the endpoint that the rule is associated with.
        public var resolverEndpointId: Swift.String?
        /// When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD. When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM. For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify FORWARD for RuleType. To then have Resolver process queries for apex.example.com, you create a rule and specify SYSTEM for RuleType. Currently, only Resolver can create rules that have a value of RECURSIVE for RuleType.
        public var ruleType: Route53ResolverClientTypes.RuleTypeOption?
        /// Whether the rule is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// A code that specifies the current status of the Resolver rule.
        public var status: Route53ResolverClientTypes.ResolverRuleStatus?
        /// A detailed description of the status of a Resolver rule.
        public var statusMessage: Swift.String?
        /// An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network.
        public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resolverEndpointId: Swift.String? = nil,
            ruleType: Route53ResolverClientTypes.RuleTypeOption? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.ResolverRuleStatus? = nil,
            statusMessage: Swift.String? = nil,
            targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.domainName = domainName
            self.id = id
            self.modificationTime = modificationTime
            self.name = name
            self.ownerId = ownerId
            self.resolverEndpointId = resolverEndpointId
            self.ruleType = ruleType
            self.shareStatus = shareStatus
            self.status = status
            self.statusMessage = statusMessage
            self.targetIps = targetIps
        }
    }

}

extension Route53ResolverClientTypes.ResolverRuleAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case vpcId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverRuleId = self.resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to an [AssociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html), [DisassociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html), or [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html) request, provides information about an association between a Resolver rule and a VPC. The association determines which DNS queries that originate in the VPC are forwarded to your network.
    public struct ResolverRuleAssociation: Swift.Equatable {
        /// The ID of the association between a Resolver rule and a VPC. Resolver assigns this value when you submit an [AssociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html) request.
        public var id: Swift.String?
        /// The name of an association between a Resolver rule and a VPC.
        public var name: Swift.String?
        /// The ID of the Resolver rule that you associated with the VPC that is specified by VPCId.
        public var resolverRuleId: Swift.String?
        /// A code that specifies the current status of the association between a Resolver rule and a VPC.
        public var status: Route53ResolverClientTypes.ResolverRuleAssociationStatus?
        /// A detailed description of the status of the association between a Resolver rule and a VPC.
        public var statusMessage: Swift.String?
        /// The ID of the VPC that you associated the Resolver rule with.
        public var vpcId: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resolverRuleId: Swift.String? = nil,
            status: Route53ResolverClientTypes.ResolverRuleAssociationStatus? = nil,
            statusMessage: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.resolverRuleId = resolverRuleId
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverRuleAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case creating
        case deleting
        case failed
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverRuleAssociationStatus] {
            return [
                .complete,
                .creating,
                .deleting,
                .failed,
                .overridden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverRuleAssociationStatus(rawValue: rawValue) ?? ResolverRuleAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverRuleConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetaddress0 in targetIps {
                try targetIpsContainer.encode(targetaddress0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[Route53ResolverClientTypes.TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [Route53ResolverClientTypes.TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In an [UpdateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html) request, information about the changes that you want to make.
    public struct ResolverRuleConfig: Swift.Equatable {
        /// The new name for the Resolver rule. The name that you specify appears in the Resolver dashboard in the Route 53 console.
        public var name: Swift.String?
        /// The ID of the new outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in TargetIps.
        public var resolverEndpointId: Swift.String?
        /// For DNS queries that originate in your VPC, the new IP addresses that you want to route outbound DNS queries to.
        public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

        public init(
            name: Swift.String? = nil,
            resolverEndpointId: Swift.String? = nil,
            targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
        )
        {
            self.name = name
            self.resolverEndpointId = resolverEndpointId
            self.targetIps = targetIps
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverRuleStatus] {
            return [
                .complete,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverRuleStatus(rawValue: rawValue) ?? ResolverRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource that you tried to create already exists.
public struct ResourceExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceExistsException error, the type of resource that the error applies to.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource that you tried to update or delete is currently in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceInUseException error, the type of resource that is currently in use.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceNotFoundException error, the type of resource that doesn't exist.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource isn't available.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// For a ResourceUnavailableException error, the type of resource that isn't available.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum RuleTypeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forward
        case recursive
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleTypeOption] {
            return [
                .forward,
                .recursive,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forward: return "FORWARD"
            case .recursive: return "RECURSIVE"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleTypeOption(rawValue: rawValue) ?? RuleTypeOption.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Fulfilling the request would cause one or more quotas to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notshared
        case sharedbyme
        case sharedwithme
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .notshared,
                .sharedbyme,
                .sharedwithme,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notshared: return "NOT_SHARED"
            case .sharedbyme: return "SHARED_BY_ME"
            case .sharedwithme: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Route53ResolverClientTypes {
    /// One tag that you want to add to the specified resource. A tag consists of a Key (a name for the tag) and a Value.
    public struct Tag: Swift.Equatable {
        /// The name for the tag. For example, if you want to associate Resolver resources with the account IDs of your customers for billing purposes, the value of Key might be account-id.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the tag. For example, if Key is account-id, then Value might be the ID of the customer account that you're creating the resource for.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource that you want to add tags to. To get the ARN for a resource, use the applicable Get or List command:
    ///
    /// * [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html)
    ///
    /// * [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html)
    ///
    /// * [GetResolverRuleAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html)
    ///
    /// * [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html)
    ///
    /// * [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html)
    ///
    /// * [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html)
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that you want to add to the specified resource.
    /// This member is required.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagException": return try await InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53ResolverClientTypes.TargetAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ip = "Ip"
        case ipv6 = "Ipv6"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = self.ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipv6 = self.ipv6 {
            try encodeContainer.encode(ipv6, forKey: .ipv6)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let ipv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6)
        ipv6 = ipv6Decoded
    }
}

extension Route53ResolverClientTypes {
    /// In a [CreateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html) request, an array of the IPs that you want to forward DNS queries to.
    public struct TargetAddress: Swift.Equatable {
        /// One IPv4 address that you want to forward DNS queries to.
        public var ip: Swift.String?
        /// One IPv6 address that you want to forward DNS queries to.
        public var ipv6: Swift.String?
        /// The port at Ip that you want to forward DNS queries to.
        public var port: Swift.Int?

        public init(
            ip: Swift.String? = nil,
            ipv6: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.ip = ip
            self.ipv6 = ipv6
            self.port = port
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was throttled. Try again in a few minutes.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource doesn't exist.
public struct UnknownResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnknownResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnknownResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource that you want to remove tags from. To get the ARN for a resource, use the applicable Get or List command:
    ///
    /// * [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html)
    ///
    /// * [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html)
    ///
    /// * [GetResolverRuleAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html)
    ///
    /// * [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html)
    ///
    /// * [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html)
    ///
    /// * [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html)
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that you want to remove to the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFirewallConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallFailOpen = self.firewallFailOpen {
            try encodeContainer.encode(firewallFailOpen.rawValue, forKey: .firewallFailOpen)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension UpdateFirewallConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallConfigInput: Swift.Equatable {
    /// Determines how Route 53 Resolver handles queries during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply.
    ///
    /// * By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall blocks queries that it is unable to evaluate properly.
    ///
    /// * If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it is unable to properly evaluate them.
    ///
    ///
    /// This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association.
    /// This member is required.
    public var firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
    /// The ID of the VPC that the configuration is for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.firewallFailOpen = firewallFailOpen
        self.resourceId = resourceId
    }
}

struct UpdateFirewallConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
}

extension UpdateFirewallConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let firewallFailOpenDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallFailOpenStatus.self, forKey: .firewallFailOpen)
        firewallFailOpen = firewallFailOpenDecoded
    }
}

extension UpdateFirewallConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFirewallConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallConfig = output.firewallConfig
        } else {
            self.firewallConfig = nil
        }
    }
}

public struct UpdateFirewallConfigOutput: Swift.Equatable {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC.
    public var firewallConfig: Route53ResolverClientTypes.FirewallConfig?

    public init(
        firewallConfig: Route53ResolverClientTypes.FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

struct UpdateFirewallConfigOutputBody: Swift.Equatable {
    let firewallConfig: Route53ResolverClientTypes.FirewallConfig?
}

extension UpdateFirewallConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallConfig = "FirewallConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallConfig.self, forKey: .firewallConfig)
        firewallConfig = firewallConfigDecoded
    }
}

enum UpdateFirewallConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFirewallDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for firewalldomainname0 in domains {
                try domainsContainer.encode(firewalldomainname0)
            }
        }
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
    }
}

extension UpdateFirewallDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallDomainsInput: Swift.Equatable {
    /// A list of domains to use in the update operation. There is a limit of 1000 domains per request. Each domain specification in your domain list must satisfy the following requirements:
    ///
    /// * It can optionally start with * (asterisk).
    ///
    /// * With the exception of the optional starting asterisk, it must only contain the following characters: A-Z, a-z, 0-9, - (hyphen).
    ///
    /// * It must be from 1-255 characters in length.
    /// This member is required.
    public var domains: [Swift.String]?
    /// The ID of the domain list whose domains you want to update.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// What you want DNS Firewall to do with the domains that you are providing:
    ///
    /// * ADD - Add the domains to the ones that are already in the domain list.
    ///
    /// * REMOVE - Search the domain list for the domains and remove them from the list.
    ///
    /// * REPLACE - Update the domain list to exactly match the list that you are providing.
    /// This member is required.
    public var operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation?

    public init(
        domains: [Swift.String]? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation? = nil
    )
    {
        self.domains = domains
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

struct UpdateFirewallDomainsInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
    let operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation?
    let domains: [Swift.String]?
}

extension UpdateFirewallDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainUpdateOperation.self, forKey: .operation)
        operation = operationDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension UpdateFirewallDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFirewallDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct UpdateFirewallDomainsOutput: Swift.Equatable {
    /// The ID of the firewall domain list that DNS Firewall just updated.
    public var id: Swift.String?
    /// The name of the domain list.
    public var name: Swift.String?
    /// Status of the UpdateFirewallDomains request.
    public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
    /// Additional information about the status of the list, if available.
    public var statusMessage: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct UpdateFirewallDomainsOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let status: Route53ResolverClientTypes.FirewallDomainListStatus?
    let statusMessage: Swift.String?
}

extension UpdateFirewallDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

enum UpdateFirewallDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFirewallRuleGroupAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = self.firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
        if let mutationProtection = self.mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateFirewallRuleGroupAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallRuleGroupAssociationInput: Swift.Equatable {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?
    /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
    public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    /// The name of the rule group association.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that you associate with the specified VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting. You must specify a unique priority for each rule group that you associate with a single VPC. To make it easier to insert rule groups later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for a rule group association after you create it.
    public var priority: Swift.Int?

    public init(
        firewallRuleGroupAssociationId: Swift.String? = nil,
        mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
    }
}

struct UpdateFirewallRuleGroupAssociationInputBody: Swift.Equatable {
    let firewallRuleGroupAssociationId: Swift.String?
    let priority: Swift.Int?
    let mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    let name: Swift.String?
}

extension UpdateFirewallRuleGroupAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFirewallRuleGroupAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFirewallRuleGroupAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct UpdateFirewallRuleGroupAssociationOutput: Swift.Equatable {
    /// The association that you just updated.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init(
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct UpdateFirewallRuleGroupAssociationOutputBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension UpdateFirewallRuleGroupAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

enum UpdateFirewallRuleGroupAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFirewallRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = self.blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = self.blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = self.blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = self.blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let firewallDomainListId = self.firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = self.firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateFirewallRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallRuleInput: Swift.Equatable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request to go through but send an alert to the logs.
    ///
    /// * BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    public var action: Route53ResolverClientTypes.Action?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
    ///
    /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
    ///
    /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
    ///
    /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
    public var blockResponse: Route53ResolverClientTypes.BlockResponse?
    /// The ID of the domain list to use in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the firewall rule group for the rule.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// The name of the rule.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group. To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for the rules in a rule group at any time.
    public var priority: Swift.Int?

    public init(
        action: Route53ResolverClientTypes.Action? = nil,
        blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
        firewallDomainListId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
    }
}

struct UpdateFirewallRuleInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let firewallDomainListId: Swift.String?
    let priority: Swift.Int?
    let action: Route53ResolverClientTypes.Action?
    let blockResponse: Route53ResolverClientTypes.BlockResponse?
    let blockOverrideDomain: Swift.String?
    let blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    let blockOverrideTtl: Swift.Int?
    let name: Swift.String?
}

extension UpdateFirewallRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFirewallRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFirewallRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct UpdateFirewallRuleOutput: Swift.Equatable {
    /// The firewall rule that you just updated.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init(
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct UpdateFirewallRuleOutputBody: Swift.Equatable {
    let firewallRule: Route53ResolverClientTypes.FirewallRule?
}

extension UpdateFirewallRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

enum UpdateFirewallRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53ResolverClientTypes.UpdateIpAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipId = "IpId"
        case ipv6 = "Ipv6"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipId = self.ipId {
            try encodeContainer.encode(ipId, forKey: .ipId)
        }
        if let ipv6 = self.ipv6 {
            try encodeContainer.encode(ipv6, forKey: .ipv6)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipId)
        ipId = ipIdDecoded
        let ipv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6)
        ipv6 = ipv6Decoded
    }
}

extension Route53ResolverClientTypes {
    /// Provides information about the IP address type in response to [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html).
    public struct UpdateIpAddress: Swift.Equatable {
        /// The ID of the IP address, specified by the ResolverEndpointId.
        /// This member is required.
        public var ipId: Swift.String?
        /// The IPv6 address that you want to use for DNS queries.
        /// This member is required.
        public var ipv6: Swift.String?

        public init(
            ipId: Swift.String? = nil,
            ipv6: Swift.String? = nil
        )
        {
            self.ipId = ipId
            self.ipv6 = ipv6
        }
    }

}

extension UpdateOutpostResolverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case preferredInstanceType = "PreferredInstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let preferredInstanceType = self.preferredInstanceType {
            try encodeContainer.encode(preferredInstanceType, forKey: .preferredInstanceType)
        }
    }
}

extension UpdateOutpostResolverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateOutpostResolverInput: Swift.Equatable {
    /// A unique string that identifies Resolver on an Outpost.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon EC2 instance count for a Resolver on the Outpost.
    public var instanceCount: Swift.Int?
    /// Name of the Resolver on the Outpost.
    public var name: Swift.String?
    /// Amazon EC2 instance type.
    public var preferredInstanceType: Swift.String?

    public init(
        id: Swift.String? = nil,
        instanceCount: Swift.Int? = nil,
        name: Swift.String? = nil,
        preferredInstanceType: Swift.String? = nil
    )
    {
        self.id = id
        self.instanceCount = instanceCount
        self.name = name
        self.preferredInstanceType = preferredInstanceType
    }
}

struct UpdateOutpostResolverInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let instanceCount: Swift.Int?
    let preferredInstanceType: Swift.String?
}

extension UpdateOutpostResolverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case preferredInstanceType = "PreferredInstanceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let preferredInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredInstanceType)
        preferredInstanceType = preferredInstanceTypeDecoded
    }
}

extension UpdateOutpostResolverOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateOutpostResolverOutputBody = try responseDecoder.decode(responseBody: data)
            self.outpostResolver = output.outpostResolver
        } else {
            self.outpostResolver = nil
        }
    }
}

public struct UpdateOutpostResolverOutput: Swift.Equatable {
    /// The response to an UpdateOutpostResolver request.
    public var outpostResolver: Route53ResolverClientTypes.OutpostResolver?

    public init(
        outpostResolver: Route53ResolverClientTypes.OutpostResolver? = nil
    )
    {
        self.outpostResolver = outpostResolver
    }
}

struct UpdateOutpostResolverOutputBody: Swift.Equatable {
    let outpostResolver: Route53ResolverClientTypes.OutpostResolver?
}

extension UpdateOutpostResolverOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpostResolver = "OutpostResolver"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostResolverDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.OutpostResolver.self, forKey: .outpostResolver)
        outpostResolver = outpostResolverDecoded
    }
}

enum UpdateOutpostResolverOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResolverConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autodefinedReverseFlag = "AutodefinedReverseFlag"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autodefinedReverseFlag = self.autodefinedReverseFlag {
            try encodeContainer.encode(autodefinedReverseFlag.rawValue, forKey: .autodefinedReverseFlag)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension UpdateResolverConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverConfigInput: Swift.Equatable {
    /// Indicates whether or not the Resolver will create autodefined rules for reverse DNS lookups. This is enabled by default. Disabling this option will also affect EC2-Classic instances using ClassicLink. For more information, see [ClassicLink](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html) in the Amazon EC2 guide. We are retiring EC2-Classic on August 15, 2022. We recommend that you migrate from EC2-Classic to a VPC. For more information, see [Migrate from EC2-Classic to a VPC](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-migrate.html) in the Amazon EC2 guide and the blog [EC2-Classic Networking is Retiring  Heres How to Prepare](http://aws.amazon.com/blogs/aws/ec2-classic-is-retiring-heres-how-to-prepare/). It can take some time for the status change to be completed.
    /// This member is required.
    public var autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag?
    /// Resource ID of the Amazon VPC that you want to update the Resolver configuration for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.autodefinedReverseFlag = autodefinedReverseFlag
        self.resourceId = resourceId
    }
}

struct UpdateResolverConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag?
}

extension UpdateResolverConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autodefinedReverseFlag = "AutodefinedReverseFlag"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let autodefinedReverseFlagDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.AutodefinedReverseFlag.self, forKey: .autodefinedReverseFlag)
        autodefinedReverseFlag = autodefinedReverseFlagDecoded
    }
}

extension UpdateResolverConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResolverConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverConfig = output.resolverConfig
        } else {
            self.resolverConfig = nil
        }
    }
}

public struct UpdateResolverConfigOutput: Swift.Equatable {
    /// An array that contains settings for the specified Resolver configuration.
    public var resolverConfig: Route53ResolverClientTypes.ResolverConfig?

    public init(
        resolverConfig: Route53ResolverClientTypes.ResolverConfig? = nil
    )
    {
        self.resolverConfig = resolverConfig
    }
}

struct UpdateResolverConfigOutputBody: Swift.Equatable {
    let resolverConfig: Route53ResolverClientTypes.ResolverConfig?
}

extension UpdateResolverConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverConfig = "ResolverConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverConfig.self, forKey: .resolverConfig)
        resolverConfig = resolverConfigDecoded
    }
}

enum UpdateResolverConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResolverDnssecConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case validation = "Validation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let validation = self.validation {
            try encodeContainer.encode(validation.rawValue, forKey: .validation)
        }
    }
}

extension UpdateResolverDnssecConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverDnssecConfigInput: Swift.Equatable {
    /// The ID of the virtual private cloud (VPC) that you're updating the DNSSEC validation status for.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The new value that you are specifying for DNSSEC validation for the VPC. The value can be ENABLE or DISABLE. Be aware that it can take time for a validation status change to be completed.
    /// This member is required.
    public var validation: Route53ResolverClientTypes.Validation?

    public init(
        resourceId: Swift.String? = nil,
        validation: Route53ResolverClientTypes.Validation? = nil
    )
    {
        self.resourceId = resourceId
        self.validation = validation
    }
}

struct UpdateResolverDnssecConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let validation: Route53ResolverClientTypes.Validation?
}

extension UpdateResolverDnssecConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case validation = "Validation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let validationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Validation.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension UpdateResolverDnssecConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResolverDnssecConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverDNSSECConfig = output.resolverDNSSECConfig
        } else {
            self.resolverDNSSECConfig = nil
        }
    }
}

public struct UpdateResolverDnssecConfigOutput: Swift.Equatable {
    /// A complex type that contains settings for the specified DNSSEC configuration.
    public var resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?

    public init(
        resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

struct UpdateResolverDnssecConfigOutputBody: Swift.Equatable {
    let resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?
}

extension UpdateResolverDnssecConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverDNSSECConfig = "ResolverDNSSECConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDNSSECConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverDnssecConfig.self, forKey: .resolverDNSSECConfig)
        resolverDNSSECConfig = resolverDNSSECConfigDecoded
    }
}

enum UpdateResolverDnssecConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case resolverEndpointType = "ResolverEndpointType"
        case updateIpAddresses = "UpdateIpAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = self.resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let resolverEndpointType = self.resolverEndpointType {
            try encodeContainer.encode(resolverEndpointType.rawValue, forKey: .resolverEndpointType)
        }
        if let updateIpAddresses = updateIpAddresses {
            var updateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateIpAddresses)
            for updateipaddress0 in updateIpAddresses {
                try updateIpAddressesContainer.encode(updateipaddress0)
            }
        }
    }
}

extension UpdateResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverEndpointInput: Swift.Equatable {
    /// The name of the Resolver endpoint that you want to update.
    public var name: Swift.String?
    /// The ID of the Resolver endpoint that you want to update.
    /// This member is required.
    public var resolverEndpointId: Swift.String?
    /// Specifies the endpoint type for what type of IP address the endpoint uses to forward DNS queries. Updating to IPV6 type isn't currently supported.
    public var resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
    /// Specifies the IPv6 address when you update the Resolver endpoint from IPv4 to dual-stack. If you don't specify an IPv6 address, one will be automatically chosen from your subnet.
    public var updateIpAddresses: [Route53ResolverClientTypes.UpdateIpAddress]?

    public init(
        name: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil,
        resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType? = nil,
        updateIpAddresses: [Route53ResolverClientTypes.UpdateIpAddress]? = nil
    )
    {
        self.name = name
        self.resolverEndpointId = resolverEndpointId
        self.resolverEndpointType = resolverEndpointType
        self.updateIpAddresses = updateIpAddresses
    }
}

struct UpdateResolverEndpointInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let name: Swift.String?
    let resolverEndpointType: Route53ResolverClientTypes.ResolverEndpointType?
    let updateIpAddresses: [Route53ResolverClientTypes.UpdateIpAddress]?
}

extension UpdateResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case resolverEndpointType = "ResolverEndpointType"
        case updateIpAddresses = "UpdateIpAddresses"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resolverEndpointTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointType.self, forKey: .resolverEndpointType)
        resolverEndpointType = resolverEndpointTypeDecoded
        let updateIpAddressesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.UpdateIpAddress?].self, forKey: .updateIpAddresses)
        var updateIpAddressesDecoded0:[Route53ResolverClientTypes.UpdateIpAddress]? = nil
        if let updateIpAddressesContainer = updateIpAddressesContainer {
            updateIpAddressesDecoded0 = [Route53ResolverClientTypes.UpdateIpAddress]()
            for structure0 in updateIpAddressesContainer {
                if let structure0 = structure0 {
                    updateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        updateIpAddresses = updateIpAddressesDecoded0
    }
}

extension UpdateResolverEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResolverEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct UpdateResolverEndpointOutput: Swift.Equatable {
    /// The response to an UpdateResolverEndpoint request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init(
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct UpdateResolverEndpointOutputBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension UpdateResolverEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

enum UpdateResolverEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = self.config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let resolverRuleId = self.resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

extension UpdateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverRuleInput: Swift.Equatable {
    /// The new settings for the Resolver rule.
    /// This member is required.
    public var config: Route53ResolverClientTypes.ResolverRuleConfig?
    /// The ID of the Resolver rule that you want to update.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init(
        config: Route53ResolverClientTypes.ResolverRuleConfig? = nil,
        resolverRuleId: Swift.String? = nil
    )
    {
        self.config = config
        self.resolverRuleId = resolverRuleId
    }
}

struct UpdateResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
    let config: Route53ResolverClientTypes.ResolverRuleConfig?
}

extension UpdateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case resolverRuleId = "ResolverRuleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let configDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension UpdateResolverRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResolverRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct UpdateResolverRuleOutput: Swift.Equatable {
    /// The response to an UpdateResolverRule request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init(
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct UpdateResolverRuleOutputBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension UpdateResolverRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

enum UpdateResolverRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceErrorException": return try await InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum Validation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case useLocalResourceSetting
        case sdkUnknown(Swift.String)

        public static var allCases: [Validation] {
            return [
                .disable,
                .enable,
                .useLocalResourceSetting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .useLocalResourceSetting: return "USE_LOCAL_RESOURCE_SETTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Validation(rawValue: rawValue) ?? Validation.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have provided an invalid command. Supported values are ADD, REMOVE, or REPLACE a domain.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
